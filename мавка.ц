взяти означення ./мавка;

простір мавка {
  структура Спроба {
    назва_зловити: адреса<Дійсне>;
    позиція_вказівки_зловити: природне;
    розмір_історії_здійснення: природне;
    розмір_накопичувача_значень: природне;
  }

  структура Спроби {
    розмір: природне;
    дані: памʼять<Спроба>;
    вмісткість: природне;
  }

  дія обробити_стан_падіння(М: адреса<Машина>,
                            дійсність: адреса<Дійсність>,
                            код: адреса<Дійсне>,
                            позиція_вказівки_падіння: природне,
                            спроби: адреса<Спроби>,
                            позиція_вказівки: адреса<природне>) -> логічне {
    якщо спроби.розмір > 0 {
      спроби.розмір -= 1;
      змінна спроба = спроби.дані[спроби.розмір];

      якщо спроба.назва_зловити != пусто {
        визначити_діяча(М, дійсність, спроба.назва_зловити, М.значення_падіння);
      }

      позиція_вказівки::вміст = спроба.позиція_вказівки_зловити;
      М.історія_здійснення.розмір = спроба.розмір_історії_здійснення;
      М.накопичувач_значень.розмір = спроба.розмір_накопичувача_значень;
      
      М.стан_падіння = ні;
      М.значення_падіння = пусто;
      М.місцезнаходження_падіння = Місцезнаходження { пусто, 0 };
      
      вернути так;
    }
    
    якщо М.місцезнаходження_падіння.значення == пусто {
      М.місцезнаходження_падіння = Місцезнаходження { код, позиція_вказівки_падіння };
    }

    вернути ні;                     
  }

  дія виконати_код(М: адреса<Машина>,
                   дійсність: адреса<Дійсність>,
                   код: адреса<Дійсне>) -> адреса<Дійсне> {
    змінна предмет_коду = код як адреса<Предмет>;
    змінна властивості_коду = предмет_коду.властивості як ВластивостіКоду;
    змінна константи = властивості_коду.константи;
    змінна предмет_вказівок = властивості_коду.вказівки як адреса<Предмет>;
    змінна вказівки = предмет_вказівок.властивості як ВластивостіДаних;

    змінна спроби = Спроби { 0, пусто, 0 };

    змінна позиція_вказівки: природне = 0;
    змінна позиція_поточної_вказівки: природне = 0;
    змінна вказівка: п8 = 0;

    поки позиція_вказівки < вказівки.розмір {
  крок_виконання_вказівки:
      позиція_поточної_вказівки = позиція_вказівки;
      вказівка = вказівки.дані[позиція_поточної_вказівки];

      якщо вказівка == ВДодати {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_додавання(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, спроби::адреса, позиція_вказівки::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВВідняти {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_відімання(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, спроби::адреса, позиція_вказівки::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВПомножити {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_множення(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, спроби::адреса, позиція_вказівки::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВПоділити {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_ділення(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, спроби::адреса, позиція_вказівки::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
  крок_виконати_далі:
      позиція_вказівки += 1;
    }
  
  крок_вихід:
    вернути пусто;
  }

  місцева дія здійснити(М: адреса<Машина>,
                        здійснювач: адреса<Дійсне>,
                        значення: адреса<Дійсне>,
                        кількість_задіяних: природне, 
                        задіяні: памʼять<адреса<Дійсне>>,
                        кількість_іменовано_задіяних: природне, 
                        іменовано_задіяні: памʼять<адреса<Дійсне>>) -> адреса<Дійсне> {
    якщо значення.тип == М.значення_структура_Дія {
      змінна предмет_дії = значення як адреса<Предмет>;
      змінна властивості_дії = предмет_дії.властивості як ВластивостіДії;

      якщо властивості_дії.рідна {
        змінна рідна_дія = властивості_дії.код як РіднаДія;

        вернути рідна_дія(
          М,
          здійснювач,
          значення,
          кількість_задіяних,
          задіяні,
          кількість_іменовано_задіяних,
          іменовано_задіяні
        );
      } інакше {        
        змінна дійсність = створити_дійсність(
          М, 
          властивості_дії.дійсність_створення, 
          здійснювач
        );

        вернути виконати_код(
          М,
          дійсність,
          властивості_дії.код як адреса<Дійсне>
        );
      }
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати дію можна лише над діями.");

      вернути пусто;
    }                         
  }

  місцева дія виконати_додавання(М: адреса<Машина>, ліво: адреса<Дійсне>, право: адреса<Дійсне>) -> адреса<Дійсне> {
    якщо ліво.тип == М.значення_структура_Число і право.тип == М.значення_структура_Число {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЧисла;
      змінна властивості_право = право_предмет.властивості як ВластивостіЧисла;

      вернути створити_число(М, властивості_ліво.значення + властивості_право.значення);
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати додавання можна лише між числами.");

      вернути пусто;
    }
  }

  місцева дія виконати_відімання(М: адреса<Машина>, ліво: адреса<Дійсне>, право: адреса<Дійсне>) -> адреса<Дійсне> {
    якщо ліво.тип == М.значення_структура_Число і право.тип == М.значення_структура_Число {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЧисла;
      змінна властивості_право = право_предмет.властивості як ВластивостіЧисла;

      вернути створити_число(М, властивості_ліво.значення - властивості_право.значення);
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати віднімання можна лише між числами.");

      вернути пусто;
    }
  }

  місцева дія виконати_множення(М: адреса<Машина>, ліво: адреса<Дійсне>, право: адреса<Дійсне>) -> адреса<Дійсне> {
    якщо ліво.тип == М.значення_структура_Число і право.тип == М.значення_структура_Число {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЧисла;
      змінна властивості_право = право_предмет.властивості як ВластивостіЧисла;

      вернути створити_число(М, властивості_ліво.значення * властивості_право.значення);
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати множення можна лише між числами.");

      вернути пусто;
    }
  }

  місцева дія виконати_ділення(М: адреса<Машина>, ліво: адреса<Дійсне>, право: адреса<Дійсне>) -> адреса<Дійсне> {
    якщо ліво.тип == М.значення_структура_Число і право.тип == М.значення_структура_Число {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЧисла;
      змінна властивості_право = право_предмет.властивості як ВластивостіЧисла;

      вернути створити_число(М, властивості_ліво.значення / властивості_право.значення);
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати ділення можна лише між числами.");

      вернути пусто;
    }
  }

  місцева дія виконати_взяти(М: адреса<Машина>, звідки: адреса<Дійсне>, довжина_шляху: природне, шлях: памʼять<адреса<Дійсне>>) -> адреса<Дійсне> {
    вернути пусто;
  }
}