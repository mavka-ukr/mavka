взяти визначення МаМа;

секція МаМа {
  місцева дія налаштувати_машину(М: адреса<Машина>, оболонка: адреса, система: Система) {
    М.оболонка = оболонка;
    М.система = система;
    М.утилізатор = зробити_утилізатор(М);
    М.БН = зробити_базу_назв(М);
    М.НатО = зробити_накопичувач<адреса<Предмет>>(М);
    М.НаО = зробити_накопичувач<адреса<Предмет>>(М);
    М.НаРАрг = зробити_накопичувач<адреса<Реєстр<адреса<Назва>, адреса<Предмет>>>>(М);
    М.НаРПар = зробити_накопичувач<адреса<Реєстр<адреса<Назва>, Параметр>>>(М);
    М.ТрК = пусто;
    М.ТрН = пусто;
    М.історія = зробити_накопичувач<ЕлементІсторіїВиконання>(М);
    М.НаН = зробити_накопичувач<адреса<Назва>>(М);
    М.НаОТ = зробити_накопичувач<адреса<Предмет>>(М);
    М.глобальне_середовище = виділити_середовище(М, пусто);
    М.стан_падіння = позитивне(ні);
    М.місцезнаходження_падіння = пусто;
    М.історія_виконання_перед_падінням = зробити_накопичувач<адреса<Предмет>>(М);
    М.сховище_констант = зробити_накопичувач<адреса<Предмет>>(М);
    М.сховище_кодів = зробити_накопичувач<адреса<Код>>(М);
    М.обробник_отримання_шляху_до_модуля = пусто;
    М.обробник_взяття_модуля = пусто;
    М.обробник_взяття_біб = пусто;
    М.взяті_модулі = зробити_реєстр<ю8, адреса<ПредметМодуля>>(М, перевірити_чи_ю8_рівні);

    // § Створення предметів "предмет" та "Структура":
    //   "предмет" це Структура що не має предка.
    //   "Структура" це Структура що має предок "предмет".
    //   Мають виконуватись наступні умови:
    //     1. предмет є предмет
    //     2. предмет є Структура
    //     3. Структура є предмет
    //     4. Структура є Структура
    М.предмет_структури_предмет = виділити_предмет_структури(М, М.БН.С.предмет, пусто);
    М.предмет_структури_Структура = виділити_предмет_структури(М, М.БН.С.Структура, пусто);
    М.предмет_структури_предмет.тип = М.предмет_структури_Структура;
    М.предмет_структури_предмет.предок = пусто;
    М.предмет_структури_Структура.тип = М.предмет_структури_Структура;
    М.предмет_структури_Структура.предок = М.предмет_структури_предмет;

    М.предмет_структури_Дія = виділити_предмет_структури(М, М.БН.С.Дія, М.предмет_структури_предмет);
    М.предмет_структури_НативнаДія = виділити_предмет_структури(М, М.БН.С.НативнаДія, М.предмет_структури_предмет);
    М.предмет_структури_число = створити_структуру_числа(М);
    М.предмет_структури_текст = створити_структуру_тексту(М);
    М.предмет_структури_юнікод = створити_структуру_юнікоду(М);
    М.предмет_структури_Модуль = створити_структуру_модуля(М);
    М.предмет_структури_список = створити_структуру_списку(М);
    М.предмет_структури_словник = створити_структуру_словника(М);
    М.предмет_структури_логічне = створити_структуру_логічного(М);
    М.предмет_структури_байти = створити_структуру_байтів(М);
    М.предмет_структури_адреса = створити_структуру_адреси(М);

    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.предмет, М.предмет_структури_предмет як адреса<Предмет>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.Структура, М.предмет_структури_Структура як адреса<Предмет>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.НативнаДія, М.предмет_структури_НативнаДія як адреса<Предмет>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.Дія, М.предмет_структури_Дія як адреса<Предмет>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.число, М.предмет_структури_число як адреса<Предмет>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.текст, М.предмет_структури_текст як адреса<Предмет>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.юнікод, М.предмет_структури_юнікод як адреса<Предмет>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.Модуль, М.предмет_структури_Модуль як адреса<Предмет>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.список, М.предмет_структури_список як адреса<Предмет>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.словник, М.предмет_структури_словник як адреса<Предмет>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.логічне, М.предмет_структури_логічне як адреса<Предмет>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.байти, М.предмет_структури_байти як адреса<Предмет>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.адреса, М.предмет_структури_адреса як адреса<Предмет>);

    М.предмет_логічного_так = виділити_предмет_логічного(М, так);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.так, М.предмет_логічного_так як адреса<Предмет>);
    М.предмет_логічного_ні = виділити_предмет_логічного(М, ні);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.ні, М.предмет_логічного_ні як адреса<Предмет>);
  }

  місцева дія розлаштувати_машину(М: адреса<Машина>) {
    // ...
  }

  місцева дія увімкнути_стан_падіння(М: адреса<Машина>, місцезнаходження_падіння: адреса<МісцезнаходженняПадіння>) {
    М.стан_падіння = позитивне(так);
    М.місцезнаходження_падіння = місцезнаходження_падіння;
//    М.історія_виконання_перед_падінням = ...;
  }

  місцева дія вимкнути_стан_падіння(М: адреса<Машина>) {
    М.стан_падіння = позитивне(ні);
    якщо М.місцезнаходження_падіння != пусто {
      звільнити_місцезнаходження_падіння(М, М.місцезнаходження_падіння);
      М.місцезнаходження_падіння = пусто;
    }
    М.історія_виконання_перед_падінням.розмір = 0;
  }

  місцева дія покласти_константу(М: адреса<Машина>, предмет: адреса<Предмет>): позитивне {
    покласти_в_накопичувач<адреса<Предмет>>(М, М.сховище_констант::адреса, предмет);
    вернути М.сховище_констант.розмір - 1;
  }

  місцева дія покласти_тимчасове_середовище(М: адреса<Машина>): адреса<Середовище> {
    ціль нове_середовище = виділити_середовище(М, М.глобальне_середовище);
    покласти_в_накопичувач<ЕлементІсторіїВиконання>(М, М.історія::адреса, ЕлементІсторіїВиконання {
      предмет_дії = пусто,
      середовище = нове_середовище
    });
    вернути нове_середовище;
  }

  місцева дія забрати_тимчасове_середовище(М: адреса<Машина>) {
    забрати_з_накопичувача<ЕлементІсторіїВиконання>(М, М.історія::адреса);
  }

  місцева дія притримати_предмет(М: адреса<Машина>, предмет: адреса<Предмет>) {
    покласти_в_накопичувач<адреса<Предмет>>(М, М.НатО::адреса, предмет);
  }

  місцева дія відпустити_предмет(М: адреса<Машина>) {
    забрати_з_накопичувача<адреса<Предмет>>(М, М.НатО::адреса);
  }

  місцева дія виконати_код(М: адреса<Машина>, середовище: адреса<Середовище>, код: адреса<Код>, предмет_дії: адреса<ПредметДії>, предмет_модуля: адреса<ПредметМодуля>, предмет_я: адреса<Предмет>): предмет_або_стан_падіння {
    ціль нове_середовище = виділити_середовище(М, середовище);
    нове_середовище.предмет_модуля = предмет_модуля;
    нове_середовище.предмет_я = предмет_я;
    покласти_в_накопичувач<ЕлементІсторіїВиконання>(М, М.історія::адреса, ЕлементІсторіїВиконання {
      предмет_дії = предмет_дії,
      середовище = нове_середовище
    });
    ціль результат = виконати_код_в_середовищі(М, нове_середовище, код);
    забрати_з_накопичувача<ЕлементІсторіїВиконання>(М, М.історія::адреса);
    вернути результат;
  }

  структура Спроба {
    назва_зловити: адреса<Назва>;
    позиція_вказівки_зловити: позитивне;
    СРНМ: СтанРозмірівНакопичувачівМашини;
  }

  дія обробити_стан_падіння(М: адреса<Машина>, середовище: адреса<Середовище>, код: адреса<Код>, предмет_помилки: адреса<Предмет>, позиція_вказівки_падіння: позитивне, адреса_на_спроби: адреса<Накопичувач<Спроба>>, адреса_на_позицію_вказівки: адреса<позитивне>): логічне {
    якщо адреса_на_спроби.розмір > 0 {
      ціль спроба = забрати_з_накопичувача<Спроба>(М, адреса_на_спроби);
      якщо спроба.назва_зловити != пусто {
        змінити_в_середовищі(М, середовище, спроба.назва_зловити, предмет_помилки);
      }
      адреса_на_позицію_вказівки::вміст = спроба.позиція_вказівки_зловити;
      відновити_СРНМ(М, спроба.СРНМ);
      вимкнути_стан_падіння(М);
      вернути так;
    }
    якщо М.місцезнаходження_падіння == пусто {
      М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки_падіння);
    }
    вернути ні;
  }

  місцева дія виконати_код_в_середовищі(М: адреса<Машина>, середовище: адреса<Середовище>, код: адреса<Код>): предмет_або_стан_падіння {
//    надрукувати_код(код);
    якщо код.накопичувач_вказівок.розмір == 0 {
      вернути пусто;
    }
    ціль СРНМ = зберегти_СРНМ(М);
    ціль спроби = зробити_накопичувач<Спроба>(М);
    змінна ціль предмет_результату: адреса<Предмет> = пусто;
    змінна ціль позиція_вказівки: позитивне = 0;
    виконання_вказівки:
    утилізувати(М);
    якщо М.утилізатор.кількість_предметів >= М.утилізатор.кількість_предметів_щоб_запустити_утилізацію {
      утилізувати(М);
    }
    якщо М.утилізатор.кількість_середовищ >= М.утилізатор.кількість_середовищ_щоб_запустити_утилізацію {
      утилізувати(М);
    }
    якщо позиція_вказівки >= код.накопичувач_вказівок.розмір {
      стрибнути вихід;
    }
    ціль вказівка = код.накопичувач_вказівок.дані[позиція_вказівки];
    якщо вказівка == ВПокластиПусто {
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, пусто);
    } інакше якщо вказівка == ВПокластиТак {
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, М.предмет_логічного_так як адреса<Предмет>);
    } інакше якщо вказівка == ВПокластиНі {
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, М.предмет_логічного_ні як адреса<Предмет>);
    } інакше якщо вказівка == ВПокластиКонстанту {
      позиція_вказівки += 1;
      ціль позиція_константи = код.накопичувач_вказівок.дані[позиція_вказівки];
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, М.сховище_констант.дані[позиція_константи]);
    } інакше якщо вказівка == ВСтворитиДію {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      ціль реєстр_параметрів = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, Параметр>>>(М, М.НаРПар::адреса);
      ціль назва = М.ТрН;
      М.ТрН = пусто;
      позиція_вказівки += 1;
      ціль позиція_коду = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль код = М.сховище_кодів.дані[позиція_коду];
      ціль типи_результату = зробити_накопичувач<адреса<ПредметСтруктури>>(М);
      змінна ціль пт: позитивне = 0;
      поки пт < М.НаОТ.розмір {
        ціль предмет = М.НаОТ.дані[пт];
        якщо предмет == пусто {
          покласти_в_накопичувач<адреса<ПредметСтруктури>>(М, типи_результату::адреса, пусто);
          пт += 1;
        } інакше якщо предмет.тип == М.предмет_структури_Структура {
          покласти_в_накопичувач<адреса<ПредметСтруктури>>(М, типи_результату::адреса, предмет як адреса<ПредметСтруктури>);
          пт += 1;
        } інакше {
          ціль предмет_помилки = виділити_предмет_тексту_з_ю8(М, ю8"Тип результату має бути структурою") як адреса<Предмет>;
          увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки));
          якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
            предмет_результату = предмет_помилки;
            звільнити_реєстр_параметрів(М, реєстр_параметрів);
            звільнити_значення_накопичувача<адреса<ПредметСтруктури>>(М, типи_результату);
            стрибнути вихід;
          }
          звільнити_реєстр_параметрів(М, реєстр_параметрів);
          звільнити_значення_накопичувача<адреса<ПредметСтруктури>>(М, типи_результату);
          стрибнути виконання_вказівки;
        }
      }
      М.НаОТ.розмір = 0;
      ціль предмет_дії = виділити_предмет_дії(М, назва, реєстр_параметрів, середовище, код, типи_результату);
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, предмет_дії як адреса<Предмет>);
    } інакше якщо вказівка == ВСтворитиСтруктуру {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      ціль реєстр_параметрів = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, Параметр>>>(М, М.НаРПар::адреса);
      ціль предмет_предка = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      якщо предмет_предка == пусто {
        ціль предмет_помилки = виділити_предмет_тексту_з_ю8(М, ю8"Предок не може бути пусто") як адреса<Предмет>;
        увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки));
        якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = предмет_помилки;
          звільнити_реєстр_параметрів(М, реєстр_параметрів);
          стрибнути вихід;
        }
        звільнити_реєстр_параметрів(М, реєстр_параметрів);
        стрибнути виконання_вказівки;
      } інакше {
        якщо предмет_предка.тип == М.предмет_структури_Структура {
          ціль назва = М.ТрН;
          М.ТрН = пусто;
          ціль предмет_структури = виділити_предмет_структури(М, назва, предмет_предка як адреса<ПредметСтруктури>);
          змінна ціль пп: позитивне = 0;
          поки пп < реєстр_параметрів.розмір {
            ціль назва_параметра = реєстр_параметрів.елементи[пп].ключ;
            ціль параметр = реєстр_параметрів.елементи[пп].значення;
            ціль елемент_реєстру = отримати_з_реєстру<адреса<Назва>, Параметр>(М, предмет_структури.параметри, назва_параметра);
            якщо елемент_реєстру == пусто {
              змінити_в_реєстрі<адреса<Назва>, Параметр>(М, предмет_структури.параметри, назва_параметра, Параметр {
                типи = зробити_копію_накопичувача<адреса<ПредметСтруктури>>(М, параметр.типи),
                код_значення_за_замовчуванням = параметр.код_значення_за_замовчуванням
              });
            } інакше {
              ціль предмет_помилки = виділити_предмет_тексту_з_ю8(М, ю8"Параметр вже визначено") як адреса<Предмет>;
              увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки));
              якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
                предмет_результату = предмет_помилки;
                звільнити_реєстр_параметрів(М, реєстр_параметрів);
                стрибнути вихід;
              }
              звільнити_реєстр_параметрів(М, реєстр_параметрів);
              стрибнути виконання_вказівки;
            }
            пп += 1;
          }
          звільнити_реєстр_параметрів(М, реєстр_параметрів);
          покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, предмет_структури як адреса<Предмет>);
        } інакше {
          ціль предмет_помилки = виділити_предмет_тексту_з_ю8(М, ю8"Предок має бути структурою") як адреса<Предмет>;
          увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки));
          якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
            предмет_результату = предмет_помилки;
            звільнити_реєстр_параметрів(М, реєстр_параметрів);
            стрибнути вихід;
          }
          звільнити_реєстр_параметрів(М, реєстр_параметрів);
          стрибнути виконання_вказівки;
        }
      }
    } інакше якщо вказівка == ВСтворитиМодуль {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      ціль назва = М.ТрН;
      М.ТрН = пусто;
      позиція_вказівки += 1;
      ціль позиція_коду = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль код_модуля = М.сховище_кодів.дані[позиція_коду];
      ціль предмет_модуля = виділити_предмет_модуля(М, назва);
      притримати_предмет(М, предмет_модуля як адреса<Предмет>);
      ціль результат_виконання = виконати_код(М, середовище, код_модуля, пусто, предмет_модуля, предмет_модуля як адреса<Предмет>);
      відпустити_предмет(М);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_виконання, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат_виконання;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, предмет_модуля як адреса<Предмет>);
    } інакше якщо вказівка == ВСтворитиСписок {
      позиція_вказівки += 1;
      ціль розмір_списку = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль предмет_списку = виділити_предмет_списку(М);
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, предмет_списку як адреса<Предмет>);
    } інакше якщо вказівка == ВПокластиВСписок {
      ціль значення = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_списку = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса) як адреса<ПредметСписку>;
      покласти_в_накопичувач<адреса<Предмет>>(М, предмет_списку.елементи::адреса, значення);
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, предмет_списку як адреса<Предмет>);
    } інакше якщо вказівка == ВСтворитиСловник {
      позиція_вказівки += 1;
      ціль розмір_словника = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль предмет_словника = виділити_предмет_словника(М);
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, предмет_словника як адреса<Предмет>);
    } інакше якщо вказівка == ВПокластиВСловник {
      ціль значення = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль ключ = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_словника = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса) як адреса<ПредметСловника>;
      змінити_в_реєстрі2<адреса<Предмет>, адреса<Предмет>>(М, предмет_словника.елементи::адреса, ключ, значення);
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, предмет_словника як адреса<Предмет>);
    } інакше якщо вказівка == ВПокластиСтруктуруПредмет {
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, М.предмет_структури_предмет як адреса<Предмет>);
    } інакше якщо вказівка == ВПокластиЯ {
      змінна ціль поточне_середовище = середовище;
      змінна ціль предмет_я: адреса<Предмет> = пусто;
      поки поточне_середовище != пусто {
        якщо поточне_середовище.предмет_я != пусто {
          предмет_я = поточне_середовище.предмет_я;
          поточне_середовище = пусто;
        } інакше {
          поточне_середовище = поточне_середовище.батьківське;
        }
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, предмет_я);
    } інакше якщо вказівка == ВЗаписатиМетод {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      ціль предмет_структури = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      якщо предмет_структури.тип == М.предмет_структури_Структура {
        ціль предмет_дії = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
        ціль результат = додати_метод_до_предмета_структури(предмет_структури як адреса<ПредметСтруктури>, М, назва, предмет_дії);
        якщо М.стан_падіння == позитивне(так) {
          якщо обробити_стан_падіння(М, середовище, код, результат, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
            предмет_результату = результат;
            стрибнути вихід;
          }
          позиція_вказівки -= 1;
        } інакше {
          покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, предмет_структури);
        }
      } інакше {
        ціль предмет_помилки = виділити_предмет_тексту_з_ю8(М, ю8"Предмет має бути структурою") як адреса<Предмет>;
        увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки));
        якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = предмет_помилки;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
    } інакше якщо вказівка == ВВизначити {
      ціль значення = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      змінити_в_середовищі(М, середовище, назва, значення);
    } інакше якщо вказівка == ВЗвернутись {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      ціль елемент_середовища = знайти_елемент_в_середовищі(М, середовище, назва);
      якщо елемент_середовища == пусто {
        ціль предмет_помилки = виділити_предмет_тексту_з_ю8(М, ю8"Підмет не визначено") як адреса<Предмет>;
        увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки));
        якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = предмет_помилки;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      } інакше {
        покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, елемент_середовища.значення);
      }
    } інакше якщо вказівка == ВВиконати {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      позиція_вказівки += 1;
      ціль кількість_аргументів = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль аргументи = зробити_накопичувач<адреса<Предмет>>(М);
      змінна ціль па: позитивне = 0;
      поки па < кількість_аргументів {
        ціль аргумент = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
        покласти_в_накопичувач<адреса<Предмет>>(М, аргументи::адреса, аргумент);
        па += 1;
      }
      обернути_накопичувач<адреса<Предмет>>(М, аргументи::адреса);
      ціль предмет = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат_виконання = предмет_виконати(предмет, М, пусто, аргументи::адреса, пусто);
      звільнити_значення_накопичувача<адреса<Предмет>>(М, аргументи);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_виконання, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат_виконання;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат_виконання);
    } інакше якщо вказівка == ВВиконатиЗНазвами {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      ціль іменовані_аргументи = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, адреса<Предмет>>>>(М, М.НаРАрг::адреса);
      позиція_вказівки += 1;
      ціль кількість_аргументів = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль аргументи = зробити_накопичувач<адреса<Предмет>>(М);
      змінна ціль па: позитивне = 0;
      поки па < кількість_аргументів {
        ціль аргумент = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
        покласти_в_накопичувач<адреса<Предмет>>(М, аргументи::адреса, аргумент);
        па += 1;
      }
      обернути_накопичувач<адреса<Предмет>>(М, аргументи::адреса);
      ціль предмет = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат_виконання = предмет_виконати(предмет, М, пусто, аргументи::адреса, іменовані_аргументи);
      звільнити_значення_накопичувача<адреса<Предмет>>(М, аргументи);
      звільнити_реєстр<адреса<Назва>, адреса<Предмет>>(М, іменовані_аргументи);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_виконання, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат_виконання;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат_виконання);
    } інакше якщо вказівка == ВОтриматиВластивість {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      ціль предмет = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      ціль результат_отримання_властивості = предмет_отримати_властивість(предмет, М, назва);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_отримання_властивості, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат_отримання_властивості;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат_отримання_властивості);
    } інакше якщо вказівка == ВЗмінитиВластивість {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      ціль значення = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      ціль результат_зміни_властивості = предмет_змінити_властивість(предмет, М, назва, значення);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_зміни_властивості, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат_зміни_властивості;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
    } інакше якщо вказівка == ВВиконатиВластивість {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      позиція_вказівки += 1;
      ціль кількість_аргументів = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль аргументи = зробити_накопичувач<адреса<Предмет>>(М);
      змінна ціль па: позитивне = 0;
      поки па < кількість_аргументів {
        ціль аргумент = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
        покласти_в_накопичувач<адреса<Предмет>>(М, аргументи::адреса, аргумент);
        па += 1;
      }
      обернути_накопичувач<адреса<Предмет>>(М, аргументи::адреса);
      ціль предмет = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат_виконання = предмет_виконати_властивість(предмет, М, назва, аргументи::адреса, пусто);
      звільнити_значення_накопичувача<адреса<Предмет>>(М, аргументи);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_виконання, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат_виконання;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат_виконання);
    } інакше якщо вказівка == ВВиконатиВластивістьЗНазвами {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      ціль іменовані_аргументи = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, адреса<Предмет>>>>(М, М.НаРАрг::адреса);
      позиція_вказівки += 1;
      ціль кількість_аргументів = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль аргументи = зробити_накопичувач<адреса<Предмет>>(М);
      змінна ціль па: позитивне = 0;
      поки па < кількість_аргументів {
        ціль аргумент = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
        покласти_в_накопичувач<адреса<Предмет>>(М, аргументи::адреса, аргумент);
        па += 1;
      }
      обернути_накопичувач<адреса<Предмет>>(М, аргументи::адреса);
      ціль предмет = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат_виконання = предмет_виконати_властивість(предмет, М, назва, аргументи::адреса, іменовані_аргументи);
      звільнити_значення_накопичувача<адреса<Предмет>>(М, аргументи);
      звільнити_реєстр<адреса<Назва>, адреса<Предмет>>(М, іменовані_аргументи);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_виконання, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат_виконання;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат_виконання);
    } інакше якщо вказівка == ВОтриматиЕлемент {
      ціль ключ = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат_отримання_елемента = предмет_отримати_елемент(предмет, М, ключ);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_отримання_елемента, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат_отримання_елемента;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат_отримання_елемента);
    } інакше якщо вказівка == ВЗмінитиЕлемент {
      ціль значення = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль ключ = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат_зміни_елемента = предмет_змінити_елемент(предмет, М, ключ, значення);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_зміни_елемента, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат_зміни_елемента;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
    } інакше якщо вказівка == ВОтриматиПеребір {
      ціль предмет = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат_отримання_перебору = предмет_отримати_перебір(предмет, М);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_отримання_перебору, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат_отримання_перебору;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат_отримання_перебору);
    } інакше якщо вказівка == ВВизначитиЗзовні {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      ціль значення = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      якщо середовище.батьківське == пусто {
        ціль предмет_помилки = виділити_предмет_тексту_з_ю8(М, ю8"Середовище є кореневим") як адреса<Предмет>;
        увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки));
        якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = предмет_помилки;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      } інакше {
        змінити_в_середовищі(М, середовище.батьківське, назва, значення);
      }
    } інакше якщо вказівка == ВВиконатиЗПредка {
      ПОМЕРТИ(М, ю8"Виконання з предка не втілено!");
    } інакше якщо вказівка == ВВиконатиЗПредкаЗНазвами {
      ПОМЕРТИ(М, ю8"Виконання з предка не втілено!");
    } інакше якщо вказівка == ВВидалити {
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      якщо видалити_з_середовища(М, середовище, назва) {
        покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, М.предмет_логічного_так як адреса<Предмет>);
      } інакше {
        покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, М.предмет_логічного_ні як адреса<Предмет>);
      }
    } інакше якщо вказівка == ВВидалитиВластивість {
      ціль предмет = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      ціль результат_видалення_властивості = предмет_видалити_властивість(предмет, М, назва);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_видалення_властивості, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат_видалення_властивості;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат_видалення_властивості);
    } інакше якщо вказівка == ВВидалитиЕлемент {
      ціль ключ = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат_видалення_елемента = предмет_видалити_елемент(предмет, М, ключ);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_видалення_елемента, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат_видалення_елемента;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат_видалення_елемента);
    } інакше якщо вказівка == ВДодати {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_додати(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВВідняти {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_відняти(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВПомножити {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_помножити(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВПоділити {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_поділити(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВОтриматиОстачуДілення {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_отримати_остачу_ділення(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВОтриматиНеповнуЧасткуДілення {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_отримати_неповну_частку_ділення(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВПіднестиДоСтепеня {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_піднести_до_степеня(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВЗсунутиВліво {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_зсунути_вліво(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВЗсунутиВправо {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_зсунути_вправо(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВЗсунутиВправоЗіЗаповненням {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_зсунути_вправо_зі_заповненням(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВДвійковеІ {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_двійкове_і(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВДвійковеАБО {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_двійкове_або(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВДвійковеВиключнеАБО {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_двійкове_виключне_або(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВДвійковеНЕ {
      ціль предмет = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_двійкове_не(предмет, М);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВМенше {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_менше(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВБільше {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_більше(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВНеБільше {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_більше(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      якщо перевірити_чи_предмет_виражається_логічним_так(результат, М) {
        покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, М.предмет_логічного_ні як адреса<Предмет>);
      } інакше {
        покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, М.предмет_логічного_так як адреса<Предмет>);
      }
    } інакше якщо вказівка == ВНеМенше {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_менше(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      якщо перевірити_чи_предмет_виражається_логічним_так(результат, М) {
        покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, М.предмет_логічного_ні як адреса<Предмет>);
      } інакше {
        покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, М.предмет_логічного_так як адреса<Предмет>);
      }
    } інакше якщо вказівка == ВРівно {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_рівно(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВНеРівно {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_рівно(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      якщо перевірити_чи_предмет_виражається_логічним_так(результат, М) {
        покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, М.предмет_логічного_ні як адреса<Предмет>);
      } інакше {
        покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, М.предмет_логічного_так як адреса<Предмет>);
      }
    } інакше якщо вказівка == ВМістить {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_містить(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВНеМістить {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_містить(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      якщо перевірити_чи_предмет_виражається_логічним_так(результат, М) {
        покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, М.предмет_логічного_ні як адреса<Предмет>);
      } інакше {
        покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, М.предмет_логічного_так як адреса<Предмет>);
      }
    } інакше якщо вказівка == ВЄ {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_є(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВНеЄ {
      ціль предмет_2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет_1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_є(предмет_1, М, предмет_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      якщо перевірити_чи_предмет_виражається_логічним_так(результат, М) {
        покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, М.предмет_логічного_ні як адреса<Предмет>);
      } інакше {
        покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, М.предмет_логічного_так як адреса<Предмет>);
      }
    } інакше якщо вказівка == ВВідʼємне {
      ціль предмет = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_відʼємне(предмет, М);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВЧислове {
      ціль предмет = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_числове(предмет, М);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВЗаперечити {
      ціль предмет = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_заперечити(предмет, М);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВЗбільшити {
      ціль предмет = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_збільшити(предмет, М);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВЗбільшитиПопереднє {
      ціль предмет2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_збільшити(предмет1, М);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, предмет2);
    } інакше якщо вказівка == ВЗбільшити {
      ціль предмет = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль результат = предмет_зменшити(предмет, М);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат);
    } інакше якщо вказівка == ВПочатиСпробу {
      позиція_вказівки += 1;
      ціль позиція_вказівки_зловити = код.накопичувач_вказівок.дані[позиція_вказівки];
      покласти_в_накопичувач<Спроба>(М, спроби::адреса, Спроба {
        назва_зловити = пусто,
        позиція_вказівки_зловити = позиція_вказівки_зловити,
        СРНМ = зберегти_СРНМ(М)
      });
    } інакше якщо вказівка == ВПочатиСпробуЗНазвою {
      позиція_вказівки += 1;
      ціль позиція_вказівки_зловити = код.накопичувач_вказівок.дані[позиція_вказівки];
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва_зловити = М.БН.дані.дані[позиція_назви];
      покласти_в_накопичувач<Спроба>(М, спроби::адреса, Спроба {
        назва_зловити = назва_зловити,
        позиція_вказівки_зловити = позиція_вказівки_зловити,
        СРНМ = зберегти_СРНМ(М)
      });
    } інакше якщо вказівка == ВПеребратиДалі {
      ціль предмет_перебору = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, предмет_перебору);
      ціль результат_виконання = предмет_виконати_властивість(предмет_перебору, М, М.БН.С.далі, пусто, пусто);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_виконання, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = результат_виконання;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, результат_виконання);
    } інакше якщо вказівка == ВЗбитиТекст {
      позиція_вказівки += 1;
      ціль кількість_предметів = код.накопичувач_вказівок.дані[позиція_вказівки];
      змінна ціль накопичувач_предметів = зробити_накопичувач<адреса<Предмет>>(М);
      змінна ціль п: позитивне = 0;
      поки п < кількість_предметів {
        покласти_в_накопичувач<адреса<Предмет>>(М, накопичувач_предметів::адреса, забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса));
        п += 1;
      }
      обернути_накопичувач<адреса<Предмет>>(М, накопичувач_предметів::адреса);
      змінна ціль накопичувач_ю8 = зробити_накопичувач_ю8(М);
      п = 0;
      поки п < кількість_предметів {
        ціль предмет = накопичувач_предметів.дані[п];
        надрукувати_предмет_в_накопичувач_ю8(предмет, М, накопичувач_ю8::адреса, 0);
        п += 1;
      }
      ціль значення_ю8 = виділити_ю8_з_накопичувача_ю8(М, накопичувач_ю8::адреса);
      звільнити_значення_накопичувача_ю8(М, накопичувач_ю8);
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, виділити_предмет_тексту_з_ю8(М, значення_ю8) як адреса<Предмет>);
      звільнити(М, значення_ю8.дані як невідома_адреса);
    } інакше якщо вказівка == ВЗбитиЮнікод {
      позиція_вказівки += 1;
      ціль кількість_предметів = код.накопичувач_вказівок.дані[позиція_вказівки];
      змінна ціль накопичувач_предметів = зробити_накопичувач<адреса<Предмет>>(М);
      змінна ціль п: позитивне = 0;
      поки п < кількість_предметів {
        покласти_в_накопичувач<адреса<Предмет>>(М, накопичувач_предметів::адреса, забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса));
        п += 1;
      }
      обернути_накопичувач<адреса<Предмет>>(М, накопичувач_предметів::адреса);
      змінна ціль накопичувач_ю8 = зробити_накопичувач_ю8(М);
      п = 0;
      поки п < кількість_предметів {
        ціль предмет = накопичувач_предметів.дані[п];
        надрукувати_предмет_в_накопичувач_ю8(предмет, М, накопичувач_ю8::адреса, 0);
        п += 1;
      }
      ціль значення_ю8 = виділити_ю8_з_накопичувача_ю8(М, накопичувач_ю8::адреса);
      звільнити_значення_накопичувача_ю8(М, накопичувач_ю8);
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, виділити_предмет_юнікоду_з_ю8(М, значення_ю8) як адреса<Предмет>);
      звільнити(М, значення_ю8.дані як невідома_адреса);
    } інакше якщо вказівка == ВВпасти {
      ціль предмет_помилки = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки));
      якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
        предмет_результату = предмет_помилки;
        стрибнути вихід;
      }
      стрибнути виконання_вказівки;
    } інакше якщо вказівка == ВЗакінчитиСпробу {
      ціль позиція_вказівки_виходу = код.накопичувач_вказівок.дані[позиція_вказівки + 1];
      забрати_з_накопичувача<Спроба>(М, спроби::адреса);
      позиція_вказівки = позиція_вказівки_виходу;
      стрибнути виконання_вказівки;
    } інакше якщо вказівка == ВВзяти {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      позиція_вказівки += 1;
      ціль позиція_назви_типу = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва_типу = М.БН.дані.дані[позиція_назви_типу];
      ціль накопичувач_назв = зробити_накопичувач<адреса<Назва>>(М);
      змінна ціль пнн: позитивне = 0;
      поки пнн < М.НаН.розмір {
        покласти_в_накопичувач<адреса<Назва>>(М, накопичувач_назв::адреса, М.НаН.дані[пнн]);
        пнн += 1;
      }
      М.НаН.розмір = 0;
      змінна ціль предмет_модуля: адреса<Предмет> = пусто;
      якщо назва_типу == М.БН.С.модуль {
        предмет_модуля = взяти_модуль(М, середовище, пусто, накопичувач_назв);
      } інакше якщо назва_типу == М.БН.С.біб {
        предмет_модуля = взяти_біб(М, накопичувач_назв);
      } інакше якщо назва_типу == М.БН.С.пак {
        предмет_модуля = взяти_модуль(М, середовище, накопичувач_назв.дані[0], накопичувач_назв);
      } інакше {
        звільнити_значення_накопичувача<адреса<Назва>>(М, накопичувач_назв);
        ціль предмет_помилки = виділити_предмет_тексту_з_ю8(М, ю8"Невідомий репозиторій взяття") як адреса<Предмет>;
        увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки));
        якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = предмет_помилки;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      звільнити_значення_накопичувача<адреса<Назва>>(М, накопичувач_назв);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, предмет_модуля, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = предмет_модуля;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, предмет_модуля);
    } інакше якщо вказівка == ВДати {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      позиція_вказівки += 1;
      ціль предмет = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      якщо середовище.предмет_модуля == пусто {
        ціль предмет_помилки = виділити_предмет_тексту_з_ю8(М, ю8"Вказівка \"дати\" працює лише в середовищі модуля") як адреса<Предмет>;
        увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки));
        якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          предмет_результату = предмет_помилки;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      } інакше {
        змінити_в_реєстрі<адреса<Назва>, адреса<Предмет>>(М, середовище.предмет_модуля.властивості::адреса, назва, предмет);
      }
    } інакше якщо вказівка == ВПокластиРеєстрАргументівЗНазвами {
      ціль іменовані_аргументи = виділити_реєстр<адреса<Назва>, адреса<Предмет>>(М, перевірити_чи_назви_рівні);
      покласти_в_накопичувач<адреса<Реєстр<адреса<Назва>, адреса<Предмет>>>>(М, М.НаРАрг::адреса, іменовані_аргументи);
    } інакше якщо вказівка == ВЗареєструватиАргументЗНазвою {
      ціль значення = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      змінити_в_реєстрі<адреса<Назва>, адреса<Предмет>>(М, М.НаРАрг.дані[М.НаРАрг.розмір - 1], назва, значення);
    } інакше якщо вказівка == ВПокластиРеєстрПараметрів {
      ціль реєстр_параметрів = виділити_реєстр<адреса<Назва>, Параметр>(М, перевірити_чи_назви_рівні);
      покласти_в_накопичувач<адреса<Реєстр<адреса<Назва>, Параметр>>>(М, М.НаРПар::адреса, реєстр_параметрів);
    } інакше якщо вказівка == ВЗареєструватиПараметр {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      позиція_вказівки += 1;
      ціль кількість_типів = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль типи = зробити_накопичувач<адреса<ПредметСтруктури>>(М);
      змінна ціль пт: позитивне = 0;
      поки пт < кількість_типів {
        ціль тип = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
        якщо тип == пусто {
          покласти_в_накопичувач<адреса<ПредметСтруктури>>(М, типи::адреса, тип як адреса<ПредметСтруктури>);
          пт = пт + 1;
        } інакше якщо тип.тип == М.предмет_структури_Структура {
          покласти_в_накопичувач<адреса<ПредметСтруктури>>(М, типи::адреса, тип як адреса<ПредметСтруктури>);
          пт = пт + 1;
        } інакше {
          ціль предмет_помилки = виділити_предмет_тексту_з_ю8(М, ю8"Тип параметра має бути структурою") як адреса<Предмет>;
          увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки));
          якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
            предмет_результату = предмет_помилки;
            звільнити_значення_накопичувача<адреса<ПредметСтруктури>>(М, типи);
            стрибнути вихід;
          }
          звільнити_значення_накопичувача<адреса<ПредметСтруктури>>(М, типи);
          стрибнути виконання_вказівки;
        }
      }
      обернути_накопичувач<адреса<ПредметСтруктури>>(М, типи::адреса);
      ціль код_значення_за_замовчуванням = М.ТрК;
      М.ТрК = пусто;
      ціль параметр = Параметр {
        типи = типи,
        код_значення_за_замовчуванням = код_значення_за_замовчуванням,
      };
      змінити_в_реєстрі<адреса<Назва>, Параметр>(М, М.НаРПар.дані[М.НаРПар.розмір - 1], назва, параметр);
    } інакше якщо вказівка == ВТриматиКод {
      позиція_вказівки += 1;
      ціль позиція_коду = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль код = М.сховище_кодів.дані[позиція_коду];
      М.ТрК = код;
    } інакше якщо вказівка == ВНакопичитиНазву {
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      покласти_в_накопичувач<адреса<Назва>>(М, М.НаН::адреса, М.БН.дані.дані[позиція_назви]);
    } інакше якщо вказівка == ВТриматиНазву {
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      М.ТрН = М.БН.дані.дані[позиція_назви];
    } інакше якщо вказівка == ВСтрибнути {
      ціль позиція_вказівки_стрибка = код.накопичувач_вказівок.дані[позиція_вказівки + 1];
      позиція_вказівки = позиція_вказівки_стрибка;
      стрибнути виконання_вказівки;
    } інакше якщо вказівка == ВСтрибнутиЯкщоНі {
      ціль значення = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      позиція_вказівки += 1;
      ціль позиція_вказівки_стрибка = код.накопичувач_вказівок.дані[позиція_вказівки];
      якщо перевірити_чи_предмет_виражається_логічним_так(значення, М) == ні {
        позиція_вказівки = позиція_вказівки_стрибка;
        стрибнути виконання_вказівки;
      }
    } інакше якщо вказівка == ВСтрибнутиЯкщоНіЗалишивши {
      ціль значення = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, значення);
      позиція_вказівки += 1;
      ціль позиція_вказівки_стрибка = код.накопичувач_вказівок.дані[позиція_вказівки];
      якщо перевірити_чи_предмет_виражається_логічним_так(значення, М) == ні {
        позиція_вказівки = позиція_вказівки_стрибка;
        стрибнути виконання_вказівки;
      }
    } інакше якщо вказівка == ВСтрибнутиЯкщоТак {
      ціль значення = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      позиція_вказівки += 1;
      ціль позиція_вказівки_стрибка = код.накопичувач_вказівок.дані[позиція_вказівки];
      якщо перевірити_чи_предмет_виражається_логічним_так(значення, М) {
        позиція_вказівки = позиція_вказівки_стрибка;
        стрибнути виконання_вказівки;
      }
    } інакше якщо вказівка == ВСтрибнутиЯкщоТакЗалишивши {
      ціль значення = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, значення);
      позиція_вказівки += 1;
      ціль позиція_вказівки_стрибка = код.накопичувач_вказівок.дані[позиція_вказівки];
      якщо перевірити_чи_предмет_виражається_логічним_так(значення, М) {
        позиція_вказівки = позиція_вказівки_стрибка;
        стрибнути виконання_вказівки;
      }
    } інакше якщо вказівка == ВДублювати {
      ціль предмет = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, предмет);
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, предмет);
    } інакше якщо вказівка == ВДублюватиПопереднє {
      ціль предмет2 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      ціль предмет1 = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, предмет1);
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, предмет2);
      покласти_в_накопичувач<адреса<Предмет>>(М, М.НаО::адреса, предмет1);
    } інакше якщо вказівка == ВЗабрати {
      забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
    } інакше якщо вказівка == ВВернути {
      предмет_результату = забрати_з_накопичувача<адреса<Предмет>>(М, М.НаО::адреса);
      стрибнути вихід;
    } інакше {
      надрукувати_п64(М, п64(вказівка));
      ціль предмет_помилки = виділити_предмет_тексту_з_ю8(М, ю8"Виявлено невідому вказівку") як адреса<Предмет>;
      увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки));
      якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
        предмет_результату = предмет_помилки;
        стрибнути вихід;
      }
      стрибнути виконання_вказівки;
    }
    позиція_вказівки += 1;
    стрибнути виконання_вказівки;
    вихід:
    звільнити_значення_накопичувача<Спроба>(М, спроби);
    відновити_СРНМ(М, СРНМ); // взагалі це по доброму треба було би викинути,
                             // але для цього ще треба порефакторити як працює сама машина
    вернути предмет_результату;
  }

  дія отримати_назву_паку_з_середовища(М: адреса<Машина>, середовище: адреса<Середовище>): адреса<Назва> {
    змінна ціль поточне_середовище = середовище;
    поки поточне_середовище != пусто {
      якщо поточне_середовище.предмет_модуля != пусто {
        якщо поточне_середовище.предмет_модуля.назва_паку != пусто {
          вернути поточне_середовище.предмет_модуля.назва_паку;
        }
      }
      поточне_середовище = поточне_середовище.батьківське;
    }
    вернути пусто;
  }

  місцева дія взяти_модуль(М: адреса<Машина>, середовище: адреса<Середовище>, назва_паку: адреса<Назва>, шлях: Накопичувач<адреса<Назва>>): предмет_або_стан_падіння {
    якщо назва_паку == пусто {
      назва_паку = отримати_назву_паку_з_середовища(М, середовище);
    }
    якщо М.обробник_отримання_шляху_до_модуля == пусто {
      вернути виділити_предмет_тексту_з_ю8(М, ю8"Обробник отримання шляху до модуля не втілено в Машині") як адреса<Предмет>;
    }
    ціль шлях_до_модуля = ю8 { пусто, 0 };
    якщо М.обробник_отримання_шляху_до_модуля(М, назва_паку, шлях, шлях_до_модуля::адреса) == ні {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_з_ю8(М, ю8"Не вдалося отримати шлях до модуля") як адреса<Предмет>;
    }
    ціль елемент_взятого_модуля = отримати_з_реєстру<ю8, адреса<ПредметМодуля>>(М, М.взяті_модулі::адреса, шлях_до_модуля);
    якщо елемент_взятого_модуля != пусто {
      вернути елемент_взятого_модуля.значення як адреса<Предмет>;
    }
    якщо М.обробник_взяття_модуля == пусто {
      вернути виділити_предмет_тексту_з_ю8(М, ю8"Обробник взяття модуля не втілено в Машині") як адреса<Предмет>;
    }
    ціль предмет_модуля = виділити_предмет_модуля(М, шлях.дані[шлях.розмір - 1]);
    якщо назва_паку != пусто {
      предмет_модуля.назва_паку = назва_паку;
    }
    змінити_в_реєстрі<ю8, адреса<ПредметМодуля>>(М, М.взяті_модулі::адреса, шлях_до_модуля, предмет_модуля);
    ціль результат_обробника_взяття_модуля = М.обробник_взяття_модуля(М, предмет_модуля, шлях_до_модуля);
    якщо М.стан_падіння == позитивне(так) {
      вернути результат_обробника_взяття_модуля;
    }
    вернути предмет_модуля як адреса<Предмет>;
  }

  місцева дія взяти_модуль_за_шляхом(М: адреса<Машина>, середовище: адреса<Середовище>, назва_модуля: адреса<Назва>, шлях_до_модуля: ю8): предмет_або_стан_падіння {
    ціль елемент_взятого_модуля = отримати_з_реєстру<ю8, адреса<ПредметМодуля>>(М, М.взяті_модулі::адреса, шлях_до_модуля);
    якщо елемент_взятого_модуля != пусто {
      вернути елемент_взятого_модуля.значення як адреса<Предмет>;
    }
    якщо М.обробник_взяття_модуля == пусто {
      вернути виділити_предмет_тексту_з_ю8(М, ю8"Обробник взяття модуля не втілено в Машині") як адреса<Предмет>;
    }
    ціль предмет_модуля = виділити_предмет_модуля(М, назва_модуля);
    змінити_в_реєстрі<ю8, адреса<ПредметМодуля>>(М, М.взяті_модулі::адреса, шлях_до_модуля, предмет_модуля);
    ціль результат_обробника_взяття_модуля = М.обробник_взяття_модуля(М, предмет_модуля, шлях_до_модуля);
    якщо М.стан_падіння == позитивне(так) {
      вернути результат_обробника_взяття_модуля;
    }
    вернути предмет_модуля як адреса<Предмет>;
  }

  місцева дія взяти_біб(М: адреса<Машина>, шлях: Накопичувач<адреса<Назва>>): предмет_або_стан_падіння {
    ціль накопичувач_ю8_шляху_до_модуля = зробити_накопичувач_ю8(М);
    покласти_ю8_в_накопичувач_ю8(М, накопичувач_ю8_шляху_до_модуля::адреса, ю8"біб://");
    змінна ціль п: позитивне = 0;
    поки п < шлях.розмір {
      ціль назва = шлях.дані[п];
      ціль ю8_назви = ю8 { пусто, 0 };
      якщо виділити_ю8_з_назви(М, назва, ю8_назви::адреса) == ні {
        увімкнути_стан_падіння(М, пусто);
        вернути виділити_предмет_тексту_з_ю8(М, ю8"Не вдалося виділити Ю8 з назви") як адреса<Предмет>;
      }
      покласти_ю8_в_накопичувач_ю8(М, накопичувач_ю8_шляху_до_модуля::адреса, ю8"/");
      покласти_ю8_в_накопичувач_ю8(М, накопичувач_ю8_шляху_до_модуля::адреса, ю8_назви);
      звільнити(М, ю8_назви.дані як адреса);
      п += 1;
    }
    покласти_ю8_в_накопичувач_ю8(М, накопичувач_ю8_шляху_до_модуля::адреса, ю8".м");
    ціль шлях_до_модуля = виділити_ю8_з_накопичувача_ю8(М, накопичувач_ю8_шляху_до_модуля::адреса);
    звільнити_значення_накопичувача_ю8(М, накопичувач_ю8_шляху_до_модуля);
    ціль елемент_взятого_модуля = отримати_з_реєстру<ю8, адреса<ПредметМодуля>>(М, М.взяті_модулі::адреса, шлях_до_модуля);
    якщо елемент_взятого_модуля != пусто {
      вернути елемент_взятого_модуля.значення як адреса<Предмет>;
    }
    якщо М.обробник_взяття_біб == пусто {
      вернути виділити_предмет_тексту_з_ю8(М, ю8"Обробник взяття біб не втілено в Машині") як адреса<Предмет>;
    }
    ціль предмет_модуля = виділити_предмет_модуля(М, шлях.дані[шлях.розмір - 1]);
    змінити_в_реєстрі<ю8, адреса<ПредметМодуля>>(М, М.взяті_модулі::адреса, шлях_до_модуля, предмет_модуля);
    ціль результат_обробника_взяття_модуля = М.обробник_взяття_біб(М, предмет_модуля, шлях);
    якщо М.стан_падіння == позитивне(так) {
      вернути результат_обробника_взяття_модуля;
    }
    вернути предмет_модуля як адреса<Предмет>;
  }

  місцева дія зберегти_СРНМ(М: адреса<Машина>): СтанРозмірівНакопичувачівМашини {
    вернути СтанРозмірівНакопичувачівМашини {
      розмір_історії = М.історія.розмір,
      розмір_НатО = М.НатО.розмір,
      розмір_НаО = М.НаО.розмір,
      розмір_НаРАрг = М.НаРАрг.розмір,
      розмір_НаРПар = М.НаРПар.розмір,
      розмір_НаН = М.НаН.розмір,
      значення_ТрК = М.ТрК,
      значення_ТрН = М.ТрН,
      розмір_НаОТ = М.НаОТ.розмір
    };
  }

  місцева дія відновити_СРНМ(М: адреса<Машина>, СРНМ: СтанРозмірівНакопичувачівМашини) {
    // тут можуть потенційно бути проблеми з невірними розмірами
    М.історія.розмір = СРНМ.розмір_історії;
    М.НатО.розмір = СРНМ.розмір_НатО;
    М.НаО.розмір = СРНМ.розмір_НаО;
    поки М.НаРАрг.розмір != СРНМ.розмір_НаРАрг {
      ціль реєстр_аргументів = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, адреса<Предмет>>>>(М, М.НаРАрг::адреса);
      звільнити_реєстр<адреса<Назва>, адреса<Предмет>>(М, реєстр_аргументів);
    }
    поки М.НаРПар.розмір != СРНМ.розмір_НаРПар {
      ціль реєстр_параметрів = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, Параметр>>>(М, М.НаРПар::адреса);
      звільнити_реєстр_параметрів(М, реєстр_параметрів);
    }
    М.НаН.розмір = СРНМ.розмір_НаН;
    М.ТрК = СРНМ.значення_ТрК;
    М.ТрН = СРНМ.значення_ТрН;
    М.НаОТ.розмір = СРНМ.розмір_НаОТ;
  }
}