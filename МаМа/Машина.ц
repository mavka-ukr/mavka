взяти визначення КД;
взяти визначення МаМа;

секція МаМа {
  зовнішня дія налаштувати_машину(М: адреса<Машина>, система: Система) {
    М.дані = пусто;
    М.виділити_сиру_памʼять = система.виділити_сиру_памʼять;
    М.перевиділити_сиру_памʼять = система.перевиділити_сиру_памʼять;
    М.звільнити_сиру_памʼять = система.звільнити_сиру_памʼять;
    М.померти = система.померти;
    М.останній_предмет = пусто;
    М.кількість_предметів = 0;
    М.кількість_предметів_для_очищення = 0;
    М.потребує_очищення = позитивне(ні);
    М.взяті_предмети = зробити_реєстр_з_даними<адреса<Предмет>, адреса<Предмет>, Машина>(М, М, перевірити_чи_предмети_рівні);
    М.обробник_взяття = пусто;
    М.предмет_глобального_середовища = пусто;
    М.предмет_структури_предмет = пусто;
    М.предмет_структури_Структура = пусто;
    М.предмет_структури_Код = пусто;
    М.предмет_структури_Середовище = пусто;
    М.предмет_структури_Дія = пусто;
    М.предмет_структури_число = пусто;
    М.предмет_структури_логічне = пусто;
    М.предмет_структури_текст = пусто;
    М.предмет_структури_юнікод = пусто;
    М.предмет_структури_список = пусто;
    М.предмет_структури_словник = пусто;
    М.предмет_структури_байти = пусто;
    М.предмет_структури_Модуль = пусто;
    М.предмет_структури_ресурс = пусто;
    М.предмет_структури_Тип = пусто;
    М.предмет_структури_Параметр = пусто;
    М.предмет_структури_ДіапазонЧисел = пусто;
    М.предмет_структури_ПеребірДіапазонуЧисел = пусто;
    М.предмет_структури_ПеребірСписку = пусто;
    М.предмет_структури_ПеребірТексту = пусто;
    М.предмет_структури_ПеребірЮнікоду = пусто;
    М.предмет_структури_Розширення = пусто;
    М.предмет_структури_ПеребірБайтів = пусто;
    М.предмет_логічного_так = пусто;
    М.предмет_логічного_ні = пусто;
    М.історія = зробити_накопичувач<ЕлементІсторії>(М);
    М.накопичувач_предметів = зробити_накопичувач<адреса<Предмет>>(М);
    М.притримувачі_предметів = зробити_накопичувач<Накопичувач<адреса<Предмет>>>(М);
    М.стан_падіння = позитивне(ні);
    М.місцезнаходження_падіння = Місцезнаходження { пусто як адреса<ПредметТексту>, 0 };

    // предмет є предмет
    // предмет є Структура
    // Структура є предмет
    // Структура є Структура
    М.предмет_структури_предмет = створити_предмет<ПредметСтруктури>(М, пусто);
    М.предмет_структури_предмет.властивості = зробити_реєстр_з_даними<адреса<ПредметТексту>, адреса<Предмет>, Машина>(М, М, перевірити_чи_предмети_назви_рівні);
    М.предмет_структури_предмет.середовище_створення = пусто;
    М.предмет_структури_предмет.назва = пусто;
    М.предмет_структури_предмет.предок = пусто;
    М.предмет_структури_предмет.параметри = Послідовність<адреса<ПредметПараметра>> { 0, пусто };
    М.предмет_структури_предмет.методи = зробити_реєстр_з_даними<адреса<ПредметТексту>, адреса<ПредметДії>, Машина>(М, М, перевірити_чи_предмети_назви_рівні);
    М.предмет_структури_предмет.власні_дії = зробити_реєстр_з_даними<адреса<ПредметТексту>, адреса<ПредметДії>, Машина>(М, М, перевірити_чи_предмети_назви_рівні);
    М.предмет_структури_предмет.заборонити_наслідування = позитивне(ні);
    М.предмет_структури_Структура = створити_предмет<ПредметСтруктури>(М, пусто);
    М.предмет_структури_Структура.властивості = зробити_реєстр_з_даними<адреса<ПредметТексту>, адреса<Предмет>, Машина>(М, М, перевірити_чи_предмети_назви_рівні);
    М.предмет_структури_Структура.середовище_створення = пусто;
    М.предмет_структури_Структура.назва = пусто;
    М.предмет_структури_Структура.предок = М.предмет_структури_предмет;
    М.предмет_структури_Структура.параметри = Послідовність<адреса<ПредметПараметра>> { 3, виділити_памʼять<адреса<ПредметПараметра>>(М, 3) };
    М.предмет_структури_Структура.методи = зробити_реєстр_з_даними<адреса<ПредметТексту>, адреса<ПредметДії>, Машина>(М, М, перевірити_чи_предмети_назви_рівні);
    М.предмет_структури_Структура.власні_дії = зробити_реєстр_з_даними<адреса<ПредметТексту>, адреса<ПредметДії>, Машина>(М, М, перевірити_чи_предмети_назви_рівні);
    М.предмет_структури_Структура.заборонити_наслідування = позитивне(так);
    М.предмет_структури_предмет.тип = М.предмет_структури_Структура;
    М.предмет_структури_Структура.тип = М.предмет_структури_Структура;

    М.предмет_структури_текст = створити_предмет_структури(М, пусто, М.предмет_структури_предмет, Послідовність<адреса<ПредметПараметра>> { 1, виділити_памʼять<адреса<ПредметПараметра>>(М, 1) });
    М.предмет_структури_текст.назва = назва(М, "текст");
    М.предмет_структури_текст.заборонити_наслідування = позитивне(так);
    М.предмет_структури_Структура.назва = назва(М, "Структура");
    М.предмет_структури_предмет.назва = назва(М, "предмет");

    М.предмет_структури_Код = створити_предмет_структури(М, назва(М, "Код"), М.предмет_структури_предмет, Послідовність<адреса<ПредметПараметра>> { 4, виділити_памʼять<адреса<ПредметПараметра>>(М, 4) });
    М.предмет_структури_Код.заборонити_наслідування = позитивне(так);
    М.предмет_структури_Середовище = створити_предмет_структури(М, назва(М, "Середовище"), М.предмет_структури_предмет, Послідовність<адреса<ПредметПараметра>> { 0, пусто });
    М.предмет_структури_Середовище.заборонити_наслідування = позитивне(так);
    М.предмет_структури_Дія = створити_предмет_структури(М, назва(М, "Дія"), М.предмет_структури_предмет, Послідовність<адреса<ПредметПараметра>> { 5, виділити_памʼять<адреса<ПредметПараметра>>(М, 5) });
    М.предмет_структури_Дія.заборонити_наслідування = позитивне(так);
    М.предмет_структури_логічне = створити_предмет_структури(М, назва(М, "логічне"), М.предмет_структури_предмет, Послідовність<адреса<ПредметПараметра>> { 0, пусто });
    М.предмет_структури_логічне.заборонити_наслідування = позитивне(так);
    М.предмет_структури_число = створити_предмет_структури(М, назва(М, "число"), М.предмет_структури_предмет, Послідовність<адреса<ПредметПараметра>> { 0, пусто });
    М.предмет_структури_число.заборонити_наслідування = позитивне(так);
    М.предмет_структури_юнікод = створити_предмет_структури(М, назва(М, "юнікод"), М.предмет_структури_предмет, Послідовність<адреса<ПредметПараметра>> { 1, виділити_памʼять<адреса<ПредметПараметра>>(М, 1) });
    М.предмет_структури_юнікод.заборонити_наслідування = позитивне(так);
    М.предмет_структури_список = створити_предмет_структури(М, назва(М, "список"), М.предмет_структури_предмет, Послідовність<адреса<ПредметПараметра>> { 1, виділити_памʼять<адреса<ПредметПараметра>>(М, 1) });
    М.предмет_структури_список.заборонити_наслідування = позитивне(так);
    М.предмет_структури_словник = створити_предмет_структури(М, назва(М, "словник"), М.предмет_структури_предмет, Послідовність<адреса<ПредметПараметра>> { 1, виділити_памʼять<адреса<ПредметПараметра>>(М, 1) });
    М.предмет_структури_словник.заборонити_наслідування = позитивне(так);
    М.предмет_структури_байти = створити_предмет_структури(М, назва(М, "байти"), М.предмет_структури_предмет, Послідовність<адреса<ПредметПараметра>> { 1, виділити_памʼять<адреса<ПредметПараметра>>(М, 1) });
    М.предмет_структури_байти.заборонити_наслідування = позитивне(так);
    М.предмет_структури_Модуль = створити_предмет_структури(М, назва(М, "Модуль"), М.предмет_структури_предмет, Послідовність<адреса<ПредметПараметра>> { 0, пусто });
    М.предмет_структури_Модуль.заборонити_наслідування = позитивне(так);
    М.предмет_структури_ресурс = створити_предмет_структури(М, назва(М, "ресурс"), М.предмет_структури_предмет, Послідовність<адреса<ПредметПараметра>> { 0, пусто });
    М.предмет_структури_ресурс.заборонити_наслідування = позитивне(так);
    М.предмет_структури_Тип = створити_предмет_структури(М, назва(М, "Тип"), М.предмет_структури_предмет, Послідовність<адреса<ПредметПараметра>> { 0, пусто });
    М.предмет_структури_Тип.заборонити_наслідування = позитивне(так);
    М.предмет_структури_Параметр = створити_предмет_структури(М, назва(М, "Параметр"), М.предмет_структури_предмет, Послідовність<адреса<ПредметПараметра>> { 3, виділити_памʼять<адреса<ПредметПараметра>>(М, 3) });
    М.предмет_структури_Параметр.заборонити_наслідування = позитивне(так);
    М.предмет_структури_ДіапазонЧисел = створити_предмет_структури(М, назва(М, "ДіапазонЧисел"), М.предмет_структури_предмет, Послідовність<адреса<ПредметПараметра>> { 3, виділити_памʼять<адреса<ПредметПараметра>>(М, 3) });
    М.предмет_структури_ДіапазонЧисел.заборонити_наслідування = позитивне(так);
    М.предмет_структури_ПеребірДіапазонуЧисел = створити_предмет_структури(М, назва(М, "ПеребірДіапазонуЧисел"), М.предмет_структури_предмет, Послідовність<адреса<ПредметПараметра>> { 2, виділити_памʼять<адреса<ПредметПараметра>>(М, 2) });
    М.предмет_структури_ПеребірДіапазонуЧисел.заборонити_наслідування = позитивне(так);
    М.предмет_структури_ПеребірСписку = створити_предмет_структури(М, назва(М, "ПеребірСписку"), М.предмет_структури_предмет, Послідовність<адреса<ПредметПараметра>> { 4, виділити_памʼять<адреса<ПредметПараметра>>(М, 4) });
    М.предмет_структури_ПеребірСписку.заборонити_наслідування = позитивне(так);
    М.предмет_структури_ПеребірТексту = створити_предмет_структури(М, назва(М, "ПеребірТексту"), М.предмет_структури_предмет, Послідовність<адреса<ПредметПараметра>> { 3, виділити_памʼять<адреса<ПредметПараметра>>(М, 3) });
    М.предмет_структури_ПеребірТексту.заборонити_наслідування = позитивне(так);
    М.предмет_структури_ПеребірЮнікоду = створити_предмет_структури(М, назва(М, "ПеребірЮнікоду"), М.предмет_структури_предмет, Послідовність<адреса<ПредметПараметра>> { 3, виділити_памʼять<адреса<ПредметПараметра>>(М, 3) });
    М.предмет_структури_ПеребірЮнікоду.заборонити_наслідування = позитивне(так);
    М.предмет_структури_Розширення = створити_предмет_структури(М, назва(М, "Розширення"), М.предмет_структури_предмет, Послідовність<адреса<ПредметПараметра>> { 0, пусто });
    М.предмет_структури_Розширення.заборонити_наслідування = позитивне(так);
    М.предмет_структури_ПеребірБайтів = створити_предмет_структури(М, назва(М, "ПеребірБайтів"), М.предмет_структури_предмет, Послідовність<адреса<ПредметПараметра>> { 3, виділити_памʼять<адреса<ПредметПараметра>>(М, 3) });
    М.предмет_структури_ПеребірБайтів.заборонити_наслідування = позитивне(так);

    заповнити_предмет_структури_Структура(М);
    заповнити_предмет_структури_Код(М);
    заповнити_предмет_структури_Середовище(М);
    заповнити_предмет_структури_Дія(М);
    заповнити_предмет_структури_логічне(М);
    заповнити_предмет_структури_число(М);
    заповнити_предмет_структури_текст(М);
    заповнити_предмет_структури_юнікод(М);
    заповнити_предмет_структури_список(М);
    заповнити_предмет_структури_словник(М);
    заповнити_предмет_структури_байти(М);
    заповнити_предмет_структури_Модуль(М);
    заповнити_предмет_структури_ресурс(М);
    заповнити_предмет_структури_Тип(М);
    заповнити_предмет_структури_Параметр(М);
    заповнити_предмет_структури_ДіапазонЧисел(М);
    заповнити_предмет_структури_ПеребірДіапазонуЧисел(М);
    заповнити_предмет_структури_ПеребірСписку(М);
    заповнити_предмет_структури_ПеребірТексту(М);
    заповнити_предмет_структури_ПеребірЮнікоду(М);
    заповнити_предмет_структури_Розширення(М);
    заповнити_предмет_структури_ПеребірБайтів(М);

    М.предмет_логічного_так = створити_предмет_логічного(М, так);
    М.предмет_логічного_ні = створити_предмет_логічного(М, ні);

    М.предмет_глобального_середовища = створити_предмет_середовища(М, пусто, пусто, пусто);

    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "предмет"), М.предмет_структури_предмет як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "Структура"), М.предмет_структури_Структура як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "Код"), М.предмет_структури_Код як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "Середовище"), М.предмет_структури_Середовище як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "Дія"), М.предмет_структури_Дія як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "логічне"), М.предмет_структури_логічне як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "число"), М.предмет_структури_число як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "текст"), М.предмет_структури_текст як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "юнікод"), М.предмет_структури_юнікод як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "список"), М.предмет_структури_список як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "словник"), М.предмет_структури_словник як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "байти"), М.предмет_структури_байти як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "Модуль"), М.предмет_структури_Модуль як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "ресурс"), М.предмет_структури_ресурс як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "Тип"), М.предмет_структури_Тип як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "Параметр"), М.предмет_структури_Параметр як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "ДіапазонЧисел"), М.предмет_структури_ДіапазонЧисел як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "ПеребірДіапазонуЧисел"), М.предмет_структури_ПеребірДіапазонуЧисел як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "ПеребірСписку"), М.предмет_структури_ПеребірСписку як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "ПеребірТексту"), М.предмет_структури_ПеребірТексту як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "ПеребірЮнікоду"), М.предмет_структури_ПеребірЮнікоду як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "Розширення"), М.предмет_структури_Розширення як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "ПеребірБайтів"), М.предмет_структури_ПеребірБайтів як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "так"), М.предмет_логічного_так як адреса<Предмет>);
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва(М, "ні"), М.предмет_логічного_ні як адреса<Предмет>);
  }

  зовнішня дія розлаштувати_машину(М: адреса<Машина>) {
    звільнити_реєстр<адреса<Предмет>, адреса<Предмет>>(М, М.взяті_предмети);
    змінна ціль предмет = М.останній_предмет;
    поки предмет != пусто {
      ціль попередній_предмет = предмет.попередній_предмет;
      звільнити_предмет(М, предмет);
      предмет = попередній_предмет;
    }
    звільнити_накопичувач<ЕлементІсторії>(М, М.історія);
    звільнити_накопичувач<адреса<Предмет>>(М, М.накопичувач_предметів);
    змінна ціль п: позитивне = 0;
    поки п < М.притримувачі_предметів.розмір {
      звільнити_накопичувач<адреса<Предмет>>(М, М.притримувачі_предметів.дані[п]);
      п += 1;
    }
    звільнити_накопичувач<Накопичувач<адреса<Предмет>>>(М, М.притримувачі_предметів);
  }

  дія прочитати_аргумент_вказівки(М: адреса<Машина>, вказівки: Послідовність<п8>, адреса_на_позицію_вказівки: адреса<позитивне>): позитивне {
    ціль значення = (вказівки.дані[адреса_на_позицію_вказівки::вміст + 1]::адреса як адреса<позитивне>)::вміст;
    адреса_на_позицію_вказівки::вміст = адреса_на_позицію_вказівки::вміст + 1 + 7;
    вернути значення;
  }

  дія прочитати_рядок_вказівки(М: адреса<Машина>, вказівки: Послідовність<п8>, адреса_на_позицію_вказівки: адреса<позитивне>): позитивне {
    ціль значення = (вказівки.дані[адреса_на_позицію_вказівки::вміст + 1]::адреса як адреса<позитивне>)::вміст;
    адреса_на_позицію_вказівки::вміст = адреса_на_позицію_вказівки::вміст + 1 + 7;
    вернути значення;
  }

  дія забрати_з_накопичувача_предметів(М: адреса<Машина>): адреса<Предмет> {
    М.накопичувач_предметів.розмір -= 1;
    вернути М.накопичувач_предметів.дані[М.накопичувач_предметів.розмір];
  }

  дія покласти_в_накопичувач_предметів(М: адреса<Машина>, предмет: адреса<Предмет>) {
    покласти_в_накопичувач<адреса<Предмет>>(М, М.накопичувач_предметів::адреса, предмет);
  }

  дія увімкнено_стан_падіння(М: адреса<Машина>): логічне {
    вернути М.стан_падіння == позитивне(так);
  }

  структура Спроба {
    назва_зловити: адреса<ПредметТексту>;
    позиція_вказівки_зловити: позитивне;
    розмір_історії: позитивне;
    розмір_накопичувача_предметів: позитивне;
  }

  дія обробити_стан_падіння(М: адреса<Машина>, середовище: адреса<ПредметСередовища>, код: адреса<ПредметКоду>, предмет_помилки: адреса<Предмет>, позиція_вказівки_падіння: позитивне, рядок_вказівки_падіння: позитивне, адреса_на_спроби: адреса<Накопичувач<Спроба>>, адреса_на_позицію_вказівки: адреса<позитивне>): логічне {
    якщо адреса_на_спроби.розмір > 0 {
      змінна ціль спроба: Спроба;
      забрати_з_накопичувача<Спроба>(М, адреса_на_спроби, спроба::адреса);
      якщо спроба.назва_зловити != пусто {
        змінити_в_середовищі(М, середовище, спроба.назва_зловити, предмет_помилки);
      }
      адреса_на_позицію_вказівки::вміст = спроба.позиція_вказівки_зловити;
      М.історія.розмір = спроба.розмір_історії;
      М.накопичувач_предметів.розмір = спроба.розмір_накопичувача_предметів;
      вимкнути_стан_падіння(М);
      вернути так;
    }
    якщо М.місцезнаходження_падіння.шлях як адреса<ПредметТексту> == пусто {
      М.місцезнаходження_падіння = Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки_падіння };
    }
    вернути ні;
  }

  зовнішня дія виконати_код(М: адреса<Машина>, код: адреса<ПредметКоду>, середовище: адреса<ПредметСередовища>): предмет_або_стан_падіння {
    ціль байти = код.байти;
    ціль вказівки = Послідовність<п8> { байти.розмір, байти.дані };
    змінна ціль предмет_результату: адреса<Предмет> = пусто;
    змінна ціль позиція_вказівки: позитивне = 0;
    змінна ціль позиція_поточної_вказівки: позитивне = 0;
    змінна ціль спроби = зробити_накопичувач<Спроба>(М);
    змінна ціль вказівка: п8 = 0;
    змінна ціль рядок_вказівки: позитивне = 0;
    виконання_вказівки:
    якщо позиція_вказівки >= вказівки.розмір {
      стрибнути вихід;
    }
    позиція_поточної_вказівки = позиція_вказівки;
    вказівка = вказівки.дані[позиція_вказівки];
    рядок_вказівки = прочитати_рядок_вказівки(М, вказівки, позиція_вказівки::адреса);
    якщо М.потребує_очищення == позитивне(так) {
      очистити(М);
    }
    якщо вказівка == ВПокластиПусто {
      покласти_в_накопичувач_предметів(М, пусто);
    } інакше якщо вказівка == ВПокластиТак {
      покласти_в_накопичувач_предметів(М, М.предмет_логічного_так як адреса<Предмет>);
    } інакше якщо вказівка == ВПокластиНі {
      покласти_в_накопичувач_предметів(М, М.предмет_логічного_ні як адреса<Предмет>);
    } інакше якщо вказівка == ВПокластиКонстанту {
      ціль позиція_константи = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      покласти_в_накопичувач_предметів(М, код.константи.дані[позиція_константи]);
    } інакше якщо вказівка == ВСтворитиДію {
      ціль кількість_параметрів_дії = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      ціль код_дії = забрати_з_накопичувача_предметів(М) як адреса<ПредметКоду>;
      ціль тип_результату_дії = забрати_з_накопичувача_предметів(М) як адреса<ПредметТипу>;
      змінна ціль параметри_дії: памʼять<адреса<ПредметПараметра>> = пусто;
      якщо кількість_параметрів_дії > 0 {
        параметри_дії = виділити_памʼять<адреса<ПредметПараметра>>(М, кількість_параметрів_дії);
        змінна ціль п: позитивне = 0;
        поки п < кількість_параметрів_дії {
          ціль параметр = забрати_з_накопичувача_предметів(М);
          параметри_дії[кількість_параметрів_дії - п - 1] = параметр як адреса<ПредметПараметра>;
          п += 1;
        }
      }
      ціль назва_дії = забрати_з_накопичувача_предметів(М) як адреса<ПредметТексту>;
      ціль предмет_дії = створити_предмет_дії(М, назва_дії, Послідовність<адреса<ПредметПараметра>> { кількість_параметрів_дії, параметри_дії }, тип_результату_дії, код_дії);
      предмет_дії.середовище_створення = середовище;
      покласти_в_накопичувач_предметів(М, предмет_дії як адреса<Предмет>);
    } інакше якщо вказівка == ВСтворитиМодуль {
      ціль код_модуля = забрати_з_накопичувача_предметів(М) як адреса<ПредметКоду>;
      ціль назва_модуля = забрати_з_накопичувача_предметів(М) як адреса<ПредметТексту>;
      ціль предмет_модуля = створити_предмет_модуля(М, назва_модуля);
      ціль середовище_виконання_модуля = створити_предмет_середовища(М, середовище, предмет_модуля, предмет_модуля як адреса<Предмет>);
      ціль результат = виконати_код(М, код_модуля, середовище_виконання_модуля);
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, предмет_модуля як адреса<Предмет>);
    } інакше якщо вказівка == ВСтворитиСтруктуру {
      ціль кількість_параметрів_структури = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      змінна ціль параметри_структури: памʼять<адреса<ПредметПараметра>> = пусто;
      якщо кількість_параметрів_структури > 0 {
        параметри_структури = виділити_памʼять<адреса<ПредметПараметра>>(М, кількість_параметрів_структури);
        змінна ціль п: позитивне = 0;
        поки п < кількість_параметрів_структури {
          ціль параметр = забрати_з_накопичувача_предметів(М);
          параметри_структури[кількість_параметрів_структури - п - 1] = параметр як адреса<ПредметПараметра>;
          п += 1;
        }
      }
      ціль предок_структури = забрати_з_накопичувача_предметів(М) як адреса<ПредметСтруктури>;
      якщо предок_структури == пусто {
        звільнити_памʼять(М, параметри_структури);
        увімкнути_стан_падіння(М, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
        ціль предмет_помилки = створити_предмет_тексту(М, "Неможливо наслідувати пусто") як адреса<Предмет>;
        якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = предмет_помилки;
        стрибнути вихід;
      }
      якщо предок_структури.тип != М.предмет_структури_Структура {
        звільнити_памʼять(М, параметри_структури);
        увімкнути_стан_падіння(М, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
        ціль предмет_помилки = створити_предмет_тексту(М, "Наслідувати можна лише структури") як адреса<Предмет>;
        якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = предмет_помилки;
        стрибнути вихід;
      }
      якщо предок_структури.заборонити_наслідування == позитивне(так) {
        звільнити_памʼять(М, параметри_структури);
        увімкнути_стан_падіння(М, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
        ціль предмет_помилки = створити_предмет_тексту(М, "Неможливо наслідувати цю структуру") як адреса<Предмет>;
        якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = предмет_помилки;
        стрибнути вихід;
      }
      ціль назва_структури = забрати_з_накопичувача_предметів(М) як адреса<ПредметТексту>;
      ціль предмет_структури = створити_предмет_структури(М, назва_структури, предок_структури, Послідовність<адреса<ПредметПараметра>> { кількість_параметрів_структури, параметри_структури });
      предмет_структури.середовище_створення = середовище;
      покласти_в_накопичувач_предметів(М, предмет_структури як адреса<Предмет>);
    } інакше якщо вказівка == ВСтворитиСписок {
      ціль довжина_списку = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      ціль предмет_списку = створити_предмет_списку(М, довжина_списку);
      покласти_в_накопичувач_предметів(М, предмет_списку як адреса<Предмет>);
    } інакше якщо вказівка == ВПокластиВСписок {
      ціль предмет_елемента_списку = забрати_з_накопичувача_предметів(М);
      ціль предмет_списку = забрати_з_накопичувача_предметів(М) як адреса<ПредметСписку>;
      покласти_в_накопичувач<адреса<Предмет>>(М, предмет_списку.елементи::адреса, предмет_елемента_списку);
      покласти_в_накопичувач_предметів(М, предмет_списку як адреса<Предмет>);
    } інакше якщо вказівка == ВСтворитиСловник {
      ціль розмір_словника = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      ціль предмет_словника = створити_предмет_словника(М, розмір_словника);
      покласти_в_накопичувач_предметів(М, предмет_словника як адреса<Предмет>);
    } інакше якщо вказівка == ВПокластиВСловник {
      ціль предмет_значення_елемента_словника = забрати_з_накопичувача_предметів(М);
      ціль предмет_ключа_елемента_словника = забрати_з_накопичувача_предметів(М);
      ціль предмет_словника = забрати_з_накопичувача_предметів(М) як адреса<ПредметСловника>;
      змінити_в_реєстрі<адреса<Предмет>, адреса<Предмет>>(М, предмет_словника.елементи::адреса, предмет_ключа_елемента_словника, предмет_значення_елемента_словника);
      покласти_в_накопичувач_предметів(М, предмет_словника як адреса<Предмет>);
    } інакше якщо вказівка == ВПокластиСтруктуруПредмет {
      покласти_в_накопичувач_предметів(М, М.предмет_структури_предмет як адреса<Предмет>);
    } інакше якщо вказівка == ВПокластиЯ {
      покласти_в_накопичувач_предметів(М, середовище.предмет_я);
    } інакше якщо вказівка == ВЗаписатиМетод {
      ціль власна = логічне(прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса));
      ціль назва_метода = забрати_з_накопичувача_предметів(М);
      ціль предмет_структури_метода = забрати_з_накопичувача_предметів(М);
      ціль предмет_дії_метода = забрати_з_накопичувача_предметів(М);
      якщо предмет_структури_метода == пусто {
        увімкнути_стан_падіння(М, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
        ціль предмет_помилки = створити_предмет_тексту(М, "Неможливо записати дію як метод для пусто") як адреса<Предмет>;
        якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = предмет_помилки;
        стрибнути вихід;
      }
      якщо предмет_структури_метода.тип != М.предмет_структури_Структура {
        увімкнути_стан_падіння(М, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
        ціль предмет_помилки = створити_предмет_тексту(М, "Записати дію як метод можна лише в структуру") як адреса<Предмет>;
        якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = предмет_помилки;
        стрибнути вихід;
      }
      змінна ціль результат: предмет_або_стан_падіння = пусто;
      якщо власна {
        результат = предмет_структури_записати_власну_дію(М, предмет_структури_метода як адреса<ПредметСтруктури>, назва_метода як адреса<ПредметТексту>, предмет_дії_метода як адреса<ПредметДії>);
      } інакше {
        результат = предмет_структури_записати_метод(М, предмет_структури_метода як адреса<ПредметСтруктури>, назва_метода як адреса<ПредметТексту>, предмет_дії_метода як адреса<ПредметДії>);
      }
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, предмет_дії_метода);
    } інакше якщо вказівка == ВЗаписатиСпецДію {
      ціль власна = логічне(прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса));
      ціль назва_метода = забрати_з_накопичувача_предметів(М);
      ціль предмет_структури_метода = забрати_з_накопичувача_предметів(М);
      ціль предмет_дії_метода = забрати_з_накопичувача_предметів(М);
      якщо предмет_структури_метода == пусто {
        увімкнути_стан_падіння(М, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
        ціль предмет_помилки = створити_предмет_тексту(М, "Неможливо записати дію як метод для пусто") як адреса<Предмет>;
        якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = предмет_помилки;
        стрибнути вихід;
      }
      якщо предмет_структури_метода.тип != М.предмет_структури_Структура {
        увімкнути_стан_падіння(М, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
        ціль предмет_помилки = створити_предмет_тексту(М, "Записати дію як метод можна лише в структуру") як адреса<Предмет>;
        якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = предмет_помилки;
        стрибнути вихід;
      }
      змінна ціль результат: предмет_або_стан_падіння = пусто;
      якщо власна {
        результат = предмет_структури_змінити_властивість(М, предмет_структури_метода як адреса<ПредметСтруктури>, назва_метода як адреса<ПредметТексту>, привласнити_дію(М, предмет_дії_метода як адреса<ПредметДії>, предмет_структури_метода) як адреса<Предмет>, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      } інакше {
        результат = предмет_структури_змінити_властивість(М, предмет_структури_метода як адреса<ПредметСтруктури>, назва_метода як адреса<ПредметТексту>, предмет_дії_метода, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      }
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, предмет_дії_метода);
    } інакше якщо вказівка == ВСтворитиДіапазон {
      ціль включно = логічне(прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса));
      ціль до = забрати_з_накопичувача_предметів(М);
      ціль від = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_отримати_діапазон(М, від, включно, до, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВВизначити {
      ціль предмет = забрати_з_накопичувача_предметів(М);
      ціль позиція_назви = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      ціль назва = код.константи.дані[позиція_назви] як адреса<ПредметТексту>;
      змінити_в_середовищі(М, середовище, назва, предмет);
    } інакше якщо вказівка == ВЗвернутись {
      ціль позиція_назви = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      ціль назва = код.константи.дані[позиція_назви] як адреса<ПредметТексту>;
      змінна ціль значення: адреса<Предмет> = пусто;
      якщо отримати_зі_середовища(М, середовище, назва, значення::адреса) {
        покласти_в_накопичувач_предметів(М, значення);
      } інакше {
        увімкнути_стан_падіння(М, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
        ціль предмет_помилки = створити_предмет_тексту(М, "Підмет не визначено") як адреса<Предмет>;
        якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = предмет_помилки;
        стрибнути вихід;
      }
    } інакше якщо вказівка == ВВиконати {
      ціль кількість_аргументів = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      ціль кількість_іменованих_аргументів = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      змінна ціль аргументи: памʼять<адреса<Предмет>> = пусто;
      змінна ціль іменовані_аргументи: памʼять<ІменованийАргумент> = пусто;
      ціль притримувач = покласти_притримувач(М);
      якщо кількість_іменованих_аргументів > 0 {
        іменовані_аргументи = виділити_памʼять<ІменованийАргумент>(М, кількість_іменованих_аргументів);
        змінна ціль п: позитивне = 0;
        поки п < кількість_іменованих_аргументів {
          ціль предмет = забрати_з_накопичувача_предметів(М);
          ціль назва = забрати_з_накопичувача_предметів(М) як адреса<ПредметТексту>;
          іменовані_аргументи[кількість_іменованих_аргументів - п - 1] = ІменованийАргумент {
            назва = назва,
            предмет = предмет
          };
          притримати(М, притримувач, назва як адреса<Предмет>);
          притримати(М, притримувач, предмет);
          п += 1;
        }
      }
      якщо кількість_аргументів > 0 {
        аргументи = виділити_памʼять<адреса<Предмет>>(М, кількість_аргументів);
        змінна ціль п: позитивне = 0;
        поки п < кількість_аргументів {
          ціль аргумент = забрати_з_накопичувача_предметів(М);
          аргументи[кількість_аргументів - п - 1] = аргумент;
          притримати(М, притримувач, аргумент);
          п += 1;
        }
      }
      ціль предмет = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_виконати(М, предмет, пусто, кількість_аргументів, аргументи, кількість_іменованих_аргументів, іменовані_аргументи, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      забрати_притримувач(М);
      звільнити_памʼять(М, аргументи);
      звільнити_памʼять(М, іменовані_аргументи);
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВОтриматиВластивість {
      ціль позиція_назви = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      ціль назва = код.константи.дані[позиція_назви] як адреса<ПредметТексту>;
      ціль предмет = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_отримати_властивість(М, предмет, назва, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВЗмінитиВластивість {
      ціль значення = забрати_з_накопичувача_предметів(М);
      ціль позиція_назви = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      ціль назва = код.константи.дані[позиція_назви] як адреса<ПредметТексту>;
      ціль предмет = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_змінити_властивість(М, предмет, назва, значення, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
    } інакше якщо вказівка == ВВиконатиВластивість {
      ціль кількість_аргументів = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      ціль кількість_іменованих_аргументів = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      змінна ціль аргументи: памʼять<адреса<Предмет>> = пусто;
      змінна ціль іменовані_аргументи: памʼять<ІменованийАргумент> = пусто;
      ціль притримувач = покласти_притримувач(М);
      якщо кількість_іменованих_аргументів > 0 {
        іменовані_аргументи = виділити_памʼять<ІменованийАргумент>(М, кількість_іменованих_аргументів);
        змінна ціль п: позитивне = 0;
        поки п < кількість_іменованих_аргументів {
          ціль предмет = забрати_з_накопичувача_предметів(М);
          ціль назва = забрати_з_накопичувача_предметів(М) як адреса<ПредметТексту>;
          іменовані_аргументи[кількість_іменованих_аргументів - п - 1] = ІменованийАргумент {
            назва = назва,
            предмет = предмет
          };
          притримати(М, притримувач, назва як адреса<Предмет>);
          притримати(М, притримувач, предмет);
          п += 1;
        }
      }
      якщо кількість_аргументів > 0 {
        аргументи = виділити_памʼять<адреса<Предмет>>(М, кількість_аргументів);
        змінна ціль п: позитивне = 0;
        поки п < кількість_аргументів {
          ціль аргумент = забрати_з_накопичувача_предметів(М);
          аргументи[кількість_аргументів - п - 1] = аргумент;
          притримати(М, притримувач, аргумент);
          п += 1;
        }
      }
      ціль назва = забрати_з_накопичувача_предметів(М) як адреса<ПредметТексту>;
      ціль предмет = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_виконати_властивість(М, предмет, назва, кількість_аргументів, аргументи, кількість_іменованих_аргументів, іменовані_аргументи, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      забрати_притримувач(М);
      звільнити_памʼять(М, аргументи);
      звільнити_памʼять(М, іменовані_аргументи);
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВОтриматиЕлемент {
      ціль ключ = забрати_з_накопичувача_предметів(М);
      ціль предмет = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_отримати_елемент(М, предмет, ключ, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВЗмінитиЕлемент {
      ціль значення = забрати_з_накопичувача_предметів(М);
      ціль ключ = забрати_з_накопичувача_предметів(М);
      ціль предмет = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_змінити_елемент(М, предмет, ключ, значення, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
    } інакше якщо вказівка == ВОтриматиПеребір {
      ціль предмет = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_отримати_перебір(М, предмет, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВВизначитиЗзовні {
      ціль позиція_назви = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      ціль назва = код.константи.дані[позиція_назви] як адреса<ПредметТексту>;
      ціль предмет = забрати_з_накопичувача_предметів(М);
      якщо середовище.зовнішнє == пусто {
        увімкнути_стан_падіння(М, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
        ціль предмет_помилки = створити_предмет_тексту(М, "Неможливо визначити поза глобальним середовищем") як адреса<Предмет>;
        якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = предмет_помилки;
        стрибнути вихід;
      }
      якщо середовище.зовнішнє == М.предмет_глобального_середовища {
        увімкнути_стан_падіння(М, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
        ціль предмет_помилки = створити_предмет_тексту(М, "Неможливо визначити в глобальному середовищі") як адреса<Предмет>;
        якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = предмет_помилки;
        стрибнути вихід;
      }
      змінити_в_середовищі(М, середовище.зовнішнє, назва, предмет);
    } інакше якщо вказівка == ВВиконатиЗПредка {
      ПОМЕРТИ(М, "Виконання з предка не втілено!");
    } інакше якщо вказівка == ВВидалити {
      ціль назва = забрати_з_накопичувача_предметів(М) як адреса<ПредметТексту>;
      якщо видалити_з_середовища(М, середовище, назва) {
        покласти_в_накопичувач_предметів(М, М.предмет_логічного_так як адреса<Предмет>);
      } інакше {
        покласти_в_накопичувач_предметів(М, М.предмет_логічного_ні як адреса<Предмет>);
      }
    } інакше якщо вказівка == ВВидалитиВластивість {
      ціль назва = забрати_з_накопичувача_предметів(М) як адреса<ПредметТексту>;
      ціль предмет = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_видалити_властивість(М, предмет, назва, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВВидалитиЕлемент {
      ціль ключ = забрати_з_накопичувача_предметів(М);
      ціль предмет = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_видалити_елемент(М, предмет, ключ, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВДодати {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_додати(М, а, б, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВВідняти {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_відняти(М, а, б, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВПомножити {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_помножити(М, а, б, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВПоділити {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_поділити(М, а, б, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВОтриматиОстачуДілення {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_остача(М, а, б, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВОтриматиНеповнуЧасткуДілення {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_частка(М, а, б, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВПіднестиДоСтепеня {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_степінь(М, а, б, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВЗсунутиВліво {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_зсунути_вліво(М, а, б, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВЗсунутиВправо {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_зсунути_вправо(М, а, б, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВЗсунутиВправоЗіЗаповненням {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_зсунути_вправо_зі_заповненням(М, а, б, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВДвійковеІ {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_двійкове_і(М, а, б, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВДвійковеАБО {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_двійкове_або(М, а, б, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВДвійковеВиключнеАБО {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_двійкове_виключне_або(М, а, б, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВДвійковеНЕ {
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_двійкове_заперечення(М, а, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВМенше {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_менше(М, а, б, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВБільше {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_більше(М, а, б, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВНеБільше {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_більше(М, а, б, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      якщо перевірити_чи_предмет_виражається_логічним_так(М, результат) {
        покласти_в_накопичувач_предметів(М, М.предмет_логічного_ні як адреса<Предмет>);
      } інакше {
        покласти_в_накопичувач_предметів(М, М.предмет_логічного_так як адреса<Предмет>);
      }
    } інакше якщо вказівка == ВНеМенше {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_менше(М, а, б, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      якщо перевірити_чи_предмет_виражається_логічним_так(М, результат) {
        покласти_в_накопичувач_предметів(М, М.предмет_логічного_ні як адреса<Предмет>);
      } інакше {
        покласти_в_накопичувач_предметів(М, М.предмет_логічного_так як адреса<Предмет>);
      }
    } інакше якщо вказівка == ВРівно {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      якщо перевірити_чи_предмети_рівні(М, а, б) {
        покласти_в_накопичувач_предметів(М, М.предмет_логічного_так як адреса<Предмет>);
      } інакше {
        покласти_в_накопичувач_предметів(М, М.предмет_логічного_ні як адреса<Предмет>);
      }
    } інакше якщо вказівка == ВНеРівно {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      якщо перевірити_чи_предмети_рівні(М, а, б) {
        покласти_в_накопичувач_предметів(М, М.предмет_логічного_ні як адреса<Предмет>);
      } інакше {
        покласти_в_накопичувач_предметів(М, М.предмет_логічного_так як адреса<Предмет>);
      }
    } інакше якщо вказівка == ВМістить {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_містить(М, а, б, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      якщо перевірити_чи_предмет_виражається_логічним_так(М, результат) {
        покласти_в_накопичувач_предметів(М, М.предмет_логічного_так як адреса<Предмет>);
      } інакше {
        покласти_в_накопичувач_предметів(М, М.предмет_логічного_ні як адреса<Предмет>);
      }
    } інакше якщо вказівка == ВНеМістить {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_містить(М, а, б, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      якщо перевірити_чи_предмет_виражається_логічним_так(М, результат) {
        покласти_в_накопичувач_предметів(М, М.предмет_логічного_ні як адреса<Предмет>);
      } інакше {
        покласти_в_накопичувач_предметів(М, М.предмет_логічного_так як адреса<Предмет>);
      }
    } інакше якщо вказівка == ВЄ {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      якщо а == пусто {
        якщо б == пусто {
          покласти_в_накопичувач_предметів(М, М.предмет_логічного_так як адреса<Предмет>);
        } інакше {
          покласти_в_накопичувач_предметів(М, М.предмет_логічного_ні як адреса<Предмет>);
        }
      } інакше якщо перевірити_чи_предмет_є(М, а, б як адреса<ПредметСтруктури>) {
        покласти_в_накопичувач_предметів(М, М.предмет_логічного_так як адреса<Предмет>);
      } інакше {
        покласти_в_накопичувач_предметів(М, М.предмет_логічного_ні як адреса<Предмет>);
      }
    } інакше якщо вказівка == ВНеЄ {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      якщо а == пусто {
        якщо б == пусто {
          покласти_в_накопичувач_предметів(М, М.предмет_логічного_ні як адреса<Предмет>);
        } інакше {
          покласти_в_накопичувач_предметів(М, М.предмет_логічного_так як адреса<Предмет>);
        }
      } інакше якщо перевірити_чи_предмет_є(М, а, б як адреса<ПредметСтруктури>) {
        покласти_в_накопичувач_предметів(М, М.предмет_логічного_ні як адреса<Предмет>);
      } інакше {
        покласти_в_накопичувач_предметів(М, М.предмет_логічного_так як адреса<Предмет>);
      }
    } інакше якщо вказівка == ВВідʼємне {
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_мінусове(М, а, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВЧислове {
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_число(М, а, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВЗаперечити {
      ціль а = забрати_з_накопичувача_предметів(М);
      якщо перевірити_чи_предмет_виражається_логічним_так(М, а) {
        покласти_в_накопичувач_предметів(М, М.предмет_логічного_ні як адреса<Предмет>);
      } інакше {
        покласти_в_накопичувач_предметів(М, М.предмет_логічного_так як адреса<Предмет>);
      }
    } інакше якщо вказівка == ВЗбільшити {
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_збільшити(М, а, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВЗбільшитиПопереднє {
      ціль б = забрати_з_накопичувача_предметів(М);
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_збільшити(М, а, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
      покласти_в_накопичувач_предметів(М, б);
    } інакше якщо вказівка == ВЗменшити {
      ціль а = забрати_з_накопичувача_предметів(М);
      ціль результат = предмет_зменшити(М, а, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВПочатиСпробу {
      ціль назва_зловити = забрати_з_накопичувача_предметів(М);
      ціль позиція_вказівки_зловити = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      покласти_в_накопичувач<Спроба>(М, спроби::адреса, Спроба {
        назва_зловити = назва_зловити як адреса<ПредметТексту>,
        позиція_вказівки_зловити = позиція_вказівки_зловити,
        розмір_історії = М.історія.розмір,
        розмір_накопичувача_предметів = М.накопичувач_предметів.розмір
      });
    } інакше якщо вказівка == ВВпасти {
      ціль предмет_помилки = забрати_з_накопичувача_предметів(М);
      увімкнути_стан_падіння(М, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
        стрибнути виконання_вказівки;
      }
      предмет_результату = предмет_помилки;
      стрибнути вихід;
    } інакше якщо вказівка == ВЗакінчитиСпробу {
      ціль позиція_вказівки_виходу = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      забрати_з_накопичувача<Спроба>(М, спроби::адреса, пусто);
      позиція_вказівки = позиція_вказівки_виходу;
      стрибнути виконання_вказівки;
    } інакше якщо вказівка == ВВзяти {
      ціль кількість_назв = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      змінна ціль дані_назв: памʼять<адреса<ПредметТексту>> = пусто;
      якщо кількість_назв > 0 {
        дані_назв = виділити_памʼять<адреса<ПредметТексту>>(М, кількість_назв);
        змінна ціль п: позитивне = 0;
        поки п < кількість_назв {
          ціль назва = забрати_з_накопичувача_предметів(М) як адреса<ПредметТексту>;
          дані_назв[кількість_назв - п - 1] = назва;
          п += 1;
        }
      }
      ціль назва = забрати_з_накопичувача_предметів(М) як адреса<ПредметТексту>;
      ціль результат = виконати_взяти(М, середовище, назва, Послідовність<адреса<ПредметТексту>> { кількість_назв, дані_назв });
      звільнити_памʼять(М, дані_назв);
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВДати {
      ціль назва = забрати_з_накопичувача_предметів(М) як адреса<ПредметТексту>;
      ціль предмет = забрати_з_накопичувача_предметів(М);
      якщо середовище.предмет_модуля == пусто {
        увімкнути_стан_падіння(М, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
        ціль предмет_помилки = створити_предмет_тексту(М, "Вказівка \"дати\" працює лише в середовищі модуля") як адреса<Предмет>;
        якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = предмет_помилки;
        стрибнути вихід;
      }
      ціль результат = предмет_змінити_властивість(М, середовище.предмет_модуля як адреса<Предмет>, назва, предмет, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
    } інакше якщо вказівка == ВПеребратиДалі {
      ціль предмет_перебору = забрати_з_накопичувача_предметів(М);
      покласти_в_накопичувач_предметів(М, предмет_перебору);
      ціль результат = предмет_виконати_властивість(М, предмет_перебору, назва(М, "далі"), 0, пусто, 0, пусто, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
      якщо увімкнено_стан_падіння(М) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
          стрибнути виконання_вказівки;
        }
        предмет_результату = результат;
        стрибнути вихід;
      }
      покласти_в_накопичувач_предметів(М, результат);
    } інакше якщо вказівка == ВЗбитиТекст {
      ціль кількість_предметів = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      змінна ціль предмети = виділити_памʼять<адреса<Предмет>>(М, кількість_предметів);
      змінна ціль п: позитивне = 0;
      ціль притримувач = покласти_притримувач(М);
      поки п < кількість_предметів {
        предмети[кількість_предметів - п - 1] = забрати_з_накопичувача_предметів(М);
        притримати(М, притримувач, предмети[кількість_предметів - п - 1]);
        п += 1;
      }
      змінна ціль накопичувач_т8 = зробити_накопичувач<п8>(М);
      п = 0;
      поки п < кількість_предметів {
        ціль предмет_як_текст = предмет_текст(М, предмети[п], Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки }) як адреса<ПредметТексту>;
        якщо увімкнено_стан_падіння(М) {
          якщо обробити_стан_падіння(М, середовище, код, предмет_як_текст як адреса<Предмет>, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
            стрибнути виконання_вказівки;
          }
          предмет_результату = предмет_як_текст як адреса<Предмет>;
          стрибнути вихід;
        }
        якщо предмет_як_текст.тип != М.предмет_структури_текст {
          увімкнути_стан_падіння(М, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
          ціль предмет_помилки = створити_предмет_тексту(М, "Не вдалось перетворити на текст") як адреса<Предмет>;
          якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
            стрибнути виконання_вказівки;
          }
          предмет_результату = предмет_помилки;
          стрибнути вихід;
        }
        покласти_в_накопичувач_т8(М, накопичувач_т8::адреса, предмет_як_текст.значення);
        п += 1;
      }
      звільнити_памʼять(М, предмети);
      покласти_в_накопичувач_предметів(М, створити_предмет_тексту(М, т8 { накопичувач_т8.розмір, накопичувач_т8.дані }) як адреса<Предмет>);
      звільнити_памʼять(М, накопичувач_т8.дані);
      забрати_притримувач(М);
    } інакше якщо вказівка == ВЗбитиЮнікод {
      ціль кількість_предметів = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      змінна ціль предмети = виділити_памʼять<адреса<Предмет>>(М, кількість_предметів);
      змінна ціль п: позитивне = 0;
      ціль притримувач = покласти_притримувач(М);
      поки п < кількість_предметів {
        предмети[кількість_предметів - п - 1] = забрати_з_накопичувача_предметів(М);
        притримати(М, притримувач, предмети[кількість_предметів - п - 1]);
        п += 1;
      }
      змінна ціль накопичувач_ю32 = зробити_накопичувач<п32>(М);
      п = 0;
      поки п < кількість_предметів {
        ціль предмет_як_юнікод = предмет_юнікод(М, предмети[п], Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки }) як адреса<ПредметЮнікоду>;
        якщо увімкнено_стан_падіння(М) {
          якщо обробити_стан_падіння(М, середовище, код, предмет_як_юнікод як адреса<Предмет>, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
            стрибнути виконання_вказівки;
          }
          предмет_результату = предмет_як_юнікод як адреса<Предмет>;
          стрибнути вихід;
        }
        якщо предмет_як_юнікод.тип != М.предмет_структури_юнікод {
          увімкнути_стан_падіння(М, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
          ціль предмет_помилки = створити_предмет_тексту(М, "Не вдалось перетворити на юнікод") як адреса<Предмет>;
          якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
            стрибнути виконання_вказівки;
          }
          предмет_результату = предмет_помилки;
          стрибнути вихід;
        }
        покласти_в_накопичувач_ю32(М, накопичувач_ю32::адреса, предмет_як_юнікод.значення);
        п += 1;
      }
      звільнити_памʼять(М, предмети);
      покласти_в_накопичувач_предметів(М, створити_предмет_юнікоду(М, ю32 { накопичувач_ю32.розмір, накопичувач_ю32.дані }) як адреса<Предмет>);
      звільнити_памʼять(М, накопичувач_ю32.дані);
      забрати_притримувач(М);
    } інакше якщо вказівка == ВСтворитиПараметр {
      ціль код_значення_параметра = забрати_з_накопичувача_предметів(М) як адреса<ПредметКоду>;
      ціль тип_параметра = забрати_з_накопичувача_предметів(М) як адреса<ПредметТипу>;
      ціль назва_параметра = забрати_з_накопичувача_предметів(М) як адреса<ПредметТексту>;
      ціль параметр = створити_предмет_параметра(М, назва_параметра, тип_параметра, код_значення_параметра);
      покласти_в_накопичувач_предметів(М, параметр як адреса<Предмет>);
    } інакше якщо вказівка == ВСтворитиТип {
      ціль кількість_допустимих = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      змінна ціль може_бути_пусто = ні;
      якщо кількість_допустимих > 0 {
        ціль допустимі_структури = зробити_накопичувач<адреса<ПредметСтруктури>>(М);
        змінна ціль п: позитивне = 0;
        поки п < кількість_допустимих {
          ціль допустима_структура = забрати_з_накопичувача_предметів(М);
          якщо допустима_структура == пусто {
            може_бути_пусто = так;
          } інакше якщо допустима_структура.тип != М.предмет_структури_Структура {
            звільнити_накопичувач<адреса<ПредметСтруктури>>(М, допустимі_структури);
            увімкнути_стан_падіння(М, Місцезнаходження { код.шлях як адреса<ПредметТексту>, рядок_вказівки });
            ціль предмет_помилки = створити_предмет_тексту(М, "Тип має бути структурою") як адреса<Предмет>;
            якщо обробити_стан_падіння(М, середовище, код, предмет_помилки, позиція_поточної_вказівки, рядок_вказівки, спроби::адреса, позиція_вказівки::адреса) {
              стрибнути виконання_вказівки;
            }
            предмет_результату = предмет_помилки;
            стрибнути вихід;
          } інакше {
            покласти_в_накопичувач<адреса<ПредметСтруктури>>(М, допустимі_структури::адреса, допустима_структура як адреса<ПредметСтруктури>);
          }
          п += 1;
        }
        ціль предмет_типу = створити_предмет_типу(М, може_бути_пусто, Послідовність<адреса<ПредметСтруктури>> { допустимі_структури.розмір, допустимі_структури.дані });
        покласти_в_накопичувач_предметів(М, предмет_типу як адреса<Предмет>);
      } інакше {
        покласти_в_накопичувач_предметів(М, пусто);
      }
    } інакше якщо вказівка == ВСтрибнути {
      ціль позиція_вказівки_стрибка = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      позиція_вказівки = позиція_вказівки_стрибка;
      стрибнути виконання_вказівки;
    } інакше якщо вказівка == ВСтрибнутиЯкщоНі {
      ціль значення = забрати_з_накопичувача_предметів(М);
      ціль позиція_вказівки_стрибка = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      якщо перевірити_чи_предмет_виражається_логічним_так(М, значення) == ні {
        позиція_вказівки = позиція_вказівки_стрибка;
        стрибнути виконання_вказівки;
      }
    } інакше якщо вказівка == ВЗабрати {
      забрати_з_накопичувача_предметів(М);
    } інакше якщо вказівка == ВВернути {
      предмет_результату = забрати_з_накопичувача_предметів(М);
      стрибнути вихід;
    } інакше якщо вказівка == ВСтрибнутиЯкщоНіЗалишивши {
      ціль значення = забрати_з_накопичувача_предметів(М);
      покласти_в_накопичувач_предметів(М, значення);
      ціль позиція_вказівки_стрибка = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      якщо перевірити_чи_предмет_виражається_логічним_так(М, значення) == ні {
        позиція_вказівки = позиція_вказівки_стрибка;
        стрибнути виконання_вказівки;
      }
    } інакше якщо вказівка == ВСтрибнутиЯкщоТак {
      ціль значення = забрати_з_накопичувача_предметів(М);
      ціль позиція_вказівки_стрибка = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      якщо перевірити_чи_предмет_виражається_логічним_так(М, значення) == ні {
        позиція_вказівки = позиція_вказівки_стрибка;
        стрибнути виконання_вказівки;
      }
    } інакше якщо вказівка == ВСтрибнутиЯкщоТакЗалишивши {
      ціль значення = забрати_з_накопичувача_предметів(М);
      покласти_в_накопичувач_предметів(М, значення);
      ціль позиція_вказівки_стрибка = прочитати_аргумент_вказівки(М, вказівки, позиція_вказівки::адреса);
      якщо перевірити_чи_предмет_виражається_логічним_так(М, значення) == ні {
        позиція_вказівки = позиція_вказівки_стрибка;
        стрибнути виконання_вказівки;
      }
    } інакше якщо вказівка == ВДублювати {
      ціль значення = забрати_з_накопичувача_предметів(М);
      покласти_в_накопичувач_предметів(М, значення);
      покласти_в_накопичувач_предметів(М, значення);
    } інакше якщо вказівка == ВДублюватиПопереднє {
      ціль значення2 = забрати_з_накопичувача_предметів(М);
      ціль значення1 = забрати_з_накопичувача_предметів(М);
      покласти_в_накопичувач_предметів(М, значення1);
      покласти_в_накопичувач_предметів(М, значення2);
      покласти_в_накопичувач_предметів(М, значення1);
    } інакше {
      надрукувати_ю8(ю8"невідома вказівка");
      ПОМЕРТИ(М, "невідома вказівка");
    }
    позиція_вказівки += 1;
    стрибнути виконання_вказівки;
    вихід:
    звільнити_накопичувач<Спроба>(М, спроби);
    вернути предмет_результату;
  }

  дія отримати_назву_паку_з_середовища(М: адреса<Машина>, середовище: адреса<ПредметСередовища>): адреса<ПредметТексту> {
    змінна ціль поточне_середовище = середовище;
    поки поточне_середовище != пусто {
      якщо поточне_середовище.предмет_модуля != пусто {
        якщо поточне_середовище.предмет_модуля.назва_паку != пусто {
          вернути поточне_середовище.предмет_модуля.назва_паку;
        }
      }
      поточне_середовище = поточне_середовище.зовнішнє;
    }
    вернути пусто;
  }

  зовнішня дія виконати_взяти(М: адреса<Машина>, середовище: адреса<ПредметСередовища>, репозиторій: адреса<ПредметТексту>, назви_шляху: Послідовність<адреса<ПредметТексту>>): предмет_або_стан_падіння {
    ціль назва_паку = отримати_назву_паку_з_середовища(М, середовище);
    якщо М.обробник_взяття == пусто {
      вернути результат_стан_падіння(М, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 }, створити_предмет_тексту(М, "Обробник взяття не втілено в Машині") як адреса<Предмет>);
    }
    вернути М.обробник_взяття(М, назва_паку, репозиторій, назви_шляху.розмір, назви_шляху.дані);
  }

  зовнішня дія отримати_взятий_предмет(М: адреса<Машина>, ключ: адреса<Предмет>, вихід: адреса<адреса<Предмет>>): логічне {
    змінна ціль елемент_реєстру = ЕлементРеєстру<адреса<Предмет>, адреса<Предмет>> { ... };
    якщо знайти_в_реєстрі<адреса<Предмет>, адреса<Предмет>>(М, М.взяті_предмети::адреса, ключ, елемент_реєстру::адреса) {
      вихід::вміст = елемент_реєстру.значення;
      вернути так;
    }
    вернути ні;
  }

  зовнішня дія покласти_взятий_предмет(М: адреса<Машина>, ключ: адреса<Предмет>, значення: адреса<Предмет>) {
    змінити_в_реєстрі<адреса<Предмет>, адреса<Предмет>>(М, М.взяті_предмети::адреса, ключ, значення);
  }
}