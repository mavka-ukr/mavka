взяти визначення ./МаМа;

секція МаМа {
  місцева дія перевірити_чи_ю8_рівні(а: ю8, б: ю8): логічне {
    вернути КД::перевірити_чи_ю8_рівні(а, б);
  }

  місцева дія перевірити_чи_ю32_рівні(а: ю32, б: ю32): логічне {
    вернути КД::перевірити_чи_ю32_рівні(а, б);
  }

  місцева дія перевірити_чи_т8_рівні(а: т8, б: т8): логічне {
    вернути КД::перевірити_чи_т8_рівні(а, б);
  }

  місцева дія перевірити_чи_т32_рівні(а: т32, б: т32): логічне {
    вернути КД::перевірити_чи_т32_рівні(а, б);
  }

  місцева дія виділити_копію_байтів(М: адреса<Машина>, вхід: памʼять<п8>, розмір_входу: позитивне, вихід: адреса<памʼять<п8>>): позитивне {
    якщо розмір_входу == 0 {
      вихід::вміст = пусто як памʼять<п8>;
      вернути 0;
    }
    ціль копія = виділити<п8>(М, розмір_входу);
    змінна ціль позиція: позитивне = 0;
    поки позиція < розмір_входу {
      копія[позиція] = вхід[позиція];
      позиція += 1;
    }
    вихід::вміст = копія;
    вернути позиція;
  }

  місцева дія виділити_копію_Ю8(М: адреса<Машина>, вхід: памʼять<п8>, розмір_входу: позитивне, вихід: адреса<памʼять<п8>>): позитивне {
    ціль копія = виділити<п8>(М, розмір_входу + 1);
    змінна ціль позиція: позитивне = 0;
    поки позиція < розмір_входу {
      копія[позиція] = вхід[позиція];
      позиція += 1;
    }
    копія[позиція] = 0;
    вихід::вміст = копія;
    вернути позиція;
  }

  місцева дія виділити_копію_Ю32(М: адреса<Машина>, вхід: памʼять<п32>, розмір_входу: позитивне, вихід: адреса<памʼять<п32>>): позитивне {
    ціль копія = виділити<п32>(М, розмір_входу + 1);
    змінна ціль позиція: позитивне = 0;
    поки позиція < розмір_входу {
      копія[позиція] = вхід[позиція];
      позиція += 1;
    }
    копія[позиція] = 0;
    вихід::вміст = копія;
    вернути позиція;
  }

  місцева дія дізнатись_розмір_символа_юнікоду(перший_байт: п8): п8 {
    якщо (перший_байт & 128) == 0 {
      вернути 1;
    }
    якщо (перший_байт & 224) == 192 {
      вернути 2;
    }
    якщо (перший_байт & 240) == 224 {
      вернути 3;
    }
    якщо (перший_байт & 248) == 240 {
      вернути 4;
    }
    вернути 0;
  }

  місцева дія вивести_текст(М: адреса<Машина>, значення: т8) {
    М.система.вивести_т8_в_стандартний_вивід(М, значення);
  }

  місцева дія вивести_ю8(М: адреса<Машина>, значення: ю8) {
    М.система.вивести_ю8_в_стандартний_вивід(М, значення);
  }

  місцева дія надрукувати_ю8(М: адреса<Машина>, значення: ю8) {
    вивести_ю8(М, значення);
    ціль символ_нового_рядка_Ю8: п8 = 10;
    М.система.вивести_в_стандартний_вивід(М, символ_нового_рядка_Ю8::адреса як памʼять<п8>, 1);
  }

  місцева дія перетворити_д64_в_Ю8(М: адреса<Машина>, значення: д64, вихід: адреса<ю8>): позитивне {
    перетворити_д64_в_ю8(М, значення, вихід);
    вернути вихід::вміст.розмір;
  }

  місцева дія перетворити_п64_в_ю8(М: адреса<Машина>, значення: п64): ю8 {
    змінна ціль буфер = виділити<п8>(М, 21);
    змінна ціль індекс: ц32 = 20;
    буфер[20] = 0;
    поки (значення > 0) {
      індекс = індекс - 1;
      буфер[індекс] = п8(значення % 10) + 48;
      значення = значення / 10;
    }
    якщо (індекс == 20) {
      індекс = індекс - 1;
      буфер[індекс] = 48;
    }
    ціль результуючий_буфер = виділити<п8>(М, позитивне(ц32(21) - індекс));
    змінна ціль х: ц32 = 0;
    поки (індекс < 21) {
      результуючий_буфер[х] = буфер[індекс];
      х = х + 1;
      індекс = індекс + 1;
    }
    звільнити(М, буфер як адреса);
    вернути ю8 { порахувати_розмір_ю8сі(результуючий_буфер), результуючий_буфер };
  }

  місцева дія вивести_п64(М: адреса<Машина>, значення: п64) {
    ціль п64ю8 = перетворити_п64_в_ю8(М, значення);
    вивести_ю8(М, п64ю8);
    звільнити(М, п64ю8.дані як адреса);
  }

  місцева дія надрукувати_п64(М: адреса<Машина>, значення: п64) {
    ціль п64ю8 = перетворити_п64_в_ю8(М, значення);
    надрукувати_ю8(М, п64ю8);
    звільнити(М, п64ю8.дані як адреса);
  }

  місцева дія вивести_д64(М: адреса<Машина>, значення: д64) {
    ціль д64ю8 = ю8 { 0, пусто };
    якщо перетворити_д64_в_Ю8(М, значення, д64ю8::адреса) == 0 {
      ПОМЕРТИ(М, ю8"Помилка при конвертації дійсного числа в рядок");
    }
    вивести_ю8(М, д64ю8);
    звільнити(М, д64ю8.дані як адреса);
  }

  місцева дія надрукувати_д64(М: адреса<Машина>, значення: д64) {
    ціль д64ю8 = ю8 { 0, пусто };
    якщо перетворити_д64_в_Ю8(М, значення, д64ю8::адреса) == 0 {
      ПОМЕРТИ(М, ю8"Помилка при конвертації дійсного числа в рядок");
    }
    надрукувати_ю8(М, д64ю8);
    звільнити(М, д64ю8.дані як адреса);
  }

  місцева дія порахувати_розмір_ю8сі(значення: памʼять<п8>): позитивне {
    вернути КД::порахувати_розмір_ю8сі(значення);
  }

  місцева дія порахувати_розмір_ю32сі(значення: памʼять<п32>): позитивне {
    вернути КД::порахувати_розмір_ю32сі(значення);
  }

  місцева дія порахувати_розмір_т8сі(значення: памʼять<п8>): позитивне {
    вернути КД::порахувати_розмір_т8сі(значення);
  }

  місцева дія порахувати_розмір_т32сі(значення: памʼять<п32>): позитивне {
    вернути КД::порахувати_розмір_т32сі(значення);
  }
}

секція МаМа {
  місцева дія виділити_копію_тексту_цілі(М: адреса<Машина>, значення: т8, вихід: адреса<т8>): логічне {
    ціль копія = т8 {
      значення.розмір,
      виділити<п8>(М, значення.розмір)
    };
    змінна ціль п: позитивне = 0;
    поки п < значення.розмір {
      копія.дані[п] = значення.дані[п];
      п += 1;
    }
    вихід::вміст = копія;
    вернути так;
  }

  місцева дія виділити_копію_ю8_цілі(М: адреса<Машина>, значення: ю8, вихід: адреса<ю8>): логічне {
    ціль копія = ю8 {
      значення.розмір,
      виділити<п8>(М, значення.розмір)
    };
    змінна ціль п: позитивне = 0;
    поки п < значення.розмір {
      копія.дані[п] = значення.дані[п];
      п += 1;
    }
    вихід::вміст = копія;
    вернути так;
  }

  місцева дія виділити_копію_ю8_цілі_з_ю8сі(М: адреса<Машина>, значення: памʼять<п8>, вихід: адреса<ю8>): логічне {
    ціль розмір_значення = МаМа::порахувати_розмір_ю8сі(значення);
    ціль копія = ю8 {
      розмір_значення,
      виділити<п8>(М, розмір_значення)
    };
    змінна ціль п: позитивне = 0;
    поки п < розмір_значення {
      копія.дані[п] = значення[п];
      п += 1;
    }
    вихід::вміст = копія;
    вернути так;
  }

  місцева дія виділити_копію_ю8сі_цілі_з_ю8(М: адреса<Машина>, значення: ю8, вихід: адреса<памʼять<п8>>): логічне {
    ціль копія_ю8сі = МаМа::виділити<п8>(М, значення.розмір + 1);
    змінна ціль п: позитивне = 0;
    поки п < значення.розмір {
      копія_ю8сі[п] = значення.дані[п];
      п += 1;
    }
    копія_ю8сі[значення.розмір] = 0;
    вихід::вміст = копія_ю8сі;
    вернути так;
  }

  місцева дія виділити_копію_ю8сі_цілі_з_тексту(М: адреса<Машина>, значення: т8, вихід: адреса<памʼять<п8>>): логічне {
    змінна ціль значення_ю8 = ю8 { 0, пусто };
    якщо МаМа::перекодувати_т8_в_ю8(М, значення, значення_ю8::адреса, так) == ні {
      вернути ні;
    }
    вихід::вміст = значення_ю8.дані;
    вернути так;
  }

  дія система_КД_виділити_сиру_памʼять(система: адреса<КД::Система>, розмір: позитивне): памʼять<п8> {
    ціль М = система.дані як адреса<Машина>;
    вернути виділити<п8>(М, розмір);
  }

  дія система_КД_перевиділити_сиру_памʼять(система: адреса<КД::Система>, значення: памʼять<п8>, новий_розмір: позитивне): памʼять<п8> {
    ціль М = система.дані як адреса<Машина>;
    вернути перевиділити<п8>(М, значення, новий_розмір);
  }

  дія система_КД_звільнити_сиру_памʼять(система: адреса<КД::Система>, значення: невідома_памʼять) {
    ціль М = система.дані як адреса<Машина>;
    звільнити(М, значення як невідома_адреса);
  }

  місцева дія виділити_копію_ю8_цілі_з_тексту(М: адреса<Машина>, значення: т8, вихід: адреса<ю8>): логічне {
    вернути МаМа::перекодувати_т8_в_ю8(М, значення, вихід, ні);
  }

  місцева дія перекодувати_ю8_в_т8(М: адреса<Машина>, вхід: ю8, вихід: адреса<т8>, з_нульовим_байтом_в_кінці: логічне): логічне {
    ціль система = КД::Система {
      дані = М,
      виділити_сиру_памʼять = система_КД_виділити_сиру_памʼять,
      перевиділити_сиру_памʼять = система_КД_перевиділити_сиру_памʼять,
      звільнити_сиру_памʼять = система_КД_звільнити_сиру_памʼять,
    };
    вернути КД::перекодувати_ю8_в_т8(система::адреса, вхід, вихід, з_нульовим_байтом_в_кінці);
  }

  місцева дія перекодувати_ю8_в_ю32(М: адреса<Машина>, вхід: ю8, вихід: адреса<ю32>, з_нульовим_байтом_в_кінці: логічне): логічне {
    ціль система = КД::Система {
      дані = М,
      виділити_сиру_памʼять = система_КД_виділити_сиру_памʼять,
      перевиділити_сиру_памʼять = система_КД_перевиділити_сиру_памʼять,
      звільнити_сиру_памʼять = система_КД_звільнити_сиру_памʼять,
    };
    вернути КД::перекодувати_ю8_в_ю32(система::адреса, вхід, вихід, з_нульовим_байтом_в_кінці);
  }

  місцева дія перекодувати_ю32_в_ю8(М: адреса<Машина>, вхід: ю32, вихід: адреса<ю8>, з_нульовим_байтом_в_кінці: логічне): логічне {
    ціль система = КД::Система {
      дані = М,
      виділити_сиру_памʼять = система_КД_виділити_сиру_памʼять,
      перевиділити_сиру_памʼять = система_КД_перевиділити_сиру_памʼять,
      звільнити_сиру_памʼять = система_КД_звільнити_сиру_памʼять,
    };
    вернути КД::перекодувати_ю32_в_ю8(система::адреса, вхід, вихід, з_нульовим_байтом_в_кінці);
  }

  місцева дія перекодувати_т8_в_ю8(М: адреса<Машина>, вхід: т8, вихід: адреса<ю8>, з_нульовим_байтом_в_кінці: логічне): логічне {
    ціль система = КД::Система {
      дані = М,
      виділити_сиру_памʼять = система_КД_виділити_сиру_памʼять,
      перевиділити_сиру_памʼять = система_КД_перевиділити_сиру_памʼять,
      звільнити_сиру_памʼять = система_КД_звільнити_сиру_памʼять,
    };
    вернути КД::перекодувати_т8_в_ю8(система::адреса, вхід, вихід, з_нульовим_байтом_в_кінці);
  }
}