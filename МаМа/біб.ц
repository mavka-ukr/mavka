взяти визначення ./МаМа;

секція МаМа {
  місцева дія перевірити_чи_ю8_рівні(а: ю8, б: ю8): логічне {
    якщо а.розмір != б.розмір {
      вернути ні;
    }
    змінна ціль п: позитивне = 0;
    поки п < а.розмір {
      якщо а.дані[п] != б.дані[п] {
        вернути ні;
      }
      п += 1;
    }
    вернути так;
  }

  місцева дія перевірити_чи_тексти_рівні(а: текст, б: текст): логічне {
    якщо а.розмір != б.розмір {
      вернути ні;
    }
    змінна ціль п: позитивне = 0;
    поки п < а.розмір {
      якщо а.дані[п] != б.дані[п] {
        вернути ні;
      }
      п += 1;
    }
    вернути так;
  }

  місцева дія виділити_копію_байтів(М: адреса<Машина>, вхід: памʼять<п8>, розмір_входу: позитивне, вихід: адреса<памʼять<п8>>): позитивне {
    якщо розмір_входу == 0 {
      вихід::вміст = пусто як памʼять<п8>;
      вернути 0;
    }
    ціль копія = виділити<п8>(М, розмір_входу);
    змінна ціль позиція: позитивне = 0;
    поки позиція < розмір_входу {
      копія[позиція] = вхід[позиція];
      позиція += 1;
    }
    вихід::вміст = копія;
    вернути позиція;
  }

  місцева дія виділити_копію_Ю8(М: адреса<Машина>, вхід: памʼять<п8>, розмір_входу: позитивне, вихід: адреса<памʼять<п8>>): позитивне {
    ціль копія = виділити<п8>(М, розмір_входу + 1);
    змінна ціль позиція: позитивне = 0;
    поки позиція < розмір_входу {
      копія[позиція] = вхід[позиція];
      позиція += 1;
    }
    копія[позиція] = 0;
    вихід::вміст = копія;
    вернути позиція;
  }

  місцева дія виділити_копію_Ю32(М: адреса<Машина>, вхід: памʼять<п32>, розмір_входу: позитивне, вихід: адреса<памʼять<п32>>): позитивне {
    ціль копія = виділити<п32>(М, розмір_входу + 1);
    змінна ціль позиція: позитивне = 0;
    поки позиція < розмір_входу {
      копія[позиція] = вхід[позиція];
      позиція += 1;
    }
    копія[позиція] = 0;
    вихід::вміст = копія;
    вернути позиція;
  }

  місцева дія дізнатись_розмір_символа_юнікоду(перший_байт: п8): п8 {
    якщо (перший_байт & 128) == 0 {
      вернути 1;
    }
    якщо (перший_байт & 224) == 192 {
      вернути 2;
    }
    якщо (перший_байт & 240) == 224 {
      вернути 3;
    }
    якщо (перший_байт & 248) == 240 {
      вернути 4;
    }
    вернути 0;
  }

  місцева дія перекодувати_Ю8_в_Ю32(М: адреса<Машина>, вхід: памʼять<п8>, розмір_входу: позитивне, адреса_виходу: адреса<памʼять<п32>>): позитивне {
    змінна ціль вихід: памʼять<п32> = виділити<п32>(М, розмір_входу + 1);
    змінна ціль розмір_виходу: позитивне = 0;
    змінна ціль х: позитивне = 0;
    поки х < розмір_входу {
      ціль перший_байт = вхід[х];
      ціль розмір_символа = дізнатись_розмір_символа_юнікоду(перший_байт);
      якщо розмір_символа == 1 {
        вихід[розмір_виходу] = п32(перший_байт & 127);
        розмір_виходу = розмір_виходу + 1;
      }
      якщо розмір_символа == 2 {
        ціль другий_байт = вхід[х + 1];
        вихід[розмір_виходу] = (п32(перший_байт & 31) << 6) | п32(другий_байт & 63);
        розмір_виходу = розмір_виходу + 1;
        х = х + 1;
      }
      якщо розмір_символа == 3 {
        ціль другий_байт = вхід[х + 1];
        ціль третій_байт = вхід[х + 2];
        вихід[розмір_виходу] = (п32(перший_байт & 15) << 12) | (п32(другий_байт & 63) << 6) | п32(третій_байт & 63);
        розмір_виходу = розмір_виходу + 1;
        х = х + 2;
      }
      якщо розмір_символа == 4 {
        ціль другий_байт = вхід[х + 1];
        ціль третій_байт = вхід[х + 2];
        ціль четвертий_байт = вхід[х + 3];
        вихід[розмір_виходу] = (п32(перший_байт & 15) << 18) | (п32(другий_байт & 63) << 12) | (п32(третій_байт & 63) << 6) | п32(четвертий_байт & 63);
        розмір_виходу = розмір_виходу + 1;
        х = х + 3;
      }
      х = х + 1;
    }
    вихід[розмір_виходу] = 0;
    вихід = перевиділити<п32>(М, вихід, розмір_виходу + 1);
    адреса_виходу::вміст = вихід;
    вернути розмір_виходу;
  }

  місцева дія перекодувати_Ю32_в_Ю8(М: адреса<Машина>, вхід: памʼять<п32>, розмір_входу: позитивне, адреса_виходу: адреса<памʼять<п8>>): позитивне {
    змінна ціль вихід = виділити<п8>(М, розмір_входу * 4 + 1) як памʼять<п8>;
    змінна ціль розмір_виходу: позитивне = 0;
    змінна ціль п: позитивне = 0;
    поки п < розмір_входу {
      ціль с = вхід[п];
      якщо с < 128 {
        вихід[розмір_виходу] = п8(с);
        розмір_виходу += 1;
      } інакше якщо с < 2048 {
        вихід[розмір_виходу] = п8(п32(192) | (с >> 6));
        розмір_виходу += 1;
        вихід[розмір_виходу] = п8(п32(128) | (с & 63));
        розмір_виходу += 1;
      } інакше якщо с < 65536 {
        вихід[розмір_виходу] = п8(п32(224) | (с >> 12));
        розмір_виходу += 1;
        вихід[розмір_виходу] = п8(п32(128) | ((с >> 6) & 63));
        розмір_виходу += 1;
        вихід[розмір_виходу] = п8(п32(128) | (с & 63));
        розмір_виходу += 1;
      } інакше {
        вихід[розмір_виходу] = п8(п32(240) | (с >> 18));
        розмір_виходу += 1;
        вихід[розмір_виходу] = п8(п32(128) | ((с >> 12) & 63));
        розмір_виходу += 1;
        вихід[розмір_виходу] = п8(п32(128) | ((с >> 6) & 63));
        розмір_виходу += 1;
        вихід[розмір_виходу] = п8(п32(128) | (с & 63));
        розмір_виходу += 1;
      }
      п += 1;
    }
    вихід[розмір_виходу] = 0;
    вихід = перевиділити<п8>(М, вихід, розмір_виходу + 1);
    адреса_виходу::вміст = вихід;
    вернути розмір_виходу;
  }

  місцева дія порівняти_КД(а: памʼять<п8>, б: памʼять<п8>): ціле {
    змінна ціль позиція: позитивне = 0;
    поки а[позиція] != 0 {
      якщо б[позиція] == 0 {
        вернути ціле(а[позиція] - б[позиція]);
      }
      якщо а[позиція] != б[позиція] {
        вернути ціле(а[позиція] - б[позиція]);
      }
      позиція += 1;
    }
    вернути ціле(а[позиція] - б[позиція]);
  }

  місцева дія порівняти_Ю32(а: памʼять<п32>, б: памʼять<п32>): ціле {
    змінна ціль позиція: позитивне = 0;
    поки а[позиція] != 0 {
      якщо б[позиція] == 0 {
        вернути ціле(а[позиція] - б[позиція]);
      }
      якщо а[позиція] != б[позиція] {
        вернути ціле(а[позиція] - б[позиція]);
      }
      позиція += 1;
    }
    вернути ціле(а[позиція] - б[позиція]);
  }

  місцева дія вивести_текст(М: адреса<Машина>, значення: текст) {
    М.система.вивести_текст_в_стандартний_вивід(М, значення);
  }

  місцева дія вивести_Ю8(М: адреса<Машина>, значення: ю8) {
    М.система.вивести_ю8_в_стандартний_вивід(М, значення);
  }

  місцева дія надрукувати_Ю8(М: адреса<Машина>, значення: ю8) {
    вивести_Ю8(М, значення);
    ціль символ_нового_рядка_Ю8: п8 = 10;
    М.система.вивести_в_стандартний_вивід(М, символ_нового_рядка_Ю8::адреса як памʼять<п8>, 1);
  }

  місцева дія перетворити_д64_в_Ю8(М: адреса<Машина>, значення: д64, вихід: адреса<ю8>): позитивне {
    ціль розмір_виходу: позитивне = 0;
    М.система.д64_в_Ю8(М, значення, вихід, розмір_виходу::адреса);
    вернути розмір_виходу;
  }

  місцева дія перетворити_п64_в_ю8(М: адреса<Машина>, значення: п64): ю8 {
    змінна ціль буфер = виділити<п8>(М, 21);
    змінна ціль індекс: ц32 = 20;
    буфер[20] = 0;
    поки (значення > 0) {
      індекс = індекс - 1;
      буфер[індекс] = п8(значення % 10) + 48;
      значення = значення / 10;
    }
    якщо (індекс == 20) {
      індекс = індекс - 1;
      буфер[індекс] = 48;
    }
    ціль результуючий_буфер = виділити<п8>(М, позитивне(ц32(21) - індекс));
    змінна ціль х: ц32 = 0;
    поки (індекс < 21) {
      результуючий_буфер[х] = буфер[індекс];
      х = х + 1;
      індекс = індекс + 1;
    }
    звільнити(М, буфер як адреса);
    вернути ю8 { результуючий_буфер, МаМа::порахувати_розмір_ю8сі(результуючий_буфер) };
  }

  місцева дія вивести_п64(М: адреса<Машина>, значення: п64) {
    ціль п64ю8 = перетворити_п64_в_ю8(М, значення);
    вивести_Ю8(М, п64ю8);
    звільнити(М, п64ю8.дані як адреса);
  }

  місцева дія надрукувати_п64(М: адреса<Машина>, значення: п64) {
    ціль п64ю8 = перетворити_п64_в_ю8(М, значення);
    надрукувати_Ю8(М, п64ю8);
    звільнити(М, п64ю8.дані як адреса);
  }

  місцева дія вивести_д64(М: адреса<Машина>, значення: д64) {
    ціль д64ю8 = ю8 { пусто, 0 };
    якщо перетворити_д64_в_Ю8(М, значення, д64ю8::адреса) == 0 {
      ПОМЕРТИ(М, ю8"Помилка при конвертації дійсного числа в рядок");
    }
    вивести_Ю8(М, д64ю8);
    звільнити(М, д64ю8.дані як адреса);
  }

  місцева дія надрукувати_д64(М: адреса<Машина>, значення: д64) {
    ціль д64ю8 = ю8 { пусто, 0 };
    якщо перетворити_д64_в_Ю8(М, значення, д64ю8::адреса) == 0 {
      ПОМЕРТИ(М, ю8"Помилка при конвертації дійсного числа в рядок");
    }
    надрукувати_Ю8(М, д64ю8);
    звільнити(М, д64ю8.дані як адреса);
  }

  місцева дія порахувати_розмір_ю8сі(значення: памʼять<п8>): позитивне {
    змінна ціль довжина: позитивне = 0;
    поки значення[довжина] != 0 {
      довжина += 1;
    }
    вернути довжина;
  }

  місцева дія порахувати_розмір_Ю32(значення: памʼять<п32>): позитивне {
    змінна ціль довжина: позитивне = 0;
    поки значення[довжина] != 0 {
      довжина += 1;
    }
    вернути довжина;
  }
}

секція МаМа {
  місцева дія виділити_копію_тексту_цілі(М: адреса<Машина>, значення: текст, вихід: адреса<текст>): логічне {
    ціль копія = текст {
      виділити<п8>(М, значення.розмір),
      значення.розмір
    };
    змінна ціль п: позитивне = 0;
    поки п < значення.розмір {
      копія.дані[п] = значення.дані[п];
      п += 1;
    }
    вихід::вміст = копія;
    вернути так;
  }

  місцева дія виділити_копію_ю8_цілі(М: адреса<Машина>, значення: ю8, вихід: адреса<ю8>): логічне {
    ціль копія = ю8 {
      виділити<п8>(М, значення.розмір),
      значення.розмір
    };
    змінна ціль п: позитивне = 0;
    поки п < значення.розмір {
      копія.дані[п] = значення.дані[п];
      п += 1;
    }
    вихід::вміст = копія;
    вернути так;
  }

  місцева дія виділити_копію_ю8_цілі_з_ю8сі(М: адреса<Машина>, значення: памʼять<п8>, вихід: адреса<ю8>): логічне {
    ціль розмір_значення = МаМа::порахувати_розмір_ю8сі(значення);
    ціль копія = ю8 {
      виділити<п8>(М, розмір_значення),
      розмір_значення
    };
    змінна ціль п: позитивне = 0;
    поки п < розмір_значення {
      копія.дані[п] = значення[п];
      п += 1;
    }
    вихід::вміст = копія;
    вернути так;
  }

  місцева дія виділити_копію_ю8сі_цілі_з_ю8(М: адреса<Машина>, значення: ю8, вихід: адреса<памʼять<п8>>): логічне {
    ціль копія_ю8сі = МаМа::виділити<п8>(М, значення.розмір + 1);
    змінна ціль п: позитивне = 0;
    поки п < значення.розмір {
      копія_ю8сі[п] = значення.дані[п];
      п += 1;
    }
    копія_ю8сі[значення.розмір] = 0;
    вихід::вміст = копія_ю8сі;
    вернути так;
  }

  місцева дія виділити_копію_ю8сі_цілі_з_тексту(М: адреса<Машина>, значення: текст, вихід: адреса<памʼять<п8>>): логічне {
    ціль копія_ю8сі = МаМа::виділити<п8>(М, (значення.розмір * 4) + 1);
    ціль розмір_ю8сі = КД::перекодувати_в_Ю8(значення.дані, значення.розмір, копія_ю8сі);
    копія_ю8сі[розмір_ю8сі] = 0;
    вихід::вміст = копія_ю8сі;
    вернути так;
  }

  місцева дія виділити_копію_ю8_цілі_з_тексту(М: адреса<Машина>, значення: текст, вихід: адреса<ю8>): логічне {
    ціль копія_ю8сі = МаМа::виділити<п8>(М, (значення.розмір * 4) + 1);
    ціль розмір_ю8сі = КД::перекодувати_в_Ю8(значення.дані, значення.розмір, копія_ю8сі);
    копія_ю8сі[розмір_ю8сі] = 0;
    вихід::вміст = ю8 { копія_ю8сі, розмір_ю8сі };
    вернути так;
  }
}