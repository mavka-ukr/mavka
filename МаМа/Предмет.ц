взяти визначення МаМа;

секція МаМа {
  // мітка: прохід по типах предметів
  місцева дія звільнити_предмет(предмет: адреса<Предмет>, М: адреса<Машина>) {
//    вивести_ю8(М, ю8"[МАВКА] звільнюємо предмет ");
//    надрукувати_предмет(предмет, М, 1);
    якщо предмет.тип == М.предмет_структури_Структура {
      звільнити_предмет_структури(предмет як адреса<ПредметСтруктури>, М);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      звільнити_предмет_дії(предмет як адреса<ПредметДії>, М);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      звільнити_предмет_нативної_дії(предмет як адреса<ПредметНативноїДії>, М);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      звільнити_предмет_числа(предмет як адреса<ПредметЧисла>, М);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      звільнити_предмет_тексту(предмет як адреса<ПредметТексту>, М);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      звільнити_предмет_юнікоду(предмет як адреса<ПредметЮнікоду>, М);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      звільнити_предмет_модуля(предмет як адреса<ПредметМодуля>, М);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      звільнити_предмет_списку(предмет як адреса<ПредметСписку>, М);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      звільнити_предмет_словника(предмет як адреса<ПредметСловника>, М);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      звільнити_предмет_логічного(предмет як адреса<ПредметЛогічного>, М);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      звільнити_предмет_байтів(предмет як адреса<ПредметБайтів>, М);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      звільнити_предмет_адреси(предмет як адреса<ПредметАдреси>, М);
    } інакше {
      звільнити_складений_предмет(предмет як адреса<СкладенийПредмет>, М);
    }
  }

  місцева дія звільнити_реєстр_параметрів(М: адреса<Машина>, реєстр_параметрів: адреса<Реєстр<адреса<Назва>, Параметр>>) {
    змінна ціль п: позитивне = 0;
    поки п < реєстр_параметрів.розмір {
      звільнити_значення_накопичувача<адреса<ПредметСтруктури>>(М, реєстр_параметрів.елементи[п].значення.типи);
      п += 1;
    }
    звільнити_реєстр<адреса<Назва>, Параметр>(М, реєстр_параметрів);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_виконати(предмет: адреса<Предмет>, М: адреса<Машина>, предмет_я: адреса<Предмет>, аргументи: адреса<Накопичувач<адреса<Предмет>>>, іменовані_аргументи: адреса<Реєстр<адреса<Назва>, адреса<Предмет>>>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_виконати_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_виконати(предмет як адреса<ПредметСтруктури>, М, предмет_я, аргументи, іменовані_аргументи);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_виконати(предмет як адреса<ПредметДії>, М, предмет_я, аргументи, іменовані_аргументи);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_виконати(предмет як адреса<ПредметНативноїДії>, М, предмет_я, аргументи, іменовані_аргументи);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_виконати(предмет як адреса<ПредметЧисла>, М, предмет_я, аргументи, іменовані_аргументи);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_виконати(предмет як адреса<ПредметТексту>, М, предмет_я, аргументи, іменовані_аргументи);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_виконати(предмет як адреса<ПредметЮнікоду>, М, предмет_я, аргументи, іменовані_аргументи);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_виконати(предмет як адреса<ПредметМодуля>, М, предмет_я, аргументи, іменовані_аргументи);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_виконати(предмет як адреса<ПредметСписку>, М, предмет_я, аргументи, іменовані_аргументи);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_виконати(предмет як адреса<ПредметСловника>, М, предмет_я, аргументи, іменовані_аргументи);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_виконати(предмет як адреса<ПредметЛогічного>, М, предмет_я, аргументи, іменовані_аргументи);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_виконати(предмет як адреса<ПредметБайтів>, М, предмет_я, аргументи, іменовані_аргументи);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_виконати(предмет як адреса<ПредметАдреси>, М, предмет_я, аргументи, іменовані_аргументи);
    }
    вернути складений_предмет_виконати(предмет як адреса<СкладенийПредмет>, М, предмет_я, аргументи, іменовані_аргументи);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_отримати_властивість(предмет: адреса<Предмет>, М: адреса<Машина>, назва: адреса<Назва>): адреса<Предмет> {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_отримати_властивість_з_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_отримати_властивість(предмет як адреса<ПредметСтруктури>, М, назва);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_отримати_властивість(предмет як адреса<ПредметДії>, М, назва);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_отримати_властивість(предмет як адреса<ПредметНативноїДії>, М, назва);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_отримати_властивість(предмет як адреса<ПредметЧисла>, М, назва);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_отримати_властивість(предмет як адреса<ПредметТексту>, М, назва);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_отримати_властивість(предмет як адреса<ПредметЮнікоду>, М, назва);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_отримати_властивість(предмет як адреса<ПредметМодуля>, М, назва);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_отримати_властивість(предмет як адреса<ПредметСписку>, М, назва);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_отримати_властивість(предмет як адреса<ПредметСловника>, М, назва);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_отримати_властивість(предмет як адреса<ПредметЛогічного>, М, назва);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_отримати_властивість(предмет як адреса<ПредметБайтів>, М, назва);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_отримати_властивість(предмет як адреса<ПредметАдреси>, М, назва);
    }
    вернути складений_предмет_отримати_властивість(предмет як адреса<СкладенийПредмет>, М, назва);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_змінити_властивість(предмет: адреса<Предмет>, М: адреса<Машина>, назва: адреса<Назва>, аргумент: адреса<Предмет>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_змінити_властивість_в_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_змінити_властивість(предмет як адреса<ПредметСтруктури>, М, назва, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_змінити_властивість(предмет як адреса<ПредметДії>, М, назва, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_змінити_властивість(предмет як адреса<ПредметНативноїДії>, М, назва, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_змінити_властивість(предмет як адреса<ПредметЧисла>, М, назва, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_змінити_властивість(предмет як адреса<ПредметТексту>, М, назва, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_змінити_властивість(предмет як адреса<ПредметЮнікоду>, М, назва, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_змінити_властивість(предмет як адреса<ПредметМодуля>, М, назва, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_змінити_властивість(предмет як адреса<ПредметСписку>, М, назва, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_змінити_властивість(предмет як адреса<ПредметСловника>, М, назва, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_змінити_властивість(предмет як адреса<ПредметЛогічного>, М, назва, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_змінити_властивість(предмет як адреса<ПредметБайтів>, М, назва, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_змінити_властивість(предмет як адреса<ПредметАдреси>, М, назва, аргумент);
    }
    вернути складений_предмет_змінити_властивість(предмет як адреса<СкладенийПредмет>, М, назва, аргумент);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_видалити_властивість(предмет: адреса<Предмет>, М: адреса<Машина>, назва: адреса<Назва>): адреса<Предмет> {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_видалити_властивість_з_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_видалити_властивість(предмет як адреса<ПредметСтруктури>, М, назва);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_видалити_властивість(предмет як адреса<ПредметДії>, М, назва);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_видалити_властивість(предмет як адреса<ПредметНативноїДії>, М, назва);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_видалити_властивість(предмет як адреса<ПредметЧисла>, М, назва);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_видалити_властивість(предмет як адреса<ПредметТексту>, М, назва);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_видалити_властивість(предмет як адреса<ПредметЮнікоду>, М, назва);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_видалити_властивість(предмет як адреса<ПредметМодуля>, М, назва);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_видалити_властивість(предмет як адреса<ПредметСписку>, М, назва);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_видалити_властивість(предмет як адреса<ПредметСловника>, М, назва);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_видалити_властивість(предмет як адреса<ПредметЛогічного>, М, назва);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_видалити_властивість(предмет як адреса<ПредметБайтів>, М, назва);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_видалити_властивість(предмет як адреса<ПредметАдреси>, М, назва);
    }
    вернути складений_предмет_видалити_властивість(предмет як адреса<СкладенийПредмет>, М, назва);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_виконати_властивість(предмет: адреса<Предмет>, М: адреса<Машина>, назва_властивості: адреса<Назва>, аргументи: адреса<Накопичувач<адреса<Предмет>>>, іменовані_аргументи: адреса<Реєстр<адреса<Назва>, адреса<Предмет>>>): предмет_або_стан_падіння {
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_виконати_властивість(предмет як адреса<ПредметСтруктури>, М, назва_властивості, аргументи, іменовані_аргументи);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_виконати_властивість(предмет як адреса<ПредметДії>, М, назва_властивості, аргументи, іменовані_аргументи);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_виконати_властивість(предмет як адреса<ПредметНативноїДії>, М, назва_властивості, аргументи, іменовані_аргументи);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_виконати_властивість(предмет як адреса<ПредметЧисла>, М, назва_властивості, аргументи, іменовані_аргументи);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_виконати_властивість(предмет як адреса<ПредметТексту>, М, назва_властивості, аргументи, іменовані_аргументи);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_виконати_властивість(предмет як адреса<ПредметЮнікоду>, М, назва_властивості, аргументи, іменовані_аргументи);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_виконати_властивість(предмет як адреса<ПредметМодуля>, М, назва_властивості, аргументи, іменовані_аргументи);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_виконати_властивість(предмет як адреса<ПредметСписку>, М, назва_властивості, аргументи, іменовані_аргументи);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_виконати_властивість(предмет як адреса<ПредметСловника>, М, назва_властивості, аргументи, іменовані_аргументи);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_виконати_властивість(предмет як адреса<ПредметЛогічного>, М, назва_властивості, аргументи, іменовані_аргументи);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_виконати_властивість(предмет як адреса<ПредметБайтів>, М, назва_властивості, аргументи, іменовані_аргументи);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_виконати_властивість(предмет як адреса<ПредметАдреси>, М, назва_властивості, аргументи, іменовані_аргументи);
    }
    вернути складений_предмет_виконати_властивість(предмет як адреса<СкладенийПредмет>, М, назва_властивості, аргументи, іменовані_аргументи);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_отримати_елемент(предмет: адреса<Предмет>, М: адреса<Машина>, ключ: адреса<Предмет>): предмет_або_стан_падіння {
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_отримати_елемент(предмет як адреса<ПредметСтруктури>, М, ключ);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_отримати_елемент(предмет як адреса<ПредметДії>, М, ключ);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_отримати_елемент(предмет як адреса<ПредметНативноїДії>, М, ключ);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_отримати_елемент(предмет як адреса<ПредметЧисла>, М, ключ);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_отримати_елемент(предмет як адреса<ПредметТексту>, М, ключ);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_отримати_елемент(предмет як адреса<ПредметЮнікоду>, М, ключ);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_отримати_елемент(предмет як адреса<ПредметМодуля>, М, ключ);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_отримати_елемент(предмет як адреса<ПредметСписку>, М, ключ);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_отримати_елемент(предмет як адреса<ПредметСловника>, М, ключ);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_отримати_елемент(предмет як адреса<ПредметЛогічного>, М, ключ);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_отримати_елемент(предмет як адреса<ПредметБайтів>, М, ключ);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_отримати_елемент(предмет як адреса<ПредметАдреси>, М, ключ);
    }
    вернути складений_предмет_отримати_елемент(предмет як адреса<СкладенийПредмет>, М, ключ);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_змінити_елемент(предмет: адреса<Предмет>, М: адреса<Машина>, ключ: адреса<Предмет>, значення: адреса<Предмет>): предмет_або_стан_падіння {
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_змінити_елемент(предмет як адреса<ПредметСтруктури>, М, ключ, значення);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_змінити_елемент(предмет як адреса<ПредметДії>, М, ключ, значення);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_змінити_елемент(предмет як адреса<ПредметНативноїДії>, М, ключ, значення);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_змінити_елемент(предмет як адреса<ПредметЧисла>, М, ключ, значення);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_змінити_елемент(предмет як адреса<ПредметТексту>, М, ключ, значення);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_змінити_елемент(предмет як адреса<ПредметЮнікоду>, М, ключ, значення);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_змінити_елемент(предмет як адреса<ПредметМодуля>, М, ключ, значення);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_змінити_елемент(предмет як адреса<ПредметСписку>, М, ключ, значення);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_змінити_елемент(предмет як адреса<ПредметСловника>, М, ключ, значення);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_змінити_елемент(предмет як адреса<ПредметЛогічного>, М, ключ, значення);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_змінити_елемент(предмет як адреса<ПредметБайтів>, М, ключ, значення);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_змінити_елемент(предмет як адреса<ПредметАдреси>, М, ключ, значення);
    }
    вернути складений_предмет_змінити_елемент(предмет як адреса<СкладенийПредмет>, М, ключ, значення);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_видалити_елемент(предмет: адреса<Предмет>, М: адреса<Машина>, ключ: адреса<Предмет>): предмет_або_стан_падіння {
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_видалити_елемент(предмет як адреса<ПредметСтруктури>, М, ключ);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_видалити_елемент(предмет як адреса<ПредметДії>, М, ключ);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_видалити_елемент(предмет як адреса<ПредметНативноїДії>, М, ключ);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_видалити_елемент(предмет як адреса<ПредметЧисла>, М, ключ);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_видалити_елемент(предмет як адреса<ПредметТексту>, М, ключ);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_видалити_елемент(предмет як адреса<ПредметЮнікоду>, М, ключ);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_видалити_елемент(предмет як адреса<ПредметМодуля>, М, ключ);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_видалити_елемент(предмет як адреса<ПредметСписку>, М, ключ);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_видалити_елемент(предмет як адреса<ПредметСловника>, М, ключ);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_видалити_елемент(предмет як адреса<ПредметЛогічного>, М, ключ);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_видалити_елемент(предмет як адреса<ПредметБайтів>, М, ключ);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_видалити_елемент(предмет як адреса<ПредметАдреси>, М, ключ);
    }
    вернути складений_предмет_видалити_елемент(предмет як адреса<СкладенийПредмет>, М, ключ);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_отримати_перебір(предмет: адреса<Предмет>, М: адреса<Машина>): предмет_або_стан_падіння {
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_отримати_перебір(предмет як адреса<ПредметСтруктури>, М);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_отримати_перебір(предмет як адреса<ПредметДії>, М);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_отримати_перебір(предмет як адреса<ПредметНативноїДії>, М);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_отримати_перебір(предмет як адреса<ПредметЧисла>, М);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_отримати_перебір(предмет як адреса<ПредметТексту>, М);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_отримати_перебір(предмет як адреса<ПредметЮнікоду>, М);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_отримати_перебір(предмет як адреса<ПредметМодуля>, М);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_отримати_перебір(предмет як адреса<ПредметСписку>, М);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_отримати_перебір(предмет як адреса<ПредметСловника>, М);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_отримати_перебір(предмет як адреса<ПредметЛогічного>, М);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_отримати_перебір(предмет як адреса<ПредметБайтів>, М);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_отримати_перебір(предмет як адреса<ПредметАдреси>, М);
    }
    вернути складений_предмет_отримати_перебір(предмет як адреса<СкладенийПредмет>, М);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_додати(предмет: адреса<Предмет>, М: адреса<Машина>, аргумент: адреса<Предмет>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_додати_до_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_додати(предмет як адреса<ПредметСтруктури>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_додати(предмет як адреса<ПредметДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_додати(предмет як адреса<ПредметНативноїДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_додати(предмет як адреса<ПредметЧисла>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_додати(предмет як адреса<ПредметТексту>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_додати(предмет як адреса<ПредметЮнікоду>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_додати(предмет як адреса<ПредметМодуля>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_додати(предмет як адреса<ПредметСписку>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_додати(предмет як адреса<ПредметСловника>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_додати(предмет як адреса<ПредметЛогічного>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_додати(предмет як адреса<ПредметБайтів>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_додати(предмет як адреса<ПредметАдреси>, М, аргумент);
    }
    вернути складений_предмет_додати(предмет як адреса<СкладенийПредмет>, М, аргумент);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_відняти(предмет: адреса<Предмет>, М: адреса<Машина>, аргумент: адреса<Предмет>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_відняти_від_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_відняти(предмет як адреса<ПредметСтруктури>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_відняти(предмет як адреса<ПредметДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_відняти(предмет як адреса<ПредметНативноїДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_відняти(предмет як адреса<ПредметЧисла>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_відняти(предмет як адреса<ПредметТексту>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_відняти(предмет як адреса<ПредметЮнікоду>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_відняти(предмет як адреса<ПредметМодуля>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_відняти(предмет як адреса<ПредметСписку>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_відняти(предмет як адреса<ПредметСловника>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_відняти(предмет як адреса<ПредметЛогічного>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_відняти(предмет як адреса<ПредметБайтів>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_відняти(предмет як адреса<ПредметАдреси>, М, аргумент);
    }
    вернути складений_предмет_відняти(предмет як адреса<СкладенийПредмет>, М, аргумент);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_помножити(предмет: адреса<Предмет>, М: адреса<Машина>, аргумент: адреса<Предмет>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_помножити_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_помножити(предмет як адреса<ПредметСтруктури>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_помножити(предмет як адреса<ПредметДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_помножити(предмет як адреса<ПредметНативноїДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_помножити(предмет як адреса<ПредметЧисла>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_помножити(предмет як адреса<ПредметТексту>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_помножити(предмет як адреса<ПредметЮнікоду>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_помножити(предмет як адреса<ПредметМодуля>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_помножити(предмет як адреса<ПредметСписку>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_помножити(предмет як адреса<ПредметСловника>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_помножити(предмет як адреса<ПредметЛогічного>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_помножити(предмет як адреса<ПредметБайтів>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_помножити(предмет як адреса<ПредметАдреси>, М, аргумент);
    }
    вернути складений_предмет_помножити(предмет як адреса<СкладенийПредмет>, М, аргумент);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_поділити(предмет: адреса<Предмет>, М: адреса<Машина>, аргумент: адреса<Предмет>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_поділити_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_поділити(предмет як адреса<ПредметСтруктури>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_поділити(предмет як адреса<ПредметДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_поділити(предмет як адреса<ПредметНативноїДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_поділити(предмет як адреса<ПредметЧисла>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_поділити(предмет як адреса<ПредметТексту>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_поділити(предмет як адреса<ПредметЮнікоду>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_поділити(предмет як адреса<ПредметМодуля>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_поділити(предмет як адреса<ПредметСписку>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_поділити(предмет як адреса<ПредметСловника>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_поділити(предмет як адреса<ПредметЛогічного>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_поділити(предмет як адреса<ПредметБайтів>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_поділити(предмет як адреса<ПредметАдреси>, М, аргумент);
    }
    вернути складений_предмет_поділити(предмет як адреса<СкладенийПредмет>, М, аргумент);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_отримати_остачу_ділення(предмет: адреса<Предмет>, М: адреса<Машина>, аргумент: адреса<Предмет>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_отримати_остачу_ділення_від_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_отримати_остачу_ділення(предмет як адреса<ПредметСтруктури>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_отримати_остачу_ділення(предмет як адреса<ПредметДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_отримати_остачу_ділення(предмет як адреса<ПредметНативноїДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_отримати_остачу_ділення(предмет як адреса<ПредметЧисла>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_отримати_остачу_ділення(предмет як адреса<ПредметТексту>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_отримати_остачу_ділення(предмет як адреса<ПредметЮнікоду>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_отримати_остачу_ділення(предмет як адреса<ПредметМодуля>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_отримати_остачу_ділення(предмет як адреса<ПредметСписку>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_отримати_остачу_ділення(предмет як адреса<ПредметСловника>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_отримати_остачу_ділення(предмет як адреса<ПредметЛогічного>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_отримати_остачу_ділення(предмет як адреса<ПредметБайтів>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_отримати_остачу_ділення(предмет як адреса<ПредметАдреси>, М, аргумент);
    }
    вернути складений_предмет_отримати_остачу_ділення(предмет як адреса<СкладенийПредмет>, М, аргумент);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_отримати_неповну_частку_ділення(предмет: адреса<Предмет>, М: адреса<Машина>, аргумент: адреса<Предмет>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_отримати_частку_ділення_від_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_отримати_частку_ділення(предмет як адреса<ПредметСтруктури>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_отримати_частку_ділення(предмет як адреса<ПредметДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_отримати_частку_ділення(предмет як адреса<ПредметНативноїДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_отримати_частку_ділення(предмет як адреса<ПредметЧисла>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_отримати_частку_ділення(предмет як адреса<ПредметТексту>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_отримати_частку_ділення(предмет як адреса<ПредметЮнікоду>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_отримати_частку_ділення(предмет як адреса<ПредметМодуля>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_отримати_частку_ділення(предмет як адреса<ПредметСписку>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_отримати_частку_ділення(предмет як адреса<ПредметСловника>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_отримати_частку_ділення(предмет як адреса<ПредметЛогічного>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_отримати_частку_ділення(предмет як адреса<ПредметБайтів>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_отримати_частку_ділення(предмет як адреса<ПредметАдреси>, М, аргумент);
    }
    вернути складений_предмет_отримати_неповну_частку_ділення(предмет як адреса<СкладенийПредмет>, М, аргумент);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_піднести_до_степеня(предмет: адреса<Предмет>, М: адреса<Машина>, аргумент: адреса<Предмет>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_піднести_до_степеня_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_піднести_до_степеня(предмет як адреса<ПредметСтруктури>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_піднести_до_степеня(предмет як адреса<ПредметДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_піднести_до_степеня(предмет як адреса<ПредметНативноїДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_піднести_до_степеня(предмет як адреса<ПредметЧисла>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_піднести_до_степеня(предмет як адреса<ПредметТексту>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_піднести_до_степеня(предмет як адреса<ПредметЮнікоду>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_піднести_до_степеня(предмет як адреса<ПредметМодуля>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_піднести_до_степеня(предмет як адреса<ПредметСписку>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_піднести_до_степеня(предмет як адреса<ПредметСловника>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_піднести_до_степеня(предмет як адреса<ПредметЛогічного>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_піднести_до_степеня(предмет як адреса<ПредметБайтів>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_піднести_до_степеня(предмет як адреса<ПредметАдреси>, М, аргумент);
    }
    вернути складений_предмет_піднести_до_степеня(предмет як адреса<СкладенийПредмет>, М, аргумент);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_зсунути_вліво(предмет: адреса<Предмет>, М: адреса<Машина>, аргумент: адреса<Предмет>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_зсунути_вліво_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_зсунути_вліво(предмет як адреса<ПредметСтруктури>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_зсунути_вліво(предмет як адреса<ПредметДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_зсунути_вліво(предмет як адреса<ПредметНативноїДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_зсунути_вліво(предмет як адреса<ПредметЧисла>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_зсунути_вліво(предмет як адреса<ПредметТексту>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_зсунути_вліво(предмет як адреса<ПредметЮнікоду>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_зсунути_вліво(предмет як адреса<ПредметМодуля>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_зсунути_вліво(предмет як адреса<ПредметСписку>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_зсунути_вліво(предмет як адреса<ПредметСловника>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_зсунути_вліво(предмет як адреса<ПредметЛогічного>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_зсунути_вліво(предмет як адреса<ПредметБайтів>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_зсунути_вліво(предмет як адреса<ПредметАдреси>, М, аргумент);
    }
    вернути складений_предмет_зсунути_вліво(предмет як адреса<СкладенийПредмет>, М, аргумент);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_зсунути_вправо(предмет: адреса<Предмет>, М: адреса<Машина>, аргумент: адреса<Предмет>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_зсунути_вправо_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_зсунути_вправо(предмет як адреса<ПредметСтруктури>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_зсунути_вправо(предмет як адреса<ПредметДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_зсунути_вправо(предмет як адреса<ПредметНативноїДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_зсунути_вправо(предмет як адреса<ПредметЧисла>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_зсунути_вправо(предмет як адреса<ПредметТексту>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_зсунути_вправо(предмет як адреса<ПредметЮнікоду>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_зсунути_вправо(предмет як адреса<ПредметМодуля>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_зсунути_вправо(предмет як адреса<ПредметСписку>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_зсунути_вправо(предмет як адреса<ПредметСловника>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_зсунути_вправо(предмет як адреса<ПредметЛогічного>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_зсунути_вправо(предмет як адреса<ПредметБайтів>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_зсунути_вправо(предмет як адреса<ПредметАдреси>, М, аргумент);
    }
    вернути складений_предмет_зсунути_вправо(предмет як адреса<СкладенийПредмет>, М, аргумент);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_зсунути_вправо_зі_заповненням(предмет: адреса<Предмет>, М: адреса<Машина>, аргумент: адреса<Предмет>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_зсунути_вправо_зі_заповненням_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_зсунути_вправо_зі_заповненням(предмет як адреса<ПредметСтруктури>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_зсунути_вправо_зі_заповненням(предмет як адреса<ПредметДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_зсунути_вправо_зі_заповненням(предмет як адреса<ПредметНативноїДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_зсунути_вправо_зі_заповненням(предмет як адреса<ПредметЧисла>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_зсунути_вправо_зі_заповненням(предмет як адреса<ПредметТексту>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_зсунути_вправо_зі_заповненням(предмет як адреса<ПредметЮнікоду>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_зсунути_вправо_зі_заповненням(предмет як адреса<ПредметМодуля>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_зсунути_вправо_зі_заповненням(предмет як адреса<ПредметСписку>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_зсунути_вправо_зі_заповненням(предмет як адреса<ПредметСловника>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_зсунути_вправо_зі_заповненням(предмет як адреса<ПредметЛогічного>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_зсунути_вправо_зі_заповненням(предмет як адреса<ПредметБайтів>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_зсунути_вправо_зі_заповненням(предмет як адреса<ПредметАдреси>, М, аргумент);
    }
    вернути складений_предмет_зсунути_вправо_зі_заповненням(предмет як адреса<СкладенийПредмет>, М, аргумент);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_двійкове_і(предмет: адреса<Предмет>, М: адреса<Машина>, аргумент: адреса<Предмет>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_виконати_двійкове_і_для_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_двійкове_і(предмет як адреса<ПредметСтруктури>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_двійкове_і(предмет як адреса<ПредметДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_двійкове_і(предмет як адреса<ПредметНативноїДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_двійкове_і(предмет як адреса<ПредметЧисла>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_двійкове_і(предмет як адреса<ПредметТексту>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_двійкове_і(предмет як адреса<ПредметЮнікоду>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_двійкове_і(предмет як адреса<ПредметМодуля>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_двійкове_і(предмет як адреса<ПредметСписку>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_двійкове_і(предмет як адреса<ПредметСловника>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_двійкове_і(предмет як адреса<ПредметЛогічного>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_двійкове_і(предмет як адреса<ПредметБайтів>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_двійкове_і(предмет як адреса<ПредметАдреси>, М, аргумент);
    }
    вернути складений_предмет_двійкове_і(предмет як адреса<СкладенийПредмет>, М, аргумент);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_двійкове_або(предмет: адреса<Предмет>, М: адреса<Машина>, аргумент: адреса<Предмет>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_виконати_двійкове_або_для_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_двійкове_або(предмет як адреса<ПредметСтруктури>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_двійкове_або(предмет як адреса<ПредметДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_двійкове_або(предмет як адреса<ПредметНативноїДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_двійкове_або(предмет як адреса<ПредметЧисла>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_двійкове_або(предмет як адреса<ПредметТексту>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_двійкове_або(предмет як адреса<ПредметЮнікоду>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_двійкове_або(предмет як адреса<ПредметМодуля>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_двійкове_або(предмет як адреса<ПредметСписку>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_двійкове_або(предмет як адреса<ПредметСловника>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_двійкове_або(предмет як адреса<ПредметЛогічного>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_двійкове_або(предмет як адреса<ПредметБайтів>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_двійкове_або(предмет як адреса<ПредметАдреси>, М, аргумент);
    }
    вернути складений_предмет_двійкове_або(предмет як адреса<СкладенийПредмет>, М, аргумент);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_двійкове_виключне_або(предмет: адреса<Предмет>, М: адреса<Машина>, аргумент: адреса<Предмет>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_виконати_двійкове_виключне_або_для_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_двійкове_виключне_або(предмет як адреса<ПредметСтруктури>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_двійкове_виключне_або(предмет як адреса<ПредметДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_двійкове_виключне_або(предмет як адреса<ПредметНативноїДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_двійкове_виключне_або(предмет як адреса<ПредметЧисла>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_двійкове_виключне_або(предмет як адреса<ПредметТексту>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_двійкове_виключне_або(предмет як адреса<ПредметЮнікоду>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_двійкове_виключне_або(предмет як адреса<ПредметМодуля>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_двійкове_виключне_або(предмет як адреса<ПредметСписку>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_двійкове_виключне_або(предмет як адреса<ПредметСловника>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_двійкове_виключне_або(предмет як адреса<ПредметЛогічного>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_двійкове_виключне_або(предмет як адреса<ПредметБайтів>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_двійкове_виключне_або(предмет як адреса<ПредметАдреси>, М, аргумент);
    }
    вернути складений_предмет_двійкове_виключне_або(предмет як адреса<СкладенийПредмет>, М, аргумент);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_двійкове_не(предмет: адреса<Предмет>, М: адреса<Машина>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_виконати_двійкове_не_для_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_двійкове_не(предмет як адреса<ПредметСтруктури>, М);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_двійкове_не(предмет як адреса<ПредметДії>, М);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_двійкове_не(предмет як адреса<ПредметНативноїДії>, М);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_двійкове_не(предмет як адреса<ПредметЧисла>, М);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_двійкове_не(предмет як адреса<ПредметТексту>, М);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_двійкове_не(предмет як адреса<ПредметЮнікоду>, М);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_двійкове_не(предмет як адреса<ПредметМодуля>, М);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_двійкове_не(предмет як адреса<ПредметСписку>, М);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_двійкове_не(предмет як адреса<ПредметСловника>, М);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_двійкове_не(предмет як адреса<ПредметЛогічного>, М);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_двійкове_не(предмет як адреса<ПредметБайтів>, М);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_двійкове_не(предмет як адреса<ПредметАдреси>, М);
    }
    вернути складений_предмет_двійкове_не(предмет як адреса<СкладенийПредмет>, М);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_більше(предмет: адреса<Предмет>, М: адреса<Машина>, аргумент: адреса<Предмет>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_виконати_перевірку_на_більше_для_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_більше(предмет як адреса<ПредметСтруктури>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_більше(предмет як адреса<ПредметДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_більше(предмет як адреса<ПредметНативноїДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_більше(предмет як адреса<ПредметЧисла>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_більше(предмет як адреса<ПредметТексту>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_більше(предмет як адреса<ПредметЮнікоду>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_більше(предмет як адреса<ПредметМодуля>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_більше(предмет як адреса<ПредметСписку>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_більше(предмет як адреса<ПредметСловника>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_більше(предмет як адреса<ПредметЛогічного>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_більше(предмет як адреса<ПредметБайтів>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_більше(предмет як адреса<ПредметАдреси>, М, аргумент);
    }
    вернути складений_предмет_більше(предмет як адреса<СкладенийПредмет>, М, аргумент);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_менше(предмет: адреса<Предмет>, М: адреса<Машина>, аргумент: адреса<Предмет>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_виконати_перевірку_на_менше_для_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_менше(предмет як адреса<ПредметСтруктури>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_менше(предмет як адреса<ПредметДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_менше(предмет як адреса<ПредметНативноїДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_менше(предмет як адреса<ПредметЧисла>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_менше(предмет як адреса<ПредметТексту>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_менше(предмет як адреса<ПредметЮнікоду>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_менше(предмет як адреса<ПредметМодуля>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_менше(предмет як адреса<ПредметСписку>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_менше(предмет як адреса<ПредметСловника>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_менше(предмет як адреса<ПредметЛогічного>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_менше(предмет як адреса<ПредметБайтів>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_менше(предмет як адреса<ПредметАдреси>, М, аргумент);
    }
    вернути складений_предмет_менше(предмет як адреса<СкладенийПредмет>, М, аргумент);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_рівно(предмет: адреса<Предмет>, М: адреса<Машина>, аргумент: адреса<Предмет>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      якщо аргумент == пусто {
        вернути М.предмет_логічного_так як адреса<Предмет>;
      }
      вернути М.предмет_логічного_ні як адреса<Предмет>;
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_рівно(предмет як адреса<ПредметСтруктури>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_рівно(предмет як адреса<ПредметДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_рівно(предмет як адреса<ПредметНативноїДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_рівно(предмет як адреса<ПредметЧисла>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_рівно(предмет як адреса<ПредметТексту>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_рівно(предмет як адреса<ПредметЮнікоду>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_рівно(предмет як адреса<ПредметМодуля>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_рівно(предмет як адреса<ПредметСписку>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_рівно(предмет як адреса<ПредметСловника>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_рівно(предмет як адреса<ПредметЛогічного>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_рівно(предмет як адреса<ПредметБайтів>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_рівно(предмет як адреса<ПредметАдреси>, М, аргумент);
    }
    вернути складений_предмет_рівно(предмет як адреса<СкладенийПредмет>, М, аргумент);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_містить(предмет: адреса<Предмет>, М: адреса<Машина>, аргумент: адреса<Предмет>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_виконати_перевірку_чи_містить_для_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_містить(предмет як адреса<ПредметСтруктури>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_містить(предмет як адреса<ПредметДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_містить(предмет як адреса<ПредметНативноїДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_містить(предмет як адреса<ПредметЧисла>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_містить(предмет як адреса<ПредметТексту>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_містить(предмет як адреса<ПредметЮнікоду>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_містить(предмет як адреса<ПредметМодуля>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_містить(предмет як адреса<ПредметСписку>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_містить(предмет як адреса<ПредметСловника>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_містить(предмет як адреса<ПредметЛогічного>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_містить(предмет як адреса<ПредметБайтів>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_містить(предмет як адреса<ПредметАдреси>, М, аргумент);
    }
    вернути складений_предмет_містить(предмет як адреса<СкладенийПредмет>, М, аргумент);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_є(предмет: адреса<Предмет>, М: адреса<Машина>, аргумент: адреса<Предмет>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      якщо аргумент == пусто {
        вернути М.предмет_логічного_так як адреса<Предмет>;
      }
      вернути М.предмет_логічного_ні як адреса<Предмет>;
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_є(предмет як адреса<ПредметСтруктури>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_є(предмет як адреса<ПредметДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_є(предмет як адреса<ПредметНативноїДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_є(предмет як адреса<ПредметЧисла>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_є(предмет як адреса<ПредметТексту>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_є(предмет як адреса<ПредметЮнікоду>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_є(предмет як адреса<ПредметМодуля>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_є(предмет як адреса<ПредметСписку>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_є(предмет як адреса<ПредметСловника>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_є(предмет як адреса<ПредметЛогічного>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_є(предмет як адреса<ПредметБайтів>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_є(предмет як адреса<ПредметАдреси>, М, аргумент);
    }
    вернути складений_предмет_є(предмет як адреса<СкладенийПредмет>, М, аргумент);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_відʼємне(предмет: адреса<Предмет>, М: адреса<Машина>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_виконати_відʼємне_для_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_відʼємне(предмет як адреса<ПредметСтруктури>, М);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_відʼємне(предмет як адреса<ПредметДії>, М);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_відʼємне(предмет як адреса<ПредметНативноїДії>, М);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_відʼємне(предмет як адреса<ПредметЧисла>, М);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_відʼємне(предмет як адреса<ПредметТексту>, М);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_відʼємне(предмет як адреса<ПредметЮнікоду>, М);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_відʼємне(предмет як адреса<ПредметМодуля>, М);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_відʼємне(предмет як адреса<ПредметСписку>, М);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_відʼємне(предмет як адреса<ПредметСловника>, М);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_відʼємне(предмет як адреса<ПредметЛогічного>, М);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_відʼємне(предмет як адреса<ПредметБайтів>, М);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_відʼємне(предмет як адреса<ПредметАдреси>, М);
    }
    вернути складений_предмет_відʼємне(предмет як адреса<СкладенийПредмет>, М);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_числове(предмет: адреса<Предмет>, М: адреса<Машина>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_виконати_числове_для_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_числове(предмет як адреса<ПредметСтруктури>, М);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_числове(предмет як адреса<ПредметДії>, М);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_числове(предмет як адреса<ПредметНативноїДії>, М);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_числове(предмет як адреса<ПредметЧисла>, М);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_числове(предмет як адреса<ПредметТексту>, М);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_числове(предмет як адреса<ПредметЮнікоду>, М);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_числове(предмет як адреса<ПредметМодуля>, М);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_числове(предмет як адреса<ПредметСписку>, М);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_числове(предмет як адреса<ПредметСловника>, М);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_числове(предмет як адреса<ПредметЛогічного>, М);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_числове(предмет як адреса<ПредметБайтів>, М);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_числове(предмет як адреса<ПредметАдреси>, М);
    }
    вернути складений_предмет_числове(предмет як адреса<СкладенийПредмет>, М);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_заперечити(предмет: адреса<Предмет>, М: адреса<Машина>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути М.предмет_логічного_так як адреса<Предмет>;
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_заперечити(предмет як адреса<ПредметСтруктури>, М);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_заперечити(предмет як адреса<ПредметДії>, М);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_заперечити(предмет як адреса<ПредметНативноїДії>, М);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_заперечити(предмет як адреса<ПредметЧисла>, М);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_заперечити(предмет як адреса<ПредметТексту>, М);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_заперечити(предмет як адреса<ПредметЮнікоду>, М);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_заперечити(предмет як адреса<ПредметМодуля>, М);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_заперечити(предмет як адреса<ПредметСписку>, М);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_заперечити(предмет як адреса<ПредметСловника>, М);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_заперечити(предмет як адреса<ПредметЛогічного>, М);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_заперечити(предмет як адреса<ПредметБайтів>, М);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_заперечити(предмет як адреса<ПредметАдреси>, М);
    }
    вернути складений_предмет_заперечити(предмет як адреса<СкладенийПредмет>, М);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_збільшити(предмет: адреса<Предмет>, М: адреса<Машина>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_виконати_збільшення_для_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_збільшити(предмет як адреса<ПредметСтруктури>, М);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_збільшити(предмет як адреса<ПредметДії>, М);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_збільшити(предмет як адреса<ПредметНативноїДії>, М);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_збільшити(предмет як адреса<ПредметЧисла>, М);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_збільшити(предмет як адреса<ПредметТексту>, М);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_збільшити(предмет як адреса<ПредметЮнікоду>, М);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_збільшити(предмет як адреса<ПредметМодуля>, М);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_збільшити(предмет як адреса<ПредметСписку>, М);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_збільшити(предмет як адреса<ПредметСловника>, М);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_збільшити(предмет як адреса<ПредметЛогічного>, М);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_збільшити(предмет як адреса<ПредметБайтів>, М);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_збільшити(предмет як адреса<ПредметАдреси>, М);
    }
    вернути складений_предмет_збільшити(предмет як адреса<СкладенийПредмет>, М);
  }

  // мітка: прохід по типах предметів
  місцева дія предмет_зменшити(предмет: адреса<Предмет>, М: адреса<Машина>): предмет_або_стан_падіння {
    якщо предмет == пусто {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_предмет_тексту_помилки_неможливо_виконати_зменшення_для_пусто(М);
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_зменшити(предмет як адреса<ПредметСтруктури>, М);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_зменшити(предмет як адреса<ПредметДії>, М);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути предмет_нативної_дії_зменшити(предмет як адреса<ПредметНативноїДії>, М);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_зменшити(предмет як адреса<ПредметЧисла>, М);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_зменшити(предмет як адреса<ПредметТексту>, М);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_зменшити(предмет як адреса<ПредметЮнікоду>, М);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_зменшити(предмет як адреса<ПредметМодуля>, М);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_зменшити(предмет як адреса<ПредметСписку>, М);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_зменшити(предмет як адреса<ПредметСловника>, М);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_зменшити(предмет як адреса<ПредметЛогічного>, М);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_зменшити(предмет як адреса<ПредметБайтів>, М);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути предмет_адреси_зменшити(предмет як адреса<ПредметАдреси>, М);
    }
    вернути складений_предмет_зменшити(предмет як адреса<СкладенийПредмет>, М);
  }

  місцева дія перевірити_чи_предмет_рівно(предмет: адреса<Предмет>, М: адреса<Машина>, аргумент: адреса<Предмет>): логічне {
    якщо предмет == пусто {
      якщо аргумент == пусто {
        вернути так;
      }
      вернути ні;
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути перевірити_чи_предмет_структури_рівно(предмет як адреса<ПредметСтруктури>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути перевірити_чи_предмет_дії_рівно(предмет як адреса<ПредметДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути перевірити_чи_предмет_нативної_дії_рівно(предмет як адреса<ПредметНативноїДії>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути перевірити_чи_предмет_числа_рівно(предмет як адреса<ПредметЧисла>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути перевірити_чи_предмет_тексту_рівно(предмет як адреса<ПредметТексту>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути перевірити_чи_предмет_юнікоду_рівно(предмет як адреса<ПредметЮнікоду>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути перевірити_чи_предмет_модуля_рівно(предмет як адреса<ПредметМодуля>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути перевірити_чи_предмет_списку_рівно(предмет як адреса<ПредметСписку>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути перевірити_чи_предмет_словника_рівно(предмет як адреса<ПредметСловника>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути перевірити_чи_предмет_логічного_рівно(предмет як адреса<ПредметЛогічного>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути перевірити_чи_предмет_байтів_рівно(предмет як адреса<ПредметБайтів>, М, аргумент);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути перевірити_чи_предмет_адреси_рівно(предмет як адреса<ПредметАдреси>, М, аргумент);
    }
    вернути перевірити_чи_складений_предмет_рівно(предмет як адреса<СкладенийПредмет>, М, аргумент);
  }

  місцева дія перевірити_чи_предмет_є(предмет: адреса<Предмет>, М: адреса<Машина>, предмет_структури: адреса<ПредметСтруктури>): логічне {
    якщо предмет_структури == пусто {
      якщо предмет == пусто {
        вернути так;
      }
      вернути ні;
    }
    якщо предмет == пусто {
      вернути ні;
    }
    якщо предмет.тип == М.предмет_структури_Структура {
      вернути перевірити_чи_предмет_структури_є(предмет як адреса<ПредметСтруктури>, М, предмет_структури);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути перевірити_чи_предмет_дії_є(предмет як адреса<ПредметДії>, М, предмет_структури);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути перевірити_чи_предмет_нативної_дії_є(предмет як адреса<ПредметНативноїДії>, М, предмет_структури);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути перевірити_чи_предмет_числа_є(предмет як адреса<ПредметЧисла>, М, предмет_структури);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути перевірити_чи_предмет_тексту_є(предмет як адреса<ПредметТексту>, М, предмет_структури);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути перевірити_чи_предмет_юнікоду_є(предмет як адреса<ПредметЮнікоду>, М, предмет_структури);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути перевірити_чи_предмет_модуля_є(предмет як адреса<ПредметМодуля>, М, предмет_структури);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути перевірити_чи_предмет_списку_є(предмет як адреса<ПредметСписку>, М, предмет_структури);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути перевірити_чи_предмет_словника_є(предмет як адреса<ПредметСловника>, М, предмет_структури);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути перевірити_чи_предмет_логічного_є(предмет як адреса<ПредметЛогічного>, М, предмет_структури);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути перевірити_чи_предмет_байтів_є(предмет як адреса<ПредметБайтів>, М, предмет_структури);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      вернути перевірити_чи_предмет_адреси_є(предмет як адреса<ПредметАдреси>, М, предмет_структури);
    }
    вернути перевірити_чи_складений_предмет_є(предмет як адреса<СкладенийПредмет>, М, предмет_структури);
  }

  місцева дія перевірити_чи_предмет_виражається_логічним_так(предмет: адреса<Предмет>, М: адреса<Машина>): логічне {
    якщо предмет == пусто {
      вернути ні;
    }
    якщо предмет == М.предмет_логічного_ні {
      вернути ні;
    }
    якщо предмет.тип == М.предмет_структури_число {
      ціль предмет_числа = предмет як адреса<ПредметЧисла>;
      якщо предмет_числа.значення == 0.0 {
        вернути ні;
      }
    }
    якщо предмет.тип == М.предмет_структури_адреса {
      ціль предмет_адреси = предмет як адреса<ПредметАдреси>;
      якщо предмет_адреси.значення == пусто {
        вернути ні;
      }
    }
    якщо предмет.тип == М.предмет_структури_текст {
      ціль предмет_тексту = предмет як адреса<ПредметТексту>;
      якщо предмет_тексту.значення.розмір == 0 {
        вернути ні;
      }
    }
    якщо предмет.тип == М.предмет_структури_юнікод {
      ціль предмет_юнікоду = предмет як адреса<ПредметЮнікоду>;
      якщо порахувати_розмір_Ю32(предмет_юнікоду.значення) == 0 {
        вернути ні;
      }
    }
    вернути так;
  }

  місцева дія перевірити_чи_предмет_структури_доступний_для_наслідування(предмет_структури: адреса<ПредметСтруктури>, М: адреса<Машина>): логічне {
    якщо предмет_структури == М.предмет_структури_Структура {
      вернути ні;
    }
    якщо предмет_структури == М.предмет_структури_Дія {
      вернути ні;
    }
    якщо предмет_структури == М.предмет_структури_НативнаДія {
      вернути ні;
    }
    якщо предмет_структури == М.предмет_структури_число {
      вернути ні;
    }
    якщо предмет_структури == М.предмет_структури_текст {
      вернути ні;
    }
    якщо предмет_структури == М.предмет_структури_юнікод {
      вернути ні;
    }
    якщо предмет_структури == М.предмет_структури_Модуль {
      вернути ні;
    }
    якщо предмет_структури == М.предмет_структури_список {
      вернути ні;
    }
    якщо предмет_структури == М.предмет_структури_словник {
      вернути ні;
    }
    якщо предмет_структури == М.предмет_структури_логічне {
      вернути ні;
    }
    якщо предмет_структури == М.предмет_структури_байти {
      вернути ні;
    }
    якщо предмет_структури == М.предмет_структури_адреса {
      вернути ні;
    }
    вернути так;
  }

  місцева дія виділити_предмет_з_назви(М: адреса<Машина>, назва: адреса<Назва>): адреса<Предмет> {
    якщо назва.кодування == КОДУВАННЯ_НАЗВИ_КД {
      вернути виділити_предмет_тексту(М, назва.значення як т8) як адреса<Предмет>;
    } інакше {
      вернути виділити_предмет_юнікоду_з_ю8(М, назва.значення як ю8) як адреса<Предмет>;
    }
  }

  місцева дія перевірити_чи_предмет_є_дією(предмет: адреса<Предмет>, М: адреса<Машина>): логічне {
    якщо предмет == пусто {
      вернути ні;
    }
    якщо предмет.тип == М.предмет_структури_Дія {
      вернути так;
    }
    вернути ні;
  }

  місцева дія перевірити_чи_предмет_є_нативною_дією(предмет: адреса<Предмет>, М: адреса<Машина>): логічне {
    якщо предмет == пусто {
      вернути ні;
    }
    якщо предмет.тип == М.предмет_структури_НативнаДія {
      вернути так;
    }
    вернути ні;
  }

  місцева дія перевірити_чи_предмет_є_числом(предмет: адреса<Предмет>, М: адреса<Машина>): логічне {
    якщо предмет == пусто {
      вернути ні;
    }
    якщо предмет.тип == М.предмет_структури_число {
      вернути так;
    }
    вернути ні;
  }

  місцева дія перевірити_чи_предмет_є_текстом(предмет: адреса<Предмет>, М: адреса<Машина>): логічне {
    якщо предмет == пусто {
      вернути ні;
    }
    якщо предмет.тип == М.предмет_структури_текст {
      вернути так;
    }
    вернути ні;
  }

  місцева дія перевірити_чи_предмет_є_юнікодом(предмет: адреса<Предмет>, М: адреса<Машина>): логічне {
    якщо предмет == пусто {
      вернути ні;
    }
    якщо предмет.тип == М.предмет_структури_юнікод {
      вернути так;
    }
    вернути ні;
  }

  місцева дія перевірити_чи_предмет_є_модулем(предмет: адреса<Предмет>, М: адреса<Машина>): логічне {
    якщо предмет == пусто {
      вернути ні;
    }
    якщо предмет.тип == М.предмет_структури_Модуль {
      вернути так;
    }
    вернути ні;
  }

  місцева дія перевірити_чи_предмет_є_списком(предмет: адреса<Предмет>, М: адреса<Машина>): логічне {
    якщо предмет == пусто {
      вернути ні;
    }
    якщо предмет.тип == М.предмет_структури_список {
      вернути так;
    }
    вернути ні;
  }

  місцева дія перевірити_чи_предмет_є_словником(предмет: адреса<Предмет>, М: адреса<Машина>): логічне {
    якщо предмет == пусто {
      вернути ні;
    }
    якщо предмет.тип == М.предмет_структури_словник {
      вернути так;
    }
    вернути ні;
  }

  місцева дія перевірити_чи_предмет_є_логічним(предмет: адреса<Предмет>, М: адреса<Машина>): логічне {
    якщо предмет == пусто {
      вернути ні;
    }
    якщо предмет.тип == М.предмет_структури_логічне {
      вернути так;
    }
    вернути ні;
  }

  місцева дія перевірити_чи_предмет_є_байтами(предмет: адреса<Предмет>, М: адреса<Машина>): логічне {
    якщо предмет == пусто {
      вернути ні;
    }
    якщо предмет.тип == М.предмет_структури_байти {
      вернути так;
    }
    вернути ні;
  }

  місцева дія перевірити_чи_предмет_є_адресою(предмет: адреса<Предмет>, М: адреса<Машина>): логічне {
    якщо предмет == пусто {
      вернути ні;
    }
    якщо предмет.тип == М.предмет_структури_адреса {
      вернути так;
    }
    вернути ні;
  }

  місцева дія записати_в_байти(предмет: адреса<ПредметБайтів>, М: адреса<Машина>, дані: памʼять<п8>, розмір: позитивне, зсув: позитивне) {
    змінна ціль п: позитивне = зсув;
    поки п < розмір {
      предмет.дані.дані[п] = дані[п - зсув];
      п += 1;
    }
  }

  місцева дія отримати_копію_даних_тексту(предмет: адреса<ПредметТексту>, М: адреса<Машина>, вихід: адреса<т8>): логічне {
    вернути виділити_копію_тексту_цілі(М, предмет.значення, вихід);
  }

  місцева дія отримати_дані_тексту(предмет: адреса<ПредметТексту>, М: адреса<Машина>, вихід: адреса<т8>): логічне {
    вихід::вміст = предмет.значення;
    вернути так;
  }

  місцева дія отримати_копію_даних_юнікоду(предмет: адреса<ПредметЮнікоду>, М: адреса<Машина>, вихід: адреса<памʼять<п32>>): позитивне {
    вернути виділити_копію_Ю32(М, предмет.значення, предмет.довжина, вихід);
  }

  місцева дія отримати_дані_юнікоду(предмет: адреса<ПредметЮнікоду>, М: адреса<Машина>, вихід: адреса<памʼять<п32>>): позитивне {
    вихід::вміст = предмет.значення;
    вернути предмет.довжина;
  }

  місцева дія отримати_копію_даних_юнікоду_як_ю8(предмет: адреса<ПредметЮнікоду>, М: адреса<Машина>, вихід: адреса<ю8>): логічне {
    ціль значення_ю8: памʼять<п8> = пусто;
    ціль розмір_ю8 = перекодувати_Ю32_в_Ю8(М, предмет.значення, предмет.довжина, значення_ю8::адреса);
    вихід::вміст = ю8 { розмір_ю8, значення_ю8 };
    вернути так;
  }

  місцева дія отримати_копію_даних_байтів(предмет: адреса<ПредметБайтів>, М: адреса<Машина>, вихід: адреса<памʼять<п8>>): позитивне {
    вернути виділити_копію_байтів(М, предмет.дані.дані, предмет.дані.розмір, вихід);
  }

  місцева дія отримати_дані_байтів(предмет: адреса<ПредметБайтів>, М: адреса<Машина>, вихід: адреса<памʼять<п8>>): позитивне {
    вихід::вміст = предмет.дані.дані;
    вернути предмет.дані.розмір;
  }

  місцева дія отримати_значення_адреси(предмет: адреса<ПредметАдреси>, М: адреса<Машина>): адреса {
    вернути предмет.значення;
  }

  місцева дія надрукувати_предмет(предмет: адреса<Предмет>, М: адреса<Машина>, глибина: позитивне) {
    ціль накопичувач_ю8 = зробити_накопичувач_ю8(М);
    надрукувати_предмет_в_накопичувач_ю8(предмет, М, накопичувач_ю8::адреса, глибина);
    ціль значення_ю8 = виділити_ю8_з_накопичувача_ю8(М, накопичувач_ю8::адреса);
    звільнити_значення_накопичувача_ю8(М, накопичувач_ю8);
    надрукувати_ю8(М, значення_ю8);
    звільнити(М, значення_ю8.дані як адреса);
  }

  // мітка: прохід по типах предметів
  місцева дія надрукувати_предмет_в_накопичувач_ю8(предмет: адреса<Предмет>, М: адреса<Машина>, накопичувач_ю8: адреса<НакопичувачЮ8>, глибина: позитивне) {
    якщо предмет == пусто {
      покласти_ю8_в_накопичувач_ю8(М, накопичувач_ю8, ю8"пусто");
    } інакше якщо предмет.тип == М.предмет_структури_число {
      надрукувати_предмет_числа_в_накопичувач_ю8(предмет як адреса<ПредметЧисла>, М, накопичувач_ю8, глибина);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      надрукувати_предмет_тексту_в_накопичувач_ю8(предмет як адреса<ПредметТексту>, М, накопичувач_ю8, глибина);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      надрукувати_предмет_юнікоду_в_накопичувач_ю8(предмет як адреса<ПредметЮнікоду>, М, накопичувач_ю8, глибина);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      надрукувати_предмет_дії_в_накопичувач_ю8(предмет як адреса<ПредметДії>, М, накопичувач_ю8, глибина);
    } інакше якщо предмет.тип == М.предмет_структури_НативнаДія {
      надрукувати_предмет_нативної_дії_в_накопичувач_ю8(предмет як адреса<ПредметНативноїДії>, М, накопичувач_ю8, глибина);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      надрукувати_предмет_структури_в_накопичувач_ю8(предмет як адреса<ПредметСтруктури>, М, накопичувач_ю8, глибина);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      надрукувати_предмет_модуля_в_накопичувач_ю8(предмет як адреса<ПредметМодуля>, М, накопичувач_ю8, глибина);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      надрукувати_предмет_списку_в_накопичувач_ю8(предмет як адреса<ПредметСписку>, М, накопичувач_ю8, глибина);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      надрукувати_предмет_словника_в_накопичувач_ю8(предмет як адреса<ПредметСловника>, М, накопичувач_ю8, глибина);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      надрукувати_предмет_логічного_в_накопичувач_ю8(предмет як адреса<ПредметЛогічного>, М, накопичувач_ю8, глибина);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      надрукувати_предмет_байтів_в_накопичувач_ю8(предмет як адреса<ПредметБайтів>, М, накопичувач_ю8, глибина);
    } інакше якщо предмет.тип == М.предмет_структури_адреса {
      надрукувати_предмет_адреси_в_накопичувач_ю8(предмет як адреса<ПредметАдреси>, М, накопичувач_ю8, глибина);
    } інакше {
      покласти_ю8_в_накопичувач_ю8(М, накопичувач_ю8, ю8"предмет");
//      якщо предмет.тип != пусто {
//        якщо предмет.тип.назва != пусто {
//          покласти_ю8_в_накопичувач_ю8(М, накопичувач_ю8, предмет.тип.назва.значення);
//        }
//      }
//      покласти_ю8_в_накопичувач_ю8(М, накопичувач_ю8, ю8"(");
//      змінна ціль пв: позитивне = 0;
//      поки пв < предмет.властивості.розмір {
//        покласти_ю8_в_накопичувач_ю8(М, накопичувач_ю8, предмет.властивості.елементи[пв].ключ.значення);
//        покласти_ю8_в_накопичувач_ю8(М, накопичувач_ю8, ю8"=");
//        надрукувати_предмет_в_накопичувач_ю8(М, накопичувач_ю8, предмет.властивості.елементи[пв].значення, глибина + 1);
//        якщо пв + 1 < предмет.властивості.розмір {
//          покласти_ю8_в_накопичувач_ю8(М, накопичувач_ю8, ю8", ");
//        }
//        пв = пв + 1;
//      }
//      покласти_ю8_в_накопичувач_ю8(М, накопичувач_ю8, Ю8")");
    }
  }
}