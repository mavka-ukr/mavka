взяти означення ДЧ;

// КОД НЕ МІЙ, Я ПРОСТО ПЕРЕКЛАВ НА ЦІЛЬ
// ТРЕБА ПЕРЕВІРИТИ ЧИ ВСЕ ОК, ХОЧА НАЧЕ ПРАЦЮЄ ПРАВИЛЬНО
// АБО ЩЕ КРАЩЕ НАПИСАТИ ВРУЧНУ З НУЛЯ. Я НЕ МАЮ ЧАСУ ПОКИ ДЛЯ ЦЬОГО

дія копіювати_памʼять<Т>(
  куди: памʼять<Т>,
  звідки: памʼять<Т>,
  кількість: природне
) {
  змінна п: природне = 0;

  поки п < кількість {
    куди[п] = звідки[п];

    п += 1;
  }
}

дія заповнити_памʼять<Т>(
  куди: памʼять<Т>,
  значення: Т,
  кількість: природне
) {
  змінна п: природне = 0;

  поки п < кількість {
    куди[п] = значення;

    п += 1;
  }
}

// Ціле
простір ДЧ {
  стала ЗСУВ_ЦІЛОГО = 30;
  дія БАЗА_ЦІЛОГО() -> п64 { вернути п64(1) << ЗСУВ_ЦІЛОГО; };
  дія МАСКА_ЦІЛОГО() -> п64 { вернути БАЗА_ЦІЛОГО() - 1; }
  стала МАКС_Ц64 = 9223372036854775807;

  дія ініціалізувати_ціле(
    виділяч: адреса<Виділяч>,
    розмір: ц32,
    вихід: адреса<Ціле>
  ) -> логічне {
    змінна вмісткість: ц32;

    якщо розмір > 0 {
      вмісткість = розмір;
    } інакше {
      вмісткість = 1;
    }

    вихід.цифри = виділити_памʼять<п32>(виділяч, природне(вмісткість));
    якщо вихід.цифри == пусто {
      вернути ні;
    }

    заповнити_памʼять<п32>(вихід.цифри, 0, природне(вмісткість));

    вихід.розмір = 0;
    вихід.вмісткість = вмісткість;

    вернути так;
  }

  місцева дія звільнити_ціле(
    виділяч: адреса<Виділяч>,
    значення: Ціле
  ) {
    звільнити_памʼять(виділяч, значення.цифри);
  }

  місцева дія копіювати_ціле(
    виділяч: адреса<Виділяч>,
    значення: Ціле,
    вихід: адреса<Ціле>
  ) -> логічне {
    змінна абсол_розмір: ц32;
    якщо значення.розмір < 0 {
      абсол_розмір = -значення.розмір;
    } інакше {
      абсол_розмір = значення.розмір;
    }

    змінна новий_розмір: ц32;
    якщо абсол_розмір > 0 {
      новий_розмір = абсол_розмір;
    } інакше {
      новий_розмір = 1;
    }

    якщо не ініціалізувати_ціле(виділяч, новий_розмір, вихід) {
      вернути ні;
    }

    копіювати_памʼять<п32>(вихід.цифри, значення.цифри, природне(абсол_розмір));
    вихід.розмір = значення.розмір;

    вернути так;
  }

  дія розширити_ціле(
    виділяч: адреса<Виділяч>,
    значення: адреса<Ціле>,
    новий_розмір: ц32
  ) -> ц32 {
    якщо новий_розмір <= значення.вмісткість {
      вернути 0;
    }

    змінна нова_вмісткість = новий_розмір + (новий_розмір >> 2) + 4;

    змінна нові_цифри = перевиділити_памʼять<п32>(виділяч, значення.цифри, природне(нова_вмісткість));

    якщо нові_цифри == пусто {
      вернути ц32(0)-1;
    }

    заповнити_памʼять<п32>(нові_цифри[значення.вмісткість]::адреса як памʼять<п32>, 0, природне(нова_вмісткість - значення.вмісткість));

    значення.цифри = нові_цифри;
    значення.вмісткість = нова_вмісткість;

    вернути 0;
  }

  дія нормалізувати_ціле(
    значення: адреса<Ціле>
  ) {
    змінна п: ц32;

    якщо значення.розмір < 0 {
      п = -значення.розмір;
    } інакше {
      п = значення.розмір;
    }

    змінна х = (п > 0) і (значення.цифри[п - 1] == 0);
    поки х {
      п -= 1;
      х = (п > 0) і (значення.цифри[п - 1] == 0);
    }

    якщо значення.розмір < 0 {
      значення.розмір = -п;
    } інакше {
      значення.розмір = п;
    }

    якщо п == 0 {
      значення.розмір = 0;
    }
  }

  місцева дія ініціалізувати_ціле_з_ц64(
    виділяч: адреса<Виділяч>,
    значення: ц64,
    вихід: адреса<Ціле>
  ) -> логічне {
    якщо не ініціалізувати_ціле(виділяч, 3, вихід) {
      вернути ні;
    }

    змінна відʼємне = значення < 0;

    змінна абсол_значення: п64;
    якщо відʼємне {
      абсол_значення = п64((-(значення + 1)) + 1);
    } інакше {
      абсол_значення = п64(значення);
    }

    змінна п: ц32 = 0;

    поки абсол_значення > 0 {
      вихід.цифри[п] = п32(абсол_значення & МАСКА_ЦІЛОГО());
      абсол_значення = абсол_значення >> ЗСУВ_ЦІЛОГО;

      п += 1;
    }

    якщо відʼємне {
      вихід.розмір = -п;
    } інакше {
      вихід.розмір = п;
    }

    нормалізувати_ціле(вихід);

    вернути так;
  }

  місцева дія ініціалізувати_ціле_з_п64(
    виділяч: адреса<Виділяч>,
    значення: п64,
    вихід: адреса<Ціле>
  ) -> логічне {
    якщо не ініціалізувати_ціле(виділяч, 3, вихід) {
      вернути ні;
    }

    змінна п: ц32 = 0;
    поки значення > 0 {
      вихід.цифри[п] = п32(значення & МАСКА_ЦІЛОГО());
      значення = значення >> ЗСУВ_ЦІЛОГО;

      п += 1;
    }

    вихід.розмір = п;

    нормалізувати_ціле(вихід);

    вернути так;
  }

  місцева дія ініціалізувати_ціле_з_кд(
    виділяч: адреса<Виділяч>,
    значення: кд,
    вихід: адреса<Ціле>
  ) -> логічне {
    якщо значення.розмір == 0 {
      вернути ініціалізувати_ціле_нуль(виділяч, вихід);
    }

    змінна п: природне = 0;

    змінна відʼємне = ні;
    якщо значення.дані[п] == 99 {
      відʼємне = так;
      п += 1;
    } інакше якщо значення.дані[п] == 96 {
      п += 1;
    }

    поки значення.розмір > п {
      якщо значення.дані[п] == 0 {
        п += 1;
      } інакше {
        стрибнути далі;
      }
    }
    вернути ініціалізувати_ціле_нуль(виділяч, вихід);

  далі:
    змінна десять: Ціле;

    якщо не ініціалізувати_ціле_нуль(виділяч, вихід) {
      вернути ні;
    }
    якщо не ініціалізувати_ціле_з_п64(виділяч, 10, десять::адреса) {
      звільнити_ціле(виділяч, вихід::вміст);
      вернути ні;
    }

    змінна х = значення.розмір > п і значення.дані[п] >= 0 і значення.дані[п] <= 9;
    поки х {
      змінна тимч: Ціле;
      якщо не помножити_цілі(виділяч, вихід::вміст, десять, тимч::адреса) {
        звільнити_ціле(виділяч, вихід::вміст);
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }
      звільнити_ціле(виділяч, вихід::вміст);

      змінна цифра: Ціле;
      якщо не ініціалізувати_ціле_з_п64(виділяч, п64(значення.дані[п]), цифра::адреса) {
        звільнити_ціле(виділяч, тимч);
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }
      якщо не додати_цілі(виділяч, тимч, цифра, вихід) {
        звільнити_ціле(виділяч, тимч);
        звільнити_ціле(виділяч, цифра);
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }

      звільнити_ціле(виділяч, тимч);
      звільнити_ціле(виділяч, цифра);

      п += 1;
      х = значення.розмір > п і значення.дані[п] >= 0 і значення.дані[п] <= 9;
    }

    звільнити_ціле(виділяч, десять);

    якщо відʼємне і вихід.розмір > 0 {
      вихід.розмір = -вихід.розмір;
    }

    вернути так;
  }

  місцева дія ініціалізувати_ціле_нуль(
    виділяч: адреса<Виділяч>,
    вихід: адреса<Ціле>
  ) -> логічне {
    вернути ініціалізувати_ціле(виділяч, 1, вихід);
  }

  місцева дія ініціалізувати_ціле_один(
    виділяч: адреса<Виділяч>,
    вихід: адреса<Ціле>
  ) -> логічне {
    якщо не ініціалізувати_ціле(виділяч, 1, вихід) {
      вернути ні;
    }

    вихід.цифри[0] = 1;
    вихід.розмір = 1;

    вернути так;
  }

  місцева дія перетворити_ціле_в_ц64(
    виділяч: адреса<Виділяч>,
    значення: Ціле,
    вихід: адреса<ц64>
  ) -> логічне {
    якщо значення.розмір == 0 {
      вихід::вміст = 0;

      вернути так;
    }

    змінна абсол_розмір: ц32;
    якщо значення.розмір < 0 {
      абсол_розмір = -значення.розмір;
    } інакше {
      абсол_розмір = значення.розмір;
    }

    якщо абсол_розмір > 3 або (абсол_розмір == 3 і значення.цифри[2] > 7) {
      вихід::вміст = 0;

      вернути ні;
    }

    змінна результат: п64 = 0;
    змінна п: ц32 = абсол_розмір - 1;

    поки п >= 0 {
      результат = (результат << ЗСУВ_ЦІЛОГО) | п64(значення.цифри[п]);

      п -= 1;
    }

    якщо значення.розмір < 0 {
      якщо результат > (п64(МАКС_Ц64) + 1) {
        вихід::вміст = 0;

        вернути ні;
      }

      вихід::вміст = -(ц64(результат));

      вернути так;
    } інакше {
      якщо результат > МАКС_Ц64 {
        вихід::вміст = 0;

        вернути ні;
      }

      вихід::вміст = ц64(результат);

      вернути так;
    }
  }

  дія поділити_ціле_на_одну_цифру(виділяч: адреса<Виділяч>, а: Ціле, д: п32, залишок: адреса<п32>, вихід: адреса<Ціле>) -> логічне;

  місцева дія перетворити_ціле_в_кд(
    виділяч: адреса<Виділяч>,
    значення: Ціле,
    вихід: адреса<кд>
  ) -> логічне {
    якщо значення.розмір == 0 {
      змінна дані_кд = виділити_памʼять<п8>(виділяч, 1);
      якщо дані_кд == пусто {
        вихід::вміст = кд { 0, пусто };
        вернути ні;
      }
      дані_кд[0] = 0;
      вихід::вміст = кд { 1, дані_кд };
      вернути так;
    }

    змінна абсол_розмір: ц32;
    якщо значення.розмір < 0 {
      абсол_розмір = -значення.розмір;
    } інакше {
      абсол_розмір = значення.розмір;
    }

    змінна максимальний_розмір_кд: ц32 = абсол_розмір * 10 + 2;
    змінна буфер = виділити_памʼять<п8>(виділяч, природне(максимальний_розмір_кд));
    якщо буфер == пусто {
      вихід::вміст = кд { 0, пусто };
      вернути ні;
    }

    змінна тимчасове_ціле: Ціле;
    якщо не копіювати_ціле(виділяч, значення, тимчасове_ціле::адреса) {
      звільнити_памʼять(виділяч, буфер);
      вихід::вміст = кд { 0, пусто };
      вернути ні;
    }

    якщо тимчасове_ціле.розмір < 0 {
      тимчасове_ціле.розмір = -тимчасове_ціле.розмір;
    }

    змінна позиція: ц32 = 0;
    змінна десять_ціле: п32 = 10;

    поки тимчасове_ціле.розмір > 0 {
      змінна залишок: п32 = 0;
      змінна наступне_ціле: Ціле;
      якщо не поділити_ціле_на_одну_цифру(виділяч, тимчасове_ціле, десять_ціле, залишок::адреса, наступне_ціле::адреса) {
        звільнити_памʼять(виділяч, буфер);
        звільнити_ціле(виділяч, тимчасове_ціле);
        вихід::вміст = кд { 0, пусто };
        вернути ні;
      }
      звільнити_ціле(виділяч, тимчасове_ціле);
      тимчасове_ціле = наступне_ціле;
      буфер[позиція] = п8(залишок);

      позиція += 1;
    }

    звільнити_ціле(виділяч, тимчасове_ціле);

    змінна початок: ц32 = 0;
    змінна довжина: ц32 = позиція;
    якщо значення.розмір < 0 {
      довжина += 1;
    }

    змінна дані_результату = виділити_памʼять<п8>(виділяч, природне(довжина));
    якщо дані_результату == пусто {
      звільнити_памʼять(виділяч, буфер);
      вихід::вміст = кд { 0, пусто };
      вернути ні;
    }

    якщо значення.розмір < 0 {
      дані_результату[початок] = 99; // -
      початок += 1;
    }

    змінна п: ц32 = позиція - 1;

    поки п >= 0 {
      дані_результату[початок] = буфер[п];
      початок += 1;
      п -= 1;
    }

    звільнити_памʼять(виділяч, буфер);
    вихід::вміст = кд { природне(початок), дані_результату };

    вернути так;
  }

  дія порівняти_цілі_абсолютно(
    а: Ціле,
    б: Ціле
  ) -> ц8 {
    змінна розмір_а: ц32;
    якщо а.розмір < 0 {
      розмір_а = -а.розмір;
    } інакше {
      розмір_а = а.розмір;
    }

    змінна розмір_б: ц32;
    якщо б.розмір < 0 {
      розмір_б = -б.розмір;
    } інакше {
      розмір_б = б.розмір;
    }

    якщо розмір_а != розмір_б {
      якщо розмір_а > розмір_б {
        вернути 1;
      } інакше {
        вернути ц8(0)-1;
      }
    }

    змінна п: ц32 = розмір_а - 1;

    поки п >= 0 {
      якщо а.цифри[п] != б.цифри[п] {
        якщо а.цифри[п] > б.цифри[п] {
          вернути 1;
        } інакше {
          вернути ц8(0)-1;
        }
      }

      п -= 1;
    }

    вернути 0;
  }

  місцева дія порівняти_цілі(
    а: Ціле,
    б: Ціле
  ) -> ц8 {
    якщо а.розмір < 0 і б.розмір >= 0 {
      вернути ц8(0)-1;
    }

    якщо а.розмір >= 0 і б.розмір < 0 {
      вернути 1;
    }

    якщо а.розмір == 0 і б.розмір == 0 {
      вернути 0;
    }

    змінна порівн = порівняти_цілі_абсолютно(а, б);

    якщо а.розмір < 0 {
      вернути -порівн;
    } інакше {
      вернути порівн;
    }
  }

  місцева дія перевірити_чи_ціле_нуль(
    значення: Ціле
  ) -> логічне {
    вернути значення.розмір == 0;
  }

  місцева дія перевірити_чи_ціле_відʼємне(
    значення: Ціле
  ) -> логічне {
    вернути значення.розмір < 0;
  }

  дія додати_цілі_абсолютно(
    виділяч: адреса<Виділяч>,
    а: Ціле,
    б: Ціле,
    вихід: адреса<Ціле>
  ) -> логічне {
    змінна розмір_а: ц32;
    якщо а.розмір < 0 {
      розмір_а = -а.розмір;
    } інакше {
      розмір_а = а.розмір;
    }

    змінна розмір_б: ц32;
    якщо б.розмір < 0 {
      розмір_б = -б.розмір;
    } інакше {
      розмір_б = б.розмір;
    }

    якщо розмір_а < розмір_б {
      змінна тимчас = а;
      а = б;
      б = тимчас;
      змінна тимчас_розмір = розмір_а;
      розмір_а = розмір_б;
      розмір_б = тимчас_розмір;
    }

    якщо не ініціалізувати_ціле(виділяч, розмір_а + 1, вихід) {
      вернути ні;
    }

    змінна перенос: п64 = 0;
    змінна п: ц32 = 0;

    поки п < розмір_б {
      перенос = перенос + п64(а.цифри[п]) + п64(б.цифри[п]);
      вихід.цифри[п] = п32(перенос & МАСКА_ЦІЛОГО());
      перенос = перенос >> ЗСУВ_ЦІЛОГО;

      п += 1;
    }

    поки п < розмір_а {
      перенос = перенос + п64(а.цифри[п]);
      вихід.цифри[п] = п32(перенос & МАСКА_ЦІЛОГО());
      перенос = перенос >> ЗСУВ_ЦІЛОГО;

      п += 1;
    }

    якщо перенос != 0 {
      вихід.цифри[п] = п32(перенос);
      п += 1;
    }

    вихід.розмір = п;

    нормалізувати_ціле(вихід);

    вернути так;
  }

  дія відняти_цілі_абсолютно(
    виділяч: адреса<Виділяч>,
    а: Ціле,
    б: Ціле,
    вихід: адреса<Ціле>
  ) -> логічне {
    змінна розмір_а: ц32;
    якщо а.розмір < 0 {
      розмір_а = -а.розмір;
    } інакше {
      розмір_а = а.розмір;
    }

    змінна розмір_б: ц32;
    якщо б.розмір < 0 {
      розмір_б = -б.розмір;
    } інакше {
      розмір_б = б.розмір;
    }

    якщо не ініціалізувати_ціле(виділяч, розмір_а, вихід) {
      вернути ні;
    }

    змінна позичка: ц64 = 0;
    змінна п: ц32 = 0;

    поки п < розмір_б {
      позичка = ц64(а.цифри[п]) - ц64(б.цифри[п]) - позичка;
      вихід.цифри[п] = п32(позичка & ц64(МАСКА_ЦІЛОГО()));
      якщо позичка < 0 {
        позичка = 1;
      } інакше {
        позичка = 0;
      }

      п += 1;
    }

    поки п < розмір_а {
      позичка = ц64(а.цифри[п]) - позичка;
      вихід.цифри[п] = п32(позичка & ц64(МАСКА_ЦІЛОГО()));
      якщо позичка < 0 {
        позичка = 1;
      } інакше {
        позичка = 0;
      }

      п += 1;
    }

    вихід.розмір = розмір_а;

    нормалізувати_ціле(вихід);

    вернути так;
  }

  місцева дія додати_цілі(
    виділяч: адреса<Виділяч>,
    а: Ціле,
    б: Ціле,
    вихід: адреса<Ціле>
  ) -> логічне {
    якщо а.розмір == 0 {
      вернути копіювати_ціле(виділяч, б, вихід);
    }
    якщо б.розмір == 0 {
      вернути копіювати_ціле(виділяч, а, вихід);
    }

    якщо (а.розмір < 0) == (б.розмір < 0) {
      якщо не додати_цілі_абсолютно(виділяч, а, б, вихід) {
        вернути ні;
      }

      якщо а.розмір < 0 {
        вихід.розмір = -вихід.розмір;
      }

      вернути так;
    } інакше {
      змінна порівн = порівняти_цілі_абсолютно(а, б);

      якщо порівн == 0 {
        вернути ініціалізувати_ціле_нуль(виділяч, вихід);
      } інакше якщо порівн > 0 {
        якщо не відняти_цілі_абсолютно(виділяч, а, б, вихід) {
          вернути ні;
        }

        якщо а.розмір < 0 {
          вихід.розмір = -вихід.розмір;
        }

        вернути так;
      } інакше {
        якщо не відняти_цілі_абсолютно(виділяч, б, а, вихід) {
          вернути ні;
        }

        якщо б.розмір < 0 {
          вихід.розмір = -вихід.розмір;
        }

        вернути так;
      }
    }
  }

  місцева дія змінити_знак_цілого(
    значення: адреса<Ціле>
  ) {
    якщо значення != пусто {
      значення.розмір = -значення.розмір;
    }
  }

  місцева дія негація_цілого(
    виділяч: адреса<Виділяч>,
    значення: Ціле,
    вихід: адреса<Ціле>
  ) -> логічне {
    якщо копіювати_ціле(виділяч, значення, вихід) {
      змінити_знак_цілого(вихід);

      вернути так;
    }

    вернути ні;
  }

  місцева дія відняти_цілі(
    виділяч: адреса<Виділяч>,
    а: Ціле,
    б: Ціле,
    вихід: адреса<Ціле>
  ) -> логічне {
    якщо б.розмір == 0 {
      вернути копіювати_ціле(виділяч, а, вихід);
    }
    якщо а.розмір == 0 {
      вернути негація_цілого(виділяч, б, вихід);
    }

    якщо (а.розмір < 0) != (б.розмір < 0) {
      якщо не додати_цілі_абсолютно(виділяч, а, б, вихід) {
        вернути ні;
      }

      якщо а.розмір < 0 {
        вихід.розмір = -вихід.розмір;
      }

      вернути так;
    } інакше {
      змінна порівн = порівняти_цілі_абсолютно(а, б);

      якщо порівн == 0 {
        вернути ініціалізувати_ціле_нуль(виділяч, вихід);
      } інакше якщо порівн > 0 {
        якщо не відняти_цілі_абсолютно(виділяч, а, б, вихід) {
          вернути ні;
        }

        якщо а.розмір < 0 {
          вихід.розмір = -вихід.розмір;
        }

        вернути так;
      } інакше {
        якщо не відняти_цілі_абсолютно(виділяч, б, а, вихід) {
          вернути ні;
        }

        якщо а.розмір >= 0 {
          вихід.розмір = -вихід.розмір;
        }

        вернути так;
      }
    }
  }

  дія помножити_цілі_грейд_скул(
    виділяч: адреса<Виділяч>,
    а: Ціле,
    б: Ціле,
    вихід: адреса<Ціле>
  ) -> логічне {
    змінна розмір_а: ц32;
    якщо а.розмір < 0 {
      розмір_а = -а.розмір;
    } інакше {
      розмір_а = а.розмір;
    }

    змінна розмір_б: ц32;
    якщо б.розмір < 0 {
      розмір_б = -б.розмір;
    } інакше {
      розмір_б = б.розмір;
    }

    якщо розмір_а == 0 або розмір_б == 0 {
      вернути ініціалізувати_ціле_нуль(виділяч, вихід);
    }

    змінна розмір_результату: ц32 = розмір_а + розмір_б;
    якщо не ініціалізувати_ціле(виділяч, розмір_результату, вихід) {
      вернути ні;
    }

    змінна п: ц32 = 0;

    поки п < розмір_а {
      змінна перенос: п64 = 0;
      змінна цифра_а: п32 = а.цифри[п];

      змінна п1: ц32 = 0;

      поки п1 < розмір_б {
        перенос = перенос + п64(цифра_а) * п64(б.цифри[п1]) + п64(вихід.цифри[п + п1]);
        вихід.цифри[п + п1] = п32(перенос & МАСКА_ЦІЛОГО());
        перенос = перенос >> ЗСУВ_ЦІЛОГО;

        п1 += 1;
      }

      якщо перенос != 0 {
        вихід.цифри[п + розмір_б] = п32(перенос);
      }

      п += 1;
    }

    вихід.розмір = розмір_результату;

    нормалізувати_ціле(вихід);

    вернути так;
  }

  дія помножити_цілі_каррацуба(виділяч: адреса<Виділяч>, а: Ціле, б: Ціле, вихід: адреса<Ціле>) -> логічне;

  дія розділити_ціле(
    виділяч: адреса<Виділяч>,
    а: Ціле,
    м: ц32,
    низ: адреса<Ціле>,
    висок: адреса<Ціле>
  ) -> логічне {
    змінна розмір: ц32;
    якщо а.розмір < 0 {
      розмір = -а.розмір;
    } інакше {
      розмір = а.розмір;
    }

    якщо м >= розмір {
      якщо не копіювати_ціле(виділяч, а, низ) {
        вернути ні;
      }

      якщо низ.розмір < 0 {
        низ.розмір = -низ.розмір;
      } інакше {
        низ.розмір = низ.розмір;
      }

      якщо не ініціалізувати_ціле_нуль(виділяч, висок) {
        звільнити_ціле(виділяч, низ::вміст);

        вернути ні;
      }

      вернути так;
    }

    якщо не ініціалізувати_ціле(виділяч, м, низ) {
      вернути ні;
    }

    копіювати_памʼять<п32>(низ.цифри, а.цифри, природне(м));
    низ.розмір = м;
    нормалізувати_ціле(низ);

    змінна висок_розмір: ц32 = розмір - м;
    якщо не ініціалізувати_ціле(виділяч, висок_розмір, висок) {
      звільнити_ціле(виділяч, низ::вміст);

      вернути ні;
    }

    копіювати_памʼять<п32>(висок.цифри, а.цифри[м]::адреса як памʼять<п32>, природне(висок_розмір));
    висок.розмір = висок_розмір;
    нормалізувати_ціле(висок);

    вернути так;
  }

  дія зсунути_вліво_ціле_на_цифри(
    виділяч: адреса<Виділяч>,
    а: Ціле,
    н: ц32,
    вихід: адреса<Ціле>
  ) -> логічне {
    якщо а.розмір == 0 або н == 0 {
      вернути копіювати_ціле(виділяч, а, вихід);
    }

    змінна абсол_розмір: ц32;
    якщо а.розмір < 0 {
      абсол_розмір = -а.розмір;
    } інакше {
      абсол_розмір = а.розмір;
    }

    якщо не ініціалізувати_ціле(виділяч, абсол_розмір + н, вихід) {
      вернути ні;
    }

    заповнити_памʼять<п32>(вихід.цифри, 0, природне(н));
    копіювати_памʼять<п32>(вихід.цифри[н]::адреса як памʼять<п32>, а.цифри, природне(абсол_розмір));

    якщо а.розмір < 0 {
      вихід.розмір = -(абсол_розмір + н);
    } інакше {
      вихід.розмір = абсол_розмір + н;
    }

    вернути так;
  }

  стала КАРРАЦУБА_ПОРІГ = 70;

  дія помножити_цілі_каррацуба(
    виділяч: адреса<Виділяч>,
    а: Ціле,
    б: Ціле,
    вихід: адреса<Ціле>
  ) -> логічне {
    змінна розмір_а: ц32;
    якщо а.розмір < 0 {
      розмір_а = -а.розмір;
    } інакше {
      розмір_а = а.розмір;
    }

    змінна розмір_б: ц32;
    якщо б.розмір < 0 {
      розмір_б = -б.розмір;
    } інакше {
      розмір_б = б.розмір;
    }

    якщо розмір_а < КАРРАЦУБА_ПОРІГ або розмір_б < КАРРАЦУБА_ПОРІГ {
      вернути помножити_цілі_грейд_скул(виділяч, а, б, вихід);
    }

    змінна м: ц32;
    якщо розмір_а < розмір_б {
      м = розмір_а / 2;
    } інакше {
      м = розмір_б / 2;
    }

    змінна а_низ: Ціле;
    змінна а_висок: Ціле;
    якщо не розділити_ціле(виділяч, а, м, а_низ::адреса, а_висок::адреса) {
      вернути ні;
    }

    змінна б_низ: Ціле;
    змінна б_висок: Ціле;
    якщо не розділити_ціле(виділяч, б, м, б_низ::адреса, б_висок::адреса) {
      звільнити_ціле(виділяч, а_низ);
      звільнити_ціле(виділяч, а_висок);
      вернути ні;
    }

    змінна з0: Ціле;
    якщо не помножити_цілі_каррацуба(виділяч, а_низ, б_низ, з0::адреса) {
      звільнити_ціле(виділяч, а_низ);
      звільнити_ціле(виділяч, а_висок);
      звільнити_ціле(виділяч, б_низ);
      звільнити_ціле(виділяч, б_висок);
      вернути ні;
    }

    змінна з2: Ціле;
    якщо не помножити_цілі_каррацуба(виділяч, а_висок, б_висок, з2::адреса) {
      звільнити_ціле(виділяч, а_низ);
      звільнити_ціле(виділяч, а_висок);
      звільнити_ціле(виділяч, б_низ);
      звільнити_ціле(виділяч, б_висок);
      звільнити_ціле(виділяч, з0);
      вернути ні;
    }

    змінна а_сума: Ціле;
    якщо не додати_цілі(виділяч, а_низ, а_висок, а_сума::адреса) {
      звільнити_ціле(виділяч, а_низ);
      звільнити_ціле(виділяч, а_висок);
      звільнити_ціле(виділяч, б_низ);
      звільнити_ціле(виділяч, б_висок);
      звільнити_ціле(виділяч, з0);
      звільнити_ціле(виділяч, з2);
      вернути ні;
    }

    змінна б_сума: Ціле;
    якщо не додати_цілі(виділяч, б_низ, б_висок, б_сума::адреса) {
      звільнити_ціле(виділяч, а_низ);
      звільнити_ціле(виділяч, а_висок);
      звільнити_ціле(виділяч, б_низ);
      звільнити_ціле(виділяч, б_висок);
      звільнити_ціле(виділяч, з0);
      звільнити_ціле(виділяч, з2);
      звільнити_ціле(виділяч, а_сума);
      вернути ні;
    }

    змінна з1_тимчас: Ціле;
    якщо не помножити_цілі_каррацуба(виділяч, а_сума, б_сума, з1_тимчас::адреса) {
      звільнити_ціле(виділяч, а_низ);
      звільнити_ціле(виділяч, а_висок);
      звільнити_ціле(виділяч, б_низ);
      звільнити_ціле(виділяч, б_висок);
      звільнити_ціле(виділяч, з0);
      звільнити_ціле(виділяч, з2);
      звільнити_ціле(виділяч, а_сума);
      звільнити_ціле(виділяч, б_сума);
      вернути ні;
    }

    змінна з1_відн1: Ціле;
    якщо не відняти_цілі(виділяч, з1_тимчас, з0, з1_відн1::адреса) {
      звільнити_ціле(виділяч, а_низ);
      звільнити_ціле(виділяч, а_висок);
      звільнити_ціле(виділяч, б_низ);
      звільнити_ціле(виділяч, б_висок);
      звільнити_ціле(виділяч, з0);
      звільнити_ціле(виділяч, з2);
      звільнити_ціле(виділяч, а_сума);
      звільнити_ціле(виділяч, б_сума);
      звільнити_ціле(виділяч, з1_тимчас);
      вернути ні;
    }

    змінна з1: Ціле;
    якщо не відняти_цілі(виділяч, з1_відн1, з2, з1::адреса) {
      звільнити_ціле(виділяч, а_низ);
      звільнити_ціле(виділяч, а_висок);
      звільнити_ціле(виділяч, б_низ);
      звільнити_ціле(виділяч, б_висок);
      звільнити_ціле(виділяч, з0);
      звільнити_ціле(виділяч, з2);
      звільнити_ціле(виділяч, а_сума);
      звільнити_ціле(виділяч, б_сума);
      звільнити_ціле(виділяч, з1_тимчас);
      звільнити_ціле(виділяч, з1_відн1);
      вернути ні;
    }

    змінна з2_зсунутий: Ціле;
    якщо не зсунути_вліво_ціле_на_цифри(виділяч, з2, м * 2, з2_зсунутий::адреса) {
      звільнити_ціле(виділяч, а_низ);
      звільнити_ціле(виділяч, а_висок);
      звільнити_ціле(виділяч, б_низ);
      звільнити_ціле(виділяч, б_висок);
      звільнити_ціле(виділяч, з0);
      звільнити_ціле(виділяч, з2);
      звільнити_ціле(виділяч, а_сума);
      звільнити_ціле(виділяч, б_сума);
      звільнити_ціле(виділяч, з1_тимчас);
      звільнити_ціле(виділяч, з1_відн1);
      звільнити_ціле(виділяч, з1);
      вернути ні;
    }

    змінна з1_зсунутий: Ціле;
    якщо не зсунути_вліво_ціле_на_цифри(виділяч, з1, м, з1_зсунутий::адреса) {
      звільнити_ціле(виділяч, а_низ);
      звільнити_ціле(виділяч, а_висок);
      звільнити_ціле(виділяч, б_низ);
      звільнити_ціле(виділяч, б_висок);
      звільнити_ціле(виділяч, з0);
      звільнити_ціле(виділяч, з2);
      звільнити_ціле(виділяч, а_сума);
      звільнити_ціле(виділяч, б_сума);
      звільнити_ціле(виділяч, з1_тимчас);
      звільнити_ціле(виділяч, з1_відн1);
      звільнити_ціле(виділяч, з1);
      звільнити_ціле(виділяч, з2_зсунутий);
      вернути ні;
    }

    змінна результат_тимчас: Ціле;
    якщо не додати_цілі(виділяч, з2_зсунутий, з1_зсунутий, результат_тимчас::адреса) {
      звільнити_ціле(виділяч, а_низ);
      звільнити_ціле(виділяч, а_висок);
      звільнити_ціле(виділяч, б_низ);
      звільнити_ціле(виділяч, б_висок);
      звільнити_ціле(виділяч, з0);
      звільнити_ціле(виділяч, з2);
      звільнити_ціле(виділяч, а_сума);
      звільнити_ціле(виділяч, б_сума);
      звільнити_ціле(виділяч, з1_тимчас);
      звільнити_ціле(виділяч, з1_відн1);
      звільнити_ціле(виділяч, з1);
      звільнити_ціле(виділяч, з2_зсунутий);
      звільнити_ціле(виділяч, з1_зсунутий);
      вернути ні;
    }

    якщо не додати_цілі(виділяч, результат_тимчас, з0, вихід) {
      звільнити_ціле(виділяч, а_низ);
      звільнити_ціле(виділяч, а_висок);
      звільнити_ціле(виділяч, б_низ);
      звільнити_ціле(виділяч, б_висок);
      звільнити_ціле(виділяч, з0);
      звільнити_ціле(виділяч, з2);
      звільнити_ціле(виділяч, а_сума);
      звільнити_ціле(виділяч, б_сума);
      звільнити_ціле(виділяч, з1_тимчас);
      звільнити_ціле(виділяч, з1_відн1);
      звільнити_ціле(виділяч, з1);
      звільнити_ціле(виділяч, з2_зсунутий);
      звільнити_ціле(виділяч, з1_зсунутий);
      звільнити_ціле(виділяч, результат_тимчас);
      вернути ні;
    }

    звільнити_ціле(виділяч, а_низ);
    звільнити_ціле(виділяч, а_висок);
    звільнити_ціле(виділяч, б_низ);
    звільнити_ціле(виділяч, б_висок);
    звільнити_ціле(виділяч, з0);
    звільнити_ціле(виділяч, з1);
    звільнити_ціле(виділяч, з2);
    звільнити_ціле(виділяч, а_сума);
    звільнити_ціле(виділяч, б_сума);
    звільнити_ціле(виділяч, з1_тимчас);
    звільнити_ціле(виділяч, з1_відн1);
    звільнити_ціле(виділяч, з2_зсунутий);
    звільнити_ціле(виділяч, з1_зсунутий);
    звільнити_ціле(виділяч, результат_тимчас);

    вернути так;
  }

  місцева дія помножити_цілі(
    виділяч: адреса<Виділяч>,
    а: Ціле,
    б: Ціле,
    вихід: адреса<Ціле>
  ) -> логічне {
    якщо а.розмір == 0 або б.розмір == 0 {
      вернути ініціалізувати_ціле_нуль(виділяч, вихід);
    }

    якщо не помножити_цілі_каррацуба(виділяч, а, б, вихід) {
      вернути ні;
    }

    змінна відʼємний: логічне = (а.розмір < 0) != (б.розмір < 0);

    якщо відʼємний і вихід.розмір > 0 {
      вихід.розмір = -вихід.розмір;
    } інакше якщо не відʼємний і вихід.розмір < 0 {
      вихід.розмір = -вихід.розмір;
    }

    вернути так;
  }

  дія поділити_ціле_на_одну_цифру(
    виділяч: адреса<Виділяч>,
    а: Ціле,
    д: п32,
    залишок: адреса<п32>,
    вихід: адреса<Ціле>
  ) -> логічне {
    змінна розмір: ц32;
    якщо а.розмір < 0 {
      розмір = -а.розмір;
    } інакше {
      розмір = а.розмір;
    }

    якщо д == 0 {
      вернути ні;
    }

    якщо розмір == 0 {
      якщо залишок != пусто {
        залишок::вміст = 0;
      }

      вернути ініціалізувати_ціле_нуль(виділяч, вихід);
    }

    якщо не ініціалізувати_ціле(виділяч, розмір, вихід) {
      вернути ні;
    }

    змінна залишок_дві_цифри: п64 = 0;
    змінна п: ц32 = розмір - 1;

    поки п >= 0 {
      залишок_дві_цифри = (залишок_дві_цифри << ЗСУВ_ЦІЛОГО) | п64(а.цифри[п]);
      вихід.цифри[п] = п32(залишок_дві_цифри / п64(д));
      залишок_дві_цифри = залишок_дві_цифри % п64(д);

      п -= 1;
    }

    якщо залишок != пусто {
      залишок::вміст = п32(залишок_дві_цифри);
    }

    вихід.розмір = розмір;

    нормалізувати_ціле(вихід);

    вернути так;
  }

  дія зсунути_вліво_ціле_на_біти(
    виділяч: адреса<Виділяч>,
    а: Ціле,
    н: ц32,
    вихід: адреса<Ціле>
  ) -> логічне {
    якщо н == 0 або а.розмір == 0 {
      вернути копіювати_ціле(виділяч, а, вихід);
    }

    змінна цифровий_зсув = н / ЗСУВ_ЦІЛОГО;
    змінна бітовий_зсув = н % ЗСУВ_ЦІЛОГО;

    змінна абсол_розмір: ц32;
    якщо а.розмір < 0 {
      абсол_розмір = -а.розмір;
    } інакше {
      абсол_розмір = а.розмір;
    }

    змінна новий_розмір = абсол_розмір + цифровий_зсув + 1;
    якщо не ініціалізувати_ціле(виділяч, новий_розмір, вихід) {
      вернути ні;
    }

    змінна перенос: п64 = 0;
    змінна п: ц32 = 0;

    поки п < абсол_розмір {
      перенос = перенос | (п64(а.цифри[п]) << п64(бітовий_зсув));
      вихід.цифри[п + цифровий_зсув] = п32(перенос & МАСКА_ЦІЛОГО());
      перенос = перенос >> ЗСУВ_ЦІЛОГО;

      п += 1;
    }

    якщо перенос != 0 {
      вихід.цифри[абсол_розмір + цифровий_зсув] = п32(перенос);
    }

    якщо а.розмір < 0 {
      вихід.розмір = -(новий_розмір);
    } інакше {
      вихід.розмір = новий_розмір;
    }

    нормалізувати_ціле(вихід);

    вернути так;
  }

  дія зсунути_вправо_ціле_на_біти(
    виділяч: адреса<Виділяч>,
    а: Ціле,
    н: ц32,
    вихід: адреса<Ціле>
  ) -> логічне {
    якщо н == 0 {
      вернути копіювати_ціле(виділяч, а, вихід);
    }
    якщо а.розмір == 0 {
      вернути ініціалізувати_ціле_нуль(виділяч, вихід);
    }

    змінна цифровий_зсув = н / ЗСУВ_ЦІЛОГО;
    змінна бітовий_зсув = н % ЗСУВ_ЦІЛОГО;

    змінна абсол_розмір: ц32;
    якщо а.розмір < 0 {
      абсол_розмір = -а.розмір;
    } інакше {
      абсол_розмір = а.розмір;
    }

    якщо цифровий_зсув >= абсол_розмір {
      вернути ініціалізувати_ціле_нуль(виділяч, вихід);
    }

    змінна новий_розмір = абсол_розмір - цифровий_зсув;
    якщо не ініціалізувати_ціле(виділяч, новий_розмір, вихід) {
      вернути ні;
    }

    змінна перенос: п64 = 0;
    змінна п = абсол_розмір - 1;

    поки п >= цифровий_зсув {
      перенос = (перенос << ЗСУВ_ЦІЛОГО) | п64(а.цифри[п]);
      вихід.цифри[п - цифровий_зсув] = п32(перенос >> п64(бітовий_зсув));
      перенос = перенос & ((п64(1) << п64(бітовий_зсув)) - п64(1));

      п -= 1;
    }

    якщо а.розмір < 0 {
      вихід.розмір = -(новий_розмір);
    } інакше {
      вихід.розмір = новий_розмір;
    }

    нормалізувати_ціле(вихід);

    вернути так;
  }

  дія порахувати_старші_нулі_в_цифрі(
    д: п32
  ) -> ц32 {
    змінна н: ц32 = 0;
    якщо д == 0 {
      вернути ЗСУВ_ЦІЛОГО;
    }

    поки (д & (п32(1) << (п32(ЗСУВ_ЦІЛОГО) - 1))) == 0 {
      н += 1;
      д = д << 1;
    }

    вернути н;
  }

  дія поділити_дівмод_абс_цілі(
    виділяч: адреса<Виділяч>,
    а: Ціле,
    б: Ціле,
    частка: адреса<Ціле>,
    залишок: адреса<Ціле>
  ) -> логічне {
    змінна розмір_а: ц32;
    якщо а.розмір < 0 {
      розмір_а = -а.розмір;
    } інакше {
      розмір_а = а.розмір;
    }

    змінна розмір_б: ц32;
    якщо б.розмір < 0 {
      розмір_б = -б.розмір;
    } інакше {
      розмір_б = б.розмір;
    }

    якщо розмір_б == 0 {
      вернути ні;
    }

    змінна порівн = порівняти_цілі_абсолютно(а, б);

    якщо порівн < 0 {
      якщо не ініціалізувати_ціле_нуль(виділяч, частка) {
        вернути ні;
      }

      якщо не копіювати_ціле(виділяч, а, залишок) {
        звільнити_ціле(виділяч, частка::вміст);
        вернути ні;
      }

      якщо залишок.розмір < 0 {
        залишок.розмір = -залишок.розмір;
      } інакше {
        залишок.розмір = залишок.розмір;
      }

      вернути так;
    }

    якщо порівн == 0 {
      якщо не ініціалізувати_ціле_один(виділяч, частка) {
        вернути ні;
      }
      якщо не ініціалізувати_ціле_нуль(виділяч, залишок) {
        звільнити_ціле(виділяч, частка::вміст);
        вернути ні;
      }
      вернути так;
    }

    якщо розмір_б == 1 {
      змінна залиш: п32;
      якщо не поділити_ціле_на_одну_цифру(виділяч, а, б.цифри[0], залиш::адреса, частка) {
        вернути ні;
      }

      якщо частка::вміст.розмір < 0 {
        частка::вміст.розмір = -частка::вміст.розмір;
      } інакше {
        частка::вміст.розмір = частка::вміст.розмір;
      }

      якщо не ініціалізувати_ціле_з_п64(виділяч, п64(залиш), залишок) {
        звільнити_ціле(виділяч, частка::вміст);
        вернути ні;
      }

      вернути так;
    }

    /* Нормалізація: зсуваємо так, щоб старша цифра б >= БАЗА/2 */
    змінна зсув = порахувати_старші_нулі_в_цифрі(б.цифри[розмір_б - 1]);

    змінна а_норм: Ціле;
    якщо не зсунути_вліво_ціле_на_біти(виділяч, а, зсув, а_норм::адреса) {
      вернути ні;
    }

    змінна б_норм: Ціле;
    якщо не зсунути_вліво_ціле_на_біти(виділяч, б, зсув, б_норм::адреса) {
      звільнити_ціле(виділяч, а_норм);
      вернути ні;
    }

    якщо а_норм.розмір < 0 {
      а_норм.розмір = -а_норм.розмір;
    }
    якщо б_норм.розмір < 0 {
      б_норм.розмір = -б_норм.розмір;
    }

    змінна м: ц32 = а_норм.розмір;
    змінна н: ц32 = б_норм.розмір;

    якщо розширити_ціле(виділяч, а_норм::адреса, м + 1) < 0 {
      звільнити_ціле(виділяч, а_норм);
      звільнити_ціле(виділяч, б_норм);
      вернути ні;
    }
    а_норм.цифри[м] = 0;

    якщо не ініціалізувати_ціле(виділяч, м - н + 1, частка) {
      звільнити_ціле(виділяч, а_норм);
      звільнити_ціле(виділяч, б_норм);
      вернути ні;
    }

    змінна бн_верх = б_норм.цифри[н - 1];
    змінна бн_друга: п32;
    якщо н > 1 {
      бн_друга = б_норм.цифри[н - 2];
    } інакше {
      бн_друга = 0;
    }

    змінна п = м - н;

    поки п >= 0 {
      змінна оцінка_частки: п64;
      змінна ан_верх = (п64(а_норм.цифри[п + н]) << ЗСУВ_ЦІЛОГО) | п64(а_норм.цифри[п + н - 1]);

      оцінка_частки = ан_верх / п64(бн_верх);
      змінна оцінка_залишку = ан_верх % п64(бн_верх);

      /* Уточнення оцінки */
      змінна ан_друга: п64;
      якщо п + н - 2 >= 0 {
        ан_друга = п64(а_норм.цифри[п + н - 2]);
      } інакше {
        ан_друга = 0;
      }

      змінна продовжувати_уточнення: логічне = так;
      поки продовжувати_уточнення {
        якщо оцінка_частки >= БАЗА_ЦІЛОГО() або оцінка_частки * п64(бн_друга) > (оцінка_залишку << ЗСУВ_ЦІЛОГО) + ан_друга {
          оцінка_частки -= 1;
          оцінка_залишку += п64(бн_верх);
          якщо оцінка_залишку >= БАЗА_ЦІЛОГО() {
            продовжувати_уточнення = ні;
          }
        } інакше {
          продовжувати_уточнення = ні;
        }
      }

      /* Множення і віднімання */
      змінна позичка: ц64 = 0;
      змінна п1: ц32 = 0;

      поки п1 < н {
        змінна добуток: п64 = оцінка_частки * п64(б_норм.цифри[п1]);
        змінна т: ц64 = ц64(а_норм.цифри[п + п1]) - ц64(п32(добуток & МАСКА_ЦІЛОГО())) - позичка;
        а_норм.цифри[п + п1] = п32(п64(т) & МАСКА_ЦІЛОГО());
        позичка = ц64(добуток >> ЗСУВ_ЦІЛОГО) - (т >> ЗСУВ_ЦІЛОГО);

        п1 += 1;
      }

      змінна т: ц64 = ц64(а_норм.цифри[п + н]) - позичка;
      а_норм.цифри[п + н] = п32(п64(т) & МАСКА_ЦІЛОГО());

      частка::вміст.цифри[п] = п32(оцінка_частки);

      якщо т < 0 {
        частка::вміст.цифри[п] -= 1;
        змінна перенос: п64 = 0;
        змінна к: ц32 = 0;

        поки к < н {
          перенос += п64(а_норм.цифри[п + к]) + п64(б_норм.цифри[к]);
          а_норм.цифри[п + к] = п32(перенос & МАСКА_ЦІЛОГО());
          перенос = перенос >> ЗСУВ_ЦІЛОГО;

          к += 1;
        }

        а_норм.цифри[п + н] += п32(перенос);
      }

      п -= 1;
    }

    частка.розмір = м - н + 1;
    нормалізувати_ціле(частка);

    /* Денормалізація залишку */
    а_норм.розмір = н;
    якщо не зсунути_вправо_ціле_на_біти(виділяч, а_норм, зсув, залишок) {
      звільнити_ціле(виділяч, а_норм);
      звільнити_ціле(виділяч, б_норм);
      звільнити_ціле(виділяч, частка::вміст);
      вернути ні;
    }

    звільнити_ціле(виділяч, а_норм);
    звільнити_ціле(виділяч, б_норм);

    вернути так;
  }

  дія дівмод_ціле(
    виділяч: адреса<Виділяч>,
    а: Ціле,
    б: Ціле,
    частка: адреса<Ціле>,
    залишок: адреса<Ціле>
  ) -> логічне {
    якщо б.розмір == 0 {
      вернути ні;
    }

    змінна абсол_ч: Ціле;
    змінна абсол_з: Ціле;

    якщо не поділити_дівмод_абс_цілі(виділяч, а, б, абсол_ч::адреса, абсол_з::адреса) {
      вернути ні;
    }

    змінна відʼємний_а = (а.розмір < 0);
    змінна відʼємний_б = (б.розмір < 0);

    якщо відʼємний_а != відʼємний_б і абсол_ч.розмір != 0 {
      абсол_ч.розмір = -абсол_ч.розмір;
    }

    якщо відʼємний_а і абсол_з.розмір != 0 {
      абсол_з.розмір = -абсол_з.розмір;
    }

    якщо частка != пусто {
      частка::вміст = абсол_ч;
    } інакше {
      звільнити_ціле(виділяч, абсол_ч);
    }

    якщо залишок != пусто {
      залишок::вміст = абсол_з;
    } інакше {
      звільнити_ціле(виділяч, абсол_з);
    }

    вернути так;
  }

  місцева дія поділити_цілі(
    виділяч: адреса<Виділяч>,
    а: Ціле,
    б: Ціле,
    вихід: адреса<Ціле>
  ) -> логічне {
    змінна частка: Ціле;
    змінна залишок: Ціле;
    якщо не дівмод_ціле(виділяч, а, б, частка::адреса, залишок::адреса) {
      вернути ні;
    }
    звільнити_ціле(виділяч, залишок);
    вихід::вміст = частка;
    вернути так;
  }

  місцева дія залишок_ділення_цілих(
    виділяч: адреса<Виділяч>,
    а: Ціле,
    б: Ціле,
    вихід: адреса<Ціле>
  ) -> логічне {
    змінна частка: Ціле;
    змінна залишок: Ціле;
    якщо не дівмод_ціле(виділяч, а, б, частка::адреса, залишок::адреса) {
      вернути ні;
    }
    звільнити_ціле(виділяч, частка);
    вихід::вміст = залишок;
    вернути так;
  }

  місцева дія абсолютне_ціле(
    виділяч: адреса<Виділяч>,
    значення: Ціле,
    вихід: адреса<Ціле>
  ) -> логічне {
    якщо не копіювати_ціле(виділяч, значення, вихід) {
      вернути ні;
    }

    якщо вихід.розмір < 0 {
      вихід.розмір = -вихід.розмір;
    }

    вернути так;
  }

  місцева дія степінь_цілого(
    виділяч: адреса<Виділяч>,
    основа: Ціле,
    показник: Ціле,
    вихід: адреса<Ціле>
  ) -> логічне {
    якщо показник.розмір < 0 {
      вернути ні;
    }

    якщо показник.розмір == 0 {
      вернути ініціалізувати_ціле_один(виділяч, вихід);
    }

    змінна результат: Ціле;
    змінна о: Ціле;
    змінна п: Ціле;
    змінна два: Ціле;

    якщо не ініціалізувати_ціле_один(виділяч, результат::адреса) {
      вернути ні;
    }

    якщо не копіювати_ціле(виділяч, основа, о::адреса) {
      звільнити_ціле(виділяч, результат);
      вернути ні;
    }

    якщо не копіювати_ціле(виділяч, показник, п::адреса) {
      звільнити_ціле(виділяч, о);
      звільнити_ціле(виділяч, результат);
      вернути ні;
    }

    якщо не ініціалізувати_ціле_з_п64(виділяч, 2, два::адреса) {
      звільнити_ціле(виділяч, п);
      звільнити_ціле(виділяч, о);
      звільнити_ціле(виділяч, результат);
      вернути ні;
    }

    поки п.розмір > 0 {
      якщо (п.цифри[0] & 1) != 0 {
        змінна тимчас: Ціле;
        якщо не помножити_цілі(виділяч, результат, о, тимчас::адреса) {
          звільнити_ціле(виділяч, два);
          звільнити_ціле(виділяч, п);
          звільнити_ціле(виділяч, о);
          звільнити_ціле(виділяч, результат);
          вернути ні;
        }
        звільнити_ціле(виділяч, результат);
        результат = тимчас;
      }

      змінна о_квадрат: Ціле;
      якщо не помножити_цілі(виділяч, о, о, о_квадрат::адреса) {
        звільнити_ціле(виділяч, два);
        звільнити_ціле(виділяч, п);
        звільнити_ціле(виділяч, о);
        звільнити_ціле(виділяч, результат);
        вернути ні;
      }
      звільнити_ціле(виділяч, о);
      о = о_квадрат;

      змінна п_половина: Ціле;
      якщо не поділити_цілі(виділяч, п, два, п_половина::адреса) {
        звільнити_ціле(виділяч, о);
        звільнити_ціле(виділяч, два);
        звільнити_ціле(виділяч, п);
        звільнити_ціле(виділяч, результат);
        вернути ні;
      }
      звільнити_ціле(виділяч, п);
      п = п_половина;
    }

    звільнити_ціле(виділяч, о);
    звільнити_ціле(виділяч, п);
    звільнити_ціле(виділяч, два);

    вихід::вміст = результат;

    вернути так;
  }

  місцева дія найбільший_спільний_дільник_цілих(
    виділяч: адреса<Виділяч>,
    а: Ціле,
    б: Ціле,
    вихід: адреса<Ціле>
  ) -> логічне {
    змінна х: Ціле;
    змінна у: Ціле;

    якщо не абсолютне_ціле(виділяч, а, х::адреса) {
      вернути ні;
    }

    якщо не абсолютне_ціле(виділяч, б, у::адреса) {
      звільнити_ціле(виділяч, х);
      вернути ні;
    }

    якщо х.розмір == 0 {
      звільнити_ціле(виділяч, х);
      вихід::вміст = у;
      вернути так;
    }

    якщо у.розмір == 0 {
      звільнити_ціле(виділяч, у);
      вихід::вміст = х;
      вернути так;
    }

    змінна зсув: ц32 = 0;
    змінна л = (х.цифри[0] & 1) == 0 і (у.цифри[0] & 1) == 0;
    поки л {
      змінна х_новий: Ціле;
      якщо не зсунути_вправо_ціле_на_біти(виділяч, х, 1, х_новий::адреса) {
        звільнити_ціле(виділяч, х);
        звільнити_ціле(виділяч, у);
        вернути ні;
      }
      змінна у_новий: Ціле;
      якщо не зсунути_вправо_ціле_на_біти(виділяч, у, 1, у_новий::адреса) {
        звільнити_ціле(виділяч, х);
        звільнити_ціле(виділяч, у);
        звільнити_ціле(виділяч, х_новий);
        вернути ні;
      }
      звільнити_ціле(виділяч, х);
      звільнити_ціле(виділяч, у);
      х = х_новий;
      у = у_новий;
      зсув += 1;
      л = (х.цифри[0] & 1) == 0 і (у.цифри[0] & 1) == 0;
    }

    поки (х.цифри[0] & 1) == 0 {
      змінна х_новий: Ціле;
      якщо не зсунути_вправо_ціле_на_біти(виділяч, х, 1, х_новий::адреса) {
        звільнити_ціле(виділяч, х);
        звільнити_ціле(виділяч, у);
        вернути ні;
      }
      звільнити_ціле(виділяч, х);
      х = х_новий;
    }

    поки у.розмір > 0 {
      поки (у.цифри[0] & 1) == 0 {
        змінна у_новий: Ціле;
        якщо не зсунути_вправо_ціле_на_біти(виділяч, у, 1, у_новий::адреса) {
          звільнити_ціле(виділяч, х);
          звільнити_ціле(виділяч, у);
          вернути ні;
        }
        звільнити_ціле(виділяч, у);
        у = у_новий;
      }

      якщо порівняти_цілі(х, у) > 0 {
        змінна тимчас = х;
        х = у;
        у = тимчас;
      }

      змінна у_новий: Ціле;
      якщо не відняти_цілі(виділяч, у, х, у_новий::адреса) {
        звільнити_ціле(виділяч, х);
        звільнити_ціле(виділяч, у);
        вернути ні;
      }
      звільнити_ціле(виділяч, у);
      у = у_новий;
    }

    звільнити_ціле(виділяч, у);

    якщо не зсунути_вліво_ціле_на_біти(виділяч, х, зсув, вихід) {
      звільнити_ціле(виділяч, х);
      вернути ні;
    }
    звільнити_ціле(виділяч, х);

    вернути так;
  }

  місцева дія зсунути_ціле_вправо(
    виділяч: адреса<Виділяч>,
    значення: Ціле,
    кількість: ц32,
    вихід: адреса<Ціле>
  ) -> логічне {
    вернути зсунути_вправо_ціле_на_біти(виділяч, значення, кількість, вихід);
  }

  місцева дія зсунути_ціле_вліво(
    виділяч: адреса<Виділяч>,
    значення: Ціле,
    кількість: ц32,
    вихід: адреса<Ціле>
  ) -> логічне {
    вернути зсунути_вліво_ціле_на_біти(виділяч, значення, кількість, вихід);
  }

  місцева дія двійкове_заперечення_цілого(
    виділяч: адреса<Виділяч>,
    значення: Ціле,
    вихід: адреса<Ціле>
  ) -> логічне {
    змінна один: Ціле;
    якщо не ініціалізувати_ціле_один(виділяч, один::адреса) {
      вернути ні;
    }

    змінна сума: Ціле;
    якщо не додати_цілі(виділяч, значення, один, сума::адреса) {
      звільнити_ціле(виділяч, один);
      вернути ні;
    }

    звільнити_ціле(виділяч, один);

    якщо не негація_цілого(виділяч, сума, вихід) {
      звільнити_ціле(виділяч, сума);
      вернути ні;
    }

    звільнити_ціле(виділяч, сума);

    вернути так;
  }

  місцева дія двійкове_і_цілих(
    виділяч: адреса<Виділяч>,
    а: Ціле,
    б: Ціле,
    вихід: адреса<Ціле>
  ) -> логічне {
    якщо а.розмір == 0 і б.розмір == 0 {
      вернути ініціалізувати_ціле_нуль(виділяч, вихід);
    }

    якщо а.розмір == 0 {
      вернути ініціалізувати_ціле_нуль(виділяч, вихід);
    }
    якщо б.розмір == 0 {
      вернути ініціалізувати_ціле_нуль(виділяч, вихід);
    }

    змінна а_відʼємне = а.розмір < 0;
    змінна б_відʼємне = б.розмір < 0;

    змінна розмір_а: ц32;
    якщо а_відʼємне {
      розмір_а = -а.розмір;
    } інакше {
      розмір_а = а.розмір;
    }

    змінна розмір_б: ц32;
    якщо б_відʼємне {
      розмір_б = -б.розмір;
    } інакше {
      розмір_б = б.розмір;
    }

    якщо не а_відʼємне і не б_відʼємне {
      змінна мін_розмір: ц32;
      якщо розмір_а < розмір_б {
        мін_розмір = розмір_а;
      } інакше {
        мін_розмір = розмір_б;
      }

      якщо не ініціалізувати_ціле(виділяч, мін_розмір, вихід) {
        вернути ні;
      }

      змінна п: ц32 = 0;
      поки п < мін_розмір {
        вихід.цифри[п] = а.цифри[п] & б.цифри[п];
        п += 1;
      }

      вихід.розмір = мін_розмір;
      нормалізувати_ціле(вихід);
      вернути так;
    }

    змінна один: Ціле;
    якщо не ініціалізувати_ціле_один(виділяч, один::адреса) {
      вернути ні;
    }

    якщо а_відʼємне != б_відʼємне {
      змінна поз: Ціле;
      змінна розмір_поз: ц32;
      змінна нег: Ціле;

      якщо а_відʼємне {
        поз = б;
        розмір_поз = розмір_б;
        нег = а;
      } інакше {
        поз = а;
        розмір_поз = розмір_а;
        нег = б;
      }

      змінна абсол_нег: Ціле;
      якщо не абсолютне_ціле(виділяч, нег, абсол_нег::адреса) {
        звільнити_ціле(виділяч, один);
        вернути ні;
      }

      змінна нег_мінус_один: Ціле;
      якщо не відняти_цілі(виділяч, абсол_нег, один, нег_мінус_один::адреса) {
        звільнити_ціле(виділяч, один);
        звільнити_ціле(виділяч, абсол_нег);
        вернути ні;
      }
      звільнити_ціле(виділяч, абсол_нег);

      змінна розмір_нег_м1: ц32;
      якщо нег_мінус_один.розмір < 0 {
        розмір_нег_м1 = -нег_мінус_один.розмір;
      } інакше {
        розмір_нег_м1 = нег_мінус_один.розмір;
      }

      якщо не ініціалізувати_ціле(виділяч, розмір_поз, вихід) {
        звільнити_ціле(виділяч, один);
        звільнити_ціле(виділяч, нег_мінус_один);
        вернути ні;
      }

      змінна п: ц32 = 0;
      поки п < розмір_поз {
        якщо п < розмір_нег_м1 {
          вихід.цифри[п] = поз.цифри[п] & (п32(МАСКА_ЦІЛОГО()) вабо нег_мінус_один.цифри[п]);
        } інакше {
          вихід.цифри[п] = поз.цифри[п];
        }
        п += 1;
      }

      вихід.розмір = розмір_поз;
      нормалізувати_ціле(вихід);

      звільнити_ціле(виділяч, один);
      звільнити_ціле(виділяч, нег_мінус_один);
      вернути так;
    }

    змінна абсол_а: Ціле;
    якщо не абсолютне_ціле(виділяч, а, абсол_а::адреса) {
      звільнити_ціле(виділяч, один);
      вернути ні;
    }

    змінна а_мінус_один: Ціле;
    якщо не відняти_цілі(виділяч, абсол_а, один, а_мінус_один::адреса) {
      звільнити_ціле(виділяч, один);
      звільнити_ціле(виділяч, абсол_а);
      вернути ні;
    }
    звільнити_ціле(виділяч, абсол_а);

    змінна абсол_б: Ціле;
    якщо не абсолютне_ціле(виділяч, б, абсол_б::адреса) {
      звільнити_ціле(виділяч, один);
      звільнити_ціле(виділяч, а_мінус_один);
      вернути ні;
    }

    змінна б_мінус_один: Ціле;
    якщо не відняти_цілі(виділяч, абсол_б, один, б_мінус_один::адреса) {
      звільнити_ціле(виділяч, один);
      звільнити_ціле(виділяч, а_мінус_один);
      звільнити_ціле(виділяч, абсол_б);
      вернути ні;
    }
    звільнити_ціле(виділяч, абсол_б);

    змінна розмір_ам1: ц32;
    якщо а_мінус_один.розмір < 0 {
      розмір_ам1 = -а_мінус_один.розмір;
    } інакше {
      розмір_ам1 = а_мінус_один.розмір;
    }

    змінна розмір_бм1: ц32;
    якщо б_мінус_один.розмір < 0 {
      розмір_бм1 = -б_мінус_один.розмір;
    } інакше {
      розмір_бм1 = б_мінус_один.розмір;
    }

    змінна макс_розмір: ц32;
    якщо розмір_ам1 > розмір_бм1 {
      макс_розмір = розмір_ам1;
    } інакше {
      макс_розмір = розмір_бм1;
    }

    змінна або_результат: Ціле;
    якщо не ініціалізувати_ціле(виділяч, макс_розмір, або_результат::адреса) {
      звільнити_ціле(виділяч, один);
      звільнити_ціле(виділяч, а_мінус_один);
      звільнити_ціле(виділяч, б_мінус_один);
      вернути ні;
    }

    змінна п: ц32 = 0;
    поки п < макс_розмір {
      змінна цифра_а: п32 = 0;
      змінна цифра_б: п32 = 0;

      якщо п < розмір_ам1 {
        цифра_а = а_мінус_один.цифри[п];
      }
      якщо п < розмір_бм1 {
        цифра_б = б_мінус_один.цифри[п];
      }

      або_результат.цифри[п] = цифра_а | цифра_б;
      п += 1;
    }

    або_результат.розмір = макс_розмір;
    нормалізувати_ціле(або_результат::адреса);

    звільнити_ціле(виділяч, а_мінус_один);
    звільнити_ціле(виділяч, б_мінус_один);

    змінна або_плюс_один: Ціле;
    якщо не додати_цілі(виділяч, або_результат, один, або_плюс_один::адреса) {
      звільнити_ціле(виділяч, один);
      звільнити_ціле(виділяч, або_результат);
      вернути ні;
    }

    звільнити_ціле(виділяч, один);
    звільнити_ціле(виділяч, або_результат);

    якщо не негація_цілого(виділяч, або_плюс_один, вихід) {
      звільнити_ціле(виділяч, або_плюс_один);
      вернути ні;
    }

    звільнити_ціле(виділяч, або_плюс_один);

    вернути так;
  }

  місцева дія двійкове_або_цілих(
    виділяч: адреса<Виділяч>,
    а: Ціле,
    б: Ціле,
    вихід: адреса<Ціле>
  ) -> логічне {
    якщо а.розмір == 0 і б.розмір == 0 {
      вернути ініціалізувати_ціле_нуль(виділяч, вихід);
    }

    якщо а.розмір == 0 {
      вернути копіювати_ціле(виділяч, б, вихід);
    }
    якщо б.розмір == 0 {
      вернути копіювати_ціле(виділяч, а, вихід);
    }

    змінна а_відʼємне = а.розмір < 0;
    змінна б_відʼємне = б.розмір < 0;

    змінна розмір_а: ц32;
    якщо а_відʼємне {
      розмір_а = -а.розмір;
    } інакше {
      розмір_а = а.розмір;
    }

    змінна розмір_б: ц32;
    якщо б_відʼємне {
      розмір_б = -б.розмір;
    } інакше {
      розмір_б = б.розмір;
    }

    якщо не а_відʼємне і не б_відʼємне {
      змінна макс_розмір: ц32;
      якщо розмір_а > розмір_б {
        макс_розмір = розмір_а;
      } інакше {
        макс_розмір = розмір_б;
      }

      якщо не ініціалізувати_ціле(виділяч, макс_розмір, вихід) {
        вернути ні;
      }

      змінна п: ц32 = 0;
      поки п < макс_розмір {
        змінна цифра_а: п32 = 0;
        змінна цифра_б: п32 = 0;

        якщо п < розмір_а {
          цифра_а = а.цифри[п];
        }
        якщо п < розмір_б {
          цифра_б = б.цифри[п];
        }

        вихід.цифри[п] = цифра_а | цифра_б;
        п += 1;
      }

      вихід.розмір = макс_розмір;
      нормалізувати_ціле(вихід);
      вернути так;
    }

    змінна один: Ціле;
    якщо не ініціалізувати_ціле_один(виділяч, один::адреса) {
      вернути ні;
    }

    якщо а_відʼємне != б_відʼємне {
      змінна поз: Ціле;
      змінна розмір_поз: ц32;
      змінна нег: Ціле;

      якщо а_відʼємне {
        поз = б;
        розмір_поз = розмір_б;
        нег = а;
      } інакше {
        поз = а;
        розмір_поз = розмір_а;
        нег = б;
      }

      змінна абсол_нег: Ціле;
      якщо не абсолютне_ціле(виділяч, нег, абсол_нег::адреса) {
        звільнити_ціле(виділяч, один);
        вернути ні;
      }

      змінна нег_мінус_один: Ціле;
      якщо не відняти_цілі(виділяч, абсол_нег, один, нег_мінус_один::адреса) {
        звільнити_ціле(виділяч, один);
        звільнити_ціле(виділяч, абсол_нег);
        вернути ні;
      }
      звільнити_ціле(виділяч, абсол_нег);

      змінна розмір_нег_м1: ц32;
      якщо нег_мінус_один.розмір < 0 {
        розмір_нег_м1 = -нег_мінус_один.розмір;
      } інакше {
        розмір_нег_м1 = нег_мінус_один.розмір;
      }

      змінна мін_розмір: ц32;
      якщо розмір_поз < розмір_нег_м1 {
        мін_розмір = розмір_поз;
      } інакше {
        мін_розмір = розмір_нег_м1;
      }

      змінна і_результат: Ціле;
      якщо не ініціалізувати_ціле(виділяч, розмір_нег_м1, і_результат::адреса) {
        звільнити_ціле(виділяч, один);
        звільнити_ціле(виділяч, нег_мінус_один);
        вернути ні;
      }

      змінна п: ц32 = 0;
      поки п < розмір_нег_м1 {
        змінна цифра_поз: п32 = 0;
        якщо п < розмір_поз {
          цифра_поз = поз.цифри[п];
        }
        і_результат.цифри[п] = (п32(МАСКА_ЦІЛОГО()) вабо цифра_поз) & нег_мінус_один.цифри[п];
        п += 1;
      }

      і_результат.розмір = розмір_нег_м1;
      нормалізувати_ціле(і_результат::адреса);

      звільнити_ціле(виділяч, нег_мінус_один);

      змінна і_плюс_один: Ціле;
      якщо не додати_цілі(виділяч, і_результат, один, і_плюс_один::адреса) {
        звільнити_ціле(виділяч, один);
        звільнити_ціле(виділяч, і_результат);
        вернути ні;
      }

      звільнити_ціле(виділяч, один);
      звільнити_ціле(виділяч, і_результат);

      якщо не негація_цілого(виділяч, і_плюс_один, вихід) {
        звільнити_ціле(виділяч, і_плюс_один);
        вернути ні;
      }

      звільнити_ціле(виділяч, і_плюс_один);

      вернути так;
    }

    змінна абсол_а: Ціле;
    якщо не абсолютне_ціле(виділяч, а, абсол_а::адреса) {
      звільнити_ціле(виділяч, один);
      вернути ні;
    }

    змінна а_мінус_один: Ціле;
    якщо не відняти_цілі(виділяч, абсол_а, один, а_мінус_один::адреса) {
      звільнити_ціле(виділяч, один);
      звільнити_ціле(виділяч, абсол_а);
      вернути ні;
    }
    звільнити_ціле(виділяч, абсол_а);

    змінна абсол_б: Ціле;
    якщо не абсолютне_ціле(виділяч, б, абсол_б::адреса) {
      звільнити_ціле(виділяч, один);
      звільнити_ціле(виділяч, а_мінус_один);
      вернути ні;
    }

    змінна б_мінус_один: Ціле;
    якщо не відняти_цілі(виділяч, абсол_б, один, б_мінус_один::адреса) {
      звільнити_ціле(виділяч, один);
      звільнити_ціле(виділяч, а_мінус_один);
      звільнити_ціле(виділяч, абсол_б);
      вернути ні;
    }
    звільнити_ціле(виділяч, абсол_б);

    змінна розмір_ам1: ц32;
    якщо а_мінус_один.розмір < 0 {
      розмір_ам1 = -а_мінус_один.розмір;
    } інакше {
      розмір_ам1 = а_мінус_один.розмір;
    }

    змінна розмір_бм1: ц32;
    якщо б_мінус_один.розмір < 0 {
      розмір_бм1 = -б_мінус_один.розмір;
    } інакше {
      розмір_бм1 = б_мінус_один.розмір;
    }

    змінна мін_розмір: ц32;
    якщо розмір_ам1 < розмір_бм1 {
      мін_розмір = розмір_ам1;
    } інакше {
      мін_розмір = розмір_бм1;
    }

    змінна і_результат: Ціле;
    якщо не ініціалізувати_ціле(виділяч, мін_розмір, і_результат::адреса) {
      звільнити_ціле(виділяч, один);
      звільнити_ціле(виділяч, а_мінус_один);
      звільнити_ціле(виділяч, б_мінус_один);
      вернути ні;
    }

    змінна п: ц32 = 0;
    поки п < мін_розмір {
      і_результат.цифри[п] = а_мінус_один.цифри[п] & б_мінус_один.цифри[п];
      п += 1;
    }

    і_результат.розмір = мін_розмір;
    нормалізувати_ціле(і_результат::адреса);

    звільнити_ціле(виділяч, а_мінус_один);
    звільнити_ціле(виділяч, б_мінус_один);

    змінна і_плюс_один: Ціле;
    якщо не додати_цілі(виділяч, і_результат, один, і_плюс_один::адреса) {
      звільнити_ціле(виділяч, один);
      звільнити_ціле(виділяч, і_результат);
      вернути ні;
    }

    звільнити_ціле(виділяч, один);
    звільнити_ціле(виділяч, і_результат);

    якщо не негація_цілого(виділяч, і_плюс_один, вихід) {
      звільнити_ціле(виділяч, і_плюс_один);
      вернути ні;
    }

    звільнити_ціле(виділяч, і_плюс_один);

    вернути так;
  }

  місцева дія двійкове_вабо_цілих(
    виділяч: адреса<Виділяч>,
    а: Ціле, б: Ціле,
    вихід: адреса<Ціле>
  ) -> логічне {
    якщо а.розмір == 0 і б.розмір == 0 {
      вернути ініціалізувати_ціле_нуль(виділяч, вихід);
    }

    якщо а.розмір == 0 {
      вернути копіювати_ціле(виділяч, б, вихід);
    }
    якщо б.розмір == 0 {
      вернути копіювати_ціле(виділяч, а, вихід);
    }

    змінна а_відʼємне = а.розмір < 0;
    змінна б_відʼємне = б.розмір < 0;

    змінна розмір_а: ц32;
    якщо а_відʼємне {
      розмір_а = -а.розмір;
    } інакше {
      розмір_а = а.розмір;
    }

    змінна розмір_б: ц32;
    якщо б_відʼємне {
      розмір_б = -б.розмір;
    } інакше {
      розмір_б = б.розмір;
    }

    якщо не а_відʼємне і не б_відʼємне {
      змінна макс_розмір: ц32;
      якщо розмір_а > розмір_б {
        макс_розмір = розмір_а;
      } інакше {
        макс_розмір = розмір_б;
      }

      якщо не ініціалізувати_ціле(виділяч, макс_розмір, вихід) {
        вернути ні;
      }

      змінна п: ц32 = 0;
      поки п < макс_розмір {
        змінна цифра_а: п32 = 0;
        змінна цифра_б: п32 = 0;

        якщо п < розмір_а {
          цифра_а = а.цифри[п];
        }
        якщо п < розмір_б {
          цифра_б = б.цифри[п];
        }

        вихід.цифри[п] = цифра_а вабо цифра_б;
        п += 1;
      }

      вихід.розмір = макс_розмір;
      нормалізувати_ціле(вихід);
      вернути так;
    }

    змінна один: Ціле;
    якщо не ініціалізувати_ціле_один(виділяч, один::адреса) {
      вернути ні;
    }

    якщо а_відʼємне != б_відʼємне {
      змінна поз: Ціле;
      змінна розмір_поз: ц32;
      змінна нег: Ціле;
      змінна розмір_нег: ц32;

      якщо а_відʼємне {
        поз = б;
        розмір_поз = розмір_б;
        нег = а;
        розмір_нег = розмір_а;
      } інакше {
        поз = а;
        розмір_поз = розмір_а;
        нег = б;
        розмір_нег = розмір_б;
      }

      змінна абсол_нег: Ціле;
      якщо не абсолютне_ціле(виділяч, нег, абсол_нег::адреса) {
        звільнити_ціле(виділяч, один);
        вернути ні;
      }

      змінна нег_мінус_один: Ціле;
      якщо не відняти_цілі(виділяч, абсол_нег, один, нег_мінус_один::адреса) {
        звільнити_ціле(виділяч, один);
        звільнити_ціле(виділяч, абсол_нег);
        вернути ні;
      }
      звільнити_ціле(виділяч, абсол_нег);

      змінна розмір_нег_м1: ц32;
      якщо нег_мінус_один.розмір < 0 {
        розмір_нег_м1 = -нег_мінус_один.розмір;
      } інакше {
        розмір_нег_м1 = нег_мінус_один.розмір;
      }

      змінна макс_розмір: ц32;
      якщо розмір_поз > розмір_нег_м1 {
        макс_розмір = розмір_поз;
      } інакше {
        макс_розмір = розмір_нег_м1;
      }

      змінна вабо_результат: Ціле;
      якщо не ініціалізувати_ціле(виділяч, макс_розмір, вабо_результат::адреса) {
        звільнити_ціле(виділяч, один);
        звільнити_ціле(виділяч, нег_мінус_один);
        вернути ні;
      }

      змінна п: ц32 = 0;
      поки п < макс_розмір {
        змінна цифра_поз: п32 = 0;
        змінна цифра_нег_м1: п32 = 0;

        якщо п < розмір_поз {
          цифра_поз = поз.цифри[п];
        }
        якщо п < розмір_нег_м1 {
          цифра_нег_м1 = нег_мінус_один.цифри[п];
        }

        вабо_результат.цифри[п] = цифра_поз вабо цифра_нег_м1;
        п += 1;
      }

      вабо_результат.розмір = макс_розмір;
      нормалізувати_ціле(вабо_результат::адреса);

      звільнити_ціле(виділяч, нег_мінус_один);

      змінна вабо_плюс_один: Ціле;
      якщо не додати_цілі(виділяч, вабо_результат, один, вабо_плюс_один::адреса) {
        звільнити_ціле(виділяч, один);
        звільнити_ціле(виділяч, вабо_результат);
        вернути ні;
      }

      звільнити_ціле(виділяч, один);
      звільнити_ціле(виділяч, вабо_результат);

      якщо не негація_цілого(виділяч, вабо_плюс_один, вихід) {
        звільнити_ціле(виділяч, вабо_плюс_один);
        вернути ні;
      }

      звільнити_ціле(виділяч, вабо_плюс_один);

      вернути так;
    }

    змінна абсол_а: Ціле;
    якщо не абсолютне_ціле(виділяч, а, абсол_а::адреса) {
      звільнити_ціле(виділяч, один);
      вернути ні;
    }

    змінна а_мінус_один: Ціле;
    якщо не відняти_цілі(виділяч, абсол_а, один, а_мінус_один::адреса) {
      звільнити_ціле(виділяч, один);
      звільнити_ціле(виділяч, абсол_а);
      вернути ні;
    }
    звільнити_ціле(виділяч, абсол_а);

    змінна абсол_б: Ціле;
    якщо не абсолютне_ціле(виділяч, б, абсол_б::адреса) {
      звільнити_ціле(виділяч, один);
      звільнити_ціле(виділяч, а_мінус_один);
      вернути ні;
    }

    змінна б_мінус_один: Ціле;
    якщо не відняти_цілі(виділяч, абсол_б, один, б_мінус_один::адреса) {
      звільнити_ціле(виділяч, один);
      звільнити_ціле(виділяч, а_мінус_один);
      звільнити_ціле(виділяч, абсол_б);
      вернути ні;
    }
    звільнити_ціле(виділяч, абсол_б);
    звільнити_ціле(виділяч, один);

    змінна розмір_ам1: ц32;
    якщо а_мінус_один.розмір < 0 {
      розмір_ам1 = -а_мінус_один.розмір;
    } інакше {
      розмір_ам1 = а_мінус_один.розмір;
    }

    змінна розмір_бм1: ц32;
    якщо б_мінус_один.розмір < 0 {
      розмір_бм1 = -б_мінус_один.розмір;
    } інакше {
      розмір_бм1 = б_мінус_один.розмір;
    }

    змінна макс_розмір: ц32;
    якщо розмір_ам1 > розмір_бм1 {
      макс_розмір = розмір_ам1;
    } інакше {
      макс_розмір = розмір_бм1;
    }

    якщо не ініціалізувати_ціле(виділяч, макс_розмір, вихід) {
      звільнити_ціле(виділяч, а_мінус_один);
      звільнити_ціле(виділяч, б_мінус_один);
      вернути ні;
    }

    змінна п: ц32 = 0;
    поки п < макс_розмір {
      змінна цифра_а: п32 = 0;
      змінна цифра_б: п32 = 0;

      якщо п < розмір_ам1 {
        цифра_а = а_мінус_один.цифри[п];
      }
      якщо п < розмір_бм1 {
        цифра_б = б_мінус_один.цифри[п];
      }

      вихід.цифри[п] = цифра_а вабо цифра_б;
      п += 1;
    }

    вихід.розмір = макс_розмір;
    нормалізувати_ціле(вихід);

    звільнити_ціле(виділяч, а_мінус_один);
    звільнити_ціле(виділяч, б_мінус_один);

    вернути так;
  }
}

// Дробове
простір ДЧ {
  дія ініціалізувати_дробове(
    виділяч: адреса<Виділяч>,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо не ініціалізувати_ціле_нуль(виділяч, вихід.мантиса::адреса) {
      вернути ні;
    }

    вихід.експонента = 0;

    вернути так;
  }

  дія нормалізувати_дробове(виділяч: адреса<Виділяч>, значення: адреса<Дробове>) -> логічне;

  місцева дія ініціалізувати_дробове_з_д64(
    виділяч: адреса<Виділяч>,
    значення: д64,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо значення == 0.0 {
      вернути ініціалізувати_дробове_нуль(виділяч, вихід);
    }

    змінна відʼємне = значення < 0.0;
    змінна абсол_значення = значення;
    якщо відʼємне {
      абсол_значення = д64(0.0) - значення;
    }

    змінна експ: ц32 = 0;

    поки абсол_значення >= 10.0 {
      абсол_значення = абсол_значення / 10.0;
      експ += 1;
    }

    змінна пу = абсол_значення < 1.0 і абсол_значення > 0.0;
    поки пу {
      абсол_значення = абсол_значення * 10.0;
      експ -= 1;
      пу = абсол_значення < 1.0 і абсол_значення > 0.0;
    }

    змінна точність: ц32 = 15;
    змінна мантиса_ц: ц64 = 0;
    змінна десяткові: ц32 = 0;

    змінна п: ц32 = 0;
    пу = п < точність і абсол_значення > 0.0;
    поки пу {
      змінна цифра = ц64(абсол_значення);
      мантиса_ц = мантиса_ц * 10 + цифра;
      абсол_значення = (абсол_значення - д64(цифра)) * 10.0;
      десяткові += 1;
      п += 1;
      пу = п < точність і абсол_значення > 0.0;
    }

    якщо не ініціалізувати_ціле_з_ц64(виділяч, мантиса_ц, вихід.мантиса::адреса) {
      вернути ні;
    }

    якщо відʼємне {
      змінити_знак_цілого(вихід.мантиса::адреса);
    }

    вихід.експонента = експ - десяткові + 1;

    якщо не нормалізувати_дробове(виділяч, вихід) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    вернути так;
  }

  місцева дія ініціалізувати_дробове_з_ц64(
    виділяч: адреса<Виділяч>,
    значення: ц64,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо не ініціалізувати_ціле_з_ц64(виділяч, значення, вихід.мантиса::адреса) {
      вернути ні;
    }
    вихід.експонента = 0;
    вернути так;
  }

  місцева дія ініціалізувати_дробове_з_кд(
    виділяч: адреса<Виділяч>,
    значення: кд,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо значення.розмір == 0 {
      вернути ініціалізувати_дробове_нуль(виділяч, вихід);
    }

    змінна п: природне = 0;

    змінна відʼємне = ні;
    якщо значення.дані[п] == 99 {
      відʼємне = так;
      п += 1;
    } інакше якщо значення.дані[п] == 96 {
      п += 1;
    }

    змінна мантиса_дані = виділити_памʼять<п8>(виділяч, значення.розмір + 1);
    якщо мантиса_дані == пусто {
      вернути ні;
    }

    змінна мантиса_поз: природне = 0;
    змінна десяткові_місця: ц32 = 0;
    змінна бачили_крапку = ні;
    змінна в_експоненті = ні;
    змінна знак_експоненти: ц32 = 1;
    змінна явна_експонента: ц32 = 0;

  початок:
    поки п < значення.розмір {
      змінна символ = значення.дані[п];

      якщо символ == 117 {
        бачили_крапку = так;
      } інакше якщо символ == 47 або символ == 15 {
        в_експоненті = так;
        п += 1;
        якщо п < значення.розмір {
          якщо значення.дані[п] == 99 {
            знак_експоненти = ц32(0) - 1;
            п += 1;
          } інакше якщо значення.дані[п] == 96 {
            п += 1;
          }
        }
        стрибнути початок;
      } інакше якщо в_експоненті і символ >= 0 і символ <= 9 {
        явна_експонента = явна_експонента * 10 + ц32(символ);
      } інакше якщо символ >= 0 і символ <= 9 {
        мантиса_дані[мантиса_поз] = символ;
        мантиса_поз += 1;
        якщо бачили_крапку {
          десяткові_місця += 1;
        }
      }
      п += 1;
    }

    змінна мантиса_початок: природне = 0;
    змінна х = мантиса_початок < мантиса_поз і мантиса_дані[мантиса_початок] == 0 і (мантиса_початок + 1) < мантиса_поз;
    поки х {
      мантиса_початок += 1;
      х = мантиса_початок < мантиса_поз і мантиса_дані[мантиса_початок] == 0 і (мантиса_початок + 1) < мантиса_поз;
    }

    змінна мантиса_кд: кд;
    мантиса_кд.дані = мантиса_дані[мантиса_початок]::адреса як памʼять<п8>;
    мантиса_кд.розмір = мантиса_поз - мантиса_початок;

    якщо не ініціалізувати_ціле_з_кд(виділяч, мантиса_кд, вихід.мантиса::адреса) {
      звільнити_памʼять(виділяч, мантиса_дані);
      вернути ні;
    }

    якщо відʼємне і не перевірити_чи_ціле_нуль(вихід.мантиса) {
      змінити_знак_цілого(вихід.мантиса::адреса);
    }

    вихід.експонента = (ц32(0) - десяткові_місця) + (знак_експоненти * явна_експонента);

    звільнити_памʼять(виділяч, мантиса_дані);

    якщо не нормалізувати_дробове(виділяч, вихід) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    вернути так;
  }

  місцева дія ініціалізувати_дробове_нуль(
    виділяч: адреса<Виділяч>,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо не ініціалізувати_ціле_нуль(виділяч, вихід.мантиса::адреса) {
      вернути ні;
    }

    вихід.експонента = 0;

    вернути так;
  }

  місцева дія ініціалізувати_дробове_один(
    виділяч: адреса<Виділяч>,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо не ініціалізувати_ціле_з_ц64(виділяч, 1, вихід.мантиса::адреса) {
      вернути ні;
    }

    вихід.експонента = 0;

    вернути так;
  }

  місцева дія звільнити_дробове(
    виділяч: адреса<Виділяч>,
    значення: Дробове
  ) {
    звільнити_ціле(виділяч, значення.мантиса);
  }

  місцева дія копіювати_дробове(
    виділяч: адреса<Виділяч>,
    джерело: Дробове,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо не копіювати_ціле(виділяч, джерело.мантиса, вихід.мантиса::адреса) {
      вернути ні;
    }

    вихід.експонента = джерело.експонента;

    вернути так;
  }

  дія нормалізувати_дробове(
    виділяч: адреса<Виділяч>,
    значення: адреса<Дробове>
  ) -> логічне {
    якщо перевірити_чи_ціле_нуль(значення.мантиса) {
      значення.експонента = 0;
      вернути так;
    }

    змінна десять: Ціле;
    якщо не ініціалізувати_ціле_з_ц64(виділяч, 10, десять::адреса) {
      вернути ні;
    }

    змінна нуль: Ціле;
    якщо не ініціалізувати_ціле_нуль(виділяч, нуль::адреса) {
      звільнити_ціле(виділяч, десять);
      вернути ні;
    }

    поки не перевірити_чи_ціле_нуль(значення.мантиса) {
      змінна залишок: Ціле;
      якщо не залишок_ділення_цілих(виділяч, значення.мантиса, десять, залишок::адреса) {
        звільнити_ціле(виділяч, десять);
        звільнити_ціле(виділяч, нуль);
        вернути ні;
      }

      якщо порівняти_цілі(залишок, нуль) != 0 {
        звільнити_ціле(виділяч, залишок);
        стрибнути далі;
      }

      звільнити_ціле(виділяч, залишок);

      змінна нова_мантиса: Ціле;
      якщо не поділити_цілі(виділяч, значення.мантиса, десять, нова_мантиса::адреса) {
        звільнити_ціле(виділяч, десять);
        звільнити_ціле(виділяч, нуль);
        вернути ні;
      }

      звільнити_ціле(виділяч, значення.мантиса);
      значення.мантиса = нова_мантиса;
      значення.експонента += 1;
    }

  далі:
    звільнити_ціле(виділяч, десять);
    звільнити_ціле(виділяч, нуль);

    вернути так;
  }

  дія порахувати_десяткові_цифри(
    виділяч: адреса<Виділяч>,
    значення: Ціле,
    вихід: адреса<ц32>
  ) -> логічне {
    якщо перевірити_чи_ціле_нуль(значення) {
      вихід::вміст = 1;
      вернути так;
    }

    змінна абсол_розмір: ц32;
    якщо значення.розмір < 0 {
      абсол_розмір = -значення.розмір;
    } інакше {
      абсол_розмір = значення.розмір;
    }

    змінна верх: п32 = значення.цифри[абсол_розмір - 1];
    змінна верх_біти: ц32 = 0;
    поки верх > 0 {
      верх_біти += 1;
      верх = верх >> 1;
    }

    змінна всього_бітів: ц64 = ц64((абсол_розмір - 1) * ЗСУВ_ЦІЛОГО) + ц64(верх_біти);

    змінна прибл_цифри: ц32 = ц32((всього_бітів * 30103) / 100000) + 1;

    змінна десять: Ціле;
    якщо не ініціалізувати_ціле_з_ц64(виділяч, 10, десять::адреса) {
      вернути ні;
    }

    змінна степінь: Ціле;
    якщо не ініціалізувати_ціле_з_ц64(виділяч, 1, степінь::адреса) {
      звільнити_ціле(виділяч, десять);
      вернути ні;
    }

    змінна п: ц32 = 1;
    поки п < прибл_цифри {
      змінна новий_степінь: Ціле;
      якщо не помножити_цілі(виділяч, степінь, десять, новий_степінь::адреса) {
        звільнити_ціле(виділяч, степінь);
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }
      звільнити_ціле(виділяч, степінь);
      степінь = новий_степінь;
      п += 1;
    }

    змінна абсол_значення: Ціле;
    якщо не абсолютне_ціле(виділяч, значення, абсол_значення::адреса) {
      звільнити_ціле(виділяч, степінь);
      звільнити_ціле(виділяч, десять);
      вернути ні;
    }

    змінна порівняння = порівняти_цілі(абсол_значення, степінь);

    звільнити_ціле(виділяч, абсол_значення);
    звільнити_ціле(виділяч, степінь);
    звільнити_ціле(виділяч, десять);

    якщо порівняння < 0 {
      вихід::вміст = прибл_цифри - 1;
    } інакше {
      вихід::вміст = прибл_цифри;
    }

    вернути так;
  }

  дія округлити_до_точності(
    виділяч: адреса<Виділяч>,
    значення: адреса<Дробове>,
    точність: ц32
  ) -> логічне {
    якщо перевірити_чи_ціле_нуль(значення.мантиса) {
      вернути так;
    }

    змінна цифри: ц32;
    якщо не порахувати_десяткові_цифри(виділяч, значення.мантиса, цифри::адреса) {
      вернути ні;
    }

    якщо цифри <= точність {
      вернути так;
    }

    змінна до_видалення: ц32 = цифри - точність;

    змінна дільник: Ціле;
    якщо не ініціалізувати_ціле_з_ц64(виділяч, 1, дільник::адреса) {
      вернути ні;
    }

    змінна десять: Ціле;
    якщо не ініціалізувати_ціле_з_ц64(виділяч, 10, десять::адреса) {
      звільнити_ціле(виділяч, дільник);
      вернути ні;
    }

    змінна п: ц32 = 0;
    поки п < до_видалення {
      змінна новий_діл: Ціле;
      якщо не помножити_цілі(виділяч, дільник, десять, новий_діл::адреса) {
        звільнити_ціле(виділяч, дільник);
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }
      звільнити_ціле(виділяч, дільник);
      дільник = новий_діл;
      п += 1;
    }

    змінна два: Ціле;
    якщо не ініціалізувати_ціле_з_ц64(виділяч, 2, два::адреса) {
      звільнити_ціле(виділяч, дільник);
      звільнити_ціле(виділяч, десять);
      вернути ні;
    }

    змінна половина_діл: Ціле;
    якщо не поділити_цілі(виділяч, дільник, два, половина_діл::адреса) {
      звільнити_ціле(виділяч, дільник);
      звільнити_ціле(виділяч, десять);
      звільнити_ціле(виділяч, два);
      вернути ні;
    }
    звільнити_ціле(виділяч, два);

    змінна абсол_мантиса: Ціле;
    якщо не абсолютне_ціле(виділяч, значення.мантиса, абсол_мантиса::адреса) {
      звільнити_ціле(виділяч, дільник);
      звільнити_ціле(виділяч, десять);
      звільнити_ціле(виділяч, половина_діл);
      вернути ні;
    }

    змінна залишок: Ціле;
    якщо не залишок_ділення_цілих(виділяч, абсол_мантиса, дільник, залишок::адреса) {
      звільнити_ціле(виділяч, дільник);
      звільнити_ціле(виділяч, десять);
      звільнити_ціле(виділяч, половина_діл);
      звільнити_ціле(виділяч, абсол_мантиса);
      вернути ні;
    }
    звільнити_ціле(виділяч, абсол_мантиса);

    змінна нова_мантиса: Ціле;
    якщо не поділити_цілі(виділяч, значення.мантиса, дільник, нова_мантиса::адреса) {
      звільнити_ціле(виділяч, дільник);
      звільнити_ціле(виділяч, десять);
      звільнити_ціле(виділяч, половина_діл);
      звільнити_ціле(виділяч, залишок);
      вернути ні;
    }

    якщо порівняти_цілі(залишок, половина_діл) >= 0 {
      змінна один: Ціле;
      якщо не ініціалізувати_ціле_з_ц64(виділяч, 1, один::адреса) {
        звільнити_ціле(виділяч, дільник);
        звільнити_ціле(виділяч, десять);
        звільнити_ціле(виділяч, половина_діл);
        звільнити_ціле(виділяч, залишок);
        звільнити_ціле(виділяч, нова_мантиса);
        вернути ні;
      }

      якщо перевірити_чи_ціле_відʼємне(значення.мантиса) {
        змінна темп: Ціле;
        якщо не відняти_цілі(виділяч, нова_мантиса, один, темп::адреса) {
          звільнити_ціле(виділяч, дільник);
          звільнити_ціле(виділяч, десять);
          звільнити_ціле(виділяч, половина_діл);
          звільнити_ціле(виділяч, залишок);
          звільнити_ціле(виділяч, нова_мантиса);
          звільнити_ціле(виділяч, один);
          вернути ні;
        }
        звільнити_ціле(виділяч, нова_мантиса);
        нова_мантиса = темп;
      } інакше {
        змінна темп: Ціле;
        якщо не додати_цілі(виділяч, нова_мантиса, один, темп::адреса) {
          звільнити_ціле(виділяч, дільник);
          звільнити_ціле(виділяч, десять);
          звільнити_ціле(виділяч, половина_діл);
          звільнити_ціле(виділяч, залишок);
          звільнити_ціле(виділяч, нова_мантиса);
          звільнити_ціле(виділяч, один);
          вернути ні;
        }
        звільнити_ціле(виділяч, нова_мантиса);
        нова_мантиса = темп;
      }
      звільнити_ціле(виділяч, один);
    }

    звільнити_ціле(виділяч, значення.мантиса);
    значення.мантиса = нова_мантиса;
    значення.експонента += до_видалення;

    звільнити_ціле(виділяч, дільник);
    звільнити_ціле(виділяч, десять);
    звільнити_ціле(виділяч, половина_діл);
    звільнити_ціле(виділяч, залишок);

    вернути так;
  }

  місцева дія перетворити_дробове_в_д64(
    виділяч: адреса<Виділяч>,
    значення: Дробове,
    вихід: адреса<д64>
  ) -> логічне {
    якщо перевірити_чи_ціле_нуль(значення.мантиса) {
      вихід::вміст = 0.0;
      вернути так;
    }

    змінна відʼємне = перевірити_чи_ціле_відʼємне(значення.мантиса);

    змінна мантиса_кд: кд;
    якщо не перетворити_ціле_в_кд(виділяч, значення.мантиса, мантиса_кд::адреса) {
      вернути ні;
    }

    змінна результат: д64 = 0.0;
    змінна початок: природне = 0;
    якщо відʼємне {
      початок = 1;
    }

    змінна п: природне = початок;
    поки п < мантиса_кд.розмір {
      результат = результат * 10.0 + д64(мантиса_кд.дані[п]);
      п += 1;
    }

    звільнити_памʼять(виділяч, мантиса_кд.дані);

    змінна експ = значення.експонента;
    поки експ > 0 {
      результат = результат * 10.0;
      експ -= 1;
    }
    поки експ < 0 {
      результат = результат / 10.0;
      експ += 1;
    }

    якщо відʼємне {
      результат = д64(0.0) - результат;
    }

    вихід::вміст = результат;
    вернути так;
  }

  місцева дія перетворити_дробове_в_кд(
    виділяч: адреса<Виділяч>,
    значення: Дробове,
    вихід: адреса<кд>
  ) -> логічне {
    якщо перевірити_чи_ціле_нуль(значення.мантиса) {
      змінна дані_кд = виділити_памʼять<п8>(виділяч, 1);
      якщо дані_кд == пусто {
        вихід::вміст = кд { 0, пусто };
        вернути ні;
      }
      дані_кд[0] = 0;
      вихід::вміст = кд { 1, дані_кд };
      вернути так;
    }

    змінна мантиса_кд: кд;
    якщо не перетворити_ціле_в_кд(виділяч, значення.мантиса, мантиса_кд::адреса) {
      вихід::вміст = кд { 0, пусто };
      вернути ні;
    }

    змінна відʼємне = перевірити_чи_ціле_відʼємне(значення.мантиса);
    змінна цифри_початок: природне = 0;
    якщо відʼємне {
      цифри_початок = 1;
    }
    змінна цифри_довжина = мантиса_кд.розмір - цифри_початок;

    змінна результат_розмір: природне = мантиса_кд.розмір + 32;
    якщо значення.експонента < 0 {
      результат_розмір += природне(-значення.експонента);
    }

    змінна результат = виділити_памʼять<п8>(виділяч, результат_розмір);
    якщо результат == пусто {
      звільнити_памʼять(виділяч, мантиса_кд.дані);
      вихід::вміст = кд { 0, пусто };
      вернути ні;
    }

    змінна поз: природне = 0;
    якщо відʼємне {
      результат[поз] = 99;
      поз += 1;
    }

    змінна десяткова_позиція = ц32(цифри_довжина) + значення.експонента;

    якщо значення.експонента >= 0 {
      змінна п: природне = 0;
      поки п < цифри_довжина {
        результат[поз] = мантиса_кд.дані[цифри_початок + п];
        поз += 1;
        п += 1;
      }
      змінна к: ц32 = 0;
      поки к < значення.експонента {
        результат[поз] = 0;
        поз += 1;
        к += 1;
      }
      результат[поз] = 117;
      поз += 1;
      результат[поз] = 0;
      поз += 1;
    } інакше якщо десяткова_позиція <= 0 {
      результат[поз] = 0;
      поз += 1;
      результат[поз] = 117;
      поз += 1;
      змінна к: ц32 = 0;
      поки к < (-десяткова_позиція) {
        результат[поз] = 0;
        поз += 1;
        к += 1;
      }
      змінна п: природне = 0;
      поки п < цифри_довжина {
        результат[поз] = мантиса_кд.дані[цифри_початок + п];
        поз += 1;
        п += 1;
      }
    } інакше {
      змінна п: природне = 0;
      поки п < цифри_довжина {
        якщо п == природне(десяткова_позиція) {
          результат[поз] = 117;
          поз += 1;
        }
        результат[поз] = мантиса_кд.дані[цифри_початок + п];
        поз += 1;
        п += 1;
      }
    }

    звільнити_памʼять(виділяч, мантиса_кд.дані);

    вихід::вміст = кд { поз, результат };
    вернути так;
  }

  місцева дія перевірити_чи_дробове_нуль(
    значення: Дробове
  ) -> логічне {
    вернути перевірити_чи_ціле_нуль(значення.мантиса);
  }

  місцева дія перевірити_чи_дробове_відʼємне(
    значення: Дробове
  ) -> логічне {
    вернути перевірити_чи_ціле_відʼємне(значення.мантиса);
  }

  місцева дія порівняти_дробові(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    б: Дробове
  ) -> ц8 {
    змінна а_нуль = перевірити_чи_дробове_нуль(а);
    змінна б_нуль = перевірити_чи_дробове_нуль(б);

    якщо а_нуль і б_нуль {
      вернути 0;
    }
    якщо а_нуль {
      якщо перевірити_чи_дробове_відʼємне(б) {
        вернути 1;
      } інакше {
        вернути ц8(0)-1;
      }
    }
    якщо б_нуль {
      якщо перевірити_чи_дробове_відʼємне(а) {
        вернути ц8(0)-1;
      } інакше {
        вернути 1;
      }
    }

    змінна відʼємне_а = перевірити_чи_дробове_відʼємне(а);
    змінна відʼємне_б = перевірити_чи_дробове_відʼємне(б);
    якщо відʼємне_а і не відʼємне_б {
      вернути ц8(0)-1;
    }
    якщо не відʼємне_а і відʼємне_б {
      вернути 1;
    }

    змінна різниця_експонентів = а.експонента - б.експонента;

    змінна масштабоване_а: Ціле;
    змінна масштабоване_б: Ціле;
    змінна десять: Ціле;

    якщо не ініціалізувати_ціле_з_п64(виділяч, 10, десять::адреса) {
      вернути 0;
    }

    якщо різниця_експонентів > 0 {
      змінна масштаб: Ціле;
      якщо не ініціалізувати_ціле_один(виділяч, масштаб::адреса) {
        звільнити_ціле(виділяч, десять);
        вернути 0;
      }

      змінна п: ц32 = 0;
      поки п < різниця_експонентів {
        змінна новий_масштаб: Ціле;
        якщо не помножити_цілі(виділяч, масштаб, десять, новий_масштаб::адреса) {
          звільнити_ціле(виділяч, масштаб);
          звільнити_ціле(виділяч, десять);
          вернути 0;
        }
        звільнити_ціле(виділяч, масштаб);
        масштаб = новий_масштаб;

        п += 1;
      }

      якщо не помножити_цілі(виділяч, а.мантиса, масштаб, масштабоване_а::адреса) {
        звільнити_ціле(виділяч, масштаб);
        звільнити_ціле(виділяч, десять);
        вернути 0;
      }
      якщо не копіювати_ціле(виділяч, б.мантиса, масштабоване_б::адреса) {
        звільнити_ціле(виділяч, масштабоване_а);
        звільнити_ціле(виділяч, масштаб);
        звільнити_ціле(виділяч, десять);
        вернути 0;
      }
      звільнити_ціле(виділяч, масштаб);
    } інакше якщо різниця_експонентів < 0 {
      змінна масштаб: Ціле;
      якщо не ініціалізувати_ціле_один(виділяч, масштаб::адреса) {
        звільнити_ціле(виділяч, десять);
        вернути 0;
      }

      змінна п: ц32 = 0;
      поки п < (-різниця_експонентів) {
        змінна новий_масштаб: Ціле;
        якщо не помножити_цілі(виділяч, масштаб, десять, новий_масштаб::адреса) {
          звільнити_ціле(виділяч, масштаб);
          звільнити_ціле(виділяч, десять);
          вернути 0;
        }
        звільнити_ціле(виділяч, масштаб);
        масштаб = новий_масштаб;

        п += 1;
      }

      якщо не копіювати_ціле(виділяч, а.мантиса, масштабоване_а::адреса) {
        звільнити_ціле(виділяч, масштаб);
        звільнити_ціле(виділяч, десять);
        вернути 0;
      }
      якщо не помножити_цілі(виділяч, б.мантиса, масштаб, масштабоване_б::адреса) {
        звільнити_ціле(виділяч, масштабоване_а);
        звільнити_ціле(виділяч, масштаб);
        звільнити_ціле(виділяч, десять);
        вернути 0;
      }
      звільнити_ціле(виділяч, масштаб);
    } інакше {
      якщо не копіювати_ціле(виділяч, а.мантиса, масштабоване_а::адреса) {
        звільнити_ціле(виділяч, десять);
        вернути 0;
      }
      якщо не копіювати_ціле(виділяч, б.мантиса, масштабоване_б::адреса) {
        звільнити_ціле(виділяч, масштабоване_а);
        звільнити_ціле(виділяч, десять);
        вернути 0;
      }
    }

    змінна результат = порівняти_цілі(масштабоване_а, масштабоване_б);

    звільнити_ціле(виділяч, десять);
    звільнити_ціле(виділяч, масштабоване_а);
    звільнити_ціле(виділяч, масштабоване_б);

    вернути результат;
  }

  місцева дія вирівняти_дробові(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    б: Дробове,
    вирівняне_а: адреса<Ціле>,
    вирівняне_б: адреса<Ціле>,
    спільна_експонента: адреса<ц32>
  ) -> логічне {
    змінна мін_експонента: ц32;
    якщо а.експонента < б.експонента {
      мін_експонента = а.експонента;
    } інакше {
      мін_експонента = б.експонента;
    }
    спільна_експонента::вміст = мін_експонента;

    змінна десять: Ціле;
    якщо не ініціалізувати_ціле_з_п64(виділяч, 10, десять::адреса) {
      вернути ні;
    }

    змінна масштаб_а = а.експонента - мін_експонента;
    якщо масштаб_а > 0 {
      змінна масштаб: Ціле;
      якщо не ініціалізувати_ціле_один(виділяч, масштаб::адреса) {
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }

      змінна п: ц32 = 0;
      поки п < масштаб_а {
        змінна новий_масштаб: Ціле;
        якщо не помножити_цілі(виділяч, масштаб, десять, новий_масштаб::адреса) {
          звільнити_ціле(виділяч, масштаб);
          звільнити_ціле(виділяч, десять);
          вернути ні;
        }
        звільнити_ціле(виділяч, масштаб);
        масштаб = новий_масштаб;

        п += 1;
      }

      якщо не помножити_цілі(виділяч, а.мантиса, масштаб, вирівняне_а) {
        звільнити_ціле(виділяч, масштаб);
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }
      звільнити_ціле(виділяч, масштаб);
    } інакше {
      якщо не копіювати_ціле(виділяч, а.мантиса, вирівняне_а) {
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }
    }

    змінна масштаб_б = б.експонента - мін_експонента;
    якщо масштаб_б > 0 {
      змінна масштаб: Ціле;
      якщо не ініціалізувати_ціле_один(виділяч, масштаб::адреса) {
        звільнити_ціле(виділяч, вирівняне_а::вміст);
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }

      змінна п: ц32 = 0;
      поки п < масштаб_б {
        змінна новий_масштаб: Ціле;
        якщо не помножити_цілі(виділяч, масштаб, десять, новий_масштаб::адреса) {
          звільнити_ціле(виділяч, масштаб);
          звільнити_ціле(виділяч, вирівняне_а::вміст);
          звільнити_ціле(виділяч, десять);
          вернути ні;
        }
        звільнити_ціле(виділяч, масштаб);
        масштаб = новий_масштаб;

        п += 1;
      }

      якщо не помножити_цілі(виділяч, б.мантиса, масштаб, вирівняне_б) {
        звільнити_ціле(виділяч, масштаб);
        звільнити_ціле(виділяч, вирівняне_а::вміст);
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }
      звільнити_ціле(виділяч, масштаб);
    } інакше {
      якщо не копіювати_ціле(виділяч, б.мантиса, вирівняне_б) {
        звільнити_ціле(виділяч, вирівняне_а::вміст);
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }
    }

    звільнити_ціле(виділяч, десять);
    вернути так;
  }

  місцева дія додати_дробові(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    б: Дробове,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо перевірити_чи_дробове_нуль(а) {
      вернути копіювати_дробове(виділяч, б, вихід);
    }
    якщо перевірити_чи_дробове_нуль(б) {
      вернути копіювати_дробове(виділяч, а, вихід);
    }

    змінна вирівняне_а: Ціле;
    змінна вирівняне_б: Ціле;
    змінна спільна_експонента: ц32;
    якщо не вирівняти_дробові(виділяч, а, б, вирівняне_а::адреса, вирівняне_б::адреса, спільна_експонента::адреса) {
      вернути ні;
    }

    змінна нова_мантиса: Ціле;
    якщо не додати_цілі(виділяч, вирівняне_а, вирівняне_б, нова_мантиса::адреса) {
      звільнити_ціле(виділяч, вирівняне_а);
      звільнити_ціле(виділяч, вирівняне_б);
      вернути ні;
    }

    звільнити_ціле(виділяч, вирівняне_а);
    звільнити_ціле(виділяч, вирівняне_б);

    вихід.мантиса = нова_мантиса;
    вихід.експонента = спільна_експонента;

    якщо не нормалізувати_дробове(виділяч, вихід) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    вернути так;
  }

  місцева дія відняти_дробові(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    б: Дробове,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо перевірити_чи_дробове_нуль(б) {
      вернути копіювати_дробове(виділяч, а, вихід);
    }
    якщо перевірити_чи_дробове_нуль(а) {
      якщо не копіювати_дробове(виділяч, б, вихід) {
        вернути ні;
      }
      змінити_знак_цілого(вихід.мантиса::адреса);
      вернути так;
    }

    змінна вирівняне_а: Ціле;
    змінна вирівняне_б: Ціле;
    змінна спільна_експонента: ц32;
    якщо не вирівняти_дробові(виділяч, а, б, вирівняне_а::адреса, вирівняне_б::адреса, спільна_експонента::адреса) {
      вернути ні;
    }

    змінна нова_мантиса: Ціле;
    якщо не відняти_цілі(виділяч, вирівняне_а, вирівняне_б, нова_мантиса::адреса) {
      звільнити_ціле(виділяч, вирівняне_а);
      звільнити_ціле(виділяч, вирівняне_б);
      вернути ні;
    }

    звільнити_ціле(виділяч, вирівняне_а);
    звільнити_ціле(виділяч, вирівняне_б);

    вихід.мантиса = нова_мантиса;
    вихід.експонента = спільна_експонента;

    якщо не нормалізувати_дробове(виділяч, вихід) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    вернути так;
  }

  місцева дія негація_дробового(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо не копіювати_дробове(виділяч, а, вихід) {
      вернути ні;
    }
    змінити_знак_цілого(вихід.мантиса::адреса);
    вернути так;
  }

  місцева дія абсолютне_значення_дробового(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо не копіювати_дробове(виділяч, а, вихід) {
      вернути ні;
    }
    якщо перевірити_чи_ціле_відʼємне(вихід.мантиса) {
      змінити_знак_цілого(вихід.мантиса::адреса);
    }
    вернути так;
  }

  місцева дія помножити_дробові(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    б: Дробове,
    точність: ц32,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо перевірити_чи_дробове_нуль(а) або перевірити_чи_дробове_нуль(б) {
      вернути ініціалізувати_дробове_нуль(виділяч, вихід);
    }

    змінна нова_мантиса: Ціле;
    якщо не помножити_цілі(виділяч, а.мантиса, б.мантиса, нова_мантиса::адреса) {
      вернути ні;
    }

    вихід.мантиса = нова_мантиса;
    вихід.експонента = а.експонента + б.експонента;

    якщо не нормалізувати_дробове(виділяч, вихід) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    якщо не округлити_до_точності(виділяч, вихід, точність) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    вернути так;
  }

  місцева дія поділити_дробові(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    б: Дробове,
    точність: ц32,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо перевірити_чи_дробове_нуль(б) {
      вернути ні;
    }

    якщо перевірити_чи_дробове_нуль(а) {
      вернути ініціалізувати_дробове_нуль(виділяч, вихід);
    }

    змінна додаткові_цифри = точність + 10;
    змінна масштаб: Ціле;
    якщо не ініціалізувати_ціле_один(виділяч, масштаб::адреса) {
      вернути ні;
    }

    змінна десять: Ціле;
    якщо не ініціалізувати_ціле_з_п64(виділяч, 10, десять::адреса) {
      звільнити_ціле(виділяч, масштаб);
      вернути ні;
    }

    змінна п: ц32 = 0;
    поки п < додаткові_цифри {
      змінна новий_масштаб: Ціле;
      якщо не помножити_цілі(виділяч, масштаб, десять, новий_масштаб::адреса) {
        звільнити_ціле(виділяч, масштаб);
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }
      звільнити_ціле(виділяч, масштаб);
      масштаб = новий_масштаб;
      п += 1;
    }

    змінна масштабоване_а: Ціле;
    якщо не помножити_цілі(виділяч, а.мантиса, масштаб, масштабоване_а::адреса) {
      звільнити_ціле(виділяч, масштаб);
      звільнити_ціле(виділяч, десять);
      вернути ні;
    }

    змінна нова_мантиса: Ціле;
    якщо не поділити_цілі(виділяч, масштабоване_а, б.мантиса, нова_мантиса::адреса) {
      звільнити_ціле(виділяч, масштаб);
      звільнити_ціле(виділяч, десять);
      звільнити_ціле(виділяч, масштабоване_а);
      вернути ні;
    }

    вихід.мантиса = нова_мантиса;
    вихід.експонента = а.експонента - б.експонента - додаткові_цифри;

    звільнити_ціле(виділяч, масштаб);
    звільнити_ціле(виділяч, десять);
    звільнити_ціле(виділяч, масштабоване_а);

    якщо не нормалізувати_дробове(виділяч, вихід) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    якщо не округлити_до_точності(виділяч, вихід, точність) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    вернути так;
  }

  місцева дія обрізати_дробове(виділяч: адреса<Виділяч>, а: Дробове, вихід: адреса<Дробове>) -> логічне;

  місцева дія залишок_ділення_дробових(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    б: Дробове,
    точність: ц32,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо перевірити_чи_дробове_нуль(б) {
      вернути ні;
    }

    якщо перевірити_чи_дробове_нуль(а) {
      вернути ініціалізувати_дробове_нуль(виділяч, вихід);
    }

    змінна частка: Дробове;
    якщо не поділити_дробові(виділяч, а, б, точність, частка::адреса) {
      вернути ні;
    }

    змінна обрізана_частка: Дробове;
    якщо не обрізати_дробове(виділяч, частка, обрізана_частка::адреса) {
      звільнити_дробове(виділяч, частка);
      вернути ні;
    }
    звільнити_дробове(виділяч, частка);

    змінна добуток: Дробове;
    якщо не помножити_дробові(виділяч, обрізана_частка, б, точність, добуток::адреса) {
      звільнити_дробове(виділяч, обрізана_частка);
      вернути ні;
    }
    звільнити_дробове(виділяч, обрізана_частка);

    якщо не відняти_дробові(виділяч, а, добуток, вихід) {
      звільнити_дробове(виділяч, добуток);
      вернути ні;
    }
    звільнити_дробове(виділяч, добуток);

    вернути так;
  }

  місцева дія абсолютне_дробове(
    виділяч: адреса<Виділяч>,
    значення: Дробове,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо не копіювати_дробове(виділяч, значення, вихід) {
      вернути ні;
    }
    якщо перевірити_чи_ціле_відʼємне(вихід.мантиса) {
      змінити_знак_цілого(вихід.мантиса::адреса);
    }
    вернути так;
  }

  дія корінь_квадратний_д64(
    значення: д64
  ) -> д64 {
  }

  дія перетворити_дробове_в_ц64(
    виділяч: адреса<Виділяч>,
    значення: Дробове,
    вихід: адреса<ц64>
  ) -> логічне {
    якщо перевірити_чи_ціле_нуль(значення.мантиса) {
      вихід::вміст = 0;
      вернути так;
    }

    змінна обрізане: Дробове;
    якщо не обрізати_дробове(виділяч, значення, обрізане::адреса) {
      вернути ні;
    }

    змінна відʼємне = перевірити_чи_ціле_відʼємне(обрізане.мантиса);

    змінна мантиса_кд: кд;
    якщо не перетворити_ціле_в_кд(виділяч, обрізане.мантиса, мантиса_кд::адреса) {
      звільнити_дробове(виділяч, обрізане);
      вернути ні;
    }

    змінна результат: ц64 = 0;
    змінна початок: природне = 0;
    якщо відʼємне {
      початок = 1;
    }

    змінна п: природне = початок;
    поки п < мантиса_кд.розмір {
      результат = результат * 10 + ц64(мантиса_кд.дані[п]);
      п += 1;
    }

    звільнити_памʼять(виділяч, мантиса_кд.дані);

    змінна експ = обрізане.експонента;
    звільнити_дробове(виділяч, обрізане);

    поки експ > 0 {
      результат = результат * 10;
      експ -= 1;
    }

    якщо відʼємне {
      результат = ц64(0) - результат;
    }

    вихід::вміст = результат;
    вернути так;
  }

  місцева дія степінь_дробового(
    виділяч: адреса<Виділяч>,
    основа: Дробове,
    показник: Дробове,
    точність: ц32,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо перевірити_чи_дробове_нуль(показник) {
      вернути ініціалізувати_дробове_один(виділяч, вихід);
    }

    якщо перевірити_чи_дробове_нуль(основа) {
      якщо перевірити_чи_дробове_відʼємне(показник) {
        вернути ні;
      }
      вернути ініціалізувати_дробове_нуль(виділяч, вихід);
    }

    змінна обрізаний_показник: Дробове;
    якщо не обрізати_дробове(виділяч, показник, обрізаний_показник::адреса) {
      вернути ні;
    }

    змінна різниця: Дробове;
    якщо не відняти_дробові(виділяч, показник, обрізаний_показник, різниця::адреса) {
      звільнити_дробове(виділяч, обрізаний_показник);
      вернути ні;
    }

    змінна є_ціле = перевірити_чи_дробове_нуль(різниця);
    звільнити_дробове(виділяч, різниця);

    якщо є_ціле {
      змінна показник_ц64: ц64;
      якщо не перетворити_дробове_в_ц64(виділяч, обрізаний_показник, показник_ц64::адреса) {
        звільнити_дробове(виділяч, обрізаний_показник);
        вернути ні;
      }
      звільнити_дробове(виділяч, обрізаний_показник);
      вернути піднести_дробове_до_цілого_степеня(виділяч, основа, показник_ц64, точність, вихід);
    }
    звільнити_дробове(виділяч, обрізаний_показник);

    якщо перевірити_чи_дробове_відʼємне(основа) {
      вернути ні;
    }

    змінна робоча_точність = точність + 20;

    змінна логарифм_основи: Дробове;
    якщо не натуральний_логарифм_дробового(виділяч, основа, робоча_точність, логарифм_основи::адреса) {
      вернути ні;
    }

    змінна добуток: Дробове;
    якщо не помножити_дробові(виділяч, показник, логарифм_основи, робоча_точність, добуток::адреса) {
      звільнити_дробове(виділяч, логарифм_основи);
      вернути ні;
    }
    звільнити_дробове(виділяч, логарифм_основи);

    якщо не експонента_дробового(виділяч, добуток, робоча_точність, вихід) {
      звільнити_дробове(виділяч, добуток);
      вернути ні;
    }
    звільнити_дробове(виділяч, добуток);

    // Округлюємо результат до потрібної точності
    якщо не округлити_до_точності(виділяч, вихід, точність) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    вернути так;
  }

  місцева дія експонента_дробового(
    виділяч: адреса<Виділяч>,
    х: Дробове,
    точність: ц32,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо перевірити_чи_дробове_нуль(х) {
      вернути ініціалізувати_дробове_один(виділяч, вихід);
    }

    змінна один: Дробове;
    якщо не ініціалізувати_дробове_один(виділяч, один::адреса) {
      вернути ні;
    }

    змінна два: Дробове;
    якщо не ініціалізувати_дробове_з_ц64(виділяч, 2, два::адреса) {
      звільнити_дробове(виділяч, один);
      вернути ні;
    }

    змінна редукції: ц64 = 0;
    змінна поточний_х: Дробове;
    якщо не копіювати_дробове(виділяч, х, поточний_х::адреса) {
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, два);
      вернути ні;
    }

    змінна абс_х: Дробове;
    якщо не абсолютне_значення_дробового(виділяч, поточний_х, абс_х::адреса) {
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, два);
      звільнити_дробове(виділяч, поточний_х);
      вернути ні;
    }

    поки порівняти_дробові(виділяч, абс_х, один) > 0 {
      змінна темп: Дробове;
      якщо не поділити_дробові(виділяч, поточний_х, два, точність, темп::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, поточний_х);
        звільнити_дробове(виділяч, абс_х);
        вернути ні;
      }
      звільнити_дробове(виділяч, поточний_х);
      поточний_х = темп;

      звільнити_дробове(виділяч, абс_х);
      якщо не абсолютне_значення_дробового(виділяч, поточний_х, абс_х::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, поточний_х);
        вернути ні;
      }
      редукції += 1;
    }
    звільнити_дробове(виділяч, абс_х);
    звільнити_дробове(виділяч, один);

    змінна сума: Дробове;
    якщо не ініціалізувати_дробове_один(виділяч, сума::адреса) {
      звільнити_дробове(виділяч, два);
      звільнити_дробове(виділяч, поточний_х);
      вернути ні;
    }

    змінна член: Дробове;
    якщо не ініціалізувати_дробове_один(виділяч, член::адреса) {
      звільнити_дробове(виділяч, два);
      звільнити_дробове(виділяч, поточний_х);
      звільнити_дробове(виділяч, сума);
      вернути ні;
    }

    змінна н: ц64 = 1;
    поки н <= ц64(точність) * 3 {
      змінна темп: Дробове;
      якщо не помножити_дробові(виділяч, член, поточний_х, точність, темп::адреса) {
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, поточний_х);
        звільнити_дробове(виділяч, сума);
        звільнити_дробове(виділяч, член);
        вернути ні;
      }
      звільнити_дробове(виділяч, член);

      змінна н_дроб: Дробове;
      якщо не ініціалізувати_дробове_з_ц64(виділяч, н, н_дроб::адреса) {
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, поточний_х);
        звільнити_дробове(виділяч, сума);
        звільнити_дробове(виділяч, темп);
        вернути ні;
      }

      якщо не поділити_дробові(виділяч, темп, н_дроб, точність, член::адреса) {
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, поточний_х);
        звільнити_дробове(виділяч, сума);
        звільнити_дробове(виділяч, темп);
        звільнити_дробове(виділяч, н_дроб);
        вернути ні;
      }
      звільнити_дробове(виділяч, темп);
      звільнити_дробове(виділяч, н_дроб);

      // сума += член
      змінна нова_сума: Дробове;
      якщо не додати_дробові(виділяч, сума, член, нова_сума::адреса) {
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, поточний_х);
        звільнити_дробове(виділяч, сума);
        звільнити_дробове(виділяч, член);
        вернути ні;
      }
      звільнити_дробове(виділяч, сума);
      сума = нова_сума;

      н += 1;
    }

    звільнити_дробове(виділяч, поточний_х);
    звільнити_дробове(виділяч, член);
    звільнити_дробове(виділяч, два);

    // Піднесення до квадрату редукції разів
    змінна й: ц64 = 0;
    поки й < редукції {
      змінна квадрат: Дробове;
      якщо не помножити_дробові(виділяч, сума, сума, точність, квадрат::адреса) {
        звільнити_дробове(виділяч, сума);
        вернути ні;
      }
      звільнити_дробове(виділяч, сума);
      сума = квадрат;
      й += 1;
    }

    вихід.мантиса = сума.мантиса;
    вихід.експонента = сума.експонента;

    якщо не округлити_до_точності(виділяч, вихід, точність) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    вернути так;
  }

  місцева дія натуральний_логарифм_дробового(
    виділяч: адреса<Виділяч>,
    х: Дробове,
    точність: ц32,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо перевірити_чи_дробове_нуль(х) або перевірити_чи_дробове_відʼємне(х) {
      вернути ні;
    }

    змінна один: Дробове;
    якщо не ініціалізувати_дробове_один(виділяч, один::адреса) {
      вернути ні;
    }

    змінна два: Дробове;
    якщо не ініціалізувати_дробове_з_ц64(виділяч, 2, два::адреса) {
      звільнити_дробове(виділяч, один);
      вернути ні;
    }

    змінна половина: Дробове;
    якщо не ініціалізувати_дробове_з_кд(виділяч, "0.5", половина::адреса) {
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, два);
      вернути ні;
    }

    змінна масштаб: ц64 = 0;
    змінна поточний_х: Дробове;
    якщо не копіювати_дробове(виділяч, х, поточний_х::адреса) {
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, два);
      звільнити_дробове(виділяч, половина);
      вернути ні;
    }

    поки порівняти_дробові(виділяч, поточний_х, два) >= 0 {
      змінна темп: Дробове;
      якщо не поділити_дробові(виділяч, поточний_х, два, точність, темп::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, половина);
        звільнити_дробове(виділяч, поточний_х);
        вернути ні;
      }
      звільнити_дробове(виділяч, поточний_х);
      поточний_х = темп;
      масштаб += 1;
    }

    поки порівняти_дробові(виділяч, поточний_х, половина) < 0 {
      змінна темп: Дробове;
      якщо не помножити_дробові(виділяч, поточний_х, два, точність, темп::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, половина);
        звільнити_дробове(виділяч, поточний_х);
        вернути ні;
      }
      звільнити_дробове(виділяч, поточний_х);
      поточний_х = темп;
      масштаб -= 1;
    }
    звільнити_дробове(виділяч, половина);

    змінна х_мінус_один: Дробове;
    якщо не відняти_дробові(виділяч, поточний_х, один, х_мінус_один::адреса) {
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, два);
      звільнити_дробове(виділяч, поточний_х);
      вернути ні;
    }

    змінна х_плюс_один: Дробове;
    якщо не додати_дробові(виділяч, поточний_х, один, х_плюс_один::адреса) {
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, два);
      звільнити_дробове(виділяч, поточний_х);
      звільнити_дробове(виділяч, х_мінус_один);
      вернути ні;
    }
    звільнити_дробове(виділяч, поточний_х);

    змінна у: Дробове;
    якщо не поділити_дробові(виділяч, х_мінус_один, х_плюс_один, точність, у::адреса) {
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, два);
      звільнити_дробове(виділяч, х_мінус_один);
      звільнити_дробове(виділяч, х_плюс_один);
      вернути ні;
    }
    звільнити_дробове(виділяч, х_мінус_один);
    звільнити_дробове(виділяч, х_плюс_один);

    змінна у_квадрат: Дробове;
    якщо не помножити_дробові(виділяч, у, у, точність, у_квадрат::адреса) {
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, два);
      звільнити_дробове(виділяч, у);
      вернути ні;
    }

    змінна сума: Дробове;
    якщо не копіювати_дробове(виділяч, у, сума::адреса) {
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, два);
      звільнити_дробове(виділяч, у);
      звільнити_дробове(виділяч, у_квадрат);
      вернути ні;
    }

    змінна у_степінь: Дробове;
    якщо не копіювати_дробове(виділяч, у, у_степінь::адреса) {
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, два);
      звільнити_дробове(виділяч, у);
      звільнити_дробове(виділяч, у_квадрат);
      звільнити_дробове(виділяч, сума);
      вернути ні;
    }

    змінна к: ц64 = 1;
    поки к < ц64(точність) * 2 {
      змінна темп: Дробове;
      якщо не помножити_дробові(виділяч, у_степінь, у_квадрат, точність, темп::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, у);
        звільнити_дробове(виділяч, у_квадрат);
        звільнити_дробове(виділяч, сума);
        звільнити_дробове(виділяч, у_степінь);
        вернути ні;
      }
      звільнити_дробове(виділяч, у_степінь);
      у_степінь = темп;

      змінна дільник_ц64: ц64 = ц64(2) * к + 1;
      змінна дільник: Дробове;
      якщо не ініціалізувати_дробове_з_ц64(виділяч, дільник_ц64, дільник::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, у);
        звільнити_дробове(виділяч, у_квадрат);
        звільнити_дробове(виділяч, сума);
        звільнити_дробове(виділяч, у_степінь);
        вернути ні;
      }

      змінна доданок: Дробове;
      якщо не поділити_дробові(виділяч, у_степінь, дільник, точність, доданок::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, у);
        звільнити_дробове(виділяч, у_квадрат);
        звільнити_дробове(виділяч, сума);
        звільнити_дробове(виділяч, у_степінь);
        звільнити_дробове(виділяч, дільник);
        вернути ні;
      }
      звільнити_дробове(виділяч, дільник);

      змінна нова_сума: Дробове;
      якщо не додати_дробові(виділяч, сума, доданок, нова_сума::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, у);
        звільнити_дробове(виділяч, у_квадрат);
        звільнити_дробове(виділяч, сума);
        звільнити_дробове(виділяч, у_степінь);
        звільнити_дробове(виділяч, доданок);
        вернути ні;
      }
      звільнити_дробове(виділяч, сума);
      звільнити_дробове(виділяч, доданок);
      сума = нова_сума;

      к += 1;
    }

    звільнити_дробове(виділяч, у);
    звільнити_дробове(виділяч, у_квадрат);
    звільнити_дробове(виділяч, у_степінь);

    змінна лн_х: Дробове;
    якщо не помножити_дробові(виділяч, два, сума, точність, лн_х::адреса) {
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, два);
      звільнити_дробове(виділяч, сума);
      вернути ні;
    }
    звільнити_дробове(виділяч, сума);

    якщо масштаб != 0 {
      змінна лн2_х: Дробове;
      якщо не копіювати_дробове(виділяч, два, лн2_х::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, лн_х);
        вернути ні;
      }

      змінна лн2_х_мінус_один: Дробове;
      якщо не відняти_дробові(виділяч, лн2_х, один, лн2_х_мінус_один::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, лн_х);
        звільнити_дробове(виділяч, лн2_х);
        вернути ні;
      }

      змінна лн2_х_плюс_один: Дробове;
      якщо не додати_дробові(виділяч, лн2_х, один, лн2_х_плюс_один::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, лн_х);
        звільнити_дробове(виділяч, лн2_х);
        звільнити_дробове(виділяч, лн2_х_мінус_один);
        вернути ні;
      }
      звільнити_дробове(виділяч, лн2_х);

      змінна лн2_у: Дробове;
      якщо не поділити_дробові(виділяч, лн2_х_мінус_один, лн2_х_плюс_один, точність, лн2_у::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, лн_х);
        звільнити_дробове(виділяч, лн2_х_мінус_один);
        звільнити_дробове(виділяч, лн2_х_плюс_один);
        вернути ні;
      }
      звільнити_дробове(виділяч, лн2_х_мінус_один);
      звільнити_дробове(виділяч, лн2_х_плюс_один);

      змінна лн2_у_квадрат: Дробове;
      якщо не помножити_дробові(виділяч, лн2_у, лн2_у, точність, лн2_у_квадрат::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, лн_х);
        звільнити_дробове(виділяч, лн2_у);
        вернути ні;
      }

      змінна лн2_сума: Дробове;
      якщо не копіювати_дробове(виділяч, лн2_у, лн2_сума::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, лн_х);
        звільнити_дробове(виділяч, лн2_у);
        звільнити_дробове(виділяч, лн2_у_квадрат);
        вернути ні;
      }

      змінна лн2_у_степінь: Дробове;
      якщо не копіювати_дробове(виділяч, лн2_у, лн2_у_степінь::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, лн_х);
        звільнити_дробове(виділяч, лн2_у);
        звільнити_дробове(виділяч, лн2_у_квадрат);
        звільнити_дробове(виділяч, лн2_сума);
        вернути ні;
      }

      змінна лн2_к: ц64 = 1;
      поки лн2_к < ц64(точність) * 2 {
        змінна темп: Дробове;
        якщо не помножити_дробові(виділяч, лн2_у_степінь, лн2_у_квадрат, точність, темп::адреса) {
          звільнити_дробове(виділяч, один);
          звільнити_дробове(виділяч, два);
          звільнити_дробове(виділяч, лн_х);
          звільнити_дробове(виділяч, лн2_у);
          звільнити_дробове(виділяч, лн2_у_квадрат);
          звільнити_дробове(виділяч, лн2_сума);
          звільнити_дробове(виділяч, лн2_у_степінь);
          вернути ні;
        }
        звільнити_дробове(виділяч, лн2_у_степінь);
        лн2_у_степінь = темп;

        змінна дільник_ц64: ц64 = ц64(2) * лн2_к + 1;
        змінна дільник: Дробове;
        якщо не ініціалізувати_дробове_з_ц64(виділяч, дільник_ц64, дільник::адреса) {
          звільнити_дробове(виділяч, один);
          звільнити_дробове(виділяч, два);
          звільнити_дробове(виділяч, лн_х);
          звільнити_дробове(виділяч, лн2_у);
          звільнити_дробове(виділяч, лн2_у_квадрат);
          звільнити_дробове(виділяч, лн2_сума);
          звільнити_дробове(виділяч, лн2_у_степінь);
          вернути ні;
        }

        змінна доданок: Дробове;
        якщо не поділити_дробові(виділяч, лн2_у_степінь, дільник, точність, доданок::адреса) {
          звільнити_дробове(виділяч, один);
          звільнити_дробове(виділяч, два);
          звільнити_дробове(виділяч, лн_х);
          звільнити_дробове(виділяч, лн2_у);
          звільнити_дробове(виділяч, лн2_у_квадрат);
          звільнити_дробове(виділяч, лн2_сума);
          звільнити_дробове(виділяч, лн2_у_степінь);
          звільнити_дробове(виділяч, дільник);
          вернути ні;
        }
        звільнити_дробове(виділяч, дільник);

        змінна нова_лн2_сума: Дробове;
        якщо не додати_дробові(виділяч, лн2_сума, доданок, нова_лн2_сума::адреса) {
          звільнити_дробове(виділяч, один);
          звільнити_дробове(виділяч, два);
          звільнити_дробове(виділяч, лн_х);
          звільнити_дробове(виділяч, лн2_у);
          звільнити_дробове(виділяч, лн2_у_квадрат);
          звільнити_дробове(виділяч, лн2_сума);
          звільнити_дробове(виділяч, лн2_у_степінь);
          звільнити_дробове(виділяч, доданок);
          вернути ні;
        }
        звільнити_дробове(виділяч, лн2_сума);
        звільнити_дробове(виділяч, доданок);
        лн2_сума = нова_лн2_сума;

        лн2_к += 1;
      }

      звільнити_дробове(виділяч, лн2_у);
      звільнити_дробове(виділяч, лн2_у_квадрат);
      звільнити_дробове(виділяч, лн2_у_степінь);

      змінна лн2: Дробове;
      якщо не помножити_дробові(виділяч, два, лн2_сума, точність, лн2::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, лн_х);
        звільнити_дробове(виділяч, лн2_сума);
        вернути ні;
      }
      звільнити_дробове(виділяч, лн2_сума);

      змінна масштаб_дроб: Дробове;
      якщо не ініціалізувати_дробове_з_ц64(виділяч, масштаб, масштаб_дроб::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, лн_х);
        звільнити_дробове(виділяч, лн2);
        вернути ні;
      }

      змінна поправка: Дробове;
      якщо не помножити_дробові(виділяч, масштаб_дроб, лн2, точність, поправка::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, лн_х);
        звільнити_дробове(виділяч, лн2);
        звільнити_дробове(виділяч, масштаб_дроб);
        вернути ні;
      }
      звільнити_дробове(виділяч, лн2);
      звільнити_дробове(виділяч, масштаб_дроб);

      змінна новий_лн_х: Дробове;
      якщо не додати_дробові(виділяч, лн_х, поправка, новий_лн_х::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, лн_х);
        звільнити_дробове(виділяч, поправка);
        вернути ні;
      }
      звільнити_дробове(виділяч, лн_х);
      звільнити_дробове(виділяч, поправка);
      лн_х = новий_лн_х;
    }

    звільнити_дробове(виділяч, один);
    звільнити_дробове(виділяч, два);

    вихід.мантиса = лн_х.мантиса;
    вихід.експонента = лн_х.експонента;

    якщо не округлити_до_точності(виділяч, вихід, точність) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    вернути так;
  }

  місцева дія квадратний_корінь_дробового(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    точність: ц32,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо перевірити_чи_дробове_відʼємне(а) {
      вернути ні;
    }

    якщо перевірити_чи_дробове_нуль(а) {
      вернути ініціалізувати_дробове_нуль(виділяч, вихід);
    }

    змінна наближення_д64: д64;
    якщо не перетворити_дробове_в_д64(виділяч, а, наближення_д64::адреса) {
      вернути ні;
    }

    змінна здогадка: Дробове;
    якщо не ініціалізувати_дробове_з_д64(виділяч, корінь_квадратний_д64(наближення_д64), здогадка::адреса) {
      вернути ні;
    }

    якщо перевірити_чи_дробове_нуль(здогадка) {
      звільнити_дробове(виділяч, здогадка);
      якщо не ініціалізувати_дробове_один(виділяч, здогадка::адреса) {
        вернути ні;
      }
    }

    змінна два: Дробове;
    якщо не ініціалізувати_дробове_з_д64(виділяч, 2.0, два::адреса) {
      звільнити_дробове(виділяч, здогадка);
      вернути ні;
    }

    змінна попереднє: Дробове;
    змінна має_попереднє = ні;

    змінна ітерація: ц32 = 0;
  початок:
    поки ітерація < ц32(точність) + 20 {
      змінна ділення: Дробове;
      якщо не поділити_дробові(виділяч, а, здогадка, точність, ділення::адреса) {
        звільнити_дробове(виділяч, здогадка);
        звільнити_дробове(виділяч, два);
        якщо має_попереднє {
          звільнити_дробове(виділяч, попереднє);
        }
        вернути ні;
      }

      змінна сума: Дробове;
      якщо не додати_дробові(виділяч, здогадка, ділення, сума::адреса) {
        звільнити_дробове(виділяч, ділення);
        звільнити_дробове(виділяч, здогадка);
        звільнити_дробове(виділяч, два);
        якщо має_попереднє {
          звільнити_дробове(виділяч, попереднє);
        }
        вернути ні;
      }
      звільнити_дробове(виділяч, ділення);

      змінна нова_здогадка: Дробове;
      якщо не поділити_дробові(виділяч, сума, два, точність, нова_здогадка::адреса) {
        звільнити_дробове(виділяч, сума);
        звільнити_дробове(виділяч, здогадка);
        звільнити_дробове(виділяч, два);
        якщо має_попереднє {
          звільнити_дробове(виділяч, попереднє);
        }
        вернути ні;
      }
      звільнити_дробове(виділяч, сума);

      якщо має_попереднє і порівняти_дробові(виділяч, здогадка, попереднє) == 0 {
        звільнити_дробове(виділяч, нова_здогадка);
        звільнити_дробове(виділяч, попереднє);
        має_попереднє = ні;
        ітерація += 1;
        стрибнути початок;
      }

      якщо має_попереднє {
        звільнити_дробове(виділяч, попереднє);
      }
      попереднє = здогадка;
      має_попереднє = так;
      здогадка = нова_здогадка;

      ітерація += 1;
    }

  далі:
    якщо має_попереднє {
      звільнити_дробове(виділяч, попереднє);
    }
    звільнити_дробове(виділяч, два);

    вихід.мантиса = здогадка.мантиса;
    вихід.експонента = здогадка.експонента;

    якщо не округлити_до_точності(виділяч, вихід, точність) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    вернути так;
  }

  місцева дія піднести_дробове_до_цілого_степеня(
    виділяч: адреса<Виділяч>,
    основа: Дробове,
    степінь: ц64,
    точність: ц32,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо степінь == 0 {
      вернути ініціалізувати_дробове_один(виділяч, вихід);
    }

    змінна відʼємний_степінь = степінь < 0;
    змінна абсол_степінь: п64;
    якщо відʼємний_степінь {
      абсол_степінь = п64((-(степінь + 1)) + 1);
    } інакше {
      абсол_степінь = п64(степінь);
    }

    змінна результат: Дробове;
    якщо не ініціалізувати_дробове_один(виділяч, результат::адреса) {
      вернути ні;
    }

    змінна б: Дробове;
    якщо не копіювати_дробове(виділяч, основа, б::адреса) {
      звільнити_дробове(виділяч, результат);
      вернути ні;
    }

    поки абсол_степінь > 0 {
      якщо (абсол_степінь & 1) != 0 {
        змінна темп: Дробове;
        якщо не помножити_дробові(виділяч, результат, б, точність, темп::адреса) {
          звільнити_дробове(виділяч, результат);
          звільнити_дробове(виділяч, б);
          вернути ні;
        }
        звільнити_дробове(виділяч, результат);
        результат = темп;
      }

      змінна б_квадрат: Дробове;
      якщо не помножити_дробові(виділяч, б, б, точність, б_квадрат::адреса) {
        звільнити_дробове(виділяч, результат);
        звільнити_дробове(виділяч, б);
        вернути ні;
      }
      звільнити_дробове(виділяч, б);
      б = б_квадрат;

      абсол_степінь = абсол_степінь >> 1;
    }

    звільнити_дробове(виділяч, б);

    якщо відʼємний_степінь {
      змінна один: Дробове;
      якщо не ініціалізувати_дробове_один(виділяч, один::адреса) {
        звільнити_дробове(виділяч, результат);
        вернути ні;
      }

      змінна обернене: Дробове;
      якщо не поділити_дробові(виділяч, один, результат, точність, обернене::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, результат);
        вернути ні;
      }
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, результат);
      результат = обернене;
    }

    вихід.мантиса = результат.мантиса;
    вихід.експонента = результат.експонента;

    вернути так;
  }

  місцева дія підлога_дробового(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо а.експонента >= 0 {
      вернути копіювати_дробове(виділяч, а, вихід);
    }

    змінна дільник: Ціле;
    якщо не ініціалізувати_ціле_один(виділяч, дільник::адреса) {
      вернути ні;
    }

    змінна десять: Ціле;
    якщо не ініціалізувати_ціле_з_п64(виділяч, 10, десять::адреса) {
      звільнити_ціле(виділяч, дільник);
      вернути ні;
    }

    змінна п: ц32 = 0;
    поки п < (-а.експонента) {
      змінна новий_діл: Ціле;
      якщо не помножити_цілі(виділяч, дільник, десять, новий_діл::адреса) {
        звільнити_ціле(виділяч, дільник);
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }
      звільнити_ціле(виділяч, дільник);
      дільник = новий_діл;
      п += 1;
    }

    змінна нова_мантиса: Ціле;
    якщо не поділити_цілі(виділяч, а.мантиса, дільник, нова_мантиса::адреса) {
      звільнити_ціле(виділяч, дільник);
      звільнити_ціле(виділяч, десять);
      вернути ні;
    }

    якщо перевірити_чи_ціле_відʼємне(а.мантиса) {
      змінна залишок: Ціле;
      якщо не залишок_ділення_цілих(виділяч, а.мантиса, дільник, залишок::адреса) {
        звільнити_ціле(виділяч, нова_мантиса);
        звільнити_ціле(виділяч, дільник);
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }

      якщо не перевірити_чи_ціле_нуль(залишок) {
        змінна один: Ціле;
        якщо не ініціалізувати_ціле_один(виділяч, один::адреса) {
          звільнити_ціле(виділяч, залишок);
          звільнити_ціле(виділяч, нова_мантиса);
          звільнити_ціле(виділяч, дільник);
          звільнити_ціле(виділяч, десять);
          вернути ні;
        }

        змінна темп: Ціле;
        якщо не відняти_цілі(виділяч, нова_мантиса, один, темп::адреса) {
          звільнити_ціле(виділяч, один);
          звільнити_ціле(виділяч, залишок);
          звільнити_ціле(виділяч, нова_мантиса);
          звільнити_ціле(виділяч, дільник);
          звільнити_ціле(виділяч, десять);
          вернути ні;
        }
        звільнити_ціле(виділяч, нова_мантиса);
        нова_мантиса = темп;
        звільнити_ціле(виділяч, один);
      }
      звільнити_ціле(виділяч, залишок);
    }

    звільнити_ціле(виділяч, дільник);
    звільнити_ціле(виділяч, десять);

    вихід.мантиса = нова_мантиса;
    вихід.експонента = 0;

    вернути так;
  }

  місцева дія стеля_дробового(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    вихід: адреса<Дробове>
  ) -> логічне {
    змінна негативне: Дробове;
    якщо не негація_дробового(виділяч, а, негативне::адреса) {
      вернути ні;
    }

    змінна підлога_негативного: Дробове;
    якщо не підлога_дробового(виділяч, негативне, підлога_негативного::адреса) {
      звільнити_дробове(виділяч, негативне);
      вернути ні;
    }

    змінна результат: Дробове;
    якщо не негація_дробового(виділяч, підлога_негативного, результат::адреса) {
      звільнити_дробове(виділяч, негативне);
      звільнити_дробове(виділяч, підлога_негативного);
      вернути ні;
    }

    звільнити_дробове(виділяч, негативне);
    звільнити_дробове(виділяч, підлога_негативного);

    вихід.мантиса = результат.мантиса;
    вихід.експонента = результат.експонента;

    вернути так;
  }

  місцева дія обрізати_дробове(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо а.експонента >= 0 {
      вернути копіювати_дробове(виділяч, а, вихід);
    }

    змінна дільник: Ціле;
    якщо не ініціалізувати_ціле_один(виділяч, дільник::адреса) {
      вернути ні;
    }

    змінна десять: Ціле;
    якщо не ініціалізувати_ціле_з_п64(виділяч, 10, десять::адреса) {
      звільнити_ціле(виділяч, дільник);
      вернути ні;
    }

    змінна п: ц32 = 0;
    поки п < (-а.експонента) {
      змінна новий_діл: Ціле;
      якщо не помножити_цілі(виділяч, дільник, десять, новий_діл::адреса) {
        звільнити_ціле(виділяч, дільник);
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }
      звільнити_ціле(виділяч, дільник);
      дільник = новий_діл;
      п += 1;
    }

    змінна нова_мантиса: Ціле;
    якщо не поділити_цілі(виділяч, а.мантиса, дільник, нова_мантиса::адреса) {
      звільнити_ціле(виділяч, дільник);
      звільнити_ціле(виділяч, десять);
      вернути ні;
    }

    звільнити_ціле(виділяч, дільник);
    звільнити_ціле(виділяч, десять);

    вихід.мантиса = нова_мантиса;
    вихід.експонента = 0;

    вернути так;
  }
}