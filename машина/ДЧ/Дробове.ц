взяти означення ДЧ;

// ЦЕ ТРЕБА ПЕРЕПИСАТИ

дія копіювати_памʼять<Т>(
  куди: памʼять<Т>,
  звідки: памʼять<Т>,
  кількість: природне
) {
  змінна п: природне = 0;

  поки п < кількість {
    куди[п] = звідки[п];

    п += 1;
  }
}

дія заповнити_памʼять<Т>(
  куди: памʼять<Т>,
  значення: Т,
  кількість: природне
) {
  змінна п: природне = 0;

  поки п < кількість {
    куди[п] = значення;

    п += 1;
  }
}

// Дробове
простір ДЧ {
  дія ініціалізувати_дробове(
    виділяч: адреса<Виділяч>,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо не ініціалізувати_ціле_нуль(виділяч, вихід.мантиса::адреса) {
      вернути ні;
    }

    вихід.експонента = 0;

    вернути так;
  }

  дія нормалізувати_дробове(виділяч: адреса<Виділяч>, значення: адреса<Дробове>) -> логічне;

  місцева дія ініціалізувати_дробове_з_д64(
    виділяч: адреса<Виділяч>,
    значення: д64,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо значення == 0.0 {
      вернути ініціалізувати_дробове_нуль(виділяч, вихід);
    }

    змінна відʼємне = значення < 0.0;
    змінна абсол_значення = значення;
    якщо відʼємне {
      абсол_значення = д64(0.0) - значення;
    }

    змінна експ: ц32 = 0;

    поки абсол_значення >= 10.0 {
      абсол_значення = абсол_значення / 10.0;
      експ += 1;
    }

    змінна пу = абсол_значення < 1.0 і абсол_значення > 0.0;
    поки пу {
      абсол_значення = абсол_значення * 10.0;
      експ -= 1;
      пу = абсол_значення < 1.0 і абсол_значення > 0.0;
    }

    змінна точність: ц32 = 15;
    змінна мантиса_ц: ц64 = 0;
    змінна десяткові: ц32 = 0;

    змінна п: ц32 = 0;
    пу = п < точність і абсол_значення > 0.0;
    поки пу {
      змінна цифра = ц64(абсол_значення);
      мантиса_ц = мантиса_ц * 10 + цифра;
      абсол_значення = (абсол_значення - д64(цифра)) * 10.0;
      десяткові += 1;
      п += 1;
      пу = п < точність і абсол_значення > 0.0;
    }

    якщо не ініціалізувати_ціле_з_ц64(виділяч, мантиса_ц, вихід.мантиса::адреса) {
      вернути ні;
    }

    якщо відʼємне {
      вихід.мантиса.розмір = -вихід.мантиса.розмір;
    }

    вихід.експонента = експ - десяткові + 1;

    якщо не нормалізувати_дробове(виділяч, вихід) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    вернути так;
  }

  місцева дія ініціалізувати_дробове_з_ц64(
    виділяч: адреса<Виділяч>,
    значення: ц64,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо не ініціалізувати_ціле_з_ц64(виділяч, значення, вихід.мантиса::адреса) {
      вернути ні;
    }
    вихід.експонента = 0;
    вернути так;
  }

  місцева дія ініціалізувати_дробове_з_кд(
    виділяч: адреса<Виділяч>,
    значення: кд,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо значення.розмір == 0 {
      вернути ініціалізувати_дробове_нуль(виділяч, вихід);
    }

    змінна п: природне = 0;

    змінна відʼємне = ні;
    якщо значення.дані[п] == 99 {
      відʼємне = так;
      п += 1;
    } інакше якщо значення.дані[п] == 96 {
      п += 1;
    }

    змінна мантиса_дані = виділити_памʼять<п8>(виділяч, значення.розмір + 1);
    якщо мантиса_дані == пусто {
      вернути ні;
    }

    змінна мантиса_поз: природне = 0;
    змінна десяткові_місця: ц32 = 0;
    змінна бачили_крапку = ні;
    змінна в_експоненті = ні;
    змінна знак_експоненти: ц32 = 1;
    змінна явна_експонента: ц32 = 0;

  початок:
    поки п < значення.розмір {
      змінна символ = значення.дані[п];

      якщо символ == 117 {
        бачили_крапку = так;
      } інакше якщо символ == 47 або символ == 15 {
        в_експоненті = так;
        п += 1;
        якщо п < значення.розмір {
          якщо значення.дані[п] == 99 {
            знак_експоненти = ц32(0) - 1;
            п += 1;
          } інакше якщо значення.дані[п] == 96 {
            п += 1;
          }
        }
        стрибнути початок;
      } інакше якщо в_експоненті і символ >= 0 і символ <= 9 {
        явна_експонента = явна_експонента * 10 + ц32(символ);
      } інакше якщо символ >= 0 і символ <= 9 {
        мантиса_дані[мантиса_поз] = символ;
        мантиса_поз += 1;
        якщо бачили_крапку {
          десяткові_місця += 1;
        }
      }
      п += 1;
    }

    змінна мантиса_початок: природне = 0;
    змінна х = мантиса_початок < мантиса_поз і мантиса_дані[мантиса_початок] == 0 і (мантиса_початок + 1) < мантиса_поз;
    поки х {
      мантиса_початок += 1;
      х = мантиса_початок < мантиса_поз і мантиса_дані[мантиса_початок] == 0 і (мантиса_початок + 1) < мантиса_поз;
    }

    змінна мантиса_кд: кд;
    мантиса_кд.дані = мантиса_дані[мантиса_початок]::адреса як памʼять<п8>;
    мантиса_кд.розмір = мантиса_поз - мантиса_початок;

    якщо не ініціалізувати_ціле_з_кд(виділяч, мантиса_кд, вихід.мантиса::адреса) {
      звільнити_памʼять(виділяч, мантиса_дані);
      вернути ні;
    }

    якщо відʼємне і не перевірити_чи_ціле_нуль(вихід.мантиса) {
      вихід.мантиса.розмір = -вихід.мантиса.розмір;
    }

    вихід.експонента = (ц32(0) - десяткові_місця) + (знак_експоненти * явна_експонента);

    звільнити_памʼять(виділяч, мантиса_дані);

    якщо не нормалізувати_дробове(виділяч, вихід) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    вернути так;
  }

  місцева дія ініціалізувати_дробове_нуль(
    виділяч: адреса<Виділяч>,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо не ініціалізувати_ціле_нуль(виділяч, вихід.мантиса::адреса) {
      вернути ні;
    }

    вихід.експонента = 0;

    вернути так;
  }

  місцева дія ініціалізувати_дробове_один(
    виділяч: адреса<Виділяч>,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо не ініціалізувати_ціле_з_ц64(виділяч, 1, вихід.мантиса::адреса) {
      вернути ні;
    }

    вихід.експонента = 0;

    вернути так;
  }

  місцева дія ініціалізувати_дробове_з_цілого(
    виділяч: адреса<Виділяч>,
    значення: Ціле,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо не клонувати_ціле(виділяч, значення, вихід.мантиса::адреса) {
      вернути ні;
    }

    вихід.експонента = 0;

    вернути так;
  }

  місцева дія звільнити_дробове(
    виділяч: адреса<Виділяч>,
    значення: Дробове
  ) {
    звільнити_ціле(виділяч, значення.мантиса);
  }

  місцева дія клонувати_дробове(
    виділяч: адреса<Виділяч>,
    джерело: Дробове,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо не клонувати_ціле(виділяч, джерело.мантиса, вихід.мантиса::адреса) {
      вернути ні;
    }

    вихід.експонента = джерело.експонента;

    вернути так;
  }

  дія нормалізувати_дробове(
    виділяч: адреса<Виділяч>,
    значення: адреса<Дробове>
  ) -> логічне {
    якщо перевірити_чи_ціле_нуль(значення.мантиса) {
      значення.експонента = 0;
      вернути так;
    }

    змінна десять: Ціле;
    якщо не ініціалізувати_ціле_з_ц64(виділяч, 10, десять::адреса) {
      вернути ні;
    }

    змінна нуль: Ціле;
    якщо не ініціалізувати_ціле_нуль(виділяч, нуль::адреса) {
      звільнити_ціле(виділяч, десять);
      вернути ні;
    }

    поки не перевірити_чи_ціле_нуль(значення.мантиса) {
      змінна залишок: Ціле;
      якщо не залишок_ділення_цілих(виділяч, значення.мантиса, десять, залишок::адреса) {
        звільнити_ціле(виділяч, десять);
        звільнити_ціле(виділяч, нуль);
        вернути ні;
      }

      якщо порівняти_цілі(виділяч, залишок, нуль) != 0 {
        звільнити_ціле(виділяч, залишок);
        стрибнути далі;
      }

      звільнити_ціле(виділяч, залишок);

      змінна нова_мантиса: Ціле;
      якщо не поділити_цілі(виділяч, значення.мантиса, десять, нова_мантиса::адреса) {
        звільнити_ціле(виділяч, десять);
        звільнити_ціле(виділяч, нуль);
        вернути ні;
      }

      звільнити_ціле(виділяч, значення.мантиса);
      значення.мантиса = нова_мантиса;
      значення.експонента += 1;
    }

  далі:
    звільнити_ціле(виділяч, десять);
    звільнити_ціле(виділяч, нуль);

    вернути так;
  }

  дія округлити_до_точності(
    виділяч: адреса<Виділяч>,
    значення: адреса<Дробове>,
    точність: ц32
  ) -> логічне {
    якщо перевірити_чи_ціле_нуль(значення.мантиса) {
      вернути так;
    }

    змінна цифри: ц32;
    якщо не порахувати_кількість_цифр_цілого(виділяч, значення.мантиса, цифри::адреса) {
      вернути ні;
    }

    якщо цифри <= точність {
      вернути так;
    }

    змінна до_видалення: ц32 = цифри - точність;

    змінна дільник: Ціле;
    якщо не ініціалізувати_ціле_з_ц64(виділяч, 1, дільник::адреса) {
      вернути ні;
    }

    змінна десять: Ціле;
    якщо не ініціалізувати_ціле_з_ц64(виділяч, 10, десять::адреса) {
      звільнити_ціле(виділяч, дільник);
      вернути ні;
    }

    змінна п: ц32 = 0;
    поки п < до_видалення {
      змінна новий_діл: Ціле;
      якщо не помножити_цілі(виділяч, дільник, десять, новий_діл::адреса) {
        звільнити_ціле(виділяч, дільник);
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }
      звільнити_ціле(виділяч, дільник);
      дільник = новий_діл;
      п += 1;
    }

    змінна два: Ціле;
    якщо не ініціалізувати_ціле_з_ц64(виділяч, 2, два::адреса) {
      звільнити_ціле(виділяч, дільник);
      звільнити_ціле(виділяч, десять);
      вернути ні;
    }

    змінна половина_діл: Ціле;
    якщо не поділити_цілі(виділяч, дільник, два, половина_діл::адреса) {
      звільнити_ціле(виділяч, дільник);
      звільнити_ціле(виділяч, десять);
      звільнити_ціле(виділяч, два);
      вернути ні;
    }
    звільнити_ціле(виділяч, два);

    змінна абсол_мантиса: Ціле;
    якщо не абсолютне_ціле(виділяч, значення.мантиса, абсол_мантиса::адреса) {
      звільнити_ціле(виділяч, дільник);
      звільнити_ціле(виділяч, десять);
      звільнити_ціле(виділяч, половина_діл);
      вернути ні;
    }

    змінна залишок: Ціле;
    якщо не залишок_ділення_цілих(виділяч, абсол_мантиса, дільник, залишок::адреса) {
      звільнити_ціле(виділяч, дільник);
      звільнити_ціле(виділяч, десять);
      звільнити_ціле(виділяч, половина_діл);
      звільнити_ціле(виділяч, абсол_мантиса);
      вернути ні;
    }
    звільнити_ціле(виділяч, абсол_мантиса);

    змінна нова_мантиса: Ціле;
    якщо не поділити_цілі(виділяч, значення.мантиса, дільник, нова_мантиса::адреса) {
      звільнити_ціле(виділяч, дільник);
      звільнити_ціле(виділяч, десять);
      звільнити_ціле(виділяч, половина_діл);
      звільнити_ціле(виділяч, залишок);
      вернути ні;
    }

    якщо порівняти_цілі(виділяч, залишок, половина_діл) >= 0 {
      змінна один: Ціле;
      якщо не ініціалізувати_ціле_з_ц64(виділяч, 1, один::адреса) {
        звільнити_ціле(виділяч, дільник);
        звільнити_ціле(виділяч, десять);
        звільнити_ціле(виділяч, половина_діл);
        звільнити_ціле(виділяч, залишок);
        звільнити_ціле(виділяч, нова_мантиса);
        вернути ні;
      }

      якщо перевірити_чи_ціле_відʼємне(значення.мантиса) {
        змінна темп: Ціле;
        якщо не відняти_цілі(виділяч, нова_мантиса, один, темп::адреса) {
          звільнити_ціле(виділяч, дільник);
          звільнити_ціле(виділяч, десять);
          звільнити_ціле(виділяч, половина_діл);
          звільнити_ціле(виділяч, залишок);
          звільнити_ціле(виділяч, нова_мантиса);
          звільнити_ціле(виділяч, один);
          вернути ні;
        }
        звільнити_ціле(виділяч, нова_мантиса);
        нова_мантиса = темп;
      } інакше {
        змінна темп: Ціле;
        якщо не додати_цілі(виділяч, нова_мантиса, один, темп::адреса) {
          звільнити_ціле(виділяч, дільник);
          звільнити_ціле(виділяч, десять);
          звільнити_ціле(виділяч, половина_діл);
          звільнити_ціле(виділяч, залишок);
          звільнити_ціле(виділяч, нова_мантиса);
          звільнити_ціле(виділяч, один);
          вернути ні;
        }
        звільнити_ціле(виділяч, нова_мантиса);
        нова_мантиса = темп;
      }
      звільнити_ціле(виділяч, один);
    }

    звільнити_ціле(виділяч, значення.мантиса);
    значення.мантиса = нова_мантиса;
    значення.експонента += до_видалення;

    звільнити_ціле(виділяч, дільник);
    звільнити_ціле(виділяч, десять);
    звільнити_ціле(виділяч, половина_діл);
    звільнити_ціле(виділяч, залишок);

    вернути так;
  }

  місцева дія перетворити_дробове_в_д64(
    виділяч: адреса<Виділяч>,
    значення: Дробове,
    вихід: адреса<д64>
  ) -> логічне {
    якщо перевірити_чи_ціле_нуль(значення.мантиса) {
      вихід::вміст = 0.0;
      вернути так;
    }

    змінна відʼємне = перевірити_чи_ціле_відʼємне(значення.мантиса);

    змінна мантиса_кд: кд;
    якщо не перетворити_ціле_в_кд(виділяч, значення.мантиса, мантиса_кд::адреса) {
      вернути ні;
    }

    змінна результат: д64 = 0.0;
    змінна початок: природне = 0;
    якщо відʼємне {
      початок = 1;
    }

    змінна п: природне = початок;
    поки п < мантиса_кд.розмір {
      результат = результат * 10.0 + д64(мантиса_кд.дані[п]);
      п += 1;
    }

    звільнити_памʼять(виділяч, мантиса_кд.дані);

    змінна експ = значення.експонента;
    поки експ > 0 {
      результат = результат * 10.0;
      експ -= 1;
    }
    поки експ < 0 {
      результат = результат / 10.0;
      експ += 1;
    }

    якщо відʼємне {
      результат = д64(0.0) - результат;
    }

    вихід::вміст = результат;
    вернути так;
  }

  місцева дія перетворити_дробове_в_кд(
    виділяч: адреса<Виділяч>,
    значення: Дробове,
    вихід: адреса<кд>
  ) -> логічне {
    якщо перевірити_чи_ціле_нуль(значення.мантиса) {
      змінна дані_кд = виділити_памʼять<п8>(виділяч, 1);
      якщо дані_кд == пусто {
        вихід::вміст = кд { 0, пусто };
        вернути ні;
      }
      дані_кд[0] = 0;
      вихід::вміст = кд { 1, дані_кд };
      вернути так;
    }

    змінна мантиса_кд: кд;
    якщо не перетворити_ціле_в_кд(виділяч, значення.мантиса, мантиса_кд::адреса) {
      вихід::вміст = кд { 0, пусто };
      вернути ні;
    }

    змінна відʼємне = перевірити_чи_ціле_відʼємне(значення.мантиса);
    змінна цифри_початок: природне = 0;
    якщо відʼємне {
      цифри_початок = 1;
    }
    змінна цифри_довжина = мантиса_кд.розмір - цифри_початок;

    змінна результат_розмір: природне = мантиса_кд.розмір + 32;
    якщо значення.експонента < 0 {
      результат_розмір += природне(-значення.експонента);
    }

    змінна результат = виділити_памʼять<п8>(виділяч, результат_розмір);
    якщо результат == пусто {
      звільнити_памʼять(виділяч, мантиса_кд.дані);
      вихід::вміст = кд { 0, пусто };
      вернути ні;
    }

    змінна поз: природне = 0;
    якщо відʼємне {
      результат[поз] = 99;
      поз += 1;
    }

    змінна десяткова_позиція = ц32(цифри_довжина) + значення.експонента;

    якщо значення.експонента >= 0 {
      змінна п: природне = 0;
      поки п < цифри_довжина {
        результат[поз] = мантиса_кд.дані[цифри_початок + п];
        поз += 1;
        п += 1;
      }
      змінна к: ц32 = 0;
      поки к < значення.експонента {
        результат[поз] = 0;
        поз += 1;
        к += 1;
      }
      результат[поз] = 117;
      поз += 1;
      результат[поз] = 0;
      поз += 1;
    } інакше якщо десяткова_позиція <= 0 {
      результат[поз] = 0;
      поз += 1;
      результат[поз] = 117;
      поз += 1;
      змінна к: ц32 = 0;
      поки к < (-десяткова_позиція) {
        результат[поз] = 0;
        поз += 1;
        к += 1;
      }
      змінна п: природне = 0;
      поки п < цифри_довжина {
        результат[поз] = мантиса_кд.дані[цифри_початок + п];
        поз += 1;
        п += 1;
      }
    } інакше {
      змінна п: природне = 0;
      поки п < цифри_довжина {
        якщо п == природне(десяткова_позиція) {
          результат[поз] = 117;
          поз += 1;
        }
        результат[поз] = мантиса_кд.дані[цифри_початок + п];
        поз += 1;
        п += 1;
      }
    }

    звільнити_памʼять(виділяч, мантиса_кд.дані);

    вихід::вміст = кд { поз, результат };
    вернути так;
  }

  місцева дія перевірити_чи_дробове_нуль(
    значення: Дробове
  ) -> логічне {
    вернути перевірити_чи_ціле_нуль(значення.мантиса);
  }

  місцева дія перевірити_чи_дробове_відʼємне(
    значення: Дробове
  ) -> логічне {
    вернути перевірити_чи_ціле_відʼємне(значення.мантиса);
  }

  місцева дія порівняти_дробові(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    б: Дробове
  ) -> ц8 {
    змінна а_нуль = перевірити_чи_дробове_нуль(а);
    змінна б_нуль = перевірити_чи_дробове_нуль(б);

    якщо а_нуль і б_нуль {
      вернути 0;
    }
    якщо а_нуль {
      якщо перевірити_чи_дробове_відʼємне(б) {
        вернути 1;
      } інакше {
        вернути ц8(0)-1;
      }
    }
    якщо б_нуль {
      якщо перевірити_чи_дробове_відʼємне(а) {
        вернути ц8(0)-1;
      } інакше {
        вернути 1;
      }
    }

    змінна відʼємне_а = перевірити_чи_дробове_відʼємне(а);
    змінна відʼємне_б = перевірити_чи_дробове_відʼємне(б);
    якщо відʼємне_а і не відʼємне_б {
      вернути ц8(0)-1;
    }
    якщо не відʼємне_а і відʼємне_б {
      вернути 1;
    }

    змінна різниця_експонентів = а.експонента - б.експонента;

    змінна масштабоване_а: Ціле;
    змінна масштабоване_б: Ціле;
    змінна десять: Ціле;

    якщо не ініціалізувати_ціле_з_п64(виділяч, 10, десять::адреса) {
      вернути 0;
    }

    якщо різниця_експонентів > 0 {
      змінна масштаб: Ціле;
      якщо не ініціалізувати_ціле_один(виділяч, масштаб::адреса) {
        звільнити_ціле(виділяч, десять);
        вернути 0;
      }

      змінна п: ц32 = 0;
      поки п < різниця_експонентів {
        змінна новий_масштаб: Ціле;
        якщо не помножити_цілі(виділяч, масштаб, десять, новий_масштаб::адреса) {
          звільнити_ціле(виділяч, масштаб);
          звільнити_ціле(виділяч, десять);
          вернути 0;
        }
        звільнити_ціле(виділяч, масштаб);
        масштаб = новий_масштаб;

        п += 1;
      }

      якщо не помножити_цілі(виділяч, а.мантиса, масштаб, масштабоване_а::адреса) {
        звільнити_ціле(виділяч, масштаб);
        звільнити_ціле(виділяч, десять);
        вернути 0;
      }
      якщо не клонувати_ціле(виділяч, б.мантиса, масштабоване_б::адреса) {
        звільнити_ціле(виділяч, масштабоване_а);
        звільнити_ціле(виділяч, масштаб);
        звільнити_ціле(виділяч, десять);
        вернути 0;
      }
      звільнити_ціле(виділяч, масштаб);
    } інакше якщо різниця_експонентів < 0 {
      змінна масштаб: Ціле;
      якщо не ініціалізувати_ціле_один(виділяч, масштаб::адреса) {
        звільнити_ціле(виділяч, десять);
        вернути 0;
      }

      змінна п: ц32 = 0;
      поки п < (-різниця_експонентів) {
        змінна новий_масштаб: Ціле;
        якщо не помножити_цілі(виділяч, масштаб, десять, новий_масштаб::адреса) {
          звільнити_ціле(виділяч, масштаб);
          звільнити_ціле(виділяч, десять);
          вернути 0;
        }
        звільнити_ціле(виділяч, масштаб);
        масштаб = новий_масштаб;

        п += 1;
      }

      якщо не клонувати_ціле(виділяч, а.мантиса, масштабоване_а::адреса) {
        звільнити_ціле(виділяч, масштаб);
        звільнити_ціле(виділяч, десять);
        вернути 0;
      }
      якщо не помножити_цілі(виділяч, б.мантиса, масштаб, масштабоване_б::адреса) {
        звільнити_ціле(виділяч, масштабоване_а);
        звільнити_ціле(виділяч, масштаб);
        звільнити_ціле(виділяч, десять);
        вернути 0;
      }
      звільнити_ціле(виділяч, масштаб);
    } інакше {
      якщо не клонувати_ціле(виділяч, а.мантиса, масштабоване_а::адреса) {
        звільнити_ціле(виділяч, десять);
        вернути 0;
      }
      якщо не клонувати_ціле(виділяч, б.мантиса, масштабоване_б::адреса) {
        звільнити_ціле(виділяч, масштабоване_а);
        звільнити_ціле(виділяч, десять);
        вернути 0;
      }
    }

    змінна результат = порівняти_цілі(виділяч, масштабоване_а, масштабоване_б);

    звільнити_ціле(виділяч, десять);
    звільнити_ціле(виділяч, масштабоване_а);
    звільнити_ціле(виділяч, масштабоване_б);

    вернути результат;
  }

  місцева дія вирівняти_дробові(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    б: Дробове,
    вирівняне_а: адреса<Ціле>,
    вирівняне_б: адреса<Ціле>,
    спільна_експонента: адреса<ц32>
  ) -> логічне {
    змінна мін_експонента: ц32;
    якщо а.експонента < б.експонента {
      мін_експонента = а.експонента;
    } інакше {
      мін_експонента = б.експонента;
    }
    спільна_експонента::вміст = мін_експонента;

    змінна десять: Ціле;
    якщо не ініціалізувати_ціле_з_п64(виділяч, 10, десять::адреса) {
      вернути ні;
    }

    змінна масштаб_а = а.експонента - мін_експонента;
    якщо масштаб_а > 0 {
      змінна масштаб: Ціле;
      якщо не ініціалізувати_ціле_один(виділяч, масштаб::адреса) {
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }

      змінна п: ц32 = 0;
      поки п < масштаб_а {
        змінна новий_масштаб: Ціле;
        якщо не помножити_цілі(виділяч, масштаб, десять, новий_масштаб::адреса) {
          звільнити_ціле(виділяч, масштаб);
          звільнити_ціле(виділяч, десять);
          вернути ні;
        }
        звільнити_ціле(виділяч, масштаб);
        масштаб = новий_масштаб;

        п += 1;
      }

      якщо не помножити_цілі(виділяч, а.мантиса, масштаб, вирівняне_а) {
        звільнити_ціле(виділяч, масштаб);
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }
      звільнити_ціле(виділяч, масштаб);
    } інакше {
      якщо не клонувати_ціле(виділяч, а.мантиса, вирівняне_а) {
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }
    }

    змінна масштаб_б = б.експонента - мін_експонента;
    якщо масштаб_б > 0 {
      змінна масштаб: Ціле;
      якщо не ініціалізувати_ціле_один(виділяч, масштаб::адреса) {
        звільнити_ціле(виділяч, вирівняне_а::вміст);
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }

      змінна п: ц32 = 0;
      поки п < масштаб_б {
        змінна новий_масштаб: Ціле;
        якщо не помножити_цілі(виділяч, масштаб, десять, новий_масштаб::адреса) {
          звільнити_ціле(виділяч, масштаб);
          звільнити_ціле(виділяч, вирівняне_а::вміст);
          звільнити_ціле(виділяч, десять);
          вернути ні;
        }
        звільнити_ціле(виділяч, масштаб);
        масштаб = новий_масштаб;

        п += 1;
      }

      якщо не помножити_цілі(виділяч, б.мантиса, масштаб, вирівняне_б) {
        звільнити_ціле(виділяч, масштаб);
        звільнити_ціле(виділяч, вирівняне_а::вміст);
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }
      звільнити_ціле(виділяч, масштаб);
    } інакше {
      якщо не клонувати_ціле(виділяч, б.мантиса, вирівняне_б) {
        звільнити_ціле(виділяч, вирівняне_а::вміст);
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }
    }

    звільнити_ціле(виділяч, десять);
    вернути так;
  }

  місцева дія додати_дробові(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    б: Дробове,
    точність: ц32,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо перевірити_чи_дробове_нуль(а) {
      вернути клонувати_дробове(виділяч, б, вихід);
    }
    якщо перевірити_чи_дробове_нуль(б) {
      вернути клонувати_дробове(виділяч, а, вихід);
    }

    змінна вирівняне_а: Ціле;
    змінна вирівняне_б: Ціле;
    змінна спільна_експонента: ц32;
    якщо не вирівняти_дробові(виділяч, а, б, вирівняне_а::адреса, вирівняне_б::адреса, спільна_експонента::адреса) {
      вернути ні;
    }

    змінна нова_мантиса: Ціле;
    якщо не додати_цілі(виділяч, вирівняне_а, вирівняне_б, нова_мантиса::адреса) {
      звільнити_ціле(виділяч, вирівняне_а);
      звільнити_ціле(виділяч, вирівняне_б);
      вернути ні;
    }

    звільнити_ціле(виділяч, вирівняне_а);
    звільнити_ціле(виділяч, вирівняне_б);

    вихід.мантиса = нова_мантиса;
    вихід.експонента = спільна_експонента;

    якщо не нормалізувати_дробове(виділяч, вихід) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    вернути так;
  }

  місцева дія відняти_дробові(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    б: Дробове,
    точність: ц32,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо перевірити_чи_дробове_нуль(б) {
      вернути клонувати_дробове(виділяч, а, вихід);
    }
    якщо перевірити_чи_дробове_нуль(а) {
      якщо не клонувати_дробове(виділяч, б, вихід) {
        вернути ні;
      }
      вихід.мантиса.розмір = -вихід.мантиса.розмір;
      вернути так;
    }

    змінна вирівняне_а: Ціле;
    змінна вирівняне_б: Ціле;
    змінна спільна_експонента: ц32;
    якщо не вирівняти_дробові(виділяч, а, б, вирівняне_а::адреса, вирівняне_б::адреса, спільна_експонента::адреса) {
      вернути ні;
    }

    змінна нова_мантиса: Ціле;
    якщо не відняти_цілі(виділяч, вирівняне_а, вирівняне_б, нова_мантиса::адреса) {
      звільнити_ціле(виділяч, вирівняне_а);
      звільнити_ціле(виділяч, вирівняне_б);
      вернути ні;
    }

    звільнити_ціле(виділяч, вирівняне_а);
    звільнити_ціле(виділяч, вирівняне_б);

    вихід.мантиса = нова_мантиса;
    вихід.експонента = спільна_експонента;

    якщо не нормалізувати_дробове(виділяч, вихід) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    вернути так;
  }

  місцева дія мінус_дробове(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо не клонувати_дробове(виділяч, а, вихід) {
      вернути ні;
    }
    вихід.мантиса.розмір = -вихід.мантиса.розмір;
    вернути так;
  }

  місцева дія абсолютне_значення_дробового(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо не клонувати_дробове(виділяч, а, вихід) {
      вернути ні;
    }
    якщо перевірити_чи_ціле_відʼємне(вихід.мантиса) {
      вихід.мантиса.розмір = -вихід.мантиса.розмір;
    }
    вернути так;
  }

  місцева дія помножити_дробові(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    б: Дробове,
    точність: ц32,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо перевірити_чи_дробове_нуль(а) або перевірити_чи_дробове_нуль(б) {
      вернути ініціалізувати_дробове_нуль(виділяч, вихід);
    }

    змінна нова_мантиса: Ціле;
    якщо не помножити_цілі(виділяч, а.мантиса, б.мантиса, нова_мантиса::адреса) {
      вернути ні;
    }

    вихід.мантиса = нова_мантиса;
    вихід.експонента = а.експонента + б.експонента;

    якщо не нормалізувати_дробове(виділяч, вихід) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    якщо не округлити_до_точності(виділяч, вихід, точність) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    вернути так;
  }

  місцева дія поділити_дробові(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    б: Дробове,
    точність: ц32,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо перевірити_чи_дробове_нуль(б) {
      вернути ні;
    }

    якщо перевірити_чи_дробове_нуль(а) {
      вернути ініціалізувати_дробове_нуль(виділяч, вихід);
    }

    змінна додаткові_цифри = точність + 10;
    змінна масштаб: Ціле;
    якщо не ініціалізувати_ціле_один(виділяч, масштаб::адреса) {
      вернути ні;
    }

    змінна десять: Ціле;
    якщо не ініціалізувати_ціле_з_п64(виділяч, 10, десять::адреса) {
      звільнити_ціле(виділяч, масштаб);
      вернути ні;
    }

    змінна п: ц32 = 0;
    поки п < додаткові_цифри {
      змінна новий_масштаб: Ціле;
      якщо не помножити_цілі(виділяч, масштаб, десять, новий_масштаб::адреса) {
        звільнити_ціле(виділяч, масштаб);
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }
      звільнити_ціле(виділяч, масштаб);
      масштаб = новий_масштаб;
      п += 1;
    }

    змінна масштабоване_а: Ціле;
    якщо не помножити_цілі(виділяч, а.мантиса, масштаб, масштабоване_а::адреса) {
      звільнити_ціле(виділяч, масштаб);
      звільнити_ціле(виділяч, десять);
      вернути ні;
    }

    змінна нова_мантиса: Ціле;
    якщо не поділити_цілі(виділяч, масштабоване_а, б.мантиса, нова_мантиса::адреса) {
      звільнити_ціле(виділяч, масштаб);
      звільнити_ціле(виділяч, десять);
      звільнити_ціле(виділяч, масштабоване_а);
      вернути ні;
    }

    вихід.мантиса = нова_мантиса;
    вихід.експонента = а.експонента - б.експонента - додаткові_цифри;

    звільнити_ціле(виділяч, масштаб);
    звільнити_ціле(виділяч, десять);
    звільнити_ціле(виділяч, масштабоване_а);

    якщо не нормалізувати_дробове(виділяч, вихід) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    якщо не округлити_до_точності(виділяч, вихід, точність) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    вернути так;
  }

  місцева дія обрізати_дробове(виділяч: адреса<Виділяч>, а: Дробове, вихід: адреса<Дробове>) -> логічне;

  місцева дія залишок_ділення_дробових(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    б: Дробове,
    точність: ц32,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо перевірити_чи_дробове_нуль(б) {
      вернути ні;
    }

    якщо перевірити_чи_дробове_нуль(а) {
      вернути ініціалізувати_дробове_нуль(виділяч, вихід);
    }

    змінна частка: Дробове;
    якщо не поділити_дробові(виділяч, а, б, точність, частка::адреса) {
      вернути ні;
    }

    змінна обрізана_частка: Дробове;
    якщо не обрізати_дробове(виділяч, частка, обрізана_частка::адреса) {
      звільнити_дробове(виділяч, частка);
      вернути ні;
    }
    звільнити_дробове(виділяч, частка);

    змінна добуток: Дробове;
    якщо не помножити_дробові(виділяч, обрізана_частка, б, точність, добуток::адреса) {
      звільнити_дробове(виділяч, обрізана_частка);
      вернути ні;
    }
    звільнити_дробове(виділяч, обрізана_частка);

    якщо не відняти_дробові(виділяч, а, добуток, точність, вихід) {
      звільнити_дробове(виділяч, добуток);
      вернути ні;
    }
    звільнити_дробове(виділяч, добуток);

    вернути так;
  }

  місцева дія абсолютне_дробове(
    виділяч: адреса<Виділяч>,
    значення: Дробове,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо не клонувати_дробове(виділяч, значення, вихід) {
      вернути ні;
    }
    якщо перевірити_чи_ціле_відʼємне(вихід.мантиса) {
      вихід.мантиса.розмір = -вихід.мантиса.розмір;
    }
    вернути так;
  }

  дія корінь_квадратний_д64(
    значення: д64
  ) -> д64 {
  }

  дія перетворити_дробове_в_ц64(
    виділяч: адреса<Виділяч>,
    значення: Дробове,
    вихід: адреса<ц64>
  ) -> логічне {
    якщо перевірити_чи_ціле_нуль(значення.мантиса) {
      вихід::вміст = 0;
      вернути так;
    }

    змінна обрізане: Дробове;
    якщо не обрізати_дробове(виділяч, значення, обрізане::адреса) {
      вернути ні;
    }

    змінна відʼємне = перевірити_чи_ціле_відʼємне(обрізане.мантиса);

    змінна мантиса_кд: кд;
    якщо не перетворити_ціле_в_кд(виділяч, обрізане.мантиса, мантиса_кд::адреса) {
      звільнити_дробове(виділяч, обрізане);
      вернути ні;
    }

    змінна результат: ц64 = 0;
    змінна початок: природне = 0;
    якщо відʼємне {
      початок = 1;
    }

    змінна п: природне = початок;
    поки п < мантиса_кд.розмір {
      результат = результат * 10 + ц64(мантиса_кд.дані[п]);
      п += 1;
    }

    звільнити_памʼять(виділяч, мантиса_кд.дані);

    змінна експ = обрізане.експонента;
    звільнити_дробове(виділяч, обрізане);

    поки експ > 0 {
      результат = результат * 10;
      експ -= 1;
    }

    якщо відʼємне {
      результат = ц64(0) - результат;
    }

    вихід::вміст = результат;
    вернути так;
  }

  місцева дія степінь_дробового(
    виділяч: адреса<Виділяч>,
    основа: Дробове,
    показник: Дробове,
    точність: ц32,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо перевірити_чи_дробове_нуль(показник) {
      вернути ініціалізувати_дробове_один(виділяч, вихід);
    }

    якщо перевірити_чи_дробове_нуль(основа) {
      якщо перевірити_чи_дробове_відʼємне(показник) {
        вернути ні;
      }
      вернути ініціалізувати_дробове_нуль(виділяч, вихід);
    }

    змінна обрізаний_показник: Дробове;
    якщо не обрізати_дробове(виділяч, показник, обрізаний_показник::адреса) {
      вернути ні;
    }

    змінна різниця: Дробове;
    якщо не відняти_дробові(виділяч, показник, обрізаний_показник, точність, різниця::адреса) {
      звільнити_дробове(виділяч, обрізаний_показник);
      вернути ні;
    }

    змінна є_ціле = перевірити_чи_дробове_нуль(різниця);
    звільнити_дробове(виділяч, різниця);

    якщо є_ціле {
      змінна показник_ц64: ц64;
      якщо не перетворити_дробове_в_ц64(виділяч, обрізаний_показник, показник_ц64::адреса) {
        звільнити_дробове(виділяч, обрізаний_показник);
        вернути ні;
      }
      звільнити_дробове(виділяч, обрізаний_показник);
      вернути степінь_дробового_і_ц64(виділяч, основа, показник_ц64, точність, вихід);
    }
    звільнити_дробове(виділяч, обрізаний_показник);

    якщо перевірити_чи_дробове_відʼємне(основа) {
      вернути ні;
    }

    змінна робоча_точність = точність + 20;

    змінна логарифм_основи: Дробове;
    якщо не натуральний_логарифм_дробового(виділяч, основа, робоча_точність, логарифм_основи::адреса) {
      вернути ні;
    }

    змінна добуток: Дробове;
    якщо не помножити_дробові(виділяч, показник, логарифм_основи, робоча_точність, добуток::адреса) {
      звільнити_дробове(виділяч, логарифм_основи);
      вернути ні;
    }
    звільнити_дробове(виділяч, логарифм_основи);

    якщо не експонента_дробового(виділяч, добуток, робоча_точність, вихід) {
      звільнити_дробове(виділяч, добуток);
      вернути ні;
    }
    звільнити_дробове(виділяч, добуток);

    // Округлюємо результат до потрібної точності
    якщо не округлити_до_точності(виділяч, вихід, точність) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    вернути так;
  }

  місцева дія експонента_дробового(
    виділяч: адреса<Виділяч>,
    х: Дробове,
    точність: ц32,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо перевірити_чи_дробове_нуль(х) {
      вернути ініціалізувати_дробове_один(виділяч, вихід);
    }

    змінна один: Дробове;
    якщо не ініціалізувати_дробове_один(виділяч, один::адреса) {
      вернути ні;
    }

    змінна два: Дробове;
    якщо не ініціалізувати_дробове_з_ц64(виділяч, 2, два::адреса) {
      звільнити_дробове(виділяч, один);
      вернути ні;
    }

    змінна редукції: ц64 = 0;
    змінна поточний_х: Дробове;
    якщо не клонувати_дробове(виділяч, х, поточний_х::адреса) {
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, два);
      вернути ні;
    }

    змінна абс_х: Дробове;
    якщо не абсолютне_значення_дробового(виділяч, поточний_х, абс_х::адреса) {
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, два);
      звільнити_дробове(виділяч, поточний_х);
      вернути ні;
    }

    поки порівняти_дробові(виділяч, абс_х, один) > 0 {
      змінна темп: Дробове;
      якщо не поділити_дробові(виділяч, поточний_х, два, точність, темп::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, поточний_х);
        звільнити_дробове(виділяч, абс_х);
        вернути ні;
      }
      звільнити_дробове(виділяч, поточний_х);
      поточний_х = темп;

      звільнити_дробове(виділяч, абс_х);
      якщо не абсолютне_значення_дробового(виділяч, поточний_х, абс_х::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, поточний_х);
        вернути ні;
      }
      редукції += 1;
    }
    звільнити_дробове(виділяч, абс_х);
    звільнити_дробове(виділяч, один);

    змінна сума: Дробове;
    якщо не ініціалізувати_дробове_один(виділяч, сума::адреса) {
      звільнити_дробове(виділяч, два);
      звільнити_дробове(виділяч, поточний_х);
      вернути ні;
    }

    змінна член: Дробове;
    якщо не ініціалізувати_дробове_один(виділяч, член::адреса) {
      звільнити_дробове(виділяч, два);
      звільнити_дробове(виділяч, поточний_х);
      звільнити_дробове(виділяч, сума);
      вернути ні;
    }

    змінна н: ц64 = 1;
    поки н <= ц64(точність) * 3 {
      змінна темп: Дробове;
      якщо не помножити_дробові(виділяч, член, поточний_х, точність, темп::адреса) {
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, поточний_х);
        звільнити_дробове(виділяч, сума);
        звільнити_дробове(виділяч, член);
        вернути ні;
      }
      звільнити_дробове(виділяч, член);

      змінна н_дроб: Дробове;
      якщо не ініціалізувати_дробове_з_ц64(виділяч, н, н_дроб::адреса) {
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, поточний_х);
        звільнити_дробове(виділяч, сума);
        звільнити_дробове(виділяч, темп);
        вернути ні;
      }

      якщо не поділити_дробові(виділяч, темп, н_дроб, точність, член::адреса) {
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, поточний_х);
        звільнити_дробове(виділяч, сума);
        звільнити_дробове(виділяч, темп);
        звільнити_дробове(виділяч, н_дроб);
        вернути ні;
      }
      звільнити_дробове(виділяч, темп);
      звільнити_дробове(виділяч, н_дроб);

      // сума += член
      змінна нова_сума: Дробове;
      якщо не додати_дробові(виділяч, сума, член, точність, нова_сума::адреса) {
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, поточний_х);
        звільнити_дробове(виділяч, сума);
        звільнити_дробове(виділяч, член);
        вернути ні;
      }
      звільнити_дробове(виділяч, сума);
      сума = нова_сума;

      н += 1;
    }

    звільнити_дробове(виділяч, поточний_х);
    звільнити_дробове(виділяч, член);
    звільнити_дробове(виділяч, два);

    // Піднесення до квадрату редукції разів
    змінна й: ц64 = 0;
    поки й < редукції {
      змінна квадрат: Дробове;
      якщо не помножити_дробові(виділяч, сума, сума, точність, квадрат::адреса) {
        звільнити_дробове(виділяч, сума);
        вернути ні;
      }
      звільнити_дробове(виділяч, сума);
      сума = квадрат;
      й += 1;
    }

    вихід.мантиса = сума.мантиса;
    вихід.експонента = сума.експонента;

    якщо не округлити_до_точності(виділяч, вихід, точність) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    вернути так;
  }

  місцева дія натуральний_логарифм_дробового(
    виділяч: адреса<Виділяч>,
    х: Дробове,
    точність: ц32,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо перевірити_чи_дробове_нуль(х) або перевірити_чи_дробове_відʼємне(х) {
      вернути ні;
    }

    змінна один: Дробове;
    якщо не ініціалізувати_дробове_один(виділяч, один::адреса) {
      вернути ні;
    }

    змінна два: Дробове;
    якщо не ініціалізувати_дробове_з_ц64(виділяч, 2, два::адреса) {
      звільнити_дробове(виділяч, один);
      вернути ні;
    }

    змінна половина: Дробове;
    якщо не ініціалізувати_дробове_з_кд(виділяч, "0.5", половина::адреса) {
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, два);
      вернути ні;
    }

    змінна масштаб: ц64 = 0;
    змінна поточний_х: Дробове;
    якщо не клонувати_дробове(виділяч, х, поточний_х::адреса) {
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, два);
      звільнити_дробове(виділяч, половина);
      вернути ні;
    }

    поки порівняти_дробові(виділяч, поточний_х, два) >= 0 {
      змінна темп: Дробове;
      якщо не поділити_дробові(виділяч, поточний_х, два, точність, темп::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, половина);
        звільнити_дробове(виділяч, поточний_х);
        вернути ні;
      }
      звільнити_дробове(виділяч, поточний_х);
      поточний_х = темп;
      масштаб += 1;
    }

    поки порівняти_дробові(виділяч, поточний_х, половина) < 0 {
      змінна темп: Дробове;
      якщо не помножити_дробові(виділяч, поточний_х, два, точність, темп::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, половина);
        звільнити_дробове(виділяч, поточний_х);
        вернути ні;
      }
      звільнити_дробове(виділяч, поточний_х);
      поточний_х = темп;
      масштаб -= 1;
    }
    звільнити_дробове(виділяч, половина);

    змінна х_мінус_один: Дробове;
    якщо не відняти_дробові(виділяч, поточний_х, один, точність, х_мінус_один::адреса) {
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, два);
      звільнити_дробове(виділяч, поточний_х);
      вернути ні;
    }

    змінна х_плюс_один: Дробове;
    якщо не додати_дробові(виділяч, поточний_х, один, точність, х_плюс_один::адреса) {
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, два);
      звільнити_дробове(виділяч, поточний_х);
      звільнити_дробове(виділяч, х_мінус_один);
      вернути ні;
    }
    звільнити_дробове(виділяч, поточний_х);

    змінна у: Дробове;
    якщо не поділити_дробові(виділяч, х_мінус_один, х_плюс_один, точність, у::адреса) {
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, два);
      звільнити_дробове(виділяч, х_мінус_один);
      звільнити_дробове(виділяч, х_плюс_один);
      вернути ні;
    }
    звільнити_дробове(виділяч, х_мінус_один);
    звільнити_дробове(виділяч, х_плюс_один);

    змінна у_квадрат: Дробове;
    якщо не помножити_дробові(виділяч, у, у, точність, у_квадрат::адреса) {
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, два);
      звільнити_дробове(виділяч, у);
      вернути ні;
    }

    змінна сума: Дробове;
    якщо не клонувати_дробове(виділяч, у, сума::адреса) {
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, два);
      звільнити_дробове(виділяч, у);
      звільнити_дробове(виділяч, у_квадрат);
      вернути ні;
    }

    змінна у_степінь: Дробове;
    якщо не клонувати_дробове(виділяч, у, у_степінь::адреса) {
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, два);
      звільнити_дробове(виділяч, у);
      звільнити_дробове(виділяч, у_квадрат);
      звільнити_дробове(виділяч, сума);
      вернути ні;
    }

    змінна к: ц64 = 1;
    поки к < ц64(точність) * 2 {
      змінна темп: Дробове;
      якщо не помножити_дробові(виділяч, у_степінь, у_квадрат, точність, темп::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, у);
        звільнити_дробове(виділяч, у_квадрат);
        звільнити_дробове(виділяч, сума);
        звільнити_дробове(виділяч, у_степінь);
        вернути ні;
      }
      звільнити_дробове(виділяч, у_степінь);
      у_степінь = темп;

      змінна дільник_ц64: ц64 = ц64(2) * к + 1;
      змінна дільник: Дробове;
      якщо не ініціалізувати_дробове_з_ц64(виділяч, дільник_ц64, дільник::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, у);
        звільнити_дробове(виділяч, у_квадрат);
        звільнити_дробове(виділяч, сума);
        звільнити_дробове(виділяч, у_степінь);
        вернути ні;
      }

      змінна доданок: Дробове;
      якщо не поділити_дробові(виділяч, у_степінь, дільник, точність, доданок::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, у);
        звільнити_дробове(виділяч, у_квадрат);
        звільнити_дробове(виділяч, сума);
        звільнити_дробове(виділяч, у_степінь);
        звільнити_дробове(виділяч, дільник);
        вернути ні;
      }
      звільнити_дробове(виділяч, дільник);

      змінна нова_сума: Дробове;
      якщо не додати_дробові(виділяч, сума, доданок, точність, нова_сума::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, у);
        звільнити_дробове(виділяч, у_квадрат);
        звільнити_дробове(виділяч, сума);
        звільнити_дробове(виділяч, у_степінь);
        звільнити_дробове(виділяч, доданок);
        вернути ні;
      }
      звільнити_дробове(виділяч, сума);
      звільнити_дробове(виділяч, доданок);
      сума = нова_сума;

      к += 1;
    }

    звільнити_дробове(виділяч, у);
    звільнити_дробове(виділяч, у_квадрат);
    звільнити_дробове(виділяч, у_степінь);

    змінна лн_х: Дробове;
    якщо не помножити_дробові(виділяч, два, сума, точність, лн_х::адреса) {
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, два);
      звільнити_дробове(виділяч, сума);
      вернути ні;
    }
    звільнити_дробове(виділяч, сума);

    якщо масштаб != 0 {
      змінна лн2_х: Дробове;
      якщо не клонувати_дробове(виділяч, два, лн2_х::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, лн_х);
        вернути ні;
      }

      змінна лн2_х_мінус_один: Дробове;
      якщо не відняти_дробові(виділяч, лн2_х, один, точність, лн2_х_мінус_один::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, лн_х);
        звільнити_дробове(виділяч, лн2_х);
        вернути ні;
      }

      змінна лн2_х_плюс_один: Дробове;
      якщо не додати_дробові(виділяч, лн2_х, один, точність, лн2_х_плюс_один::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, лн_х);
        звільнити_дробове(виділяч, лн2_х);
        звільнити_дробове(виділяч, лн2_х_мінус_один);
        вернути ні;
      }
      звільнити_дробове(виділяч, лн2_х);

      змінна лн2_у: Дробове;
      якщо не поділити_дробові(виділяч, лн2_х_мінус_один, лн2_х_плюс_один, точність, лн2_у::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, лн_х);
        звільнити_дробове(виділяч, лн2_х_мінус_один);
        звільнити_дробове(виділяч, лн2_х_плюс_один);
        вернути ні;
      }
      звільнити_дробове(виділяч, лн2_х_мінус_один);
      звільнити_дробове(виділяч, лн2_х_плюс_один);

      змінна лн2_у_квадрат: Дробове;
      якщо не помножити_дробові(виділяч, лн2_у, лн2_у, точність, лн2_у_квадрат::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, лн_х);
        звільнити_дробове(виділяч, лн2_у);
        вернути ні;
      }

      змінна лн2_сума: Дробове;
      якщо не клонувати_дробове(виділяч, лн2_у, лн2_сума::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, лн_х);
        звільнити_дробове(виділяч, лн2_у);
        звільнити_дробове(виділяч, лн2_у_квадрат);
        вернути ні;
      }

      змінна лн2_у_степінь: Дробове;
      якщо не клонувати_дробове(виділяч, лн2_у, лн2_у_степінь::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, лн_х);
        звільнити_дробове(виділяч, лн2_у);
        звільнити_дробове(виділяч, лн2_у_квадрат);
        звільнити_дробове(виділяч, лн2_сума);
        вернути ні;
      }

      змінна лн2_к: ц64 = 1;
      поки лн2_к < ц64(точність) * 2 {
        змінна темп: Дробове;
        якщо не помножити_дробові(виділяч, лн2_у_степінь, лн2_у_квадрат, точність, темп::адреса) {
          звільнити_дробове(виділяч, один);
          звільнити_дробове(виділяч, два);
          звільнити_дробове(виділяч, лн_х);
          звільнити_дробове(виділяч, лн2_у);
          звільнити_дробове(виділяч, лн2_у_квадрат);
          звільнити_дробове(виділяч, лн2_сума);
          звільнити_дробове(виділяч, лн2_у_степінь);
          вернути ні;
        }
        звільнити_дробове(виділяч, лн2_у_степінь);
        лн2_у_степінь = темп;

        змінна дільник_ц64: ц64 = ц64(2) * лн2_к + 1;
        змінна дільник: Дробове;
        якщо не ініціалізувати_дробове_з_ц64(виділяч, дільник_ц64, дільник::адреса) {
          звільнити_дробове(виділяч, один);
          звільнити_дробове(виділяч, два);
          звільнити_дробове(виділяч, лн_х);
          звільнити_дробове(виділяч, лн2_у);
          звільнити_дробове(виділяч, лн2_у_квадрат);
          звільнити_дробове(виділяч, лн2_сума);
          звільнити_дробове(виділяч, лн2_у_степінь);
          вернути ні;
        }

        змінна доданок: Дробове;
        якщо не поділити_дробові(виділяч, лн2_у_степінь, дільник, точність, доданок::адреса) {
          звільнити_дробове(виділяч, один);
          звільнити_дробове(виділяч, два);
          звільнити_дробове(виділяч, лн_х);
          звільнити_дробове(виділяч, лн2_у);
          звільнити_дробове(виділяч, лн2_у_квадрат);
          звільнити_дробове(виділяч, лн2_сума);
          звільнити_дробове(виділяч, лн2_у_степінь);
          звільнити_дробове(виділяч, дільник);
          вернути ні;
        }
        звільнити_дробове(виділяч, дільник);

        змінна нова_лн2_сума: Дробове;
        якщо не додати_дробові(виділяч, лн2_сума, доданок, точність, нова_лн2_сума::адреса) {
          звільнити_дробове(виділяч, один);
          звільнити_дробове(виділяч, два);
          звільнити_дробове(виділяч, лн_х);
          звільнити_дробове(виділяч, лн2_у);
          звільнити_дробове(виділяч, лн2_у_квадрат);
          звільнити_дробове(виділяч, лн2_сума);
          звільнити_дробове(виділяч, лн2_у_степінь);
          звільнити_дробове(виділяч, доданок);
          вернути ні;
        }
        звільнити_дробове(виділяч, лн2_сума);
        звільнити_дробове(виділяч, доданок);
        лн2_сума = нова_лн2_сума;

        лн2_к += 1;
      }

      звільнити_дробове(виділяч, лн2_у);
      звільнити_дробове(виділяч, лн2_у_квадрат);
      звільнити_дробове(виділяч, лн2_у_степінь);

      змінна лн2: Дробове;
      якщо не помножити_дробові(виділяч, два, лн2_сума, точність, лн2::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, лн_х);
        звільнити_дробове(виділяч, лн2_сума);
        вернути ні;
      }
      звільнити_дробове(виділяч, лн2_сума);

      змінна масштаб_дроб: Дробове;
      якщо не ініціалізувати_дробове_з_ц64(виділяч, масштаб, масштаб_дроб::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, лн_х);
        звільнити_дробове(виділяч, лн2);
        вернути ні;
      }

      змінна поправка: Дробове;
      якщо не помножити_дробові(виділяч, масштаб_дроб, лн2, точність, поправка::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, лн_х);
        звільнити_дробове(виділяч, лн2);
        звільнити_дробове(виділяч, масштаб_дроб);
        вернути ні;
      }
      звільнити_дробове(виділяч, лн2);
      звільнити_дробове(виділяч, масштаб_дроб);

      змінна новий_лн_х: Дробове;
      якщо не додати_дробові(виділяч, лн_х, поправка, точність, новий_лн_х::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, два);
        звільнити_дробове(виділяч, лн_х);
        звільнити_дробове(виділяч, поправка);
        вернути ні;
      }
      звільнити_дробове(виділяч, лн_х);
      звільнити_дробове(виділяч, поправка);
      лн_х = новий_лн_х;
    }

    звільнити_дробове(виділяч, один);
    звільнити_дробове(виділяч, два);

    вихід.мантиса = лн_х.мантиса;
    вихід.експонента = лн_х.експонента;

    якщо не округлити_до_точності(виділяч, вихід, точність) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    вернути так;
  }

  місцева дія квадратний_корінь_дробового(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    точність: ц32,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо перевірити_чи_дробове_відʼємне(а) {
      вернути ні;
    }

    якщо перевірити_чи_дробове_нуль(а) {
      вернути ініціалізувати_дробове_нуль(виділяч, вихід);
    }

    змінна наближення_д64: д64;
    якщо не перетворити_дробове_в_д64(виділяч, а, наближення_д64::адреса) {
      вернути ні;
    }

    змінна здогадка: Дробове;
    якщо не ініціалізувати_дробове_з_д64(виділяч, корінь_квадратний_д64(наближення_д64), здогадка::адреса) {
      вернути ні;
    }

    якщо перевірити_чи_дробове_нуль(здогадка) {
      звільнити_дробове(виділяч, здогадка);
      якщо не ініціалізувати_дробове_один(виділяч, здогадка::адреса) {
        вернути ні;
      }
    }

    змінна два: Дробове;
    якщо не ініціалізувати_дробове_з_д64(виділяч, 2.0, два::адреса) {
      звільнити_дробове(виділяч, здогадка);
      вернути ні;
    }

    змінна попереднє: Дробове;
    змінна має_попереднє = ні;

    змінна ітерація: ц32 = 0;
  початок:
    поки ітерація < ц32(точність) + 20 {
      змінна ділення: Дробове;
      якщо не поділити_дробові(виділяч, а, здогадка, точність, ділення::адреса) {
        звільнити_дробове(виділяч, здогадка);
        звільнити_дробове(виділяч, два);
        якщо має_попереднє {
          звільнити_дробове(виділяч, попереднє);
        }
        вернути ні;
      }

      змінна сума: Дробове;
      якщо не додати_дробові(виділяч, здогадка, ділення, точність, сума::адреса) {
        звільнити_дробове(виділяч, ділення);
        звільнити_дробове(виділяч, здогадка);
        звільнити_дробове(виділяч, два);
        якщо має_попереднє {
          звільнити_дробове(виділяч, попереднє);
        }
        вернути ні;
      }
      звільнити_дробове(виділяч, ділення);

      змінна нова_здогадка: Дробове;
      якщо не поділити_дробові(виділяч, сума, два, точність, нова_здогадка::адреса) {
        звільнити_дробове(виділяч, сума);
        звільнити_дробове(виділяч, здогадка);
        звільнити_дробове(виділяч, два);
        якщо має_попереднє {
          звільнити_дробове(виділяч, попереднє);
        }
        вернути ні;
      }
      звільнити_дробове(виділяч, сума);

      якщо має_попереднє і порівняти_дробові(виділяч, здогадка, попереднє) == 0 {
        звільнити_дробове(виділяч, нова_здогадка);
        звільнити_дробове(виділяч, попереднє);
        має_попереднє = ні;
        ітерація += 1;
        стрибнути початок;
      }

      якщо має_попереднє {
        звільнити_дробове(виділяч, попереднє);
      }
      попереднє = здогадка;
      має_попереднє = так;
      здогадка = нова_здогадка;

      ітерація += 1;
    }

  далі:
    якщо має_попереднє {
      звільнити_дробове(виділяч, попереднє);
    }
    звільнити_дробове(виділяч, два);

    вихід.мантиса = здогадка.мантиса;
    вихід.експонента = здогадка.експонента;

    якщо не округлити_до_точності(виділяч, вихід, точність) {
      звільнити_ціле(виділяч, вихід.мантиса);
      вернути ні;
    }

    вернути так;
  }

  місцева дія степінь_дробового_і_ц64(
    виділяч: адреса<Виділяч>,
    основа: Дробове,
    степінь: ц64,
    точність: ц32,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо степінь == 0 {
      вернути ініціалізувати_дробове_один(виділяч, вихід);
    }

    змінна відʼємний_степінь = степінь < 0;
    змінна абсол_степінь: п64;
    якщо відʼємний_степінь {
      абсол_степінь = п64((-(степінь + 1)) + 1);
    } інакше {
      абсол_степінь = п64(степінь);
    }

    змінна результат: Дробове;
    якщо не ініціалізувати_дробове_один(виділяч, результат::адреса) {
      вернути ні;
    }

    змінна б: Дробове;
    якщо не клонувати_дробове(виділяч, основа, б::адреса) {
      звільнити_дробове(виділяч, результат);
      вернути ні;
    }

    поки абсол_степінь > 0 {
      якщо (абсол_степінь & 1) != 0 {
        змінна темп: Дробове;
        якщо не помножити_дробові(виділяч, результат, б, точність, темп::адреса) {
          звільнити_дробове(виділяч, результат);
          звільнити_дробове(виділяч, б);
          вернути ні;
        }
        звільнити_дробове(виділяч, результат);
        результат = темп;
      }

      змінна б_квадрат: Дробове;
      якщо не помножити_дробові(виділяч, б, б, точність, б_квадрат::адреса) {
        звільнити_дробове(виділяч, результат);
        звільнити_дробове(виділяч, б);
        вернути ні;
      }
      звільнити_дробове(виділяч, б);
      б = б_квадрат;

      абсол_степінь = абсол_степінь >> 1;
    }

    звільнити_дробове(виділяч, б);

    якщо відʼємний_степінь {
      змінна один: Дробове;
      якщо не ініціалізувати_дробове_один(виділяч, один::адреса) {
        звільнити_дробове(виділяч, результат);
        вернути ні;
      }

      змінна обернене: Дробове;
      якщо не поділити_дробові(виділяч, один, результат, точність, обернене::адреса) {
        звільнити_дробове(виділяч, один);
        звільнити_дробове(виділяч, результат);
        вернути ні;
      }
      звільнити_дробове(виділяч, один);
      звільнити_дробове(виділяч, результат);
      результат = обернене;
    }

    вихід.мантиса = результат.мантиса;
    вихід.експонента = результат.експонента;

    вернути так;
  }

  місцева дія підлога_дробового(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо а.експонента >= 0 {
      вернути клонувати_дробове(виділяч, а, вихід);
    }

    змінна дільник: Ціле;
    якщо не ініціалізувати_ціле_один(виділяч, дільник::адреса) {
      вернути ні;
    }

    змінна десять: Ціле;
    якщо не ініціалізувати_ціле_з_п64(виділяч, 10, десять::адреса) {
      звільнити_ціле(виділяч, дільник);
      вернути ні;
    }

    змінна п: ц32 = 0;
    поки п < (-а.експонента) {
      змінна новий_діл: Ціле;
      якщо не помножити_цілі(виділяч, дільник, десять, новий_діл::адреса) {
        звільнити_ціле(виділяч, дільник);
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }
      звільнити_ціле(виділяч, дільник);
      дільник = новий_діл;
      п += 1;
    }

    змінна нова_мантиса: Ціле;
    якщо не поділити_цілі(виділяч, а.мантиса, дільник, нова_мантиса::адреса) {
      звільнити_ціле(виділяч, дільник);
      звільнити_ціле(виділяч, десять);
      вернути ні;
    }

    якщо перевірити_чи_ціле_відʼємне(а.мантиса) {
      змінна залишок: Ціле;
      якщо не залишок_ділення_цілих(виділяч, а.мантиса, дільник, залишок::адреса) {
        звільнити_ціле(виділяч, нова_мантиса);
        звільнити_ціле(виділяч, дільник);
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }

      якщо не перевірити_чи_ціле_нуль(залишок) {
        змінна один: Ціле;
        якщо не ініціалізувати_ціле_один(виділяч, один::адреса) {
          звільнити_ціле(виділяч, залишок);
          звільнити_ціле(виділяч, нова_мантиса);
          звільнити_ціле(виділяч, дільник);
          звільнити_ціле(виділяч, десять);
          вернути ні;
        }

        змінна темп: Ціле;
        якщо не відняти_цілі(виділяч, нова_мантиса, один, темп::адреса) {
          звільнити_ціле(виділяч, один);
          звільнити_ціле(виділяч, залишок);
          звільнити_ціле(виділяч, нова_мантиса);
          звільнити_ціле(виділяч, дільник);
          звільнити_ціле(виділяч, десять);
          вернути ні;
        }
        звільнити_ціле(виділяч, нова_мантиса);
        нова_мантиса = темп;
        звільнити_ціле(виділяч, один);
      }
      звільнити_ціле(виділяч, залишок);
    }

    звільнити_ціле(виділяч, дільник);
    звільнити_ціле(виділяч, десять);

    вихід.мантиса = нова_мантиса;
    вихід.експонента = 0;

    вернути так;
  }

  місцева дія стеля_дробового(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    вихід: адреса<Дробове>
  ) -> логічне {
    змінна негативне: Дробове;
    якщо не мінус_дробове(виділяч, а, негативне::адреса) {
      вернути ні;
    }

    змінна підлога_негативного: Дробове;
    якщо не підлога_дробового(виділяч, негативне, підлога_негативного::адреса) {
      звільнити_дробове(виділяч, негативне);
      вернути ні;
    }

    змінна результат: Дробове;
    якщо не мінус_дробове(виділяч, підлога_негативного, результат::адреса) {
      звільнити_дробове(виділяч, негативне);
      звільнити_дробове(виділяч, підлога_негативного);
      вернути ні;
    }

    звільнити_дробове(виділяч, негативне);
    звільнити_дробове(виділяч, підлога_негативного);

    вихід.мантиса = результат.мантиса;
    вихід.експонента = результат.експонента;

    вернути так;
  }

  місцева дія обрізати_дробове(
    виділяч: адреса<Виділяч>,
    а: Дробове,
    вихід: адреса<Дробове>
  ) -> логічне {
    якщо а.експонента >= 0 {
      вернути клонувати_дробове(виділяч, а, вихід);
    }

    змінна дільник: Ціле;
    якщо не ініціалізувати_ціле_один(виділяч, дільник::адреса) {
      вернути ні;
    }

    змінна десять: Ціле;
    якщо не ініціалізувати_ціле_з_п64(виділяч, 10, десять::адреса) {
      звільнити_ціле(виділяч, дільник);
      вернути ні;
    }

    змінна п: ц32 = 0;
    поки п < (-а.експонента) {
      змінна новий_діл: Ціле;
      якщо не помножити_цілі(виділяч, дільник, десять, новий_діл::адреса) {
        звільнити_ціле(виділяч, дільник);
        звільнити_ціле(виділяч, десять);
        вернути ні;
      }
      звільнити_ціле(виділяч, дільник);
      дільник = новий_діл;
      п += 1;
    }

    змінна нова_мантиса: Ціле;
    якщо не поділити_цілі(виділяч, а.мантиса, дільник, нова_мантиса::адреса) {
      звільнити_ціле(виділяч, дільник);
      звільнити_ціле(виділяч, десять);
      вернути ні;
    }

    звільнити_ціле(виділяч, дільник);
    звільнити_ціле(виділяч, десять);

    вихід.мантиса = нова_мантиса;
    вихід.експонента = 0;

    вернути так;
  }
}