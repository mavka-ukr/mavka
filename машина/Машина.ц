взяти означення мавка/машина;

простір мавка {
  дія рідна_дія_методу_структури_Предмет__чародія_текст(
    М: адреса<Машина>,
    здійснювач: адреса<Предмет>,
    предмет_дії: адреса<ПредметДії>,
    задіяні: Задіяні
  ) -> ПредметАбоСтанПадіння {
    якщо здійснювач == пусто {
      вернути М.константи_назв._недійсне як адреса<Предмет>;
    }

    якщо здійснювач == М.значення_дійсне {
      вернути М.константи_назв._дійсне як адреса<Предмет>;
    }

    змінна накопичувач_тексту = зробити_накопичувач_тексту(М, 16);

    покласти_в_накопичувач_тексту(М, накопичувач_тексту::адреса, "<");

    змінна предмет_здійснювача = здійснювач;

    якщо предмет_здійснювача.тип.назва != пусто {
      покласти_в_накопичувач_тексту(М, накопичувач_тексту::адреса, предмет_здійснювача.тип.назва.значення);
    }

    покласти_в_накопичувач_тексту(М, накопичувач_тексту::адреса, ">");

    вернути створити_текст_без_копіювання(
      М,
      накопичувач_тексту.розмір,
      накопичувач_тексту.дані
    ) як адреса<Предмет>;
  }

  дія записати_метод_структури_Предмет__чародія_текст(
    М: адреса<Машина>
   ) {
    змінна предмет_дії = створити_рідну_дію(
      М,
      М.константи_назв._чародія_текст,
      М.предмет_пустої_послідовності,
      пусто,
      рідна_дія_методу_структури_Предмет__чародія_текст,
      пусто
    );

    записати_метод_структури(
      М,
      М.предмет_структури_Предмет,
      М.константи_назв._чародія_текст,
      предмет_дії
    );

    якщо М.стан_падіння {
      запанікувати(М, "Помилка при записі дії \"чародія_текст\" для структури \"Предмет\".");
    }
  }

  дія заповнити_структуру_Предмет(
    М: адреса<Машина>
  ) {
    записати_метод_структури_Предмет__чародія_текст(М);
  }
}

простір мавка {
  місцева дія налаштувати_машину(
    М: адреса<Машина>,
    налаштування: Налаштування
  ) {
    М.налаштування = налаштування;

    М.глобальна_дійсність = виділити<Дійсність>(М);
    М.глобальна_дійсність.попередня = пусто;
    М.глобальна_дійсність.наступна = пусто;
    М.глобальна_дійсність.позначено = ні;
    М.глобальна_дійсність.кількість_запозичень = 1;
    М.глобальна_дійсність.зовні = пусто;
    М.глобальна_дійсність.властивості = Властивості { 0, пусто, 0 };
    М.перша_дійсність = М.глобальна_дійсність;
    М.остання_дійсність = М.глобальна_дійсність;

    стала вмісткість_накопичувача_значень = 1024;
    М.накопичувач_значень = НакопичувачЗначень {
      розмір = 0,
      дані = виділити_памʼять<адреса<Предмет>>(М, вмісткість_накопичувача_значень),
      вмісткість = вмісткість_накопичувача_значень
    };

    стала вмісткість_історії_здійснення = 1024;
    М.історія_здійснення = ІсторіяЗдійснення {
      розмір = 0,
      дані = виділити_памʼять<ЕлементІсторіїЗдійснення>(М, вмісткість_історії_здійснення),
      вмісткість = вмісткість_історії_здійснення
    };

    М.стан_падіння = ні;
    М.значення_падіння = пусто;
    М.місцезнаходження_падіння = Місцезнаходження { пусто, 0 };

    М.взяті_значення = ВзятіЗначення {
      0,
      пусто
    };

    М.користувацькі_дані_пристрою = пусто;
    М.користувацькі_дані_бібліотеки = пусто;

    М.черга_здійснення = ЧергаЗдійснення { пусто, пусто };

    М.глобальний_притримувач = виділити<Притримувач>(М);
    М.глобальний_притримувач.попередній = пусто;
    М.глобальний_притримувач.наступний = пусто;
    М.глобальний_притримувач.перше = пусто;
    М.глобальний_притримувач.останнє = пусто;
    М.останній_притримувач = М.глобальний_притримувач;

    // поки що воно втілено як структура, хоча структурою не є
    // потім треба зробити якось інакше
    змінна дійсне = виділити<ПредметСтруктури>(М);
    дійсне.наступний = пусто;
    дійсне.позначено = ні;
    дійсне.тип = дійсне;
    дійсне.користувацькі_дані = пусто;
    дійсне.заборонити_наслідування = так;
    дійсне.назва = пусто;
    дійсне.предок = пусто;
    дійсне.параметри = пусто;
    дійсне.методи = Методи { 0, пусто };
    дійсне.властивості = Властивості { 0, пусто, 0 };
    М.значення_дійсне = дійсне як адреса<Предмет>;

    М.предмет_структури_Предмет = виділити<ПредметСтруктури>(М);
    М.предмет_структури_Предмет.наступний = пусто;
    М.предмет_структури_Предмет.позначено = ні;
    М.предмет_структури_Предмет.тип = пусто;
    М.предмет_структури_Предмет.користувацькі_дані = пусто;
    М.предмет_структури_Предмет.заборонити_наслідування = ні;
    М.предмет_структури_Предмет.назва = пусто;
    М.предмет_структури_Предмет.предок = пусто;
    М.предмет_структури_Предмет.параметри = пусто;
    М.предмет_структури_Предмет.методи = Методи { 0, пусто };
    М.предмет_структури_Предмет.властивості = Властивості { 0, пусто, 0 };
    М.перший_предмет = М.предмет_структури_Предмет як адреса<Предмет>;
    М.останній_предмет = М.предмет_структури_Предмет як адреса<Предмет>;
    М.кількість_дійсних = 1;
    М.кількість_дійсних_для_очищення = 100;
    М.потребує_очищення = ні;

    М.предмет_структури_Структура = створити_структуру(М, пусто, М.предмет_структури_Предмет, пусто);
    М.предмет_структури_Структура.тип = М.предмет_структури_Структура;
    М.предмет_структури_Предмет.тип = М.предмет_структури_Структура;
    М.предмет_структури_Предмет.предок = пусто;

    М.предмет_структури_Текст = створити_структуру(М, пусто, М.предмет_структури_Предмет, пусто);

    М.константи_назв = КонстантиНазв {
      _значення = створити_текст(М, "значення"),
      _недійсне = створити_текст(М, "недійсне"),
      _дійсне = створити_текст(М, "дійсне"),
      _Послідовність = створити_текст(М, "Послідовність"),
      _дійсність = створити_текст(М, "дійсність"),
      _Предмет = створити_текст(М, "Предмет"),
      _Структура = створити_текст(М, "Структура"),
      _Модуль = створити_текст(М, "Модуль"),
      _Параметр = створити_текст(М, "Параметр"),
      _Число = створити_текст(М, "Число"),
      _Ціле = створити_текст(М, "Ціле"),
      _Дробове = створити_текст(М, "Дробове"),
      _Текст = створити_текст(М, "Текст"),
      _Код = створити_текст(М, "Код"),
      _Дія = створити_текст(М, "Дія"),
      _Список = створити_текст(М, "Список"),
      _Словник = створити_текст(М, "Словник"),
      _Дані = створити_текст(М, "Дані"),
      _ДіапазонЦілих = створити_текст(М, "ДіапазонЦілих"),
      _ДіапазонДробових = створити_текст(М, "ДіапазонДробових"),
      _ПеребірДіапазонуЦілих = створити_текст(М, "ПеребірДіапазонуЦілих"),
      _ПеребірДіапазонуДробових = створити_текст(М, "ПеребірДіапазонуДробових"),
      _ПеребірСписку = створити_текст(М, "ПеребірСписку"),
      _далі = створити_текст(М, "далі"),
      _з = створити_текст(М, "з"),
      _довжина = створити_текст(М, "довжина"),
      _0 = створити_текст(М, "0"),
      _1 = створити_текст(М, "1"),
      _модуль = створити_текст(М, "модуль"),
      _пак = створити_текст(М, "пак"),
      _біб = створити_текст(М, "біб"),
      _математика = створити_текст(М, "математика"),
      _читати = створити_текст(М, "читати"),
      _перед = створити_текст(М, "перед"),
      _розмір = створити_текст(М, "розмір"),
      _чародія = створити_текст(М, "чародія"),
      _чародія_ціле = створити_текст(М, "чародія_ціле"),
      _чародія_дробове = створити_текст(М, "чародія_дробове"),
      _чародія_текст = створити_текст(М, "чародія_текст"),
      _чародія_діапазон = створити_текст(М, "чародія_діапазон"),
      _чародія_перебір = створити_текст(М, "чародія_перебір"),
      _дія_перевірки = створити_текст(М, "дія_перевірки"),
      _дія_перетворення = створити_текст(М, "дія_перетворення"),
      _додати = створити_текст(М, "додати"),
      _забрати = створити_текст(М, "забрати"),
      _знайти = створити_текст(М, "знайти"),
      _знайти_позицію = створити_текст(М, "знайти_позицію"),
      _фільтрований = створити_текст(М, "фільтрований"),
      _перетворений = створити_текст(М, "перетворений"),
      _обернений = створити_текст(М, "обернений"),
      _містить = створити_текст(М, "містить"),
      _ключ = створити_текст(М, "ключ"),
      _ключі = створити_текст(М, "ключі"),
      _список = створити_текст(М, "список"),
      _словник = створити_текст(М, "словник"),
      _послідовність = створити_текст(М, "послідовність"),
      _дані = створити_текст(М, "дані"),
      _діапазон = створити_текст(М, "діапазон"),
      _ПеребірПослідовності = створити_текст(М, "ПеребірПослідовності"),
      _ПеребірДаних = створити_текст(М, "ПеребірДаних"),
      _назва = створити_текст(М, "назва"),
      _параметри = створити_текст(М, "параметри"),
      _тип_результату = створити_текст(М, "тип_результату"),
      _код = створити_текст(М, "код"),
      _константи = створити_текст(М, "константи"),
      _вказівки = створити_текст(М, "вказівки"),
      _шлях = створити_текст(М, "шлях"),
      _ПеребірСловника = створити_текст(М, "ПеребірСловника"),
      _предок = створити_текст(М, "предок"),
      _Е = створити_текст(М, "Е"),
      _ПІ = створити_текст(М, "ПІ"),
      _ЛОГ2Е = створити_текст(М, "ЛОГ2Е"),
      _ЛОГ10Е = створити_текст(М, "ЛОГ10Е"),
      _ЛОГ2 = створити_текст(М, "ЛОГ2"),
      _ЛОГ10 = створити_текст(М, "ЛОГ10"),
      _КОРІНЬ2 = створити_текст(М, "КОРІНЬ2"),
      _КОРІНЬ1_2 = створити_текст(М, "КОРІНЬ1_2"),
      _синус = створити_текст(М, "синус"),
      _косинус = створити_текст(М, "косинус"),
      _тангенс = створити_текст(М, "тангенс"),
      _арксинус = створити_текст(М, "арксинус"),
      _арккосинус = створити_текст(М, "арккосинус"),
      _арктангенс = створити_текст(М, "арктангенс"),
      _арктангенс2 = створити_текст(М, "арктангенс2"),
      _абсолютне = створити_текст(М, "абсолютне"),
      _експонента = створити_текст(М, "експонента"),
      _корінь = створити_текст(М, "корінь"),
      _стеля = створити_текст(М, "стеля"),
      _підлога = створити_текст(М, "підлога"),
      _округлити = створити_текст(М, "округлити"),
      _ПеребірТексту = створити_текст(М, "ПеребірТексту"),
      _текст = створити_текст(М, "текст"),
    };

    М.предмет_структури_Послідовність = створити_структуру(М, М.константи_назв._Послідовність, М.предмет_структури_Предмет, пусто);
    М.предмет_пустої_послідовності = створити_послідовність_без_копіювання(М, 0, пусто);

    М.предмет_структури_Послідовність.параметри = М.предмет_пустої_послідовності;
    М.предмет_структури_Предмет.параметри = М.предмет_пустої_послідовності;
    М.предмет_структури_Структура.параметри = М.предмет_пустої_послідовності;
    М.предмет_структури_Текст.параметри = М.предмет_пустої_послідовності;

    М.предмет_структури_Предмет.назва = М.константи_назв._Предмет;
    М.предмет_структури_Структура.назва = М.константи_назв._Структура;
    М.предмет_структури_Текст.назва = М.константи_назв._Текст;

    М.предмет_структури_Число = створити_структуру(М, М.константи_назв._Число, М.предмет_структури_Предмет, М.предмет_пустої_послідовності);
    М.предмет_структури_Ціле = створити_структуру(М, М.константи_назв._Ціле, М.предмет_структури_Число, М.предмет_пустої_послідовності);
    М.предмет_структури_Дробове = створити_структуру(М, М.константи_назв._Дробове, М.предмет_структури_Число, М.предмет_пустої_послідовності);
    М.предмет_структури_Дані = створити_структуру(М, М.константи_назв._Дані, М.предмет_структури_Предмет, М.предмет_пустої_послідовності);
    М.предмет_структури_Параметр = створити_структуру(М, М.константи_назв._Параметр, М.предмет_структури_Предмет, М.предмет_пустої_послідовності);
    М.предмет_структури_Код = створити_структуру(М, М.константи_назв._Код, М.предмет_структури_Предмет, М.предмет_пустої_послідовності);
    М.предмет_структури_Дія = створити_структуру(М, М.константи_назв._Дія, М.предмет_структури_Предмет, М.предмет_пустої_послідовності);
    М.предмет_структури_Словник = створити_структуру(М, М.константи_назв._Словник, М.предмет_структури_Предмет, М.предмет_пустої_послідовності);
    М.предмет_структури_Список = створити_структуру(М, М.константи_назв._Список, М.предмет_структури_Предмет, М.предмет_пустої_послідовності);
    М.предмет_структури_Модуль = створити_структуру(М, М.константи_назв._Модуль, М.предмет_структури_Предмет, М.предмет_пустої_послідовності);

    М.предмет_структури_ДіапазонДробових = створити_структуру(М, М.константи_назв._ДіапазонДробових, М.предмет_структури_Предмет, М.предмет_пустої_послідовності);
    М.предмет_структури_ДіапазонЦілих = створити_структуру(М, М.константи_назв._ДіапазонЦілих, М.предмет_структури_Предмет, М.предмет_пустої_послідовності);
    М.предмет_структури_ПеребірДаних = створити_структуру(М, М.константи_назв._ПеребірДаних, М.предмет_структури_Предмет, М.предмет_пустої_послідовності);
    М.предмет_структури_ПеребірДіапазонуДробових = створити_структуру(М, М.константи_назв._ПеребірДіапазонуДробових, М.предмет_структури_Предмет, М.предмет_пустої_послідовності);
    М.предмет_структури_ПеребірДіапазонуЦілих = створити_структуру(М, М.константи_назв._ПеребірДіапазонуЦілих, М.предмет_структури_Предмет, М.предмет_пустої_послідовності);
    М.предмет_структури_ПеребірПослідовності = створити_структуру(М, М.константи_назв._ПеребірПослідовності, М.предмет_структури_Предмет, М.предмет_пустої_послідовності);
    М.предмет_структури_ПеребірСловника = створити_структуру(М, М.константи_назв._ПеребірСловника, М.предмет_структури_Предмет, М.предмет_пустої_послідовності);
    М.предмет_структури_ПеребірСписку = створити_структуру(М, М.константи_назв._ПеребірСписку, М.предмет_структури_Предмет, М.предмет_пустої_послідовності);
    М.предмет_структури_ПеребірТексту = створити_структуру(М, М.константи_назв._ПеребірТексту, М.предмет_структури_Предмет, М.предмет_пустої_послідовності);

    заповнити_структуру_Предмет(М);
    заповнити_структуру_Структура(М);
    заповнити_структуру_Послідовність(М);
    заповнити_структуру_Дані(М);
    заповнити_структуру_ДіапазонДробових(М);
    заповнити_структуру_ДіапазонЦілих(М);
    заповнити_структуру_Дія(М);
    заповнити_структуру_Дробове(М);
    заповнити_структуру_Код(М);
    заповнити_структуру_Модуль(М);
    заповнити_структуру_Параметр(М);
    заповнити_структуру_ПеребірДаних(М);
    заповнити_структуру_ПеребірДіапазонуДробових(М);
    заповнити_структуру_ПеребірДіапазонуЦілих(М);
    заповнити_структуру_ПеребірПослідовності(М);
    заповнити_структуру_ПеребірСловника(М);
    заповнити_структуру_ПеребірСписку(М);
    заповнити_структуру_ПеребірТексту(М);
    заповнити_структуру_Словник(М);
    заповнити_структуру_Список(М);
    заповнити_структуру_Текст(М);
    заповнити_структуру_Ціле(М);
    М.предмет_структури_Число.заборонити_наслідування = так;

    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._недійсне, пусто);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._дійсне, М.значення_дійсне);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._Предмет, М.предмет_структури_Предмет як адреса<Предмет>);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._Структура, М.предмет_структури_Структура як адреса<Предмет>);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._Модуль, М.предмет_структури_Модуль як адреса<Предмет>);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._Параметр, М.предмет_структури_Параметр як адреса<Предмет>);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._Число, М.предмет_структури_Число як адреса<Предмет>);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._Ціле, М.предмет_структури_Ціле як адреса<Предмет>);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._Дробове, М.предмет_структури_Дробове як адреса<Предмет>);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._Текст, М.предмет_структури_Текст як адреса<Предмет>);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._Код, М.предмет_структури_Код як адреса<Предмет>);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._Дія, М.предмет_структури_Дія як адреса<Предмет>);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._Список, М.предмет_структури_Список як адреса<Предмет>);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._Словник, М.предмет_структури_Словник як адреса<Предмет>);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._Дані, М.предмет_структури_Дані як адреса<Предмет>);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._ДіапазонЦілих, М.предмет_структури_ДіапазонЦілих як адреса<Предмет>);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._ДіапазонДробових, М.предмет_структури_ДіапазонДробових як адреса<Предмет>);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._ПеребірДаних, М.предмет_структури_ПеребірДаних як адреса<Предмет>);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._ПеребірДіапазонуЦілих, М.предмет_структури_ПеребірДіапазонуЦілих як адреса<Предмет>);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._ПеребірДіапазонуДробових, М.предмет_структури_ПеребірДіапазонуДробових як адреса<Предмет>);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._ПеребірПослідовності, М.предмет_структури_ПеребірПослідовності як адреса<Предмет>);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._ПеребірСловника, М.предмет_структури_ПеребірСловника як адреса<Предмет>);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._ПеребірСписку, М.предмет_структури_ПеребірСписку як адреса<Предмет>);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._ПеребірТексту, М.предмет_структури_ПеребірТексту як адреса<Предмет>);
    записати_в_дійсність(М, М.глобальна_дійсність, М.константи_назв._Послідовність, М.предмет_структури_Послідовність як адреса<Предмет>);
  }

  місцева дія розлаштувати_машину(
    М: адреса<Машина>
  ) {
    // потім: втілити
  }

  місцева дія увімкнути_стан_падіння(
    М: адреса<Машина>,
    значення_падіння: адреса<Предмет>,
    місцезнаходження_падіння: Місцезнаходження
  ) -> ніщо {
    М.стан_падіння = так;
    М.значення_падіння = значення_падіння;
    М.місцезнаходження_падіння = місцезнаходження_падіння;
  }

  місцева дія вимкнути_стан_падіння(
    М: адреса<Машина>
  ) -> ніщо {
    М.стан_падіння = ні;
    М.значення_падіння = пусто;
    М.місцезнаходження_падіння = Місцезнаходження { пусто, 0 };
  }

  місцева дія покласти_в_історію_здійснення(
    М: адреса<Машина>,
    дійсність: адреса<Дійсність>,
    здійснювач: адреса<Предмет>,
    предмет_дії: адреса<ПредметДії>,
    задіяні: Задіяні,
    місцезнаходження: Місцезнаходження
  ) -> адреса<ЕлементІсторіїЗдійснення> {
    М.історія_здійснення.дані[М.історія_здійснення.розмір] = ЕлементІсторіїЗдійснення {
      спроби = Спроби { 0, пусто },
      дійсність = дійсність,
      здійснювач = здійснювач,
      предмет_дії = предмет_дії,
      задіяні = задіяні,
      місцезнаходження = місцезнаходження,
    };
    М.історія_здійснення.розмір += 1;

    якщо дійсність != пусто {
      дійсність.кількість_запозичень += 1;
    }

    вернути М.історія_здійснення.дані[М.історія_здійснення.розмір - 1]::адреса;
  }

  місцева дія видалити_з_історії_здійснення(
    М: адреса<Машина>,
    кількість: природне
  ) {
    змінна п: природне = 0;

    поки п < кількість {
      змінна елемент_історії = М.історія_здійснення.дані[М.історія_здійснення.розмір - 1 - п];

      якщо елемент_історії.дійсність != пусто {
        віддати_дійсність(М, елемент_історії.дійсність);
      }

      звільнити_памʼять(М, елемент_історії.спроби.дані);

      звільнити_задіяні(М, елемент_історії.задіяні);

      п += 1;
    }

    М.історія_здійснення.розмір -= кількість;
  }

  місцева дія покласти_в_чергу_здійснення(
    М: адреса<Машина>,
    предмет_дії: адреса<ПредметДії>,
    задіяні: Задіяні
  ) {
    // ...
  }

  місцева дія забрати_з_черги_здійснення(
    М: адреса<Машина>,
    вихід: адреса<ЕлементЧергиЗдійснення>
  ) -> логічне {
    якщо М.черга_здійснення.перший != пусто {
      змінна елемент = М.черга_здійснення.перший;

      М.черга_здійснення.перший = елемент.наступний;

      вихід::вміст = елемент::вміст;

      звільнити(М, елемент);

      вернути так;
    } інакше {
      М.черга_здійснення.останній = пусто;

      вернути ні;
    }
  }

  місцева дія взяти_модуль(
    М: адреса<Машина>,
    шлях_до_теки_модулів: адреса<ПредметДаних>,
    відносно: логічне,
    довжина_шляху: природне,
    шлях: памʼять<адреса<ПредметТексту>>,
    місцезнаходження: Місцезнаходження
  ) -> ПредметАбоСтанПадіння {
    якщо М.налаштування.взяти_модуль == пусто {
      увімкнути_стан_падіння(
        М,
        створити_текст(М, "Обробник взяття модуля не встановлено в Машині") як адреса<Предмет>,
        місцезнаходження
      );
      вернути пусто;
    }

    вернути М.налаштування.взяти_модуль(
      М,
      шлях_до_теки_модулів,
      відносно,
      довжина_шляху,
      шлях,
      місцезнаходження
    );
  }

  місцева дія взяти_пак(
    М: адреса<Машина>,
    довжина_шляху: природне,
    шлях: памʼять<адреса<ПредметТексту>>,
    місцезнаходження: Місцезнаходження
  ) -> ПредметАбоСтанПадіння {
    якщо М.налаштування.взяти_пак == пусто {
      увімкнути_стан_падіння(
        М,
        створити_текст(М, "Обробник взяття паку не встановлено в Машині") як адреса<Предмет>,
        місцезнаходження
      );
      вернути пусто;
    }

    вернути М.налаштування.взяти_пак(
      М,
      довжина_шляху,
      шлях,
      місцезнаходження
    );
  }

  місцева дія взяти_біб(
    М: адреса<Машина>,
    довжина_шляху: природне,
    шлях: памʼять<адреса<ПредметТексту>>,
    місцезнаходження: Місцезнаходження
  ) -> ПредметАбоСтанПадіння {
    якщо М.налаштування.взяти_біб == пусто {
      увімкнути_стан_падіння(
        М,
        створити_текст(М, "Обробник взяття біб не встановлено в Машині") як адреса<Предмет>,
        місцезнаходження
      );
      вернути пусто;
    }

    вернути М.налаштування.взяти_біб(
      М,
      довжина_шляху,
      шлях,
      місцезнаходження
    );
  }
}

простір мавка {
  дія покласти_в_накопичувач_значень(
    М: адреса<Машина>,
    накопичувач_значень: адреса<НакопичувачЗначень>,
    значення: адреса<Предмет>
  ) {
    якщо накопичувач_значень.розмір == накопичувач_значень.вмісткість {
      запанікувати(М, "Накопичувач значень заповнено!");
      вернути;
    }

    накопичувач_значень.дані[накопичувач_значень.розмір] = значення;
    накопичувач_значень.розмір += 1;
  }

  дія забрати_з_накопичувача_значень(
    М: адреса<Машина>,
    накопичувач_значень: адреса<НакопичувачЗначень>
  ) -> адреса<Предмет> {
    якщо накопичувач_значень.розмір == 0 {
      запанікувати(М, "Накопичувач значень порожній 1!");
    }

    накопичувач_значень.розмір -= 1;

    вернути накопичувач_значень.дані[накопичувач_значень.розмір];
  }

  дія отримати_з_накопичувача_значень(
    М: адреса<Машина>,
    накопичувач_значень: адреса<НакопичувачЗначень>,
    позиція: природне
  ) -> адреса<Предмет> {
    якщо накопичувач_значень.розмір == 0 {
      запанікувати(М, "Накопичувач значень порожній 2!");
    }

    вернути накопичувач_значень.дані[накопичувач_значень.розмір - 1 - позиція];
  }

  дія видалити_з_накопичувача_значень(
    М: адреса<Машина>,
    накопичувач_значень: адреса<НакопичувачЗначень>,
    кількість: природне
  ) {
    якщо накопичувач_значень.розмір == 0 {
      запанікувати(М, "Накопичувач значень порожній 3!");
    }

    накопичувач_значень.розмір -= кількість;
  }

  дія обробити_стан_падіння(
    М: адреса<Машина>,
    спроби: адреса<Спроби>,
    дійсність: адреса<Дійсність>,
    предмет_коду: адреса<ПредметКоду>,
    позиція_вказівки_падіння: природне,
    позиція: адреса<природне>
  ) -> логічне {
    якщо спроби.розмір > 0 {
      спроби.розмір -= 1;
      змінна спроба = спроби.дані[спроби.розмір];

      якщо спроба.назва_зловити != пусто {
        записати_в_дійсність(М, дійсність, спроба.назва_зловити, М.значення_падіння);
      }

      позиція::вміст = спроба.позиція_вказівки_зловити;
      М.історія_здійснення.розмір = спроба.розмір_історії_здійснення;
      М.накопичувач_значень.розмір = спроба.розмір_накопичувача_значень;

      М.стан_падіння = ні;
      М.значення_падіння = пусто;
      М.місцезнаходження_падіння = Місцезнаходження { пусто, 0 };

      вернути так;
    }

    якщо (М.місцезнаходження_падіння.шлях_або_код як адреса<ПредметДаних>) == пусто {
      М.місцезнаходження_падіння = Місцезнаходження { предмет_коду, позиція_вказівки_падіння };
    }

    вернути ні;
  }

  дія прочитати_аргумент_вказівки(вказівки: адреса<ПредметДаних>, позиція: адреса<природне>) -> п32 {
    позиція::вміст += 1;
    змінна адреса_аргумента = вказівки.дані[позиція::вміст]::адреса як адреса<п32>;
    позиція::вміст += 3;
    вернути адреса_аргумента::вміст;
  }

  місцева дія виконати_код(
    М: адреса<Машина>,
    накопичувач_значень: адреса<НакопичувачЗначень>,
    спроби: адреса<Спроби>,
    дійсність: адреса<Дійсність>,
    здійснювач: адреса<Предмет>,
    предмет_коду: адреса<ПредметКоду>,
    початкова_позиція_вказівки: природне,
    структура_предка: адреса<ПредметСтруктури>,
    шлях_до_теки_модулів: адреса<ПредметДаних>
  ) -> ПредметАбоСтанПадіння {
    // надрукувати_кд(М, "виконати_код");

    змінна константи = предмет_коду.константи;
    змінна вказівки = предмет_коду.вказівки;

    змінна результат_вернути: адреса<Предмет> = пусто;
    змінна результат: адреса<Предмет> = пусто;

    змінна позиція = початкова_позиція_вказівки;
    змінна позиція_поточної_вказівки: природне;
    змінна вказівка: п8;

    змінна п: природне = 0; // спільний лічильник

    // надрукувати_кд(М, "Початок виконання коду");
    // надрукувати_п64(М, п64(вказівки.розмір));

    поки позиція < вказівки.розмір {
  крок_виконання_вказівки:
      якщо М.потребує_очищення {
        запустити_очищувач(М);
      }

      позиція_поточної_вказівки = позиція;
      вказівка = вказівки.дані[позиція_поточної_вказівки];

      // вивести_кд(М, "Виконується вказівка: ");
      // надрукувати_п64(М, п64(вказівка));

      якщо вказівка == ВПокластиНедійсне {
        покласти_в_накопичувач_значень(М, накопичувач_значень, пусто);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПокластиДійсне {
        покласти_в_накопичувач_значень(М, накопичувач_значень, М.значення_дійсне);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПокластиПредмет {
        покласти_в_накопичувач_значень(М, накопичувач_значень, М.предмет_структури_Предмет як адреса<Предмет>);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПокластиЯ {
        покласти_в_накопичувач_значень(М, накопичувач_значень, здійснювач);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПокластиКонстанту {
        змінна позиція_константи = прочитати_аргумент_вказівки(вказівки, позиція::адреса);

        покласти_в_накопичувач_значень(М, накопичувач_значень, константи.елементи[позиція_константи]);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиДію {
        змінна кількість_параметрів = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        змінна код = забрати_з_накопичувача_значень(М, накопичувач_значень) як адреса<ПредметКоду>;

        змінна тип_результату = забрати_з_накопичувача_значень(М, накопичувач_значень);

        змінна параметри = М.предмет_пустої_послідовності;

        якщо кількість_параметрів > 0 {
          параметри = створити_сиру_послідовність(М, кількість_параметрів);

          п = 0;

          поки п < кількість_параметрів {
            змінна параметр_з_накопичувача = забрати_з_накопичувача_значень(М, накопичувач_значень);
            параметри.елементи[кількість_параметрів - п - 1] = параметр_з_накопичувача;

            п += 1;
          }
        }

        змінна назва = забрати_з_накопичувача_значень(М, накопичувач_значень) як адреса<ПредметТексту>;

        змінна предмет_дії = створити_дію(
          М,
          дійсність,
          назва,
          параметри,
          пусто,
          код,
          шлях_до_теки_модулів
        );

        // надрукувати_кд(М, "створити дію ");
        // надрукувати_п64(М, п64(накопичувач_значень.розмір));

        покласти_в_накопичувач_значень(М, накопичувач_значень, предмет_дії як адреса<Предмет>);

        // надрукувати_п64(М, п64(накопичувач_значень.розмір));

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиСтруктуру {
        змінна кількість_параметрів = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        змінна предок = отримати_з_накопичувача_значень(М, накопичувач_значень, кількість_параметрів) як адреса<ПредметСтруктури>;
        змінна кількість_параметрів_предка: природне = 0;

        змінна параметри = М.предмет_пустої_послідовності;

        якщо предок == пусто {
          увімкнути_стан_падіння(
            М,
            створити_текст(М, "Неможливо наслідувати недійсне.") як адреса<Предмет>,
            Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
          );

          видалити_з_накопичувача_значень(М, накопичувач_значень, кількість_параметрів + 2);

          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        } інакше якщо предок.тип == М.предмет_структури_Структура {
          якщо предок.заборонити_наслідування {
            увімкнути_стан_падіння(
              М,
              створити_текст(М, "Неможливо наслідувати цю структуру.") як адреса<Предмет>,
              Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
            );

            видалити_з_накопичувача_значень(М, накопичувач_значень, кількість_параметрів + 2);

            якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
              стрибнути крок_виконання_вказівки;
            }

            стрибнути крок_вихід;
          }

          кількість_параметрів_предка = предок.параметри.розмір;

          якщо кількість_параметрів_предка > 0 {
            якщо кількість_параметрів > 0 {
              параметри = створити_сиру_послідовність(М, кількість_параметрів + кількість_параметрів_предка);

              п = 0;

              поки п < кількість_параметрів_предка {
                параметри.елементи[п] = предок.параметри.елементи[п];

                п += 1;
              }

              п = 0;

              поки п < кількість_параметрів {
                змінна параметр_з_накопичувача = забрати_з_накопичувача_значень(М, накопичувач_значень);
                параметри.елементи[кількість_параметрів + кількість_параметрів_предка - п - 1] = параметр_з_накопичувача;

                п += 1;
              }
            } інакше {
              параметри = предок.параметри;
            }
          } інакше якщо кількість_параметрів > 0 {
            параметри = створити_сиру_послідовність(М, кількість_параметрів);

            п = 0;

            поки п < кількість_параметрів {
              змінна параметр_з_накопичувача = забрати_з_накопичувача_значень(М, накопичувач_значень);
              параметри.елементи[кількість_параметрів - п - 1] = параметр_з_накопичувача;

              п += 1;
            }
          }
        } інакше {
          увімкнути_стан_падіння(
            М,
            створити_текст(М, "Наслідувати можна лише структуру.") як адреса<Предмет>,
            Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
          );

          видалити_з_накопичувача_значень(М, накопичувач_значень, кількість_параметрів + 2);

          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        видалити_з_накопичувача_значень(М, накопичувач_значень, 1); // предок
        змінна назва = забрати_з_накопичувача_значень(М, накопичувач_значень) як адреса<ПредметТексту>;

        змінна предмет_структури = створити_структуру(М, назва, предок, параметри);

        покласти_в_накопичувач_значень(М, накопичувач_значень, предмет_структури як адреса<Предмет>);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиМодуль {
        змінна код = забрати_з_накопичувача_значень(М, накопичувач_значень) як адреса<ПредметКоду>;
        змінна назва = забрати_з_накопичувача_значень(М, накопичувач_значень) як адреса<ПредметТексту>;

        змінна предмет_модуля = створити_модуль(М, назва);

        змінна предмет_дії = створити_дію(
          М,
          дійсність,
          назва,
          М.предмет_пустої_послідовності,
          пусто,
          код,
          шлях_до_теки_модулів
        );

        змінна результат = здійснити(
          М,
          предмет_модуля як адреса<Предмет>,
          предмет_дії як адреса<Предмет>,
          Задіяні { 0, пусто, пусто },
          Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
        );

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, предмет_модуля як адреса<Предмет>);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиСписок {
        змінна кількість_елементів = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        змінна значення_списку = створити_список(М, кількість_елементів);

        п = 0;

        поки п < кількість_елементів {
          записати_в_список(
            М,
            значення_списку,
            кількість_елементів - п - 1,
            забрати_з_накопичувача_значень(М, накопичувач_значень)
          );

          п += 1;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, значення_списку як адреса<Предмет>);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиСловник {
        змінна кількість_елементів = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        змінна предмет_словника = створити_словник(М);

        п = 0;

        поки п < кількість_елементів {
          змінна ключ = отримати_з_накопичувача_значень(М, накопичувач_значень, (кількість_елементів * 2) - (п * 2) - 1);
          змінна значення = отримати_з_накопичувача_значень(М, накопичувач_значень, (кількість_елементів * 2) - (п * 2) - 2);

          записати_в_словник(М, предмет_словника, ключ, значення);

          п += 1;
        }

        видалити_з_накопичувача_значень(М, накопичувач_значень, кількість_елементів * 2);

        покласти_в_накопичувач_значень(М, накопичувач_значень, предмет_словника як адреса<Предмет>);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиПослідовність {
        змінна кількість_елементів = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        змінна послідовність = створити_сиру_послідовність(М, кількість_елементів);

        п = 0;

        поки п < кількість_елементів {
          послідовність.елементи[кількість_елементів - п - 1] = забрати_з_накопичувача_значень(М, накопичувач_значень);

          п += 1;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, послідовність як адреса<Предмет>);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиДіапазон {
        змінна до = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна включно = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна від = забрати_з_накопичувача_значень(М, накопичувач_значень);

        змінна включно_логічне: логічне = ні;
        якщо включно != пусто {
          включно_логічне = так;
        }

        якщо від == пусто {
          увімкнути_стан_падіння(
            М,
            створити_текст(М, "Неможливо отримати діапазон з недійсного.") як адреса<Предмет>,
            Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
          );

          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        змінна предмет_діапазону = отримати_діапазон(
          М,
          від,
          до,
          включно_логічне,
          Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
        );

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, предмет_діапазону);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиПараметр {
        змінна дія_значення = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна тип = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна назва = забрати_з_накопичувача_значень(М, накопичувач_значень) як адреса<ПредметТексту>;

        змінна предмет_параметра = створити_параметр(М, назва, пусто, пусто); // потім: ...

        покласти_в_накопичувач_значень(М, накопичувач_значень, предмет_параметра як адреса<Предмет>);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗаписатиМетод {
        змінна значення_структури = забрати_з_накопичувача_значень(М, накопичувач_значень) як адреса<ПредметСтруктури>;
        змінна значення_дії = забрати_з_накопичувача_значень(М, накопичувач_значень) як адреса<ПредметДії>;
        змінна назва = забрати_з_накопичувача_значень(М, накопичувач_значень) як адреса<ПредметТексту>;

        якщо значення_структури == пусто {
          увімкнути_стан_падіння(
            М,
            створити_текст(М, "Неможливо записати метод в недійсне.") як адреса<Предмет>,
            Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
          );

          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        якщо значення_структури.тип != М.предмет_структури_Структура {
          увімкнути_стан_падіння(
            М,
            створити_текст(М, "Метод можна записати лише в структуру.") як адреса<Предмет>,
            Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
          );

          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        значення_дії.метод_структури = значення_структури;

        записати_метод_структури(М, значення_структури, назва, значення_дії);

        покласти_в_накопичувач_значень(М, накопичувач_значень, значення_дії як адреса<Предмет>);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВВизначити {
        змінна значення = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна назва = забрати_з_накопичувача_значень(М, накопичувач_значень) як адреса<ПредметТексту>;

        записати_в_дійсність(М, дійсність, назва, значення);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВВизначитиНавпаки {
        змінна назва = забрати_з_накопичувача_значень(М, накопичувач_значень) як адреса<ПредметТексту>;
        змінна значення = забрати_з_накопичувача_значень(М, накопичувач_значень);

        записати_в_дійсність(М, дійсність, назва, значення);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗвернутись {
        змінна назва = забрати_з_накопичувача_значень(М, накопичувач_значень) як адреса<ПредметТексту>;

        змінна значення: адреса<Предмет>;
        якщо не знайти_в_дійсності(М, дійсність, назва, значення::адреса) {
          змінна накопичувач_тексту = зробити_накопичувач_тексту(М, 32);
          покласти_в_накопичувач_тексту(М, накопичувач_тексту::адреса, "Діяча \"");
          покласти_в_накопичувач_тексту(М, накопичувач_тексту::адреса, назва.значення);
          покласти_в_накопичувач_тексту(М, накопичувач_тексту::адреса, "\" не визначено.");

          увімкнути_стан_падіння(
            М,
            створити_текст_без_копіювання(М, накопичувач_тексту.розмір, накопичувач_тексту.дані) як адреса<Предмет>,
            Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
          );

          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, значення);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗдійснити {
        змінна кількість_задіяних = прочитати_аргумент_вказівки(вказівки, позиція::адреса);
        змінна кількість_іменованих_аргументів = прочитати_аргумент_вказівки(вказівки, позиція::адреса);

        змінна позиційно_задіяні: памʼять<адреса<Предмет>> = пусто;
        змінна іменовано_задіяні: адреса<ІменованіЗадіяні> = пусто;
        змінна п: п32 = 0;

        якщо кількість_іменованих_аргументів > 0 {
          іменовано_задіяні = створити_іменовано_задіяні(М);

          поки п < кількість_іменованих_аргументів {
            змінна значення = забрати_з_накопичувача_значень(М, накопичувач_значень);
            змінна назва = забрати_з_накопичувача_значень(М, накопичувач_значень) як адреса<ПредметТексту>;

            покласти_іменовано_задіяне(М, іменовано_задіяні, назва, значення);

            п += 1;
          }
        }

        якщо кількість_задіяних > 0 {
          позиційно_задіяні = виділити_памʼять<адреса<Предмет>>(М, природне(кількість_задіяних));

          п = 0;

          поки п < кількість_задіяних {
            позиційно_задіяні[кількість_задіяних - п - 1] = забрати_з_накопичувача_значень(М, накопичувач_значень);

            п += 1;
          }
        }

        змінна предмет_дії = забрати_з_накопичувача_значень(М, накопичувач_значень);

        результат = здійснити(
          М,
          пусто,
          предмет_дії,
          Задіяні { природне(кількість_задіяних), позиційно_задіяні, іменовано_задіяні },
          Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
        );

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВОтриматиВластивість {
        змінна назва = забрати_з_накопичувача_значень(М, накопичувач_значень) як адреса<ПредметТексту>;
        змінна предмет = забрати_з_накопичувача_значень(М, накопичувач_значень);

        результат = отримати_властивість(М, предмет, назва, Місцезнаходження { предмет_коду, позиція_поточної_вказівки });

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗмінитиВластивість {
        змінна значення = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна назва = забрати_з_накопичувача_значень(М, накопичувач_значень) як адреса<ПредметТексту>;
        змінна предмет = забрати_з_накопичувача_значень(М, накопичувач_значень);

        змінити_властивість(
          М,
          предмет,
          назва,
          значення,
          Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
        );

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗдійснитиВластивість {
        змінна кількість_задіяних = прочитати_аргумент_вказівки(вказівки, позиція::адреса);
        змінна кількість_іменованих_аргументів = прочитати_аргумент_вказівки(вказівки, позиція::адреса);

        змінна позиційно_задіяні: памʼять<адреса<Предмет>> = пусто;
        змінна іменовано_задіяні: адреса<ІменованіЗадіяні> = пусто;
        змінна п: п32 = 0;

        якщо кількість_іменованих_аргументів > 0 {
          іменовано_задіяні = створити_іменовано_задіяні(М);

          поки п < кількість_іменованих_аргументів {
            змінна значення = забрати_з_накопичувача_значень(М, накопичувач_значень);
            змінна назва = забрати_з_накопичувача_значень(М, накопичувач_значень) як адреса<ПредметТексту>;

            покласти_іменовано_задіяне(М, іменовано_задіяні, назва, значення);

            п += 1;
          }
        }

        якщо кількість_задіяних > 0 {
          позиційно_задіяні = виділити_памʼять<адреса<Предмет>>(М, природне(кількість_задіяних));

          п = 0;

          поки п < кількість_задіяних {
            позиційно_задіяні[кількість_задіяних - п - 1] = забрати_з_накопичувача_значень(М, накопичувач_значень);

            п += 1;
          }
        }

        змінна назва = забрати_з_накопичувача_значень(М, накопичувач_значень) як адреса<ПредметТексту>;
        змінна предмет = забрати_з_накопичувача_значень(М, накопичувач_значень);

        результат = здійснити_властивість(
          М,
          предмет,
          назва,
          Задіяні { природне(кількість_задіяних), позиційно_задіяні, іменовано_задіяні },
          Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
        );

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВОтриматиЕлемент {
        змінна ключ = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна предмет = забрати_з_накопичувача_значень(М, накопичувач_значень);

        змінна значення = отримати_елемент(М, предмет, ключ, Місцезнаходження { предмет_коду, позиція_поточної_вказівки });

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, значення);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗмінитиЕлемент {
        змінна значення = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна ключ = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна предмет = забрати_з_накопичувача_значень(М, накопичувач_значень);

        змінити_елемент(М, предмет, ключ, значення, Місцезнаходження { предмет_коду, позиція_поточної_вказівки });

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВОтриматиПеребір {
        змінна значення = забрати_з_накопичувача_значень(М, накопичувач_значень);

        результат = отримати_перебір(М, значення, Місцезнаходження { предмет_коду, позиція_поточної_вказівки });

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВДодати {
        змінна б = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна а = забрати_з_накопичувача_значень(М, накопичувач_значень);

        результат = виконати_додати(М, а, б, Місцезнаходження { предмет_коду, позиція_поточної_вказівки });

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВВідняти {
        змінна б = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна а = забрати_з_накопичувача_значень(М, накопичувач_значень);

        результат = виконати_відняти(М, а, б, Місцезнаходження { предмет_коду, позиція_поточної_вказівки });

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПомножити {
        змінна б = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна а = забрати_з_накопичувача_значень(М, накопичувач_значень);

        результат = виконати_помножити(М, а, б, Місцезнаходження { предмет_коду, позиція_поточної_вказівки });

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПоділити {
        змінна б = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна а = забрати_з_накопичувача_значень(М, накопичувач_значень);

        результат = виконати_поділити(М, а, б, Місцезнаходження { предмет_коду, позиція_поточної_вказівки });

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВОтриматиОстачуДілення {
        змінна б = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна а = забрати_з_накопичувача_значень(М, накопичувач_значень);

        результат = виконати_остача(М, а, б, Місцезнаходження { предмет_коду, позиція_поточної_вказівки });

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВОтриматиНеповнуЧасткуДілення {
        змінна б = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна а = забрати_з_накопичувача_значень(М, накопичувач_значень);

        результат = виконати_поділити_націло(М, а, б, Місцезнаходження { предмет_коду, позиція_поточної_вказівки });

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПіднестиДоСтепеня {
        змінна б = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна а = забрати_з_накопичувача_значень(М, накопичувач_значень);

        результат = виконати_степінь(М, а, б, Місцезнаходження { предмет_коду, позиція_поточної_вказівки });

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗсунутиВліво {
        змінна б = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна а = забрати_з_накопичувача_значень(М, накопичувач_значень);

        результат = виконати_вліво(М, а, б, Місцезнаходження { предмет_коду, позиція_поточної_вказівки });

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗсунутиВправо {
        змінна б = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна а = забрати_з_накопичувача_значень(М, накопичувач_значень);

        результат = виконати_вправо(М, а, б, Місцезнаходження { предмет_коду, позиція_поточної_вказівки });

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВДвійковеІ {
        змінна б = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна а = забрати_з_накопичувача_значень(М, накопичувач_значень);

        результат = виконати_двійкове_і(М, а, б, Місцезнаходження { предмет_коду, позиція_поточної_вказівки });

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВДвійковеАБО {
        змінна б = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна а = забрати_з_накопичувача_значень(М, накопичувач_значень);

        результат = виконати_двійкове_або(М, а, б, Місцезнаходження { предмет_коду, позиція_поточної_вказівки });

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВДвійковеВиключнеАБО {
        змінна б = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна а = забрати_з_накопичувача_значень(М, накопичувач_значень);

        результат = виконати_двійкове_вабо(М, а, б, Місцезнаходження { предмет_коду, позиція_поточної_вказівки });

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВМенше {
        змінна б = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна а = забрати_з_накопичувача_значень(М, накопичувач_значень);

        результат = виконати_менше(М, а, б, Місцезнаходження { предмет_коду, позиція_поточної_вказівки });

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВБільше {
        змінна б = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна а = забрати_з_накопичувача_значень(М, накопичувач_значень);

        результат = виконати_більше(М, а, б, Місцезнаходження { предмет_коду, позиція_поточної_вказівки });

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВНеБільше {
        змінна б = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна а = забрати_з_накопичувача_значень(М, накопичувач_значень);

        результат = виконати_більше(М, а, б, Місцезнаходження { предмет_коду, позиція_поточної_вказівки });

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        якщо результат == пусто {
          покласти_в_накопичувач_значень(М, накопичувач_значень, М.значення_дійсне);
        } інакше {
          покласти_в_накопичувач_значень(М, накопичувач_значень, пусто);
        }

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВНеМенше {
        змінна б = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна а = забрати_з_накопичувача_значень(М, накопичувач_значень);

        результат = виконати_менше(М, а, б, Місцезнаходження { предмет_коду, позиція_поточної_вказівки });

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        якщо результат == пусто {
          покласти_в_накопичувач_значень(М, накопичувач_значень, М.значення_дійсне);
        } інакше {
          покласти_в_накопичувач_значень(М, накопичувач_значень, пусто);
        }

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВРівно {
        змінна б = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна а = забрати_з_накопичувача_значень(М, накопичувач_значень);

        якщо перевірити_чи_значення_рівні(М, а, б) {
          результат = М.значення_дійсне;
        } інакше {
          результат = пусто;
        }

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВНеРівно {
        змінна б = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна а = забрати_з_накопичувача_значень(М, накопичувач_значень);

        якщо перевірити_чи_значення_рівні(М, а, б) {
          результат = пусто;
        } інакше {
          результат = М.значення_дійсне;
        }

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЄ {
        змінна б = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна а = забрати_з_накопичувача_значень(М, накопичувач_значень);

        якщо б == пусто {
          якщо а == пусто {
            результат = М.значення_дійсне;
          } інакше {
            результат = пусто;
          }
        } інакше якщо а == пусто {
          результат = пусто;
        } інакше якщо б == М.значення_дійсне {
          результат = М.значення_дійсне;
        } інакше якщо а == М.значення_дійсне {
          результат = пусто;
        } інакше {
          якщо б.тип == М.предмет_структури_Структура {
            якщо перевірити_чи_предмет_є(М, а, б як адреса<ПредметСтруктури>) {
              результат = М.значення_дійсне;
            } інакше {
              результат = пусто;
            }
          } інакше {
            увімкнути_стан_падіння(
              М,
              створити_текст(М, "Зліва операції \"є\" має бути структура.") як адреса<Предмет>,
              Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
            );
          }
        }

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВНеЄ {
        змінна б = забрати_з_накопичувача_значень(М, накопичувач_значень);
        змінна а = забрати_з_накопичувача_значень(М, накопичувач_значень);

        якщо б == пусто {
          якщо а == пусто {
            результат = М.значення_дійсне;
          } інакше {
            результат = пусто;
          }
        } інакше якщо а == пусто {
          результат = пусто;
        } інакше якщо б == М.значення_дійсне {
          результат = М.значення_дійсне;
        } інакше якщо а == М.значення_дійсне {
          результат = пусто;
        } інакше {
          якщо б.тип == М.предмет_структури_Структура {
            якщо перевірити_чи_предмет_є(М, а, б як адреса<ПредметСтруктури>) {
              результат = М.значення_дійсне;
            } інакше {
              результат = пусто;
            }
          } інакше {
            увімкнути_стан_падіння(
              М,
              створити_текст(М, "Зліва операції \"є\" має бути структура.") як адреса<Предмет>,
              Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
            );
          }
        }

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        якщо результат == М.значення_дійсне {
          покласти_в_накопичувач_значень(М, накопичувач_значень, пусто);
        } інакше {
          покласти_в_накопичувач_значень(М, накопичувач_значень, М.значення_дійсне);
        }

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВДвійковеНЕ {
        змінна значення = забрати_з_накопичувача_значень(М, накопичувач_значень);

        результат = виконати_двійкове_не(М, значення, Місцезнаходження { предмет_коду, позиція_поточної_вказівки });

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВВідʼємне {
        змінна значення = забрати_з_накопичувача_значень(М, накопичувач_значень);

        результат = виконати_змінити_знак(М, значення, Місцезнаходження { предмет_коду, позиція_поточної_вказівки });

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗаперечити {
        змінна значення = забрати_з_накопичувача_значень(М, накопичувач_значень);

        якщо значення == пусто {
          покласти_в_накопичувач_значень(М, накопичувач_значень, М.значення_дійсне);
        } інакше {
          покласти_в_накопичувач_значень(М, накопичувач_значень, пусто);
        }

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПочатиСпробу {
        змінна назва_зловити = забрати_з_накопичувача_значень(М, накопичувач_значень) як адреса<ПредметТексту>;

        змінна позиція_вказівки_зловити = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        покласти_спробу(М, спроби, назва_зловити, позиція_вказівки_зловити);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВВпасти {
        змінна значення_помилки = забрати_з_накопичувача_значень(М, накопичувач_значень);

        увімкнути_стан_падіння(
          М,
          значення_помилки,
          Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
        );

        якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
          стрибнути крок_виконання_вказівки;
        }

        стрибнути крок_вихід;
      }

      якщо вказівка == ВЗакінчитиСпробу {
        змінна позиція_вказівки_виходу = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        видалити_останню_спробу(М, спроби);

        позиція = позиція_вказівки_виходу;

        стрибнути крок_виконання_вказівки;
      }

      якщо вказівка == ВВзяти {
        змінна кількість_назв = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        змінна дані_назв: памʼять<адреса<ПредметТексту>> = пусто;

        якщо кількість_назв > 0 {
          дані_назв = виділити_памʼять<адреса<ПредметТексту>>(М, кількість_назв);

          змінна п: природне = 0;

          поки п < кількість_назв {
            змінна назва = забрати_з_накопичувача_значень(М, накопичувач_значень) як адреса<ПредметТексту>;

            дані_назв[кількість_назв - п - 1] = назва;

            п += 1;
          }
        }

        змінна звідки = забрати_з_накопичувача_значень(М, накопичувач_значень) як адреса<ПредметТексту>;

        якщо звідки == М.константи_назв._модуль або перевірити_чи_предмети_тексту_рівні(М, звідки, М.константи_назв._модуль) {
          результат = взяти_модуль(
            М,
            шлях_до_теки_модулів,
            ні,
            кількість_назв,
            дані_назв,
            Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
          );
        } інакше якщо звідки == М.константи_назв._пак або перевірити_чи_предмети_тексту_рівні(М, звідки, М.константи_назв._пак) {
          результат = взяти_пак(
            М,
            кількість_назв,
            дані_назв,
            Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
          );
        } інакше якщо звідки == М.константи_назв._біб або перевірити_чи_предмети_тексту_рівні(М, звідки, М.константи_назв._біб) {
          результат = взяти_біб(
            М,
            кількість_назв,
            дані_назв,
            Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
          );
        } інакше {
          увімкнути_стан_падіння(
            М,
            створити_текст(М, "Взяти можна лише модуль, пак або біб.") як адреса<Предмет>,
            Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
          );
        }

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВДати {
        змінна назва = забрати_з_накопичувача_значень(М, накопичувач_значень) як адреса<ПредметТексту>;
        змінна значення = забрати_з_накопичувача_значень(М, накопичувач_значень);

        якщо здійснювач == пусто {
          увімкнути_стан_падіння(
            М,
            створити_текст(М, "Неможливо дати.") як адреса<Предмет>,
            Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
          );

          якщо М.стан_падіння {
            якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
              стрибнути крок_виконання_вказівки;
            }

            стрибнути крок_вихід;
          }
        }

        змінити_властивість(
          М,
          здійснювач,
          назва,
          значення,
          Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
        );

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПеребратиДалі {
        змінна значення_перебору = забрати_з_накопичувача_значень(М, накопичувач_значень);

        покласти_в_накопичувач_значень(М, накопичувач_значень, значення_перебору);

        результат = здійснити_властивість(
          М,
          значення_перебору,
          М.константи_назв._далі,
          Задіяні { 0, пусто, пусто },
          Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
        );

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, накопичувач_значень, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗбитиТекст {
        змінна кількість_предметів = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        змінна накопичувач_тексту = зробити_накопичувач_тексту(М, кількість_предметів);

        п = 0;

        поки п < кількість_предметів {
          змінна значення = отримати_з_накопичувача_значень(М, накопичувач_значень, кількість_предметів - п - 1);

          змінна предмет_як_текст = отримати_текст(
            М,
            значення,
            Місцезнаходження { предмет_коду, позиція_поточної_вказівки }
          );

          якщо М.стан_падіння {
            звільнити_памʼять(М, накопичувач_тексту.дані);

            якщо обробити_стан_падіння(М, спроби, дійсність, предмет_коду, позиція_поточної_вказівки, позиція::адреса) {
              стрибнути крок_виконання_вказівки;
            }

            стрибнути крок_вихід;
          }

          покласти_в_накопичувач_тексту(М, накопичувач_тексту::адреса, предмет_як_текст.значення);

          п += 1;
        }

        видалити_з_накопичувача_значень(М, накопичувач_значень, кількість_предметів);

        покласти_в_накопичувач_значень(
          М,
          накопичувач_значень,
          створити_текст_без_копіювання(М, накопичувач_тексту.розмір, накопичувач_тексту.дані) як адреса<Предмет>
        );

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтрибнути {
        змінна позиція_вказівки_стрибка = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        позиція = позиція_вказівки_стрибка;

        стрибнути крок_виконання_вказівки;
      }

      якщо вказівка == ВСтрибнутиЯкщоТак {
        змінна значення = забрати_з_накопичувача_значень(М, накопичувач_значень);

        змінна позиція_вказівки_стрибка = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        якщо значення != пусто {
          позиція = позиція_вказівки_стрибка;

          стрибнути крок_виконання_вказівки;
        }

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтрибнутиЯкщоНі {
        змінна значення = забрати_з_накопичувача_значень(М, накопичувач_значень);

        змінна позиція_вказівки_стрибка = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        якщо значення == пусто {
          позиція = позиція_вказівки_стрибка;

          стрибнути крок_виконання_вказівки;
        }

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗабрати {
        видалити_з_накопичувача_значень(М, накопичувач_значень, 1);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВДублювати {
        змінна значення = забрати_з_накопичувача_значень(М, накопичувач_значень);

        покласти_в_накопичувач_значень(М, накопичувач_значень, значення);
        покласти_в_накопичувач_значень(М, накопичувач_значень, значення);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВВернути {
        результат_вернути = забрати_з_накопичувача_значень(М, накопичувач_значень);

        стрибнути крок_вихід;
      }

      надрукувати_п64(М, п64(вказівка));
      запанікувати(М, "Невідома вказівка під час виконання коду.");

  крок_виконати_далі:
      позиція += 1;
    }

  крок_вихід:
    вернути результат_вернути;
  }
}