взяти означення машина_мавки;

простір мавка {
  дія рідна_дія__з(
    М: адреса<Машина>,
    здійснювач: Значення,
    предмет_дії: адреса<ПредметДії>,
    задіяні: Задіяні
  ) -> ЗначенняАбоСтанПадіння {
    змінна задіяне_значення: Значення = значення_недійсне();

    знайти_задіяне(М, задіяні, 0, М.константи_назв._значення, задіяне_значення::адреса);

    якщо задіяне_значення.вид == ЗНедійсне {
      вернути значення_ціле(0);
    }

    якщо задіяне_значення.вид == ЗДійсне {
      вернути значення_ціле(1);
    }

    якщо задіяне_значення.вид == ЗЦіле {
      вернути задіяне_значення;
    }

    якщо задіяне_значення.вид == ЗДробове {
      вернути значення_ціле(ц64(задіяне_значення.дані як д64));
    }

    вернути здійснити_властивість(
      М,
      задіяне_значення,
      М.константи_назв._чародія_ціле,
      Задіяні { 0, пусто, пусто },
      Місцезнаходження { пусто, 0 }
    );
  }

  дія записати_дію__з(М: адреса<Машина>) {
    змінна предмет_дії = створити_рідну_дію(
      М,
      М.константи_назв._з,
      М.предмет_пустої_послідовності як адреса<ПредметПослідовності>,
      пусто,
      рідна_дія__з,
      пусто
    );

    предмет_структури_змінити_властивість(
      М,
      М.предмет_структури_Ціле,
      М.константи_назв._з,
      значення_предмет(предмет_дії),
      Місцезнаходження { пусто, 0 }
    );

    якщо М.стан_падіння {
      запанікувати(М, "Помилка при записі дії \"з\" для структури \"Ціле\".");
    }
  }
}

простір мавка {
  місцева дія заповнити_структуру_Ціле(
    М: адреса<Машина>
  ) {
    М.предмет_структури_Ціле.заборонити_наслідування = так;

    записати_дію__з(М);
  }

  місцева дія предмет_цілого_додати(
    М: адреса<Машина>,
    значення: ц64,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право.вид == ЗЦіле {
      вернути значення_ціле(значення + право.дані як ц64);
    }

    якщо право.вид == ЗДробове {
      вернути значення_дробове(д64(значення) + право.дані як д64);
    }

    увімкнути_стан_падіння(
      М,
      значення_предмет(створити_текст(М, "Додати до цілого числа можна лише або ціле або дробове число.")),
      місцезнаходження
    );
    вернути значення_недійсне();
  }

  місцева дія предмет_цілого_відняти(
    М: адреса<Машина>,
    значення: ц64,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право.вид == ЗЦіле {
      вернути значення_ціле(значення - право.дані як ц64);
    }

    якщо право.вид == ЗДробове {
      вернути значення_дробове(д64(значення) - право.дані як д64) як Значення;
    }

    увімкнути_стан_падіння(
      М,
      значення_предмет(створити_текст(М, "Відняти від цілого числа можна лише або ціле або дробове число.")),
      місцезнаходження
    );
    вернути значення_недійсне();
  }

  місцева дія предмет_цілого_помножити(
    М: адреса<Машина>,
    значення: ц64,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право.вид == ЗЦіле {
      вернути значення_ціле(значення * право.дані як ц64);
    }

    якщо право.вид == ЗДробове {
      вернути значення_дробове(д64(значення) * право.дані як д64) як Значення;
    }

    увімкнути_стан_падіння(
      М,
      значення_предмет(створити_текст(М, "Помножити ціле число можна лише на або ціле або дробове число.")),
      місцезнаходження
    );
    вернути значення_недійсне();
  }

  місцева дія предмет_цілого_поділити(
    М: адреса<Машина>,
    значення: ц64,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право.вид == ЗЦіле {
      вернути значення_дробове(д64(значення) / д64(право.дані як ц64)) як Значення;
    }

    якщо право.вид == ЗДробове {
      вернути значення_дробове(д64(значення) / право.дані як д64) як Значення;
    }

    увімкнути_стан_падіння(
      М,
      значення_предмет(створити_текст(М, "Поділити ціле число можна лише на або ціле або дробове число.")),
      місцезнаходження
    );
    вернути значення_недійсне();
  }

  місцева дія предмет_цілого_остача(
    М: адреса<Машина>,
    значення: ц64,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право.вид == ЗЦіле {
      вернути значення_ціле(значення % право.дані як ц64);
    }

    якщо право.вид == ЗДробове {
      вернути значення_дробове(д64(значення) % право.дані як д64) як Значення;
    }

    увімкнути_стан_падіння(
      М,
      значення_предмет(створити_текст(М, "Отримати остачу ділення цілого числа можна лише з або цілим або дробовим число.")),
      місцезнаходження
    );
    вернути значення_недійсне();
  }

  місцева дія предмет_цілого_частка(
    М: адреса<Машина>,
    значення: ц64,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право.вид == ЗЦіле {
      вернути значення_ціле(значення / право.дані як ц64);
    }

    якщо право.вид == ЗДробове {
      вернути значення_дробове(д64(значення) / право.дані як д64);
    }

    увімкнути_стан_падіння(
      М,
      значення_предмет(створити_текст(М, "Отримати неповну частку ділення цілого числа можна лише з або цілим або дробовим число.")),
      місцезнаходження
    );
    вернути значення_недійсне();
  }

  місцева дія предмет_цілого_степінь(
    М: адреса<Машина>,
    значення: ц64,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право.вид == ЗЦіле {
      вернути значення_ціле(піднести_до_степеня_ц64(М, значення, право.дані як ц64));
    }

    якщо право.вид == ЗДробове {
      вернути значення_дробове(піднести_до_степеня_д64(М, д64(значення), право.дані як д64));
    }

    увімкнути_стан_падіння(
      М,
      значення_предмет(створити_текст(М, "Отримати степінь цілого числа можна лише з або цілим або дробовим число.")),
      місцезнаходження
    );
    вернути значення_недійсне();
  }

  місцева дія предмет_цілого_вліво(
    М: адреса<Машина>,
    значення: ц64,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право.вид == ЗЦіле {
      вернути значення_ціле(значення << право.дані як ц64);
    }

    увімкнути_стан_падіння(
      М,
      значення_предмет(створити_текст(М, "Зсунути вліво ціле число можна лише з або цілим числом.")),
      місцезнаходження
    );
    вернути значення_недійсне();
  }

  місцева дія предмет_цілого_вправо(
    М: адреса<Машина>,
    значення: ц64,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право.вид == ЗЦіле {
      вернути значення_ціле(значення >> право.дані як ц64);
    }

    увімкнути_стан_падіння(
      М,
      значення_предмет(створити_текст(М, "Зсунути вправо ціле число можна лише з або цілим числом.")),
      місцезнаходження
    );
    вернути значення_недійсне();
  }

  місцева дія предмет_цілого_двійкове_і(
    М: адреса<Машина>,
    значення: ц64,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право.вид == ЗЦіле {
      вернути значення_ціле(значення & право.дані як ц64);
    }

    увімкнути_стан_падіння(
      М,
      значення_предмет(створити_текст(М, "Виконути двійкове І можна лише між цілими числами.")),
      місцезнаходження
    );
    вернути значення_недійсне();
  }

  місцева дія предмет_цілого_двійкове_або(
    М: адреса<Машина>,
    значення: ц64,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право.вид == ЗЦіле {
      вернути значення_ціле(значення | право.дані як ц64) як Значення;
    }

    увімкнути_стан_падіння(
      М,
      значення_предмет(створити_текст(М, "Виконути двійкове АБО можна лише між цілими числами.")),
      місцезнаходження
    );
    вернути значення_недійсне();
  }

  місцева дія предмет_цілого_двійкове_вабо(
    М: адреса<Машина>,
    значення: ц64,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право.вид == ЗЦіле {
      вернути значення_ціле(значення вабо право.дані як ц64);
    }

    увімкнути_стан_падіння(
      М,
      значення_предмет(створити_текст(М, "Виконути двійкове ВАБО можна лише між цілими числами.")),
      місцезнаходження
    );
    вернути значення_недійсне();
  }

  місцева дія предмет_цілого_менше(
    М: адреса<Машина>,
    значення: ц64,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право.вид == ЗЦіле {
      якщо значення < право.дані як ц64 {
        вернути значення_дійсне();
      } інакше {
        вернути значення_недійсне();
      }
    }

    якщо право.вид == ЗДробове {
      якщо д64(значення) < право.дані як д64 {
        вернути значення_дійсне();
      } інакше {
        вернути значення_недійсне();
      }
    }

    увімкнути_стан_падіння(
      М,
      значення_предмет(створити_текст(М, "Виконути перевірку ціле число менше можна з цілим або дробовим числом.")),
      місцезнаходження
    );
    вернути значення_недійсне();
  }

  місцева дія предмет_цілого_більше(
    М: адреса<Машина>,
    значення: ц64,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право.вид == ЗЦіле {
      якщо значення > право.дані як ц64 {
        вернути значення_дійсне();
      } інакше {
        вернути значення_недійсне();
      }
    }

    якщо право.вид == ЗДробове {
      якщо д64(значення) > право.дані як д64 {
        вернути значення_дійсне();
      } інакше {
        вернути значення_недійсне();
      }
    }

    увімкнути_стан_падіння(
      М,
      значення_предмет(створити_текст(М, "Виконути перевірку ціле число менше можна з цілим або дробовим числом.")),
      місцезнаходження
    );
    вернути значення_недійсне();
  }

  місцева дія предмет_цілого_двійкове_не(
    М: адреса<Машина>,
    значення: ц64,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    вернути значення_ціле(значення); // потім: втілити
  }

  місцева дія предмет_цілого_змінити_знак(
    М: адреса<Машина>,
    значення: ц64,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    вернути значення_ціле(-значення);
  }

  місцева дія предмет_цілого_отримати_властивість(
    М: адреса<Машина>,
    значення: ц64,
    назва: адреса<ПредметТексту>,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо назва == М.константи_назв._0 або перевірити_чи_предмети_тексту_рівні(М, назва, М.константи_назв._0) {
      якщо (значення & (ц64(1) << 0)) >> 0 {
        вернути значення_дійсне();
      } інакше {
        вернути значення_недійсне();
      }
    }
    якщо назва == М.константи_назв._1 або перевірити_чи_предмети_тексту_рівні(М, назва, М.константи_назв._1) {
      якщо (значення & (ц64(1) << 1)) >> 1 {
        вернути значення_дійсне();
      } інакше {
        вернути значення_недійсне();
      }
    }
    якщо назва == М.константи_назв._2 або перевірити_чи_предмети_тексту_рівні(М, назва, М.константи_назв._2) {
      якщо (значення & (ц64(1) << 2)) >> 2 {
        вернути значення_дійсне();
      } інакше {
        вернути значення_недійсне();
      }
    }
    якщо назва == М.константи_назв._3 або перевірити_чи_предмети_тексту_рівні(М, назва, М.константи_назв._3) {
      якщо (значення & (ц64(1) << 3)) >> 3 {
        вернути значення_дійсне();
      } інакше {
        вернути значення_недійсне();
      }
    }
    якщо назва == М.константи_назв._4 або перевірити_чи_предмети_тексту_рівні(М, назва, М.константи_назв._4) {
      якщо (значення & (ц64(1) << 4)) >> 4 {
        вернути значення_дійсне();
      } інакше {
        вернути значення_недійсне();
      }
    }
    якщо назва == М.константи_назв._5 або перевірити_чи_предмети_тексту_рівні(М, назва, М.константи_назв._5) {
      якщо (значення & (ц64(1) << 5)) >> 5 {
        вернути значення_дійсне();
      } інакше {
        вернути значення_недійсне();
      }
    }
    якщо назва == М.константи_назв._6 або перевірити_чи_предмети_тексту_рівні(М, назва, М.константи_назв._6) {
      якщо (значення & (ц64(1) << 6)) >> 6 {
        вернути значення_дійсне();
      } інакше {
        вернути значення_недійсне();
      }
    }
    якщо назва == М.константи_назв._7 або перевірити_чи_предмети_тексту_рівні(М, назва, М.константи_назв._7) {
      якщо (значення & (ц64(1) << 7)) >> 7 {
        вернути значення_дійсне();
      } інакше {
        вернути значення_недійсне();
      }
    }
    якщо назва == М.константи_назв._8 або перевірити_чи_предмети_тексту_рівні(М, назва, М.константи_назв._8) {
      якщо (значення & (ц64(1) << 8)) >> 8 {
        вернути значення_дійсне();
      } інакше {
        вернути значення_недійсне();
      }
    }
    якщо назва == М.константи_назв._9 або перевірити_чи_предмети_тексту_рівні(М, назва, М.константи_назв._9) {
      якщо (значення & (ц64(1) << 9)) >> 9 {
        вернути значення_дійсне();
      } інакше {
        вернути значення_недійсне();
      }
    }

    // потім: доробити

    вернути значення_недійсне();
  }
}