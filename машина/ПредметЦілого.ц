взяти означення мавка;

простір мавка {
  дія рідна_дія__з(
    М: адреса<Машина>,
    здійснювач: Значення,
    предмет_дії: адреса<ПредметДії>,
    задіяні: Задіяні
  ) -> ЗначенняАбоСтанПадіння {
    змінна задіяне_значення: Значення = пусто;

    знайти_задіяне(М, задіяні, 0, М.константи_назв._значення, задіяне_значення::адреса);

    якщо задіяне_значення == пусто {
      вернути створити_ціле(М, 0) як Значення;
    }

    якщо задіяне_значення.тип == М.предмет_структури_Ціле {
      вернути задіяне_значення;
    }

    якщо задіяне_значення.тип == М.предмет_структури_Дробове {
      вернути створити_ціле(
        М,
        ц64((задіяне_значення як адреса<ПредметДробового>).значення)
      ) як Значення;
    }

    вернути здійснити_властивість(
      М,
      задіяне_значення,
      М.константи_назв._чародія_ціле,
      Задіяні { 0, пусто, пусто },
      Місцезнаходження { пусто, 0 }
    );
  }

  дія записати_дію__з(М: адреса<Машина>) {
    змінна предмет_дії = створити_рідну_дію(
      М,
      М.константи_назв._з,
      пусто,
      пусто,
      рідна_дія__з,
      пусто
    );

    змінити_властивість(
      М,
      М.предмет_структури_Ціле як Значення,
      М.константи_назв._з,
      предмет_дії як Значення,
      Місцезнаходження { пусто, 0 }
    );

    якщо М.стан_падіння {
      запанікувати(М, "Помилка при записі дії \"з\" для структури \"Ціле\".");
    }
  }
}

простір мавка {
  місцева дія заповнити_структуру_Ціле(
    М: адреса<Машина>
  ) {
    записати_дію__з(М);
  }

  місцева дія створити_ціле(
    М: адреса<Машина>,
    значення: ц64
  ) -> адреса<ПредметЦілого> {
    змінна предмет = виділити_предмет<ПредметЦілого>(М, М.предмет_структури_Ціле);

    предмет.значення = значення;

    вернути предмет;
  }

  місцева дія предмет_цілого_додати(
    М: адреса<Машина>,
    предмет: адреса<ПредметЦілого>,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    якщо право.тип == М.предмет_структури_Ціле {
      змінна властивості_право = право як адреса<ПредметЦілого>;

      вернути створити_ціле(М, предмет.значення + властивості_право.значення) як Значення;
    }

    якщо право.тип == М.предмет_структури_Дробове {
      змінна властивості_право = право як адреса<ПредметДробового>;

      вернути створити_дробове(М, д64(предмет.значення) + властивості_право.значення) як Значення;
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Додати до цілого числа можна лише або ціле або дробове число.") як Значення,
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_відняти(
    М: адреса<Машина>,
    предмет: адреса<ПредметЦілого>,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    якщо право.тип == М.предмет_структури_Ціле {
      змінна властивості_право = право як адреса<ПредметЦілого>;

      вернути створити_ціле(М, предмет.значення - властивості_право.значення) як Значення;
    }

    якщо право.тип == М.предмет_структури_Дробове {
      змінна властивості_право = право як адреса<ПредметДробового>;

      вернути створити_дробове(М, д64(предмет.значення) - властивості_право.значення) як Значення;
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Відняти від цілого числа можна лише або ціле або дробове число.") як Значення,
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_помножити(
    М: адреса<Машина>,
    предмет: адреса<ПредметЦілого>,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    якщо право.тип == М.предмет_структури_Ціле {
      змінна властивості_право = право як адреса<ПредметЦілого>;

      вернути створити_ціле(М, предмет.значення * властивості_право.значення) як Значення;
    }

    якщо право.тип == М.предмет_структури_Дробове {
      змінна властивості_право = право як адреса<ПредметДробового>;

      вернути створити_дробове(М, д64(предмет.значення) * властивості_право.значення) як Значення;
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Помножити ціле число можна лише на або ціле або дробове число.") як Значення,
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_поділити(
    М: адреса<Машина>,
    предмет: адреса<ПредметЦілого>,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    якщо право.тип == М.предмет_структури_Ціле {
      змінна властивості_право = право як адреса<ПредметЦілого>;

      вернути створити_дробове(М, д64(предмет.значення) / д64(властивості_право.значення)) як Значення;
    }

    якщо право.тип == М.предмет_структури_Дробове {
      змінна властивості_право = право як адреса<ПредметДробового>;

      вернути створити_дробове(М, д64(предмет.значення) / властивості_право.значення) як Значення;
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Поділити ціле число можна лише на або ціле або дробове число.") як Значення,
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_остача(
    М: адреса<Машина>,
    предмет: адреса<ПредметЦілого>,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    якщо право.тип == М.предмет_структури_Ціле {
      змінна властивості_право = право як адреса<ПредметЦілого>;

      вернути створити_ціле(М, предмет.значення % властивості_право.значення) як Значення;
    }

    якщо право.тип == М.предмет_структури_Дробове {
      змінна властивості_право = право як адреса<ПредметДробового>;

      вернути створити_дробове(М, д64(предмет.значення) % властивості_право.значення) як Значення;
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Отримати остачу ділення цілого числа можна лише з або цілим або дробовим число.") як Значення,
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_частка(
    М: адреса<Машина>,
    предмет: адреса<ПредметЦілого>,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    якщо право.тип == М.предмет_структури_Ціле {
      змінна властивості_право = право як адреса<ПредметЦілого>;

      вернути створити_ціле(М, предмет.значення / властивості_право.значення) як Значення;
    }

    якщо право.тип == М.предмет_структури_Дробове {
      змінна властивості_право = право як адреса<ПредметДробового>;

      вернути створити_дробове(М, д64(предмет.значення) / властивості_право.значення) як Значення;
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Отримати неповну частку ділення цілого числа можна лише з або цілим або дробовим число.") як Значення,
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_степінь(
    М: адреса<Машина>,
    предмет: адреса<ПредметЦілого>,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    якщо право.тип == М.предмет_структури_Ціле {
      змінна властивості_право = право як адреса<ПредметЦілого>;

      вернути створити_ціле(М, піднести_до_степеня_ц64(М, предмет.значення, властивості_право.значення)) як Значення;
    }

    якщо право.тип == М.предмет_структури_Дробове {
      змінна властивості_право = право як адреса<ПредметДробового>;

      вернути створити_дробове(М, піднести_до_степеня_д64(М, д64(предмет.значення), властивості_право.значення)) як Значення;
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Отримати степінь цілого числа можна лише з або цілим або дробовим число.") як Значення,
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_вліво(
    М: адреса<Машина>,
    предмет: адреса<ПредметЦілого>,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    якщо право.тип == М.предмет_структури_Ціле {
      змінна властивості_право = право як адреса<ПредметЦілого>;

      вернути створити_ціле(М, предмет.значення << властивості_право.значення) як Значення;
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Зсунути вліво ціле число можна лише з або цілим числом.") як Значення,
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_вправо(
    М: адреса<Машина>,
    предмет: адреса<ПредметЦілого>,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    якщо право.тип == М.предмет_структури_Ціле {
      змінна властивості_право = право як адреса<ПредметЦілого>;

      вернути створити_ціле(М, предмет.значення >> властивості_право.значення) як Значення;
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Зсунути вправо ціле число можна лише з або цілим числом.") як Значення,
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_двійкове_і(
    М: адреса<Машина>,
    предмет: адреса<ПредметЦілого>,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    якщо право.тип == М.предмет_структури_Ціле {
      змінна властивості_право = право як адреса<ПредметЦілого>;

      вернути створити_ціле(М, предмет.значення & властивості_право.значення) як Значення;
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконути двійкове І можна лише між цілими числами.") як Значення,
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_двійкове_або(
    М: адреса<Машина>,
    предмет: адреса<ПредметЦілого>,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    якщо право.тип == М.предмет_структури_Ціле {
      змінна властивості_право = право як адреса<ПредметЦілого>;

      вернути створити_ціле(М, предмет.значення | властивості_право.значення) як Значення;
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконути двійкове АБО можна лише між цілими числами.") як Значення,
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_двійкове_вабо(
    М: адреса<Машина>,
    предмет: адреса<ПредметЦілого>,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    якщо право.тип == М.предмет_структури_Ціле {
      змінна властивості_право = право як адреса<ПредметЦілого>;

      вернути створити_ціле(М, предмет.значення вабо властивості_право.значення) як Значення;
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконути двійкове ВАБО можна лише між цілими числами.") як Значення,
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_менше(
    М: адреса<Машина>,
    предмет: адреса<ПредметЦілого>,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    якщо право.тип == М.предмет_структури_Ціле {
      змінна властивості_право = право як адреса<ПредметЦілого>;

      якщо предмет.значення < властивості_право.значення {
        вернути М.значення_дійсне;
      } інакше {
        вернути пусто;
      }
    }

    якщо право.тип == М.предмет_структури_Дробове {
      змінна властивості_право = право як адреса<ПредметДробового>;

      якщо д64(предмет.значення) < властивості_право.значення {
        вернути М.значення_дійсне;
      } інакше {
        вернути пусто;
      }
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконути перевірку ціле число менше можна з цілим або дробовим числом.") як Значення,
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_більше(
    М: адреса<Машина>,
    предмет: адреса<ПредметЦілого>,
    право: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    якщо право.тип == М.предмет_структури_Ціле {
      змінна властивості_право = право як адреса<ПредметЦілого>;

      якщо предмет.значення > властивості_право.значення {
        вернути М.значення_дійсне;
      } інакше {
        вернути пусто;
      }
    }

    якщо право.тип == М.предмет_структури_Дробове {
      змінна властивості_право = право як адреса<ПредметДробового>;

      якщо д64(предмет.значення) > властивості_право.значення {
        вернути М.значення_дійсне;
      } інакше {
        вернути пусто;
      }
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконути перевірку ціле число менше можна з цілим або дробовим числом.") як Значення,
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_двійкове_не(
    М: адреса<Машина>,
    предмет: адреса<ПредметЦілого>,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    вернути створити_ціле(М, предмет.значення) як Значення;
  }

  місцева дія предмет_цілого_змінити_знак(
    М: адреса<Машина>,
    предмет: адреса<ПредметЦілого>,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    вернути створити_ціле(М, -предмет.значення) як Значення;
  }

  місцева дія предмет_цілого_отримати_властивість(
    М: адреса<Машина>,
    предмет_цілого: адреса<ПредметЦілого>,
    назва: адреса<ПредметТексту>,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо назва == М.константи_назв._0 або перевірити_чи_предмети_тексту_рівні(М, назва, М.константи_назв._0) {
      якщо (предмет_цілого.значення & (ц64(1) << 0)) >> 0 {
        вернути М.значення_дійсне;
      } інакше {
        вернути пусто;
      }
    }
    якщо назва == М.константи_назв._1 або перевірити_чи_предмети_тексту_рівні(М, назва, М.константи_назв._1) {
      якщо (предмет_цілого.значення & (ц64(1) << 1)) >> 1 {
        вернути М.значення_дійсне;
      } інакше {
        вернути пусто;
      }
    }
    якщо назва == М.константи_назв._2 або перевірити_чи_предмети_тексту_рівні(М, назва, М.константи_назв._2) {
      якщо (предмет_цілого.значення & (ц64(1) << 2)) >> 2 {
        вернути М.значення_дійсне;
      } інакше {
        вернути пусто;
      }
    }
    якщо назва == М.константи_назв._3 або перевірити_чи_предмети_тексту_рівні(М, назва, М.константи_назв._3) {
      якщо (предмет_цілого.значення & (ц64(1) << 3)) >> 3 {
        вернути М.значення_дійсне;
      } інакше {
        вернути пусто;
      }
    }
    якщо назва == М.константи_назв._4 або перевірити_чи_предмети_тексту_рівні(М, назва, М.константи_назв._4) {
      якщо (предмет_цілого.значення & (ц64(1) << 4)) >> 4 {
        вернути М.значення_дійсне;
      } інакше {
        вернути пусто;
      }
    }
    якщо назва == М.константи_назв._5 або перевірити_чи_предмети_тексту_рівні(М, назва, М.константи_назв._5) {
      якщо (предмет_цілого.значення & (ц64(1) << 5)) >> 5 {
        вернути М.значення_дійсне;
      } інакше {
        вернути пусто;
      }
    }
    якщо назва == М.константи_назв._6 або перевірити_чи_предмети_тексту_рівні(М, назва, М.константи_назв._6) {
      якщо (предмет_цілого.значення & (ц64(1) << 6)) >> 6 {
        вернути М.значення_дійсне;
      } інакше {
        вернути пусто;
      }
    }
    якщо назва == М.константи_назв._7 або перевірити_чи_предмети_тексту_рівні(М, назва, М.константи_назв._7) {
      якщо (предмет_цілого.значення & (ц64(1) << 7)) >> 7 {
        вернути М.значення_дійсне;
      } інакше {
        вернути пусто;
      }
    }
    якщо назва == М.константи_назв._8 або перевірити_чи_предмети_тексту_рівні(М, назва, М.константи_назв._8) {
      якщо (предмет_цілого.значення & (ц64(1) << 8)) >> 8 {
        вернути М.значення_дійсне;
      } інакше {
        вернути пусто;
      }
    }
    якщо назва == М.константи_назв._9 або перевірити_чи_предмети_тексту_рівні(М, назва, М.константи_назв._9) {
      якщо (предмет_цілого.значення & (ц64(1) << 9)) >> 9 {
        вернути М.значення_дійсне;
      } інакше {
        вернути пусто;
      }
    }

    // потім: доробити

    вернути пусто;
  }
}