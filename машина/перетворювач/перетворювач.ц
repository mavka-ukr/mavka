взяти означення мавка/перетворювач;

дія перевірити_чи_кд_рівні(а: кд, б: кд) -> логічне {
  якщо а.розмір != б.розмір {
    вернути ні;
  }

  змінна п: природне = 0;

  поки п < а.розмір {
    якщо а.дані[п] != б.дані[п] {
      вернути ні;
    }

    п += 1;
  }

  вернути так;
}

дія перевірити_чи_починається_на(значення: кд, починається_на: кд, п: адреса<природне>) -> логічне {
  змінна пп: природне = 0;

  поки пп < починається_на.розмір {
    змінна ппп = п::вміст + пп;

    якщо ппп >= значення.розмір {
      вернути ні;
    }

    якщо значення.дані[ппп] != починається_на.дані[пп] {
      вернути ні;
    }

    пп += 1;
  }

  п::вміст = п::вміст + пп - 1;

  вернути так;
}

дія розібрати_ціле_з_кд(значення: кд, вихід: адреса<ц64>) -> логічне {
  змінна відʼємне = ні;
  змінна п: природне = 0;
  якщо значення.дані[п] == 45 {
    відʼємне = так;
    п += 1;
  }
  якщо перевірити_чи_починається_на(значення, "0д", п::адреса) {
    п += 1;
    змінна значення_0д: ц64 = 0;
    поки п < значення.розмір {
      значення_0д *= 2;
      якщо значення.дані[п] == мавка::розбирач::КД_0 {
      } інакше якщо значення.дані[п] == мавка::розбирач::КД_1 {
        значення_0д += 1;
      } інакше {
        вернути ні;
      }
      п += 1;
    }
    якщо відʼємне {
      вихід::вміст = ц64(0) - значення_0д;
      вернути так;
    }
    вихід::вміст = значення_0д;
    вернути так;
  }
  якщо перевірити_чи_починається_на(значення, "0ш", п::адреса) {
    п += 1;
    змінна значення_0ш: ц64 = 0;
    поки п < значення.розмір {
      змінна с: п8 = 0;
      якщо перевірити_чи_починається_на(значення, "0", п::адреса) {
        с = 0;
      } інакше якщо перевірити_чи_починається_на(значення, "1", п::адреса) {
        с = 1;
      } інакше якщо перевірити_чи_починається_на(значення, "2", п::адреса) {
        с = 2;
      } інакше якщо перевірити_чи_починається_на(значення, "3", п::адреса) {
        с = 3;
      } інакше якщо перевірити_чи_починається_на(значення, "4", п::адреса) {
        с = 4;
      } інакше якщо перевірити_чи_починається_на(значення, "5", п::адреса) {
        с = 5;
      } інакше якщо перевірити_чи_починається_на(значення, "6", п::адреса) {
        с = 6;
      } інакше якщо перевірити_чи_починається_на(значення, "7", п::адреса) {
        с = 7;
      } інакше якщо перевірити_чи_починається_на(значення, "8", п::адреса) {
        с = 8;
      } інакше якщо перевірити_чи_починається_на(значення, "9", п::адреса) {
        с = 9;
      } інакше якщо перевірити_чи_починається_на(значення, "А", п::адреса) {
        с = 10;
      } інакше якщо перевірити_чи_починається_на(значення, "Б", п::адреса) {
        с = 11;
      } інакше якщо перевірити_чи_починається_на(значення, "В", п::адреса) {
        с = 12;
      } інакше якщо перевірити_чи_починається_на(значення, "Г", п::адреса) {
        с = 13;
      } інакше якщо перевірити_чи_починається_на(значення, "Д", п::адреса) {
        с = 14;
      } інакше якщо перевірити_чи_починається_на(значення, "Е", п::адреса) {
        с = 15;
      } інакше якщо перевірити_чи_починається_на(значення, "а", п::адреса) {
        с = 10;
      } інакше якщо перевірити_чи_починається_на(значення, "б", п::адреса) {
        с = 11;
      } інакше якщо перевірити_чи_починається_на(значення, "в", п::адреса) {
        с = 12;
      } інакше якщо перевірити_чи_починається_на(значення, "г", п::адреса) {
        с = 13;
      } інакше якщо перевірити_чи_починається_на(значення, "д", п::адреса) {
        с = 14;
      } інакше якщо перевірити_чи_починається_на(значення, "е", п::адреса) {
        с = 15;
      } інакше {
        вернути ні;
      }
      значення_0ш = (значення_0ш << 4) | (ц64(с) & 15);
      п += 1;
    }
    якщо відʼємне {
      вихід::вміст = -значення_0ш;
      вернути так;
    }
    вихід::вміст = значення_0ш;
    вернути так;
  }
  змінна результат: ц64 = 0;
  змінна символ_: п8 = значення.дані[0];
  поки п < значення.розмір {
    символ_ = значення.дані[п];
    якщо символ_ == мавка::розбирач::КД_0 { // 0
      результат = результат * 10;
    } інакше якщо символ_ == мавка::розбирач::КД_1 { // 1
      результат = результат * 10 + 1;
    } інакше якщо символ_ == мавка::розбирач::КД_2 { // 2
      результат = результат * 10 + 2;
    } інакше якщо символ_ == мавка::розбирач::КД_3 { // 3
      результат = результат * 10 + 3;
    } інакше якщо символ_ == мавка::розбирач::КД_4 { // 4
      результат = результат * 10 + 4;
    } інакше якщо символ_ == мавка::розбирач::КД_5 { // 5
      результат = результат * 10 + 5;
    } інакше якщо символ_ == мавка::розбирач::КД_6 { // 6
      результат = результат * 10 + 6;
    } інакше якщо символ_ == мавка::розбирач::КД_7 { // 7
      результат = результат * 10 + 7;
    } інакше якщо символ_ == мавка::розбирач::КД_8 { // 8
      результат = результат * 10 + 8;
    } інакше якщо символ_ == мавка::розбирач::КД_9 { // 9
      результат = результат * 10 + 9;
    } інакше якщо символ_ == мавка::розбирач::КД_ПІДРИСКА { // _
      // ігноруємо
    } інакше {
      вернути ні;
    }
    п += 1;
  }
  вихід::вміст = результат;
  вернути так;
}

дія розібрати_дробове_з_кд(значення: кд, вихід: адреса<д64>) -> логічне {
  змінна відʼємне = ні;
  змінна п: природне = 0;
  якщо значення.дані[п] == 45 {
    відʼємне = так;
    п += 1;
  }
  змінна результат: д64 = 0;
  змінна символ_: п8 = значення.дані[0];
  поки п < значення.розмір {
    символ_ = значення.дані[п];
    якщо символ_ == мавка::розбирач::КД_0 { // 0
      результат = результат * 10;
    } інакше якщо символ_ == мавка::розбирач::КД_1 { // 1
      результат = результат * 10 + 1;
    } інакше якщо символ_ == мавка::розбирач::КД_2 { // 2
      результат = результат * 10 + 2;
    } інакше якщо символ_ == мавка::розбирач::КД_3 { // 3
      результат = результат * 10 + 3;
    } інакше якщо символ_ == мавка::розбирач::КД_4 { // 4
      результат = результат * 10 + 4;
    } інакше якщо символ_ == мавка::розбирач::КД_5 { // 5
      результат = результат * 10 + 5;
    } інакше якщо символ_ == мавка::розбирач::КД_6 { // 6
      результат = результат * 10 + 6;
    } інакше якщо символ_ == мавка::розбирач::КД_7 { // 7
      результат = результат * 10 + 7;
    } інакше якщо символ_ == мавка::розбирач::КД_8 { // 8
      результат = результат * 10 + 8;
    } інакше якщо символ_ == мавка::розбирач::КД_9 { // 9
      результат = результат * 10 + 9;
    } інакше якщо символ_ == мавка::розбирач::КД_ПІДРИСКА { // _
      // ігноруємо
    } інакше якщо символ_ == мавка::розбирач::КД_КРАПКА { // .
      п += 1;
      символ_ = значення.дані[п];
      змінна дробна_частина: д64 = 0;
      змінна дільник: д64 = 1;
      поки п < значення.розмір {
        символ_ = значення.дані[п];
        якщо символ_ == мавка::розбирач::КД_0 { // 0
          дробна_частина = дробна_частина * 10;
        } інакше якщо символ_ == мавка::розбирач::КД_1 { // 1
          дробна_частина = дробна_частина * 10 + 1;
        } інакше якщо символ_ == мавка::розбирач::КД_2 { // 2
          дробна_частина = дробна_частина * 10 + 2;
        } інакше якщо символ_ == мавка::розбирач::КД_3 { // 3
          дробна_частина = дробна_частина * 10 + 3;
        } інакше якщо символ_ == мавка::розбирач::КД_4 { // 4
          дробна_частина = дробна_частина * 10 + 4;
        } інакше якщо символ_ == мавка::розбирач::КД_5 { // 5
          дробна_частина = дробна_частина * 10 + 5;
        } інакше якщо символ_ == мавка::розбирач::КД_6 { // 6
          дробна_частина = дробна_частина * 10 + 6;
        } інакше якщо символ_ == мавка::розбирач::КД_7 { // 7
          дробна_частина = дробна_частина * 10 + 7;
        } інакше якщо символ_ == мавка::розбирач::КД_8 { // 8
          дробна_частина = дробна_частина * 10 + 8;
        } інакше якщо символ_ == мавка::розбирач::КД_9 { // 9
          дробна_частина = дробна_частина * 10 + 9;
        } інакше якщо символ_ == мавка::розбирач::КД_ПІДРИСКА { // _
          // ігноруємо
        } інакше {
          вернути ні;
        }
        п += 1;
        дільник = дільник * 10;
      }
      результат = результат + дробна_частина / дільник;
      вихід::вміст = результат;
      вернути так;
    } інакше {
      вернути ні;
    }
    п += 1;
  }
  вихід::вміст = результат;
  вернути так;
}

простір мавка {
  простір перетворювач {
    дія клонувати_кд(М: адреса<Машина>, значення: кд) -> кд {
      змінна дані_клону_значення = виділити_памʼять<п8>(М, значення.розмір);

      змінна п: природне = 0;
      поки п < значення.розмір {
        дані_клону_значення[п] = значення.дані[п];
        п += 1;
      }

      вернути кд {
        значення.розмір,
        дані_клону_значення
      };
    }

    дія отримати_оброблену_копію_кд_тексту(М: адреса<Машина>, значення_кд: кд, вихід: адреса<кд>) -> логічне {
      змінна новий_розмір: природне = 0;
      змінна нові_дані = виділити_памʼять<п8>(М, значення_кд.розмір);

      змінна п: природне = 0;

      поки п < значення_кд.розмір {
        змінна символ = значення_кд.дані[п];

        якщо символ == розбирач::КД_ОБЕРНЕНА_ПОХИЛА {
          якщо (п + 1) < значення_кд.розмір {
            змінна наступний_символ = значення_кд.дані[п + 1];

            якщо наступний_символ == розбирач::КД_ОБЕРНЕНА_ПОХИЛА {
              нові_дані[новий_розмір] = розбирач::КД_ОБЕРНЕНА_ПОХИЛА;
              новий_розмір += 1;
              п += 1;
            } інакше якщо наступний_символ == розбирач::КД_ДВОЛАПКА {
              нові_дані[новий_розмір] = розбирач::КД_ДВОЛАПКА;
              новий_розмір += 1;
              п += 1;
            } інакше якщо наступний_символ == розбирач::КД_ЛАПКА {
              нові_дані[новий_розмір] = розбирач::КД_ЛАПКА;
              новий_розмір += 1;
              п += 1;
            } інакше якщо наступний_символ == розбирач::КД_р {
              нові_дані[новий_розмір] = розбирач::КД_РОЗРИВ;
              новий_розмір += 1;
              п += 1;
            } інакше якщо наступний_символ == розбирач::КД_д {
              нові_дані[новий_розмір] = розбирач::КД_ДІЯ;
              новий_розмір += 1;
              п += 1;
            } інакше {
              вернути ні;
            }
          } інакше {
            вернути ні;
          }
        } інакше {
          нові_дані[новий_розмір] = значення_кд.дані[п];
          новий_розмір += 1;
        }

        п += 1;
      }

      вихід::вміст = кд {
        новий_розмір,
        нові_дані
      };

      вернути так;
    }

    дія покласти_вказівку_ПокластиДійсне(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВПокластиДійсне);
    }

    дія покласти_вказівку_ПокластиНедійсне(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВПокластиНедійсне);
    }

    дія покласти_вказівку_ПокластиПредмет(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВПокластиПредмет);
    }

    дія покласти_вказівку_ПокластиЯ(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВПокластиЯ);
    }

    дія покласти_вказівку_ПокластиКонстанту(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32, позиція_константи: п32) -> п32 {
      вернути дії.покласти_вказівку_з_аргументом(М, код, рядок, ВПокластиКонстанту, позиція_константи);
    }

    дія покласти_вказівку_Звернутись(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВЗвернутись);
    }

    дія покласти_вказівку_ОтриматиВластивість(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВОтриматиВластивість);
    }

    дія покласти_вказівку_ОтриматиЕлемент(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВОтриматиЕлемент);
    }

    дія покласти_вказівку_Здійснити(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32, кількість_аргументів: п32, кількість_іменованих_аргументів: п32) -> п32 {
      вернути дії.покласти_вказівку_з_двома_аргументами(М, код, рядок, ВЗдійснити, кількість_аргументів, кількість_іменованих_аргументів);
    }

    дія покласти_вказівку_ЗдійснитиВластивість(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32, кількість_аргументів: п32, кількість_іменованих_аргументів: п32) -> п32 {
      вернути дії.покласти_вказівку_з_двома_аргументами(М, код, рядок, ВЗдійснитиВластивість, кількість_аргументів, кількість_іменованих_аргументів);
    }

    дія покласти_вказівку_СтворитиПараметр(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВСтворитиПараметр);
    }

    дія покласти_вказівку_СтворитиДію(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32, кількість_параметрів: п32) -> п32 {
      вернути дії.покласти_вказівку_з_аргументом(М, код, рядок, ВСтворитиДію, кількість_параметрів);
    }

    дія покласти_вказівку_СтворитиМодуль(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВСтворитиМодуль);
    }

    дія покласти_вказівку_СтворитиСтруктуру(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32, кількість_параметрів: п32) -> п32 {
      вернути дії.покласти_вказівку_з_аргументом(М, код, рядок, ВСтворитиСтруктуру, кількість_параметрів);
    }

    дія покласти_вказівку_СтворитиСписок(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32, кількість_елементів: п32) -> п32 {
      вернути дії.покласти_вказівку_з_аргументом(М, код, рядок, ВСтворитиСписок, кількість_елементів);
    }

    дія покласти_вказівку_СтворитиСловник(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32, кількість_елементів: п32) -> п32 {
      вернути дії.покласти_вказівку_з_аргументом(М, код, рядок, ВСтворитиСловник, кількість_елементів);
    }

    дія покласти_вказівку_СтворитиДіапазон(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВСтворитиДіапазон);
    }

    дія покласти_вказівку_ЗбитиТекст(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32, кількість_елементів: п32) -> п32 {
      вернути дії.покласти_вказівку_з_аргументом(М, код, рядок, ВЗбитиТекст, кількість_елементів);
    }

    дія покласти_вказівку_Дублювати(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВДублювати);
    }

    дія покласти_вказівку_Забрати(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВЗабрати);
    }

    дія покласти_вказівку_Стрибнути(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32, позиція_вказівки: п32) -> п32 {
      вернути дії.покласти_вказівку_з_аргументом(М, код, рядок, ВСтрибнути, позиція_вказівки);
    }

    дія покласти_вказівку_СтрибнутиЯкщоНі(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32, позиція_вказівки: п32) -> п32 {
      вернути дії.покласти_вказівку_з_аргументом(М, код, рядок, ВСтрибнутиЯкщоНі, позиція_вказівки);
    }

    дія покласти_вказівку_СтрибнутиЯкщоТак(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32, позиція_вказівки: п32) -> п32 {
      вернути дії.покласти_вказівку_з_аргументом(М, код, рядок, ВСтрибнутиЯкщоТак, позиція_вказівки);
    }

    дія покласти_вказівку_Взяти(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32, кількість_назв: п32) -> п32 {
      вернути дії.покласти_вказівку_з_аргументом(М, код, рядок, ВВзяти, кількість_назв);
    }

    дія покласти_вказівку_ПочатиСпробу(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32, позиція_вказівки_зловити: п32) -> п32 {
      вернути дії.покласти_вказівку_з_аргументом(М, код, рядок, ВПочатиСпробу, позиція_вказівки_зловити);
    }

    дія покласти_вказівку_ЗакінчитиСпробу(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32, позиція_вказівки_виходу: п32) -> п32 {
      вернути дії.покласти_вказівку_з_аргументом(М, код, рядок, ВЗакінчитиСпробу, позиція_вказівки_виходу);
    }

    дія покласти_вказівку_Додати(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВДодати);
    }

    дія покласти_вказівку_Відняти(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВВідняти);
    }

    дія покласти_вказівку_Помножити(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВПомножити);
    }

    дія покласти_вказівку_Поділити(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВПоділити);
    }

    дія покласти_вказівку_ОтриматиОстачуДілення(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВОтриматиОстачуДілення);
    }

    дія покласти_вказівку_ОтриматиНеповнуЧасткуДілення(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВОтриматиНеповнуЧасткуДілення);
    }

    дія покласти_вказівку_ПіднестиДоСтепеня(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВПіднестиДоСтепеня);
    }

    дія покласти_вказівку_ЗсунутиВліво(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВЗсунутиВліво);
    }

    дія покласти_вказівку_ЗсунутиВправо(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВЗсунутиВправо);
    }

    дія покласти_вказівку_ЗсунутиВправо2(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВЗсунутиВправо2);
    }

    дія покласти_вказівку_ДвійковеІ(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВДвійковеІ);
    }

    дія покласти_вказівку_ДвійковеАБО(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВДвійковеАБО);
    }

    дія покласти_вказівку_ДвійковеВиключнеАБО(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВДвійковеВиключнеАБО);
    }

    дія покласти_вказівку_ДвійковеНЕ(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВДвійковеНЕ);
    }

    дія покласти_вказівку_Менше(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВМенше);
    }

    дія покласти_вказівку_Більше(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВБільше);
    }

    дія покласти_вказівку_НеБільше(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВНеБільше);
    }

    дія покласти_вказівку_НеМенше(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВНеМенше);
    }

    дія покласти_вказівку_Рівно(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВРівно);
    }

    дія покласти_вказівку_НеРівно(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВНеРівно);
    }

    дія покласти_вказівку_Є(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВЄ);
    }

    дія покласти_вказівку_НеЄ(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВНеЄ);
    }

    дія покласти_вказівку_Відʼємне(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВВідʼємне);
    }

    дія покласти_вказівку_Заперечити(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВЗаперечити);
    }

    дія покласти_вказівку_Визначити(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВВизначити);
    }

    дія покласти_вказівку_ВизначитиНавпаки(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВВизначитиНавпаки);
    }

    дія покласти_вказівку_ЗаписатиМетод(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВЗаписатиМетод);
    }

    дія покласти_вказівку_ЗмінитиВластивість(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВЗмінитиВластивість);
    }

    дія покласти_вказівку_ЗмінитиЕлемент(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВЗмінитиЕлемент);
    }

    дія покласти_вказівку_Вернути(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВВернути);
    }

    дія покласти_вказівку_Впасти(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВВпасти);
    }

    дія покласти_вказівку_Дати(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВДати);
    }

    дія покласти_вказівку_ОтриматиПеребір(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВОтриматиПеребір);
    }

    дія покласти_вказівку_ПеребратиДалі(М: адреса<Машина>, код: невідома_адреса, дії: Дії, рядок: п32) -> п32 {
      вернути дії.покласти_вказівку(М, код, рядок, ВПеребратиДалі);
    }
  }


  простір перетворювач {
    дія зробити_помилку_перетворення(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, місцезнаходження: розбирач::Місцезнаходження, повідомлення: кд) -> ПомилкаПеретворення;
    дія перетворити_сполуку_визначити(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиВизначити, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_звернутись(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиЗвернутись, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_отримати_властивість(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиОтриматиВластивість, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_отримати_елемент(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиОтриматиЕлемент, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_змінити_властивість(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиЗмінитиВластивість, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_змінити_елемент(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиЗмінитиЕлемент, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_виконати(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиВиконати, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_дія(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиДія, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_структура(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиСтруктура, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_ціле(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиЦіле, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_дробове(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиДробове, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_текст(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиТекст, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_операція(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиОперація, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_якщо(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиЯкщо, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_поки(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиПоки, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_вернути(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиВернути, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_значення_якщо(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиЗначенняЯкщо, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_само_операція(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиСамоОперація, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_взяти(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиВзяти, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_спробувати(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиСпробувати, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_впасти(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиВпасти, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_дати(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиДати, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_модуль(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиМодуль, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_список(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиСписок, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_словник(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиСловник, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилок: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_символ(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиСимвол, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилок: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_перебрати(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиПеребрати, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилок: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_цикл(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиЦикл, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилок: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_вічний_цикл(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиВічнийЦикл, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилок: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_чекати(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиЧекати, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилок: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_діапазон(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиДіапазон, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилок: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку_збитий_текст(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, дані: розбирач::ДаніСполукиЗбитийТекст, місцезнаходження: розбирач::Місцезнаходження, код: невідома_адреса, дії: Дії, вихід_помилок: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_сполуку(М: адреса<Машина>, текст: кд, знаки: розбирач::Знаки, сполука: адреса<розбирач::Сполука>, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;
    дія перетворити_тіло(М: адреса<Машина>, сирий_текст: кд, знаки: розбирач::Знаки, сполуки: розбирач::Сполуки, вернути_в_кінці: логічне, код: невідома_адреса, дії: Дії, вихід_помилки: адреса<ПомилкаПеретворення>) -> логічне;

    дія зробити_помилку_перетворення(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      місцезнаходження: розбирач::Місцезнаходження,
      повідомлення: кд
    ) -> ПомилкаПеретворення {
      змінна знак = знаки.дані[місцезнаходження.позиція_знаки];
      змінна рядок = розбирач::отримати_рядок_з_місцезнаходження(текст, знаки, місцезнаходження);
      змінна стовпець = розбирач::отримати_стовпець_з_місцезнаходження(текст, знаки, місцезнаходження);

      вернути ПомилкаПеретворення {
        позиція_в_тексті = знак.позиція_початку.позиція_в_тексті,
        рядок = рядок,
        стовпець = стовпець,
        повідомлення = повідомлення,
      };
    }

    дія перетворити_сполуку_визначити(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиВизначити,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      змінна текст_ідентифікатора = розбирач::отримати_значення_ідентифікатора(
        текст,
        знаки,
        дані.ідентифікатор
      );

      змінна позиція_назви = дії.покласти_константу_тексту(М, код, текст_ідентифікатора);
      покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви);

      успіх = перетворити_сполуку(
        М,
        текст,
        знаки,
        дані.значення,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      покласти_вказівку_Визначити(М, код, дії, рядок);

      вернути так;
    }

    дія перетворити_сполуку_звернутись(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиЗвернутись,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      змінна текст_ідентифікатора = розбирач::отримати_значення_ідентифікатора(
        текст,
        знаки,
        дані.ідентифікатор
      );

      якщо перевірити_чи_кд_рівні(текст_ідентифікатора, "дійсне") {
        покласти_вказівку_ПокластиДійсне(М, код, дії, рядок);
      } інакше якщо перевірити_чи_кд_рівні(текст_ідентифікатора, "недійсне") {
        покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок);
      } інакше якщо перевірити_чи_кд_рівні(текст_ідентифікатора, "я") {
        покласти_вказівку_ПокластиЯ(М, код, дії, рядок);
      } інакше {
        змінна позиція_назви = дії.покласти_константу_тексту(М, код, текст_ідентифікатора);
        покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви);
        покласти_вказівку_Звернутись(М, код, дії, рядок);
      }

      вернути так;
    }

    дія перетворити_сполуку_отримати_властивість(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиОтриматиВластивість,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      змінна текст_ідентифікатора = розбирач::отримати_значення_ідентифікатора(
        текст,
        знаки,
        дані.ідентифікатор
      );

      успіх = перетворити_сполуку(
        М,
        текст,
        знаки,
        дані.предмет,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      змінна позиція_назви = дії.покласти_константу_тексту(М, код, текст_ідентифікатора);
      покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви);
      покласти_вказівку_ОтриматиВластивість(М, код, дії, рядок);

      вернути так;
    }

    дія перетворити_сполуку_отримати_елемент(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиОтриматиЕлемент,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      успіх = перетворити_сполуку(
        М,
        текст,
        знаки,
        дані.предмет,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      успіх = перетворити_сполуку(
        М,
        текст,
        знаки,
        дані.ключ,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      покласти_вказівку_ОтриматиЕлемент(М, код, дії, рядок);

      вернути так;
    }

    дія перетворити_сполуку_змінити_властивість(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиЗмінитиВластивість,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      успіх = перетворити_сполуку(
        М,
        текст,
        знаки,
        дані.предмет,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      змінна текст_ідентифікатора = розбирач::отримати_значення_ідентифікатора(
        текст,
        знаки,
        дані.ідентифікатор
      );

      змінна позиція_назви = дії.покласти_константу_тексту(М, код, текст_ідентифікатора);
      покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви);

      успіх = перетворити_сполуку(
        М,
        текст,
        знаки,
        дані.значення,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      покласти_вказівку_ЗмінитиВластивість(М, код, дії, рядок);

      вернути так;
    }

    дія перетворити_сполуку_змінити_елемент(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиЗмінитиЕлемент,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      успіх = перетворити_сполуку(
        М,
        текст,
        знаки,
        дані.предмет,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      успіх = перетворити_сполуку(
        М,
        текст,
        знаки,
        дані.ключ,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      успіх = перетворити_сполуку(
        М,
        текст,
        знаки,
        дані.значення,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      покласти_вказівку_ЗмінитиЕлемент(М, код, дії, рядок);

      вернути так;
    }

    дія перетворити_сполуку_виконати(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиВиконати,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      якщо дані.предмет.вид == розбирач::ВидСполукиОтриматиВластивість {
        змінна дані_отримання = дані.предмет.дані як розбирач::ДаніСполукиОтриматиВластивість;

        успіх = перетворити_сполуку(
          М,
          текст,
          знаки,
          дані_отримання.предмет,
          код,
          дії,
          вихід_помилки
        );
        якщо не успіх {
          вернути ні;
        }

        змінна текст_ідентифікатора = розбирач::отримати_значення_ідентифікатора(
          текст,
          знаки,
          дані_отримання.ідентифікатор
        );

        змінна позиція_назви_властивості = дії.покласти_константу_тексту(М, код, текст_ідентифікатора);
        покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви_властивості);
      } інакше {
        успіх = перетворити_сполуку(
          М,
          текст,
          знаки,
          дані.предмет,
          код,
          дії,
          вихід_помилки
        );
        якщо не успіх {
          вернути ні;
        }
      }

      змінна кількість_аргументів_без_назви: п32 = 0;
      змінна кількість_аргументів_з_назвою: п32 = 0;

      змінна п: п32 = 0;

      поки п < п32(дані.кількість_аргументів) {
        змінна аргумент = дані.аргументи[п];

        змінна рядок_аргумента = п32(розбирач::отримати_рядок_з_місцезнаходження(
          текст,
          знаки,
          аргумент.місцезнаходження
        ));

        якщо аргумент.ідентифікатор.заповнено {
          змінна текст_ідентифікатора_аргумента = розбирач::отримати_значення_ідентифікатора(
            текст,
            знаки,
            аргумент.ідентифікатор.значення
          );

          змінна позиція_назви_аргумента = дії.покласти_константу_тексту(М, код, текст_ідентифікатора_аргумента);
          покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок_аргумента, позиція_назви_аргумента);

          успіх = перетворити_сполуку(
            М,
            текст,
            знаки,
            аргумент.значення,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх {
            вернути ні;
          }

          кількість_аргументів_з_назвою += 1;
        } інакше {
          якщо кількість_аргументів_з_назвою > 0 {
            вихід_помилки::вміст = зробити_помилку_перетворення(
              М,
              текст,
              знаки,
              аргумент.місцезнаходження,
              клонувати_кд(М, "Аргументи без назви не можуть йти після аргументів з назвою.")
            );
            вернути ні;
          }

          успіх = перетворити_сполуку(
            М,
            текст,
            знаки,
            аргумент.значення,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх {
            вернути ні;
          }

          кількість_аргументів_без_назви += 1;
        }

        п += 1;
      }

      якщо дані.предмет.вид == розбирач::ВидСполукиОтриматиВластивість {
        покласти_вказівку_ЗдійснитиВластивість(М, код, дії, рядок, кількість_аргументів_без_назви, кількість_аргументів_з_назвою);
      } інакше {
        покласти_вказівку_Здійснити(М, код, дії, рядок, кількість_аргументів_без_назви, кількість_аргументів_з_назвою);
      }

      вернути так;
    }

    дія перетворити_сполуку_дія(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиДія,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      якщо дані.ідентифікатор.заповнено {
        змінна текст_ідентифікатора = розбирач::отримати_значення_ідентифікатора(
          текст,
          знаки,
          дані.ідентифікатор.значення
        );

        змінна позиція_назви = дії.покласти_константу_тексту(М, код, текст_ідентифікатора);
        покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви); // назва
      } інакше {
        покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок); // назва
      }

      змінна п: природне = 0;

      поки п < дані.кількість_параметрів {
        змінна параметр = дані.параметри[п];

        змінна рядок_параметра = п32(розбирач::отримати_рядок_з_місцезнаходження(
          текст,
          знаки,
          параметр.місцезнаходження
        ));

        змінна значення_ідентифікатора_параметра = розбирач::отримати_значення_ідентифікатора(
          текст,
          знаки,
          параметр.ідентифікатор
        );

        змінна позиція_назви_параметра = дії.покласти_константу_тексту(М, код, значення_ідентифікатора_параметра);
        покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви_параметра);

        покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок); // тип параметра

        якщо параметр.значення == пусто {
          покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок); // дія значення
        } інакше {
          вихід_помилки::вміст = зробити_помилку_перетворення(
            М,
            текст,
            знаки,
            місцезнаходження,
            клонувати_кд(М, "Значення параметра зараз не підтримується.")
          );
          вернути ні;
        }

        покласти_вказівку_СтворитиПараметр(М, код, дії, рядок);

        п += 1;
      }

      покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок); // тип результату

      змінна код_дії = дії.створити_код(М, дії.отримати_шлях_коду(М, код));

      успіх = перетворити_тіло(
        М,
        текст,
        знаки,
        дані.тіло,
        так,
        код_дії,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      змінна позиція_коду_дії = дії.покласти_константу_коду(М, код, код_дії);
      покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_коду_дії); // код

      покласти_вказівку_СтворитиДію(М, код, дії, рядок, п32(дані.кількість_параметрів));

      вернути так;
    }

    дія перетворити_сполуку_структура(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиСтруктура,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      якщо дані.ідентифікатор.заповнено {
        змінна текст_ідентифікатора = розбирач::отримати_значення_ідентифікатора(
          текст,
          знаки,
          дані.ідентифікатор.значення
        );

        змінна позиція_назви = дії.покласти_константу_тексту(М, код, текст_ідентифікатора);
        покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви); // назва
      } інакше {
        покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок); // назва
      }

      якщо дані.предок == пусто {
        покласти_вказівку_ПокластиПредмет(М, код, дії, рядок); // предок
      } інакше {
        успіх = перетворити_сполуку(
          М,
          текст,
          знаки,
          дані.предок,
          код,
          дії,
          вихід_помилки
        );
        якщо не успіх {
          вернути ні;
        }
      }

      змінна п: природне = 0;

      поки п < дані.кількість_параметрів {
        змінна параметр = дані.параметри[п];

        змінна рядок_параметра = п32(розбирач::отримати_рядок_з_місцезнаходження(
          текст,
          знаки,
          параметр.місцезнаходження
        ));

        змінна текст_ідентифікатора_параметра = розбирач::отримати_значення_ідентифікатора(
          текст,
          знаки,
          параметр.ідентифікатор
        );

        змінна позиція_назви_параметра = дії.покласти_константу_тексту(М, код, текст_ідентифікатора_параметра);
        покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви_параметра); // назва параметра

        покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок); // тип параметра

        якщо параметр.значення == пусто {
          покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок); // дія значення
        } інакше {
          вихід_помилки::вміст = зробити_помилку_перетворення(
            М,
            текст,
            знаки,
            місцезнаходження,
            клонувати_кд(М, "Значення параметра зараз не підтримується.")
          );
          вернути ні;
        }

        покласти_вказівку_СтворитиПараметр(М, код, дії, рядок);

        п += 1;
      }

      покласти_вказівку_СтворитиСтруктуру(М, код, дії, рядок, п32(дані.кількість_параметрів));

      вернути так;
    }

    дія перетворити_сполуку_ціле(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиЦіле,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      змінна знак = знаки.дані[дані.позиція_знаки];

      змінна текст_знаки = розбирач::отримати_значення_знаки(
        текст,
        знаки,
        знак
      );

      змінна розібране_ціле: ц64;

      успіх = розібрати_ціле_з_кд(текст_знаки, розібране_ціле::адреса);

      якщо не успіх {
        вихід_помилки::вміст = зробити_помилку_перетворення(
          М,
          текст,
          знаки,
          місцезнаходження,
          клонувати_кд(М, "Не вдалось розібрати число.")
        );
        вернути ні;
      }

      змінна позиція_константи = дії.покласти_константу_цілого(М, код, розібране_ціле);
      покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_константи);

      вернути так;
    }

    дія перетворити_сполуку_дробове(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиДробове,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      змінна знак = знаки.дані[дані.позиція_знаки];

      змінна текст_знаки = розбирач::отримати_значення_знаки(
        текст,
        знаки,
        знак
      );

      змінна розібране_дробове: д64 = 0.0;

      успіх = розібрати_дробове_з_кд(текст_знаки, розібране_дробове::адреса);

      якщо не успіх {
        вихід_помилки::вміст = зробити_помилку_перетворення(
          М,
          текст,
          знаки,
          місцезнаходження,
          клонувати_кд(М, "Не вдалось розібрати число.")
        );
        вернути ні;
      }

      змінна позиція_константи = дії.покласти_константу_дробового(М, код, розібране_дробове);
      покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_константи);

      вернути так;
    }

    дія перетворити_сполуку_текст(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиТекст,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      змінна знак = знаки.дані[дані.позиція_знаки];

      змінна значення_тексту = розбирач::отримати_значення_тексту(текст, знаки, знак);

      змінна оброблене_значення_тексту_кд = кд { 0, пусто };

      успіх = отримати_оброблену_копію_кд_тексту(М, значення_тексту, оброблене_значення_тексту_кд::адреса);

      якщо не успіх {
        вихід_помилки::вміст = зробити_помилку_перетворення(
          М,
          текст,
          знаки,
          місцезнаходження,
          клонувати_кд(М, "Не вдалось розібрати текст.")
        );
        вернути ні;
      }

      змінна позиція_константи = дії.покласти_константу_тексту(М, код, оброблене_значення_тексту_кд);
      покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_константи);

      звільнити_памʼять(М, оброблене_значення_тексту_кд.дані);

      вернути так;
    }

    дія перетворити_сполуку_операція(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиОперація,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      успіх = перетворити_сполуку(
        М,
        текст,
        знаки,
        дані.ліво,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      якщо дані.операція == розбирач::ВидОпераціїІ {
        покласти_вказівку_Дублювати(М, код, дії, рядок);
        змінна позиція_вказівки_стрибнути_якщо_ні = покласти_вказівку_СтрибнутиЯкщоНі(М, код, дії, рядок, 0);
        покласти_вказівку_Забрати(М, код, дії, рядок);

        успіх = перетворити_сполуку(
          М,
          текст,
          знаки,
          дані.право,
          код,
          дії,
          вихід_помилки
        );
        якщо не успіх {
          вернути ні;
        }

        дії.змінити_аргумент_вказівки(
          М,
          код,
          позиція_вказівки_стрибнути_якщо_ні,
          0,
          дії.отримати_розмір_вказівок(М, код)
        );

        вернути так;
      } інакше якщо дані.операція == розбирач::ВидОпераціїАБО {
        покласти_вказівку_Дублювати(М, код, дії, рядок);
        змінна позиція_вказівки_стрибнути_якщо_так = покласти_вказівку_СтрибнутиЯкщоТак(М, код, дії, рядок, 0);
        покласти_вказівку_Забрати(М, код, дії, рядок);

        успіх = перетворити_сполуку(
          М,
          текст,
          знаки,
          дані.право,
          код,
          дії,
          вихід_помилки
        );
        якщо не успіх {
          вернути ні;
        }

        дії.змінити_аргумент_вказівки(
          М,
          код,
          позиція_вказівки_стрибнути_якщо_так,
          0,
          дії.отримати_розмір_вказівок(М, код)
        );

        вернути так;
      }

      успіх = перетворити_сполуку(
        М,
        текст,
        знаки,
        дані.право,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      якщо дані.операція == розбирач::ВидОпераціїДодавання {
        покласти_вказівку_Додати(М, код, дії, рядок);
        вернути так;
      } інакше якщо дані.операція == розбирач::ВидОпераціїВіднімання {
        покласти_вказівку_Відняти(М, код, дії, рядок);
        вернути так;
      } інакше якщо дані.операція == розбирач::ВидОпераціїМноження {
        покласти_вказівку_Помножити(М, код, дії, рядок);
        вернути так;
      } інакше якщо дані.операція == розбирач::ВидОпераціїДілення {
        покласти_вказівку_Поділити(М, код, дії, рядок);
        вернути так;
      } інакше якщо дані.операція == розбирач::ВидОпераціїМодуль {
        покласти_вказівку_ОтриматиОстачуДілення(М, код, дії, рядок);
        вернути так;
      } інакше якщо дані.операція == розбирач::ВидОпераціїДіленняНаціло {
        покласти_вказівку_ОтриматиНеповнуЧасткуДілення(М, код, дії, рядок);
        вернути так;
      } інакше якщо дані.операція == розбирач::ВидОпераціїПіднесенняДоСтепеня {
        покласти_вказівку_ПіднестиДоСтепеня(М, код, дії, рядок);
        вернути так;
      } інакше якщо дані.операція == розбирач::ВидОпераціїЗсувВліво {
        покласти_вказівку_ЗсунутиВліво(М, код, дії, рядок);
        вернути так;
      } інакше якщо дані.операція == розбирач::ВидОпераціїЗсувВправо {
        покласти_вказівку_ЗсунутиВправо(М, код, дії, рядок);
        вернути так;
      } інакше якщо дані.операція == розбирач::ВидОпераціїЗсувВправоЗнаковий {
        покласти_вказівку_ЗсунутиВправо2(М, код, дії, рядок);
        вернути так;
      } інакше якщо дані.операція == розбирач::ВидОпераціїДІ {
        покласти_вказівку_ДвійковеІ(М, код, дії, рядок);
        вернути так;
      } інакше якщо дані.операція == розбирач::ВидОпераціїДАБО {
        покласти_вказівку_ДвійковеАБО(М, код, дії, рядок);
        вернути так;
      } інакше якщо дані.операція == розбирач::ВидОпераціїВАБО {
        покласти_вказівку_ДвійковеВиключнеАБО(М, код, дії, рядок);
        вернути так;
      } інакше якщо дані.операція == розбирач::ВидОпераціїМенше {
        покласти_вказівку_Менше(М, код, дії, рядок);
        вернути так;
      } інакше якщо дані.операція == розбирач::ВидОпераціїБільше {
        покласти_вказівку_Більше(М, код, дії, рядок);
        вернути так;
      } інакше якщо дані.операція == розбирач::ВидОпераціїМеншеРівне {
        покласти_вказівку_НеБільше(М, код, дії, рядок);
        вернути так;
      } інакше якщо дані.операція == розбирач::ВидОпераціїБільшеРівне {
        покласти_вказівку_НеМенше(М, код, дії, рядок);
        вернути так;
      } інакше якщо дані.операція == розбирач::ВидОпераціїРівне {
        покласти_вказівку_Рівно(М, код, дії, рядок);
        вернути так;
      } інакше якщо дані.операція == розбирач::ВидОпераціїНерівне {
        покласти_вказівку_НеРівно(М, код, дії, рядок);
        вернути так;
      } інакше якщо дані.операція == розбирач::ВидОпераціїЄ {
        покласти_вказівку_Є(М, код, дії, рядок);
        вернути так;
      } інакше якщо дані.операція == розбирач::ВидОпераціїНеЄ {
        покласти_вказівку_НеЄ(М, код, дії, рядок);
        вернути так;
      }

      вихід_помилки::вміст = зробити_помилку_перетворення(
        М,
        текст,
        знаки,
        місцезнаходження,
        клонувати_кд(М, "Невідома операція.")
      );
      вернути ні;
    }

    дія перетворити_сполуку_якщо(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиЯкщо,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      успіх = перетворити_сполуку(
        М,
        текст,
        знаки,
        дані.умова,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      змінна позиція_вказівки_якщо_ні = покласти_вказівку_СтрибнутиЯкщоНі(М, код, дії, рядок, 0);

      якщо дані.тіло.розмір != 0 {
        успіх = перетворити_тіло(
          М,
          текст,
          знаки,
          дані.тіло,
          ні,
          код,
          дії,
          вихід_помилки
        );
        якщо не успіх {
          вернути ні;
        }
      }

      змінна позиція_вказівки_якщо_так = покласти_вказівку_Стрибнути(М, код, дії, рядок, 0);

      дії.змінити_аргумент_вказівки(
        М,
        код,
        позиція_вказівки_якщо_ні,
        0,
        дії.отримати_розмір_вказівок(М, код)
      );

      якщо дані.тіло_інакше.розмір != 0 {
        успіх = перетворити_тіло(
          М,
          текст,
          знаки,
          дані.тіло_інакше,
          ні,
          код,
          дії,
          вихід_помилки
        );
        якщо не успіх {
          вернути ні;
        }
      }

      дії.змінити_аргумент_вказівки(
        М,
        код,
        позиція_вказівки_якщо_так,
        0,
        дії.отримати_розмір_вказівок(М, код)
      );

      вернути так;
    }

    дія перетворити_сполуку_поки(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиПоки,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      змінна позиція_вказівки_початку_поки = дії.отримати_розмір_вказівок(М, код);

      успіх = перетворити_сполуку(
        М,
        текст,
        знаки,
        дані.умова,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      змінна позиція_вказівки_якщо_ні = покласти_вказівку_СтрибнутиЯкщоНі(М, код, дії, рядок, 0);

      успіх = перетворити_тіло(
        М,
        текст,
        знаки,
        дані.тіло,
        ні,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      покласти_вказівку_Стрибнути(М, код, дії, рядок, позиція_вказівки_початку_поки);

      дії.змінити_аргумент_вказівки(
        М,
        код,
        позиція_вказівки_якщо_ні,
        0,
        дії.отримати_розмір_вказівок(М, код)
      );

      вернути так;
    }

    дія перетворити_сполуку_вернути(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиВернути,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      якщо дані.значення == пусто {
        покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок);
      } інакше {
        успіх = перетворити_сполуку(
          М,
          текст,
          знаки,
          дані.значення,
          код,
          дії,
          вихід_помилки
        );
        якщо не успіх {
          вернути ні;
        }
      }

      покласти_вказівку_Вернути(М, код, дії, рядок);

      вернути так;
    }

    дія перетворити_сполуку_значення_якщо(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиЗначенняЯкщо,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      успіх = перетворити_сполуку(
        М,
        текст,
        знаки,
        дані.умова,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      змінна позиція_вказівки_стрибнути_якщо_ні = покласти_вказівку_СтрибнутиЯкщоНі(М, код, дії, рядок, 0);

      успіх = перетворити_сполуку(
        М,
        текст,
        знаки,
        дані.значення_так,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      змінна позиція_вказівки_виходу_з_так = покласти_вказівку_Стрибнути(М, код, дії, рядок, 0);
      дії.змінити_аргумент_вказівки(
        М,
        код,
        позиція_вказівки_стрибнути_якщо_ні,
        0,
        дії.отримати_розмір_вказівок(М, код)
      );

      успіх = перетворити_сполуку(
        М,
        текст,
        знаки,
        дані.значення_ні,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      дії.змінити_аргумент_вказівки(
        М,
        код,
        позиція_вказівки_виходу_з_так,
        0,
        дії.отримати_розмір_вказівок(М, код)
      );

      вернути так;
    }

    дія перетворити_сполуку_само_операція(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиСамоОперація,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      успіх = перетворити_сполуку(
        М,
        текст,
        знаки,
        дані.предмет,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      якщо дані.операція == розбирач::ВидСамоОпераціїЛогічнеНі {
        покласти_вказівку_Заперечити(М, код, дії, рядок);

        вернути так;
      }

      якщо дані.операція == розбирач::ВидСамоОпераціїДвійковеНі {
        покласти_вказівку_ДвійковеНЕ(М, код, дії, рядок);

        вернути так;
      }

      якщо дані.операція == розбирач::ВидСамоОпераціїМінус {
        покласти_вказівку_Відʼємне(М, код, дії, рядок);

        вернути так;
      }

      вихід_помилки::вміст = зробити_помилку_перетворення(
        М,
        текст,
        знаки,
        місцезнаходження,
        клонувати_кд(М, "Невідома самооперація.")
      );
      вернути ні;
    }

    дія перетворити_сполуку_взяти(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиВзяти,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      змінна назва = розбирач::отримати_значення_ідентифікатора(текст, знаки, дані.тип.значення);
      змінна позиція_назви_типу = дії.покласти_константу_тексту(М, код, назва);
      покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви_типу);

      змінна позиція_останьої_назви: п32 = 0;

      змінна пп: п32 = 0;
      поки пп < п32(дані.довжина_шляху) {
        змінна елемент_шляху = дані.шлях[пп];

        змінна назва = розбирач::отримати_значення_ідентифікатора(текст, знаки, елемент_шляху);
        змінна позиція_назви = дії.покласти_константу_тексту(М, код, назва );
        покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви);

        якщо пп == п32(дані.довжина_шляху) - 1 {
          позиція_останьої_назви = позиція_назви;
        }

        пп += 1;
      }

      покласти_вказівку_Взяти(М, код, дії, рядок, п32(дані.довжина_шляху));

      якщо не дані.ідентифікатор_як.заповнено {
        якщо дані.кількість_елементів == 0 {
          покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_останьої_назви);
          покласти_вказівку_ВизначитиНавпаки(М, код, дії, рядок);
        } інакше {
          змінна пе: п32 = 0;
          поки пе < п32(дані.кількість_елементів) {
            змінна елемент = дані.елементи[пе];

            покласти_вказівку_Дублювати(М, код, дії, рядок);

            змінна назва = розбирач::отримати_значення_ідентифікатора(текст, знаки, елемент.ідентифікатор);
            змінна позиція_назви = дії.покласти_константу_тексту(М, код, назва);
            покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви);
            покласти_вказівку_ОтриматиВластивість(М, код, дії, рядок);

            якщо елемент.ідентифікатор_як.заповнено {
              змінна назва = розбирач::отримати_значення_ідентифікатора(текст, знаки, елемент.ідентифікатор_як.значення);
              змінна позиція_назви = дії.покласти_константу_тексту(М, код, назва);
              покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви);
              покласти_вказівку_ВизначитиНавпаки(М, код, дії, рядок);
            } інакше {
              змінна назва = розбирач::отримати_значення_ідентифікатора(текст, знаки, елемент.ідентифікатор);
              змінна позиція_назви = дії.покласти_константу_тексту(М, код, назва);
              покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви);
              покласти_вказівку_ВизначитиНавпаки(М, код, дії, рядок);
            }

            пе += 1;
          }
        }
      } інакше {
        змінна назва = розбирач::отримати_значення_ідентифікатора(текст, знаки, дані.ідентифікатор_як.значення);
        змінна позиція_назви = дії.покласти_константу_тексту(М, код, назва);
        покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви);
        покласти_вказівку_ВизначитиНавпаки(М, код, дії, рядок);
      }

      вернути так;
    }

    дія перетворити_сполуку_спробувати(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиСпробувати,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      якщо дані.ідентифікатор_зловити.заповнено {
        змінна назва = розбирач::отримати_значення_ідентифікатора(текст, знаки, дані.ідентифікатор_зловити.значення);
        змінна позиція_назви = дії.покласти_константу_тексту(М, код, назва);
        покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви);
      } інакше {
        покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок);
      }

      змінна позиція_вказівки_почати_спробу = покласти_вказівку_ПочатиСпробу(М, код, дії, рядок, 0);

      успіх = перетворити_тіло(
        М,
        текст,
        знаки,
        дані.тіло,
        ні,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      змінна позиція_вказівки_закінчити_спробу = покласти_вказівку_ЗакінчитиСпробу(М, код, дії, рядок, 0);

      дії.змінити_аргумент_вказівки(
        М,
        код,
        позиція_вказівки_почати_спробу,
        0,
        дії.отримати_розмір_вказівок(М, код)
      );

      успіх = перетворити_тіло(
        М,
        текст,
        знаки,
        дані.тіло_зловити,
        ні,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      дії.змінити_аргумент_вказівки(
        М,
        код,
        позиція_вказівки_закінчити_спробу,
        0,
        дії.отримати_розмір_вказівок(М, код)
      );

      вернути так;
    }

    дія перетворити_сполуку_впасти(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиВпасти,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      якщо дані.значення == пусто {
        покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок);
      } інакше {
        успіх = перетворити_сполуку(
          М,
          текст,
          знаки,
          дані.значення,
          код,
          дії,
          вихід_помилки
        );
        якщо не успіх {
          вернути ні;
        }
      }

      покласти_вказівку_Впасти(М, код, дії, рядок);

      вернути так;
    }

    дія перетворити_сполуку_дати(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиДати,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      змінна пп: п32 = 0;
      поки пп < п32(дані.кількість_елементів) {
        змінна елемент = дані.елементи[пп];

        змінна назва = розбирач::отримати_значення_ідентифікатора(текст, знаки, елемент.ідентифікатор);
        змінна позиція_назви = дії.покласти_константу_тексту(М, код, назва);
        покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви); // назва
        покласти_вказівку_Звернутись(М, код, дії, рядок); // предмет

        якщо елемент.ідентифікатор_як.заповнено {
          змінна назва_як = розбирач::отримати_значення_ідентифікатора(текст, знаки, елемент.ідентифікатор_як.значення);
          змінна позиція_назви_як = дії.покласти_константу_тексту(М, код, назва_як);
          покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви_як); // назва
        } інакше {
          покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви); // назва
        }

        покласти_вказівку_Дати(М, код, дії, рядок);

        пп += 1;
      }

      вернути так;
    }

    дія перетворити_сполуку_модуль(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиМодуль,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      якщо дані.ідентифікатор.заповнено {
        змінна текст_ідентифікатора = розбирач::отримати_значення_ідентифікатора(
          текст,
          знаки,
          дані.ідентифікатор.значення
        );

        змінна позиція_назви = дії.покласти_константу_тексту(М, код, текст_ідентифікатора);
        покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви); // назва
      } інакше {
        покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок); // назва
      }

      змінна код_модуля = дії.створити_код(М, дії.отримати_шлях_коду(М, код));

      успіх = перетворити_тіло(
        М,
        текст,
        знаки,
        дані.тіло,
        так,
        код_модуля,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      змінна позиція_коду_модуля = дії.покласти_константу_коду(М, код, код_модуля);
      покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_коду_модуля); // код

      покласти_вказівку_СтворитиМодуль(М, код, дії, рядок);

      вернути так;
    }

    дія перетворити_сполуку_список(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиСписок,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      змінна п: природне = 0;

      поки п < дані.кількість_елементів {
        змінна елемент_списку = дані.елементи[п];

        успіх = перетворити_сполуку(
          М,
          текст,
          знаки,
          елемент_списку,
          код,
          дії,
          вихід_помилки
        );
        якщо не успіх {
          вернути ні;
        }

        п += 1;
      }

      покласти_вказівку_СтворитиСписок(М, код, дії, рядок, п32(дані.кількість_елементів));

      вернути так;
    }

    дія перетворити_сполуку_словник(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиСловник,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      змінна п: п32 = 0;

      поки п < п32(дані.кількість_елементів) {
        змінна елемент_словника = дані.елементи[п];

        успіх = перетворити_сполуку(
          М,
          текст,
          знаки,
          елемент_словника.ключ,
          код,
          дії,
          вихід_помилки
        );
        якщо не успіх {
          вернути ні;
        }

        успіх = перетворити_сполуку(
          М,
          текст,
          знаки,
          елемент_словника.значення,
          код,
          дії,
          вихід_помилки
        );
        якщо не успіх {
          вернути ні;
        }

        п += 1;
      }

      покласти_вказівку_СтворитиСловник(М, код, дії, рядок, п32(дані.кількість_елементів));

      вернути так;
    }

    дія перетворити_сполуку_символ(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиСимвол,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      змінна знак = знаки.дані[дані.позиція_знаки];

      змінна значення_символа_кд = розбирач::отримати_значення_символу(
        текст,
        знаки,
        знак
      );

      змінна оброблене_значення_символу_кд = кд { 0, пусто };

      успіх = отримати_оброблену_копію_кд_тексту(М, значення_символа_кд, оброблене_значення_символу_кд::адреса);

      якщо не успіх {
        вихід_помилки::вміст = зробити_помилку_перетворення(
          М,
          текст,
          знаки,
          місцезнаходження,
          клонувати_кд(М, "Не вдалось розібрати символ.")
        );
        вернути ні;
      }

      змінна позиція_константи: п32 = 0;

      якщо оброблене_значення_символу_кд.розмір == 0 {
        звільнити_памʼять(М, оброблене_значення_символу_кд.дані);

        вихід_помилки::вміст = зробити_помилку_перетворення(
          М,
          текст,
          знаки,
          місцезнаходження,
          клонувати_кд(М, "Символ не може бути порожнім.")
        );
        вернути ні;
      } інакше {
        позиція_константи = дії.покласти_константу_цілого(
          М,
          код,
          ц64(оброблене_значення_символу_кд.дані[0])
        );
      }

      звільнити_памʼять(М, оброблене_значення_символу_кд.дані);

      покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_константи);

      вернути так;
    }

    дія перетворити_сполуку_перебрати(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиПеребрати,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      успіх = перетворити_сполуку(
        М,
        текст,
        знаки,
        дані.предмет,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      покласти_вказівку_ОтриматиПеребір(М, код, дії, рядок);

      змінна позиція_вказівки_початку_перебору = покласти_вказівку_ПеребратиДалі(М, код, дії, рядок);

      змінна позиція_вказівки_якщо_ні = покласти_вказівку_СтрибнутиЯкщоНі(М, код, дії, рядок, 0);
      покласти_вказівку_Дублювати(М, код, дії, рядок);
      покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, дії.покласти_константу_тексту(М, код, "значення"));
      покласти_вказівку_ОтриматиВластивість(М, код, дії, рядок);
      змінна назва = розбирач::отримати_значення_ідентифікатора(текст, знаки, дані.ідентифікатор.значення);
      змінна позиція_назви = дії.покласти_константу_тексту(М, код, назва);
      покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви);
      покласти_вказівку_ВизначитиНавпаки(М, код, дії, рядок);

      успіх = перетворити_тіло(
        М,
        текст,
        знаки,
        дані.тіло,
        ні,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      покласти_вказівку_Стрибнути(М, код, дії, рядок, позиція_вказівки_початку_перебору);
      дії.змінити_аргумент_вказівки(
        М,
        код,
        позиція_вказівки_якщо_ні,
        0,
        дії.отримати_розмір_вказівок(М, код)
      );
      назва = розбирач::отримати_значення_ідентифікатора(текст, знаки, дані.ідентифікатор.значення);
      позиція_назви = дії.покласти_константу_тексту(М, код, назва);
      покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви);
      покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок);
      покласти_вказівку_Визначити(М, код, дії, рядок);
      покласти_вказівку_Забрати(М, код, дії, рядок);

      вернути так;
    }

    дія перетворити_сполуку_цикл(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиЦикл,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      вихід_помилки::вміст = зробити_помилку_перетворення(
        М,
        текст,
        знаки,
        місцезнаходження,
        клонувати_кд(М, "Цикл не втілено.")
      );
      вернути ні;
    }

    дія перетворити_сполуку_вічний_цикл(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиВічнийЦикл,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      змінна позиція_вказівки_початку_циклу = дії.отримати_розмір_вказівок(М, код);

      успіх = перетворити_тіло(
        М,
        текст,
        знаки,
        дані.тіло,
        ні,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      покласти_вказівку_Стрибнути(М, код, дії, рядок, позиція_вказівки_початку_циклу);

      вернути так;
    }

    дія перетворити_сполуку_чекати(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиЧекати,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      // ...
    }

    дія перетворити_сполуку_діапазон(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиДіапазон,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      успіх = перетворити_сполуку(
        М,
        текст,
        знаки,
        дані.від,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      якщо дані.включно {
        покласти_вказівку_ПокластиДійсне(М, код, дії, рядок);
      } інакше {
        покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок);
      }

      успіх = перетворити_сполуку(
        М,
        текст,
        знаки,
        дані.до,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх {
        вернути ні;
      }

      покласти_вказівку_СтворитиДіапазон(М, код, дії, рядок);

      вернути так;
    }

    дія перетворити_сполуку_збитий_текст(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      дані: розбирач::ДаніСполукиЗбитийТекст,
      місцезнаходження: розбирач::Місцезнаходження,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
        текст,
        знаки,
        місцезнаходження
      ));

      змінна п: природне = 0;

      поки п < дані.кількість_гілок {
        успіх = перетворити_сполуку(
          М,
          текст,
          знаки,
          дані.сполуки[п],
          код,
          дії,
          вихід_помилки
        );
        якщо не успіх {
          вернути ні;
        }

        п += 1;
      }

      покласти_вказівку_ЗбитиТекст(М, код, дії, рядок, п32(дані.кількість_гілок));

      вернути так;
    }

    дія перетворити_сполуку(
      М: адреса<Машина>,
      текст: кд,
      знаки: розбирач::Знаки,
      сполука: адреса<розбирач::Сполука>,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      якщо сполука.вид == розбирач::ВидСполукиЗвернутись {
        вернути перетворити_сполуку_звернутись(
          М,
          текст,
          знаки,
          сполука.дані як розбирач::ДаніСполукиЗвернутись,
          сполука.місцезнаходження,
          код,
          дії,
          вихід_помилки
        );
      }

      якщо сполука.вид == розбирач::ВидСполукиОтриматиВластивість {
        вернути перетворити_сполуку_отримати_властивість(
          М,
          текст,
          знаки,
          сполука.дані як розбирач::ДаніСполукиОтриматиВластивість,
          сполука.місцезнаходження,
          код,
          дії,
          вихід_помилки
        );
      }

      якщо сполука.вид == розбирач::ВидСполукиОтриматиЕлемент {
        вернути перетворити_сполуку_отримати_елемент(
          М,
          текст,
          знаки,
          сполука.дані як розбирач::ДаніСполукиОтриматиЕлемент,
          сполука.місцезнаходження,
          код,
          дії,
          вихід_помилки
        );
      }

      якщо сполука.вид == розбирач::ВидСполукиВиконати {
        вернути перетворити_сполуку_виконати(
          М,
          текст,
          знаки,
          сполука.дані як розбирач::ДаніСполукиВиконати,
          сполука.місцезнаходження,
          код,
          дії,
          вихід_помилки
        );
      }

      якщо сполука.вид == розбирач::ВидСполукиДія {
        вернути перетворити_сполуку_дія(
          М,
          текст,
          знаки,
          сполука.дані як розбирач::ДаніСполукиДія,
          сполука.місцезнаходження,
          код,
          дії,
          вихід_помилки
        );
      }

      якщо сполука.вид == розбирач::ВидСполукиСтруктура {
        вернути перетворити_сполуку_структура(
          М,
          текст,
          знаки,
          сполука.дані як розбирач::ДаніСполукиСтруктура,
          сполука.місцезнаходження,
          код,
          дії,
          вихід_помилки
        );
      }

      якщо сполука.вид == розбирач::ВидСполукиЦіле {
        вернути перетворити_сполуку_ціле(
          М,
          текст,
          знаки,
          сполука.дані як розбирач::ДаніСполукиЦіле,
          сполука.місцезнаходження,
          код,
          дії,
          вихід_помилки
        );
      }

      якщо сполука.вид == розбирач::ВидСполукиДробове {
        вернути перетворити_сполуку_дробове(
          М,
          текст,
          знаки,
          сполука.дані як розбирач::ДаніСполукиДробове,
          сполука.місцезнаходження,
          код,
          дії,
          вихід_помилки
        );
      }

      якщо сполука.вид == розбирач::ВидСполукиТекст {
        вернути перетворити_сполуку_текст(
          М,
          текст,
          знаки,
          сполука.дані як розбирач::ДаніСполукиТекст,
          сполука.місцезнаходження,
          код,
          дії,
          вихід_помилки
        );
      }

      якщо сполука.вид == розбирач::ВидСполукиОперація {
        вернути перетворити_сполуку_операція(
          М,
          текст,
          знаки,
          сполука.дані як розбирач::ДаніСполукиОперація,
          сполука.місцезнаходження,
          код,
          дії,
          вихід_помилки
        );
      }

      якщо сполука.вид == розбирач::ВидСполукиЗначенняЯкщо {
        вернути перетворити_сполуку_значення_якщо(
          М,
          текст,
          знаки,
          сполука.дані як розбирач::ДаніСполукиЗначенняЯкщо,
          сполука.місцезнаходження,
          код,
          дії,
          вихід_помилки
        );
      }

      якщо сполука.вид == розбирач::ВидСполукиСамоОперація {
        вернути перетворити_сполуку_само_операція(
          М,
          текст,
          знаки,
          сполука.дані як розбирач::ДаніСполукиСамоОперація,
          сполука.місцезнаходження,
          код,
          дії,
          вихід_помилки
        );
      }

      якщо сполука.вид == розбирач::ВидСполукиМодуль {
        вернути перетворити_сполуку_модуль(
          М,
          текст,
          знаки,
          сполука.дані як розбирач::ДаніСполукиМодуль,
          сполука.місцезнаходження,
          код,
          дії,
          вихід_помилки
        );
      }

      якщо сполука.вид == розбирач::ВидСполукиСписок {
        вернути перетворити_сполуку_список(
          М,
          текст,
          знаки,
          сполука.дані як розбирач::ДаніСполукиСписок,
          сполука.місцезнаходження,
          код,
          дії,
          вихід_помилки
        );
      }

      якщо сполука.вид == розбирач::ВидСполукиСловник {
        вернути перетворити_сполуку_словник(
          М,
          текст,
          знаки,
          сполука.дані як розбирач::ДаніСполукиСловник,
          сполука.місцезнаходження,
          код,
          дії,
          вихід_помилки
        );
      }

      якщо сполука.вид == розбирач::ВидСполукиСимвол {
        вернути перетворити_сполуку_символ(
          М,
          текст,
          знаки,
          сполука.дані як розбирач::ДаніСполукиСимвол,
          сполука.місцезнаходження,
          код,
          дії,
          вихід_помилки
        );
      }

      якщо сполука.вид == розбирач::ВидСполукиЧекати {
        вихід_помилки::вміст = зробити_помилку_перетворення(
          М,
          текст,
          знаки,
          сполука.місцезнаходження,
          клонувати_кд(М, "Чекати зараз не підтримується.")
        );
        вернути ні;
      }

      якщо сполука.вид == розбирач::ВидСполукиДіапазон {
        вернути перетворити_сполуку_діапазон(
          М,
          текст,
          знаки,
          сполука.дані як розбирач::ДаніСполукиДіапазон,
          сполука.місцезнаходження,
          код,
          дії,
          вихід_помилки
        );
      }

      якщо сполука.вид == розбирач::ВидСполукиЗбитийТекст {
        вернути перетворити_сполуку_збитий_текст(
          М,
          текст,
          знаки,
          сполука.дані як розбирач::ДаніСполукиЗбитийТекст,
          сполука.місцезнаходження,
          код,
          дії,
          вихід_помилки
        );
      }

      вихід_помилки::вміст = зробити_помилку_перетворення(
        М,
        текст,
        знаки,
        сполука.місцезнаходження,
        клонувати_кд(М, "Неочікувана сполука для перетворення.")
      );
      вернути ні;
    }

    дія перетворити_тіло(
      М: адреса<Машина>,
      сирий_текст: кд,
      знаки: розбирач::Знаки,
      сполуки: розбирач::Сполуки,
      вернути_в_кінці: логічне,
      код: невідома_адреса,
      дії: Дії,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна успіх = ні;

      змінна п: природне = 0;

      поки п < сполуки.розмір {
        змінна сполука = сполуки.дані[п];

        змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(
          сирий_текст,
          знаки,
          сполука.місцезнаходження
        ));

        якщо сполука.вид == розбирач::ВидСполукиВизначити {
          успіх = перетворити_сполуку_визначити(
            М,
            сирий_текст,
            знаки,
            сполука.дані як розбирач::ДаніСполукиВизначити,
            сполука.місцезнаходження,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх {
            вернути ні;
          }

          якщо вернути_в_кінці і п == сполуки.розмір - 1 {
            покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок);
            покласти_вказівку_Вернути(М, код, дії, рядок);
          }
        } інакше якщо сполука.вид == розбирач::ВидСполукиДія {
          змінна дані = сполука.дані як розбирач::ДаніСполукиДія;

          якщо дані.ідентифікатор.заповнено {
            змінна текст_ідентифікатора = розбирач::отримати_значення_ідентифікатора(
              сирий_текст,
              знаки,
              дані.ідентифікатор.значення
            );

            змінна позиція_назви = дії.покласти_константу_тексту(М, код, текст_ідентифікатора);
            покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви);
          }

          успіх = перетворити_сполуку(
            М,
            сирий_текст,
            знаки,
            сполука,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх {
            вернути ні;
          }

          якщо дані.ідентифікатор.заповнено {
            якщо дані.структура_ == пусто {
              покласти_вказівку_Визначити(М, код, дії, рядок);

              // потім: обробити це

              якщо вернути_в_кінці і п == сполуки.розмір - 1 {
                покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок);
                покласти_вказівку_Вернути(М, код, дії, рядок);
              }
            } інакше {
              успіх = перетворити_сполуку(
                М,
                сирий_текст,
                знаки,
                дані.структура_,
                код,
                дії,
                вихід_помилки
              );
              якщо не успіх {
                вернути ні;
              }

              покласти_вказівку_ЗаписатиМетод(М, код, дії, рядок);

              якщо вернути_в_кінці і п == сполуки.розмір - 1 {
                покласти_вказівку_Вернути(М, код, дії, рядок);
              } інакше {
                покласти_вказівку_Забрати(М, код, дії, рядок);
              }
            }
          } інакше {
            якщо вернути_в_кінці і п == сполуки.розмір - 1 {
              покласти_вказівку_Вернути(М, код, дії, рядок);
            } інакше {
              покласти_вказівку_Забрати(М, код, дії, рядок);
            }
          }
        } інакше якщо сполука.вид == розбирач::ВидСполукиСтруктура {
          змінна дані = сполука.дані як розбирач::ДаніСполукиСтруктура;

          якщо дані.ідентифікатор.заповнено {
            змінна текст_ідентифікатора = розбирач::отримати_значення_ідентифікатора(
              сирий_текст,
              знаки,
              дані.ідентифікатор.значення
            );

            змінна позиція_назви = дії.покласти_константу_тексту(М, код, текст_ідентифікатора);
            покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви);
          }

          успіх = перетворити_сполуку(
            М,
            сирий_текст,
            знаки,
            сполука,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх {
            вернути ні;
          }

          якщо дані.ідентифікатор.заповнено {
            покласти_вказівку_Визначити(М, код, дії, рядок);

            // потім: обробити це

            якщо вернути_в_кінці і п == сполуки.розмір - 1 {
              покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок);
              покласти_вказівку_Вернути(М, код, дії, рядок);
            }
          } інакше {
            якщо вернути_в_кінці і п == сполуки.розмір - 1 {
              покласти_вказівку_Вернути(М, код, дії, рядок);
            } інакше {
              покласти_вказівку_Забрати(М, код, дії, рядок);
            }
          }
        } інакше якщо сполука.вид == розбирач::ВидСполукиМодуль {
          змінна дані = сполука.дані як розбирач::ДаніСполукиМодуль;

          якщо дані.ідентифікатор.заповнено {
            змінна текст_ідентифікатора = розбирач::отримати_значення_ідентифікатора(
              сирий_текст,
              знаки,
              дані.ідентифікатор.значення
            );

            змінна позиція_назви = дії.покласти_константу_тексту(М, код, текст_ідентифікатора);
            покласти_вказівку_ПокластиКонстанту(М, код, дії, рядок, позиція_назви);
          }

          успіх = перетворити_сполуку(
            М,
            сирий_текст,
            знаки,
            сполука,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх {
            вернути ні;
          }

          якщо дані.ідентифікатор.заповнено {
            покласти_вказівку_Визначити(М, код, дії, рядок);

            // потім: обробити це

            якщо вернути_в_кінці і п == сполуки.розмір - 1 {
              покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок);
              покласти_вказівку_Вернути(М, код, дії, рядок);
            }
          } інакше {
            якщо вернути_в_кінці і п == сполуки.розмір - 1 {
              покласти_вказівку_Вернути(М, код, дії, рядок);
            } інакше {
              покласти_вказівку_Забрати(М, код, дії, рядок);
            }
          }
        } інакше якщо сполука.вид == розбирач::ВидСполукиЗвернутись
                  або сполука.вид == розбирач::ВидСполукиОтриматиВластивість
                  або сполука.вид == розбирач::ВидСполукиОтриматиЕлемент
                  або сполука.вид == розбирач::ВидСполукиВиконати
                  або сполука.вид == розбирач::ВидСполукиЦіле
                  або сполука.вид == розбирач::ВидСполукиДробове
                  або сполука.вид == розбирач::ВидСполукиТекст
                  або сполука.вид == розбирач::ВидСполукиОперація
                  або сполука.вид == розбирач::ВидСполукиЗначенняЯкщо
                  або сполука.вид == розбирач::ВидСполукиСписок
                  або сполука.вид == розбирач::ВидСполукиСловник
                  або сполука.вид == розбирач::ВидСполукиСимвол
                  або сполука.вид == розбирач::ВидСполукиЧекати
                  або сполука.вид == розбирач::ВидСполукиДіапазон
                  або сполука.вид == розбирач::ВидСполукиЗбитийТекст
                  або сполука.вид == розбирач::ВидСполукиСамоОперація {
          успіх = перетворити_сполуку(
            М,
            сирий_текст,
            знаки,
            сполука,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх {
            вернути ні;
          }

          якщо вернути_в_кінці і п == сполуки.розмір - 1 {
            покласти_вказівку_Вернути(М, код, дії, рядок);
          } інакше {
            покласти_вказівку_Забрати(М, код, дії, рядок);
          }
        } інакше якщо сполука.вид == розбирач::ВидСполукиЗмінитиВластивість {
          успіх = перетворити_сполуку_змінити_властивість(
            М,
            сирий_текст,
            знаки,
            сполука.дані як розбирач::ДаніСполукиЗмінитиВластивість,
            сполука.місцезнаходження,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх {
            вернути ні;
          }

          якщо вернути_в_кінці і п == сполуки.розмір - 1 {
            покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок);
            покласти_вказівку_Вернути(М, код, дії, рядок);
          }
        } інакше якщо сполука.вид == розбирач::ВидСполукиЗмінитиЕлемент {
          успіх = перетворити_сполуку_змінити_елемент(
            М,
            сирий_текст,
            знаки,
            сполука.дані як розбирач::ДаніСполукиЗмінитиЕлемент,
            сполука.місцезнаходження,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх {
            вернути ні;
          }

          якщо вернути_в_кінці і п == сполуки.розмір - 1 {
            покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок);
            покласти_вказівку_Вернути(М, код, дії, рядок);
          }
        } інакше якщо сполука.вид == розбирач::ВидСполукиЯкщо {
          успіх = перетворити_сполуку_якщо(
            М,
            сирий_текст,
            знаки,
            сполука.дані як розбирач::ДаніСполукиЯкщо,
            сполука.місцезнаходження,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх {
            вернути ні;
          }

          якщо вернути_в_кінці і п == сполуки.розмір - 1 {
            покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок);
            покласти_вказівку_Вернути(М, код, дії, рядок);
          }
        } інакше якщо сполука.вид == розбирач::ВидСполукиПоки {
          успіх = перетворити_сполуку_поки(
            М,
            сирий_текст,
            знаки,
            сполука.дані як розбирач::ДаніСполукиПоки,
            сполука.місцезнаходження,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх {
            вернути ні;
          }

          якщо вернути_в_кінці і п == сполуки.розмір - 1 {
            покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок);
            покласти_вказівку_Вернути(М, код, дії, рядок);
          }
        } інакше якщо сполука.вид == розбирач::ВидСполукиВернути {
          успіх = перетворити_сполуку_вернути(
            М,
            сирий_текст,
            знаки,
            сполука.дані як розбирач::ДаніСполукиВернути,
            сполука.місцезнаходження,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх {
            вернути ні;
          }
        } інакше якщо сполука.вид == розбирач::ВидСполукиВзяти {
          успіх = перетворити_сполуку_взяти(
            М,
            сирий_текст,
            знаки,
            сполука.дані як розбирач::ДаніСполукиВзяти,
            сполука.місцезнаходження,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх {
            вернути ні;
          }

          якщо вернути_в_кінці і п == сполуки.розмір - 1 {
            покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок);
            покласти_вказівку_Вернути(М, код, дії, рядок);
          }
        } інакше якщо сполука.вид == розбирач::ВидСполукиСпробувати {
          успіх = перетворити_сполуку_спробувати(
            М,
            сирий_текст,
            знаки,
            сполука.дані як розбирач::ДаніСполукиСпробувати,
            сполука.місцезнаходження,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх {
            вернути ні;
          }

          якщо вернути_в_кінці і п == сполуки.розмір - 1 {
            покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок);
            покласти_вказівку_Вернути(М, код, дії, рядок);
          }
        } інакше якщо сполука.вид == розбирач::ВидСполукиВпасти {
          успіх = перетворити_сполуку_впасти(
            М,
            сирий_текст,
            знаки,
            сполука.дані як розбирач::ДаніСполукиВпасти,
            сполука.місцезнаходження,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх {
            вернути ні;
          }
        } інакше якщо сполука.вид == розбирач::ВидСполукиДати {
          успіх = перетворити_сполуку_дати(
            М,
            сирий_текст,
            знаки,
            сполука.дані як розбирач::ДаніСполукиДати,
            сполука.місцезнаходження,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх {
            вернути ні;
          }

          якщо вернути_в_кінці і п == сполуки.розмір - 1 {
            покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок);
            покласти_вказівку_Вернути(М, код, дії, рядок);
          }
        } інакше якщо сполука.вид == розбирач::ВидСполукиПеребрати {
          успіх = перетворити_сполуку_перебрати(
            М,
            сирий_текст,
            знаки,
            сполука.дані як розбирач::ДаніСполукиПеребрати,
            сполука.місцезнаходження,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх {
            вернути ні;
          }

          якщо вернути_в_кінці і п == сполуки.розмір - 1 {
            покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок);
            покласти_вказівку_Вернути(М, код, дії, рядок);
          }
        } інакше якщо сполука.вид == розбирач::ВидСполукиЦикл {
          успіх = перетворити_сполуку_цикл(
            М,
            сирий_текст,
            знаки,
            сполука.дані як розбирач::ДаніСполукиЦикл,
            сполука.місцезнаходження,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх {
            вернути ні;
          }

          якщо вернути_в_кінці і п == сполуки.розмір - 1 {
            покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок);
            покласти_вказівку_Вернути(М, код, дії, рядок);
          }
        } інакше якщо сполука.вид == розбирач::ВидСполукиВічнийЦикл {
          успіх = перетворити_сполуку_вічний_цикл(
            М,
            сирий_текст,
            знаки,
            сполука.дані як розбирач::ДаніСполукиВічнийЦикл,
            сполука.місцезнаходження,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх {
            вернути ні;
          }

          якщо вернути_в_кінці і п == сполуки.розмір - 1 {
            покласти_вказівку_ПокластиНедійсне(М, код, дії, рядок);
            покласти_вказівку_Вернути(М, код, дії, рядок);
          }
        } інакше {
          вихід_помилки::вміст = зробити_помилку_перетворення(
            М,
            сирий_текст,
            знаки,
            сполука.місцезнаходження,
            клонувати_кд(М, "Невідома сполука.")
          );
          вернути ні;
        }

        п += 1;
      }

      вернути так;
    }

    місцева дія перетворити(
      М: адреса<Машина>,
      шлях: невідома_адреса,
      сирий_текст: кд,
      знаки: розбирач::Знаки,
      сполуки: розбирач::Сполуки,
      дії: Дії,
      вихід_коду: адреса<невідома_адреса>,
      вихід_помилки: адреса<ПомилкаПеретворення>
    ) -> логічне {
      змінна код = дії.створити_код(М, шлях);

      змінна успіх_перетворення_тіла = перетворити_тіло(
        М,
        сирий_текст,
        знаки,
        сполуки,
        так,
        код,
        дії,
        вихід_помилки
      );
      якщо не успіх_перетворення_тіла {
        вернути успіх_перетворення_тіла;
      }

      вихід_коду::вміст = код;

      вернути так;
    }
  }

  простір перетворювач_в_код {
    структура Константи {
      розмір: п32;
      дані: памʼять<адреса<Предмет>>;
    }

    структура Вказівки {
      розмір: п32;
      дані: памʼять<п8>;
    }

    структура Код {
      константи: Константи;
      вказівки: Вказівки;
      шлях: адреса<ПредметДаних>;
      місцезнаходження_вказівок: МісцезнаходженняВказівок;
    }

    дія покласти_константу(М: адреса<Машина>, код: невідома_адреса, предмет: адреса<Предмет>) -> п32 {
      змінна код_як_код = код як адреса<Код>;
      код_як_код.константи.дані = перевиділити_памʼять<адреса<Предмет>>(М, код_як_код.константи.дані, природне(код_як_код.константи.розмір + 1));
      код_як_код.константи.дані[код_як_код.константи.розмір] = предмет;
      код_як_код.константи.розмір += 1;
      вернути код_як_код.константи.розмір - 1;
    }

    дія створити_код(М: адреса<Машина>, шлях: невідома_адреса) -> невідома_адреса {
      змінна код = виділити<Код>(М);

      код.константи = Константи { 0, пусто };
      код.вказівки = Вказівки { 0, пусто };
      код.шлях = шлях як адреса<ПредметДаних>;
      код.місцезнаходження_вказівок = МісцезнаходженняВказівок { 0, пусто };

      вернути код;
    }

    дія покласти_константу_цілого(М: адреса<Машина>, код: невідома_адреса, значення: ц64) -> п32 {
      змінна код_як_код = код як адреса<Код>;

      змінна п: п32 = 0;

      поки п < код_як_код.константи.розмір {
        змінна константа = код_як_код.константи.дані[п];

        якщо константа.тип == М.предмет_структури_Ціле {
          якщо ((константа як адреса<ПредметЦілого>).значення == значення) {
            вернути п;
          }
        }

        п += 1;
      }

      вернути покласти_константу(М, код, створити_ціле_з_ц64(М, значення) як адреса<Предмет>);
    }

    дія покласти_константу_дробового(М: адреса<Машина>, код: невідома_адреса, значення: д64) -> п32 {
      змінна код_як_код = код як адреса<Код>;

      змінна п: п32 = 0;

      поки п < код_як_код.константи.розмір {
        змінна константа = код_як_код.константи.дані[п];

        якщо константа.тип == М.предмет_структури_Дробове {
          якщо ((константа як адреса<ПредметДробового>).значення == значення) {
            вернути п;
          }
        }

        п += 1;
      }

      вернути покласти_константу(М, код, створити_дробове_з_д64(М, значення) як адреса<Предмет>);
    }

    дія покласти_константу_тексту(М: адреса<Машина>, код: невідома_адреса, значення: кд) -> п32 {
      змінна код_як_код = код як адреса<Код>;

      змінна п: п32 = 0;

      поки п < код_як_код.константи.розмір {
        змінна константа = код_як_код.константи.дані[п];

        якщо константа.тип == М.предмет_структури_Текст {
          змінна предмет = константа як адреса<ПредметТексту>;

          якщо предмет.тип == М.предмет_структури_Текст {
            якщо перевірити_чи_кд_рівні(предмет.значення, значення) {
              вернути п;
            }
          }
        }

        п += 1;
      }

      змінна предмет_тексту = створити_текст(М, значення);

      вернути покласти_константу(М, код, предмет_тексту як адреса<Предмет>);
    }

    дія покласти_константу_коду(М: адреса<Машина>, код: невідома_адреса, значення: невідома_адреса) -> п32 {
      змінна код_як_код = значення як адреса<Код>;
      змінна значення_як_код = значення як адреса<Код>;
      змінна константи = створити_послідовність_без_копіювання(М, природне(значення_як_код.константи.розмір), значення_як_код.константи.дані);
      змінна вказівки = створити_дані_без_копіювання(М, природне(значення_як_код.вказівки.розмір), значення_як_код.вказівки.дані);
      змінна предмет_коду = мавка::створити_код(М, константи, вказівки, значення_як_код.шлях, значення_як_код.місцезнаходження_вказівок);

      вернути покласти_константу(М, код, предмет_коду як адреса<Предмет>);
    }

    дія покласти_вказівку(М: адреса<Машина>, код: невідома_адреса, рядок: п32, вид: п8) -> п32 {
      змінна код_як_код = код як адреса<Код>;

      код_як_код.вказівки.дані = перевиділити_памʼять<п8>(М, код_як_код.вказівки.дані, природне(код_як_код.вказівки.розмір + 1));

      змінна позиція_вказівки = код_як_код.вказівки.розмір;
      код_як_код.вказівки.дані[код_як_код.вказівки.розмір] = вид;
      код_як_код.вказівки.розмір += 1;

      покласти_місцезнаходження_вказівки(М, код_як_код.місцезнаходження_вказівок::адреса, рядок, позиція_вказівки);

      вернути позиція_вказівки;
    }

    дія покласти_вказівку_з_аргументом(М: адреса<Машина>, код: невідома_адреса, рядок: п32, вид: п8, аргумент: п32) -> п32 {
      змінна код_як_код = код як адреса<Код>;

      код_як_код.вказівки.дані = перевиділити_памʼять<п8>(М, код_як_код.вказівки.дані, природне((код_як_код.вказівки.розмір + 1) + 4));

      змінна позиція_вказівки = код_як_код.вказівки.розмір;
      код_як_код.вказівки.дані[код_як_код.вказівки.розмір] = вид;
      код_як_код.вказівки.розмір += 1;

      змінна аргумент_байти = аргумент::адреса як памʼять<п8>;
      код_як_код.вказівки.дані[код_як_код.вказівки.розмір] = аргумент_байти[0];
      код_як_код.вказівки.розмір += 1;
      код_як_код.вказівки.дані[код_як_код.вказівки.розмір] = аргумент_байти[1];
      код_як_код.вказівки.розмір += 1;
      код_як_код.вказівки.дані[код_як_код.вказівки.розмір] = аргумент_байти[2];
      код_як_код.вказівки.розмір += 1;
      код_як_код.вказівки.дані[код_як_код.вказівки.розмір] = аргумент_байти[3];
      код_як_код.вказівки.розмір += 1;

      покласти_місцезнаходження_вказівки(М, код_як_код.місцезнаходження_вказівок::адреса, рядок, позиція_вказівки);

      вернути позиція_вказівки;
    }

    дія покласти_вказівку_з_двома_аргументами(М: адреса<Машина>, код: невідома_адреса, рядок: п32, вид: п8, аргумент1: п32, аргумент2: п32) -> п32 {
      змінна код_як_код = код як адреса<Код>;

      код_як_код.вказівки.дані = перевиділити_памʼять<п8>(М, код_як_код.вказівки.дані, природне((код_як_код.вказівки.розмір + 1) + 8));

      змінна позиція_вказівки = код_як_код.вказівки.розмір;
      код_як_код.вказівки.дані[код_як_код.вказівки.розмір] = вид;
      код_як_код.вказівки.розмір += 1;

      змінна аргумент_1_байти = аргумент1::адреса як памʼять<п8>;
      код_як_код.вказівки.дані[код_як_код.вказівки.розмір] = аргумент_1_байти[0];
      код_як_код.вказівки.розмір += 1;
      код_як_код.вказівки.дані[код_як_код.вказівки.розмір] = аргумент_1_байти[1];
      код_як_код.вказівки.розмір += 1;
      код_як_код.вказівки.дані[код_як_код.вказівки.розмір] = аргумент_1_байти[2];
      код_як_код.вказівки.розмір += 1;
      код_як_код.вказівки.дані[код_як_код.вказівки.розмір] = аргумент_1_байти[3];
      код_як_код.вказівки.розмір += 1;

      змінна аргумент_2_байти = аргумент2::адреса як памʼять<п8>;
      код_як_код.вказівки.дані[код_як_код.вказівки.розмір] = аргумент_2_байти[0];
      код_як_код.вказівки.розмір += 1;
      код_як_код.вказівки.дані[код_як_код.вказівки.розмір] = аргумент_2_байти[1];
      код_як_код.вказівки.розмір += 1;
      код_як_код.вказівки.дані[код_як_код.вказівки.розмір] = аргумент_2_байти[2];
      код_як_код.вказівки.розмір += 1;
      код_як_код.вказівки.дані[код_як_код.вказівки.розмір] = аргумент_2_байти[3];
      код_як_код.вказівки.розмір += 1;

      покласти_місцезнаходження_вказівки(М, код_як_код.місцезнаходження_вказівок::адреса, рядок, позиція_вказівки);

      вернути позиція_вказівки;
    }

    дія змінити_аргумент_вказівки(М: адреса<Машина>, код: невідома_адреса, позиція_виду_вказівки: п32, позиція_аргумента_вказівки: п32, новий_аргумент: п32) {
      змінна код_як_код = код як адреса<Код>;
      змінна позиція_аргумента_як_байти = позиція_виду_вказівки + 1 + (позиція_аргумента_вказівки * 4);
      змінна новий_аргумент_як_байти = новий_аргумент::адреса як памʼять<п8>;

      код_як_код.вказівки.дані[позиція_аргумента_як_байти + 0] = новий_аргумент_як_байти[0];
      код_як_код.вказівки.дані[позиція_аргумента_як_байти + 1] = новий_аргумент_як_байти[1];
      код_як_код.вказівки.дані[позиція_аргумента_як_байти + 2] = новий_аргумент_як_байти[2];
      код_як_код.вказівки.дані[позиція_аргумента_як_байти + 3] = новий_аргумент_як_байти[3];
    }

    дія отримати_розмір_вказівок(М: адреса<Машина>, код: невідома_адреса) -> п32 {
      змінна код_як_код = код як адреса<Код>;

      вернути код_як_код.вказівки.розмір;
    }

    дія отримати_шлях_коду(М: адреса<Машина>, код: невідома_адреса) -> невідома_адреса {
      змінна код_як_код = код як адреса<Код>;

      вернути код_як_код.шлях;
    }
  }

  місцева дія перетворити_в_код(
    М: адреса<Машина>,
    шлях: адреса<ПредметДаних>,
    сирий_текст: кд,
    знаки: розбирач::Знаки,
    сполуки: розбирач::Сполуки,
    вихід_коду: адреса<адреса<ПредметКоду>>,
    вихід_помилки: адреса<перетворювач::ПомилкаПеретворення>
  ) -> логічне {
    змінна код: адреса<перетворювач_в_код::Код> = пусто;

    змінна успіх_перетворення = перетворювач::перетворити(
      М,
      шлях,
      сирий_текст,
      знаки,
      сполуки,
      перетворювач::Дії {
        створити_код = перетворювач_в_код::створити_код,
        покласти_константу_цілого = перетворювач_в_код::покласти_константу_цілого,
        покласти_константу_дробового = перетворювач_в_код::покласти_константу_дробового,
        покласти_константу_тексту = перетворювач_в_код::покласти_константу_тексту,
        покласти_константу_коду = перетворювач_в_код::покласти_константу_коду,
        покласти_вказівку = перетворювач_в_код::покласти_вказівку,
        покласти_вказівку_з_аргументом = перетворювач_в_код::покласти_вказівку_з_аргументом,
        покласти_вказівку_з_двома_аргументами = перетворювач_в_код::покласти_вказівку_з_двома_аргументами,
        змінити_аргумент_вказівки = перетворювач_в_код::змінити_аргумент_вказівки,
        отримати_розмір_вказівок = перетворювач_в_код::отримати_розмір_вказівок,
        отримати_шлях_коду = перетворювач_в_код::отримати_шлях_коду,
      },
      код::адреса як адреса<невідома_адреса>,
      вихід_помилки
    );
    якщо не успіх_перетворення {
      вернути успіх_перетворення;
    }

    змінна константи = створити_послідовність_без_копіювання(М, природне(код.константи.розмір), код.константи.дані);
    змінна вказівки = створити_дані_без_копіювання(М, природне(код.вказівки.розмір), код.вказівки.дані);

    вихід_коду::вміст = створити_код(М, константи, вказівки, шлях, код.місцезнаходження_вказівок);

    вернути так;
  }

  місцева дія перетворити_у_файл_коду(
    М: адреса<Машина>,
    сирий_текст: кд,
    знаки: розбирач::Знаки,
    сполуки: розбирач::Сполуки,
    вихід_розміру: адреса<природне>,
    вихід_даних: адреса<памʼять<п8>>,
    вихід_помилки: адреса<перетворювач::ПомилкаПеретворення>
  ) -> логічне {
    вернути ні;
  }
}