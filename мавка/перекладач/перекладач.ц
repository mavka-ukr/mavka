взяти визначення ./перекладач;
взяти визначення мавка/розбирач;
взяти визначення біб/КД;

секція мавка {
  секція перекладач {
    дія отримати_оброблену_копію_т8_тексту(М: адреса<Машина>, значення_т8: т8, вихід: адреса<т8>): логічне {
      змінна розмір_обробленого_значення_т8: натуральне = 0;
      змінна дані_обробленого_значення_т8 = виділити_памʼять<п8>(М, значення_т8.розмір);
      змінна п: натуральне = 0;
      поки п < значення_т8.розмір {
        змінна символ = значення_т8.дані[п];
        змінна розмір_символа = розбирач::визначити_розмір_символа(символ);
        якщо розмір_символа == 1 {
          якщо символ == розбирач::КД_ОБЕРНЕНА_ПОХИЛА {
            якщо (п + 1) < значення_т8.розмір {
              змінна наступний_символ = значення_т8.дані[п + 1];
              змінна розмір_наступного_символа = розбирач::визначити_розмір_символа(наступний_символ);
              якщо розмір_наступного_символа == 1 {
                якщо наступний_символ == розбирач::КД_ОБЕРНЕНА_ПОХИЛА {
                  дані_обробленого_значення_т8[розмір_обробленого_значення_т8] = розбирач::КД_ОБЕРНЕНА_ПОХИЛА;
                  розмір_обробленого_значення_т8 += 1;
                  п += 1;
                } інакше якщо наступний_символ == розбирач::КД_ДВОЛАПКА {
                  дані_обробленого_значення_т8[розмір_обробленого_значення_т8] = розбирач::КД_ДВОЛАПКА;
                  розмір_обробленого_значення_т8 += 1;
                  п += 1;
                } інакше якщо наступний_символ == розбирач::КД_ЛАПКА {
                  дані_обробленого_значення_т8[розмір_обробленого_значення_т8] = розбирач::КД_ЛАПКА;
                  розмір_обробленого_значення_т8 += 1;
                  п += 1;
                } інакше якщо наступний_символ == розбирач::КД_р {
                  дані_обробленого_значення_т8[розмір_обробленого_значення_т8] = розбирач::КД_РОЗРИВ;
                  розмір_обробленого_значення_т8 += 1;
                  п += 1;
                } інакше {
                  дані_обробленого_значення_т8[розмір_обробленого_значення_т8] = значення_т8.дані[п];
                  розмір_обробленого_значення_т8 += 1;
                }
              } інакше {
                дані_обробленого_значення_т8[розмір_обробленого_значення_т8] = значення_т8.дані[п];
                розмір_обробленого_значення_т8 += 1;
              }
            } інакше {
              дані_обробленого_значення_т8[розмір_обробленого_значення_т8] = значення_т8.дані[п];
              розмір_обробленого_значення_т8 += 1;
            }
          } інакше {
            дані_обробленого_значення_т8[розмір_обробленого_значення_т8] = значення_т8.дані[п];
            розмір_обробленого_значення_т8 += 1;
          }
        } інакше якщо розмір_символа == 2 {
          дані_обробленого_значення_т8[розмір_обробленого_значення_т8] = значення_т8.дані[п];
          розмір_обробленого_значення_т8 += 1;
          п += 1;
          дані_обробленого_значення_т8[розмір_обробленого_значення_т8] = значення_т8.дані[п];
          розмір_обробленого_значення_т8 += 1;
        } інакше якщо розмір_символа == 3 {
          дані_обробленого_значення_т8[розмір_обробленого_значення_т8] = значення_т8.дані[п];
          розмір_обробленого_значення_т8 += 1;
          п += 1;
          дані_обробленого_значення_т8[розмір_обробленого_значення_т8] = значення_т8.дані[п];
          розмір_обробленого_значення_т8 += 1;
          п += 1;
          дані_обробленого_значення_т8[розмір_обробленого_значення_т8] = значення_т8.дані[п];
          розмір_обробленого_значення_т8 += 1;
        } інакше якщо розмір_символа == 4 {
          дані_обробленого_значення_т8[розмір_обробленого_значення_т8] = значення_т8.дані[п];
          розмір_обробленого_значення_т8 += 1;
          п += 1;
          дані_обробленого_значення_т8[розмір_обробленого_значення_т8] = значення_т8.дані[п];
          розмір_обробленого_значення_т8 += 1;
          п += 1;
          дані_обробленого_значення_т8[розмір_обробленого_значення_т8] = значення_т8.дані[п];
          розмір_обробленого_значення_т8 += 1;
          п += 1;
          дані_обробленого_значення_т8[розмір_обробленого_значення_т8] = значення_т8.дані[п];
          розмір_обробленого_значення_т8 += 1;
        }
        п += 1;
      }
      вихід::вміст = т8 {
        розмір_обробленого_значення_т8,
        дані_обробленого_значення_т8
      };
      вернути так;
    }
  }
}

секція мавка {
  секція перекладач {
    дія копія_т8(М: адреса<Машина>, значення: т8): т8 {
      змінна результат = т8 { 0, пусто };
      якщо не виділити_копію_т8(М, значення, результат::адреса) {
        // потім: помилка
      }
      вернути результат;
    }
  }
}

дія перевірити_чи_т8_починається_на(значення: т8, починається_на: т8, п: адреса<натуральне>): логічне {
  змінна пп: натуральне = 0;
  поки пп < починається_на.розмір {
    змінна ппп = п::вміст + пп;
    якщо ппп >= значення.розмір {
      вернути ні;
    }
    якщо значення.дані[ппп] != починається_на.дані[пп] {
      вернути ні;
    }
    пп += 1;
  }
  п::вміст = п::вміст + пп - 1;
  вернути так;
}

дія розібрати_число_з_т8(значення: т8, вихід: адреса<д64>): логічне {
  змінна відʼємне = ні;
  змінна п: натуральне = 0;
  якщо значення.дані[п] == 45 {
    відʼємне = так;
    п += 1;
  }
  якщо перевірити_чи_т8_починається_на(значення, "0д", п::адреса) {
    п += 1;
    змінна значення_0д: ц64 = 0;
    поки п < значення.розмір {
      значення_0д *= 2;
      якщо значення.дані[п] == мавка::розбирач::КД_0 {
      } інакше якщо значення.дані[п] == мавка::розбирач::КД_1 {
        значення_0д += 1;
      } інакше {
        вернути ні;
      }
      п += 1;
    }
    якщо відʼємне {
      вихід::вміст = д64(ц64(0) - значення_0д);
      вернути так;
    }
    вихід::вміст = д64(значення_0д);
    вернути так;
  }
  якщо перевірити_чи_т8_починається_на(значення, "0ш", п::адреса) {
    п += 1;
    змінна значення_0ш: ц64 = 0;
    поки п < значення.розмір {
      змінна с: п8 = 0;
      якщо перевірити_чи_т8_починається_на(значення, "0", п::адреса) {
        с = 0;
      } інакше якщо перевірити_чи_т8_починається_на(значення, "1", п::адреса) {
        с = 1;
      } інакше якщо перевірити_чи_т8_починається_на(значення, "2", п::адреса) {
        с = 2;
      } інакше якщо перевірити_чи_т8_починається_на(значення, "3", п::адреса) {
        с = 3;
      } інакше якщо перевірити_чи_т8_починається_на(значення, "4", п::адреса) {
        с = 4;
      } інакше якщо перевірити_чи_т8_починається_на(значення, "5", п::адреса) {
        с = 5;
      } інакше якщо перевірити_чи_т8_починається_на(значення, "6", п::адреса) {
        с = 6;
      } інакше якщо перевірити_чи_т8_починається_на(значення, "7", п::адреса) {
        с = 7;
      } інакше якщо перевірити_чи_т8_починається_на(значення, "8", п::адреса) {
        с = 8;
      } інакше якщо перевірити_чи_т8_починається_на(значення, "9", п::адреса) {
        с = 9;
      } інакше якщо перевірити_чи_т8_починається_на(значення, "А", п::адреса) {
        с = 10;
      } інакше якщо перевірити_чи_т8_починається_на(значення, "Б", п::адреса) {
        с = 11;
      } інакше якщо перевірити_чи_т8_починається_на(значення, "В", п::адреса) {
        с = 12;
      } інакше якщо перевірити_чи_т8_починається_на(значення, "Г", п::адреса) {
        с = 13;
      } інакше якщо перевірити_чи_т8_починається_на(значення, "Д", п::адреса) {
        с = 14;
      } інакше якщо перевірити_чи_т8_починається_на(значення, "Е", п::адреса) {
        с = 15;
      } інакше якщо перевірити_чи_т8_починається_на(значення, "а", п::адреса) {
        с = 10;
      } інакше якщо перевірити_чи_т8_починається_на(значення, "б", п::адреса) {
        с = 11;
      } інакше якщо перевірити_чи_т8_починається_на(значення, "в", п::адреса) {
        с = 12;
      } інакше якщо перевірити_чи_т8_починається_на(значення, "г", п::адреса) {
        с = 13;
      } інакше якщо перевірити_чи_т8_починається_на(значення, "д", п::адреса) {
        с = 14;
      } інакше якщо перевірити_чи_т8_починається_на(значення, "е", п::адреса) {
        с = 15;
      } інакше {
        вернути ні;
      }
      значення_0ш = (значення_0ш << 4) | (ц64(с) & 15);
      п += 1;
    }
    якщо відʼємне {
      вихід::вміст = д64(ц64(0) - значення_0ш);
      вернути так;
    }
    вихід::вміст = д64(значення_0ш);
    вернути так;
  }
  змінна результат: д64 = 0;
  змінна символ_: п8 = значення.дані[0];
  поки п < значення.розмір {
    символ_ = значення.дані[п];
    якщо символ_ == мавка::розбирач::КД_0 { // 0
      результат = результат * 10;
    } інакше якщо символ_ == мавка::розбирач::КД_1 { // 1
      результат = результат * 10 + 1;
    } інакше якщо символ_ == мавка::розбирач::КД_2 { // 2
      результат = результат * 10 + 2;
    } інакше якщо символ_ == мавка::розбирач::КД_3 { // 3
      результат = результат * 10 + 3;
    } інакше якщо символ_ == мавка::розбирач::КД_4 { // 4
      результат = результат * 10 + 4;
    } інакше якщо символ_ == мавка::розбирач::КД_5 { // 5
      результат = результат * 10 + 5;
    } інакше якщо символ_ == мавка::розбирач::КД_6 { // 6
      результат = результат * 10 + 6;
    } інакше якщо символ_ == мавка::розбирач::КД_7 { // 7
      результат = результат * 10 + 7;
    } інакше якщо символ_ == мавка::розбирач::КД_8 { // 8
      результат = результат * 10 + 8;
    } інакше якщо символ_ == мавка::розбирач::КД_9 { // 9
      результат = результат * 10 + 9;
    } інакше якщо символ_ == мавка::розбирач::КД_ПІДРИСКА { // _
      // ігноруємо
    } інакше якщо символ_ == мавка::розбирач::КД_КРАПКА { // .
      п += 1;
      символ_ = значення.дані[п];
      змінна дробна_частина: д64 = 0;
      змінна дільник: д64 = 1;
      поки п < значення.розмір {
        символ_ = значення.дані[п];
        якщо символ_ == мавка::розбирач::КД_0 { // 0
          дробна_частина = дробна_частина * 10;
        } інакше якщо символ_ == мавка::розбирач::КД_1 { // 1
          дробна_частина = дробна_частина * 10 + 1;
        } інакше якщо символ_ == мавка::розбирач::КД_2 { // 2
          дробна_частина = дробна_частина * 10 + 2;
        } інакше якщо символ_ == мавка::розбирач::КД_3 { // 3
          дробна_частина = дробна_частина * 10 + 3;
        } інакше якщо символ_ == мавка::розбирач::КД_4 { // 4
          дробна_частина = дробна_частина * 10 + 4;
        } інакше якщо символ_ == мавка::розбирач::КД_5 { // 5
          дробна_частина = дробна_частина * 10 + 5;
        } інакше якщо символ_ == мавка::розбирач::КД_6 { // 6
          дробна_частина = дробна_частина * 10 + 6;
        } інакше якщо символ_ == мавка::розбирач::КД_7 { // 7
          дробна_частина = дробна_частина * 10 + 7;
        } інакше якщо символ_ == мавка::розбирач::КД_8 { // 8
          дробна_частина = дробна_частина * 10 + 8;
        } інакше якщо символ_ == мавка::розбирач::КД_9 { // 9
          дробна_частина = дробна_частина * 10 + 9;
        } інакше якщо символ_ == мавка::розбирач::КД_ПІДРИСКА { // _
          // ігноруємо
        } інакше {
          вернути ні;
        }
        п += 1;
        дільник = дільник * 10;
      }
      результат = результат + дробна_частина / дільник;
      вихід::вміст = результат;
      вернути так;
    } інакше {
      вернути ні;
    }
    п += 1;
  }
  вихід::вміст = результат;
  вернути так;
}

секція мавка {
  секція перекладач {
    дія покласти_константу_назви(М: адреса<Машина>, код: адреса<Код>, значення: т8) -> н32 {
      покласти_в_накопичувач<адреса<Предмет>>(
        М,
        код.накопичувач_констант::адреса,
        створити_предмет_тексту(М, значення) як адреса<Предмет>
      );
      вернути н32(код.накопичувач_констант.розмір - 1);
    }

    дія позиція_назви_з_т8(М: адреса<Машина>, код: адреса<Код>, значення: т8) -> н32 {
      вернути покласти_константу_назви(М, код, значення);
    }

    дія покласти_константу_числа(М: адреса<Машина>, код: адреса<Код>, значення: д64) -> н32 {
      покласти_в_накопичувач<адреса<Предмет>>(
        М,
        код.накопичувач_констант::адреса,
        створити_предмет_числа(М, значення) як адреса<Предмет>
      );
      вернути н32(код.накопичувач_констант.розмір - 1);
    }

    дія покласти_константу_тексту(М: адреса<Машина>, код: адреса<Код>, значення: т8) -> н32 {
      покласти_в_накопичувач<адреса<Предмет>>(
        М,
        код.накопичувач_констант::адреса,
        створити_предмет_тексту(М, значення) як адреса<Предмет>
      );
      вернути н32(код.накопичувач_констант.розмір - 1);
    }

    дія покласти_константу_коду(М: адреса<Машина>, код: адреса<Код>, значення: адреса<Код>) -> н32 {
      покласти_в_накопичувач<адреса<Предмет>>(
        М,
        код.накопичувач_констант::адреса,
        створити_предмет_коду_з_коду_перекладача(М, значення) як адреса<Предмет>
      );
      вернути н32(код.накопичувач_констант.розмір - 1);
    }

    дія перекласти_сполуку(М: адреса<Машина>, значення_коду_т8: т8, слова: розбирач::Слова, контекст: адреса<КонтекстПерекладу>, код: адреса<Код>, елемент: адреса<розбирач::Сполука>, вихід_помилки: адреса<ПомилкаПерекладуВМаМа>): логічне {
      змінна результат = так;

      змінна рядок = н32(розбирач::отримати_рядок_з_місцезнаходження(
        значення_коду_т8,
        слова,
        елемент.місцезнаходження
      ));

      якщо елемент.вид == розбирач::ВидСполукиЗвернутись {
        змінна дані = елемент.дані як розбирач::ДаніСполукиЗвернутись;

        змінна значення_ідентифікатора = розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, дані.ідентифікатор);

        якщо перевірити_чи_т8_рівні(значення_ідентифікатора, "я") {
          В1::покласти_вказівку_ПокластиЯ(М, код.будівельник_вказівок::адреса, рядок);
        } інакше якщо перевірити_чи_т8_рівні(значення_ідентифікатора, "так") {
          В1::покласти_вказівку_ПокластиТак(М, код.будівельник_вказівок::адреса, рядок);
        } інакше якщо перевірити_чи_т8_рівні(значення_ідентифікатора, "ні") {
          В1::покласти_вказівку_ПокластиНі(М, код.будівельник_вказівок::адреса, рядок);
        } інакше якщо перевірити_чи_т8_рівні(значення_ідентифікатора, "пусто") {
          В1::покласти_вказівку_ПокластиПусто(М, код.будівельник_вказівок::адреса, рядок);
        } інакше {
          змінна позиція_назви = позиція_назви_з_т8(М, код, значення_ідентифікатора);
          В1::покласти_вказівку_Звернутись(М, код.будівельник_вказівок::адреса, рядок, позиція_назви);
        }

        вернути так;
      }

      якщо елемент.вид == розбирач::ВидСполукиОтримати {
        змінна дані = елемент.дані як розбирач::ДаніСполукиОтримати;
        
        змінна успіх_компіляції_предмета = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.предмет, вихід_помилки);
        якщо успіх_компіляції_предмета == ні {
          вернути успіх_компіляції_предмета;
        }
        
        змінна позиція_назви = позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, дані.ідентифікатор));
        В1::покласти_вказівку_ОтриматиВластивість(М, код.будівельник_вказівок::адреса, рядок, позиція_назви);

        вернути так;
      }

      якщо елемент.вид == розбирач::ВидСполукиОтриматиЕлемент {
        змінна дані = елемент.дані як розбирач::ДаніСполукиОтриматиЕлемент;

        змінна успіх_компіляції_предмета = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.предмет, вихід_помилки);
        якщо успіх_компіляції_предмета == ні {
          вернути успіх_компіляції_предмета;
        }

        змінна успіх_компіляції_ключа = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.ключ, вихід_помилки);
        якщо успіх_компіляції_ключа == ні {
          вернути успіх_компіляції_ключа;
        }

        В1::покласти_вказівку_ОтриматиЕлемент(М, код.будівельник_вказівок::адреса, рядок);

        вернути так;
      }

      якщо елемент.вид == розбирач::ВидСполукиВиконати {
        змінна дані = елемент.дані як розбирач::ДаніСполукиВиконати;

        якщо дані.предмет.вид == розбирач::ВидСполукиОтримати {
          змінна дані_отримання = дані.предмет.дані як розбирач::ДаніСполукиОтримати;

          змінна успіх_компіляції_предмета = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані_отримання.предмет, вихід_помилки);
          якщо успіх_компіляції_предмета == ні {
            вернути успіх_компіляції_предмета;
          }

          змінна позиція_назви_прохання = позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, дані_отримання.ідентифікатор));
          В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок, позиція_назви_прохання);
        } інакше {
          змінна успіх_компіляції_предмета = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.предмет, вихід_помилки);
          якщо успіх_компіляції_предмета == ні {
            вернути успіх_компіляції_предмета;
          }
        }

        змінна кількість_аргументів_без_назви: н32 = 0;
        змінна кількість_аргументів_з_назвою: н32 = 0;
        змінна п: н32 = 0;
        поки п < н32(дані.кількість_аргументів) {
          змінна аргумент = дані.аргументи[п];
          змінна рядок_аргумента = н32(розбирач::отримати_рядок_з_місцезнаходження(значення_коду_т8, слова, аргумент.місцезнаходження));

          якщо аргумент.ідентифікатор.заповнено {
            змінна позиція_назви_аргумента = позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, аргумент.ідентифікатор.значення));
            В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок_аргумента, позиція_назви_аргумента);

            змінна успіх_компіляції_аргумента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, аргумент.значення, вихід_помилки);
            якщо успіх_компіляції_аргумента == ні {
              вернути успіх_компіляції_аргумента;
            }

            кількість_аргументів_з_назвою += 1;
          } інакше {
            якщо кількість_аргументів_з_назвою > 0 {
              вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
                повідомлення = копія_т8(М, "Іменовані аргументи не можуть йти перед позиційними"),
                позиція_слова = 0
              };
              вернути ні;
            }

            змінна успіх_компіляції_аргумента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, аргумент.значення, вихід_помилки);
            якщо успіх_компіляції_аргумента == ні {
              вернути успіх_компіляції_аргумента;
            }

            кількість_аргументів_без_назви += 1;
          }

          п += 1;
        }

        якщо дані.предмет.вид == розбирач::ВидСполукиОтримати {
          В1::покласти_вказівку_ВиконатиВластивість(М, код.будівельник_вказівок::адреса, рядок, кількість_аргументів_без_назви, кількість_аргументів_з_назвою);
        } інакше {
          В1::покласти_вказівку_Виконати(М, код.будівельник_вказівок::адреса, рядок, кількість_аргументів_без_назви, кількість_аргументів_з_назвою);
        }

        вернути так;
      }

      якщо елемент.вид == розбирач::ВидСполукиДія {
        змінна дані = елемент.дані як розбирач::ДаніСполукиДія;

//        якщо дані.власна {
//          вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
//            повідомлення = копія_т8(М, "Неможливо перекласти дію"),
//            позиція_слова = 0
//          };
//          результат = ні;
//          стрибнути вихід;
//        }

        якщо дані.тривала {
          вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
            повідомлення = копія_т8(М, "Тривалі дії наразі не підтримуються"),
            позиція_слова = 0
          };
          результат = ні;
          стрибнути вихід;
        }

        якщо дані.ідентифікатор.заповнено {
          змінна позиція_назви = позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, дані.ідентифікатор.значення));
          В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок, позиція_назви); // назва
        } інакше {
          В1::покласти_вказівку_ПокластиПусто(М, код.будівельник_вказівок::адреса, рядок); // назва
        }

        змінна п: натуральне = 0;
        поки п < дані.кількість_параметрів {
          змінна параметр = дані.параметри[п];

          змінна позиція_назви_параметра = позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, параметр.ідентифікатор));
          В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок, позиція_назви_параметра);
          В1::покласти_вказівку_ПокластиПусто(М, код.будівельник_вказівок::адреса, рядок);

          якщо параметр.значення != пусто {
            змінна код_значення_параметра = створити_код(М, код.шлях);
            змінна контекст_значення_параметра = створити_контекст(М);

            змінна успіх_перекладу_коду = перекласти_сполуку(М, значення_коду_т8, слова, контекст_значення_параметра, код_значення_параметра, параметр.значення, вихід_помилки);
            якщо успіх_перекладу_коду == ні {
              знищити_код(М, код_значення_параметра);
              знищити_контекст(М, контекст_значення_параметра);
              результат = ні;
              стрибнути вихід;
            }

            В1::покласти_вказівку_Вернути(М, код_значення_параметра.будівельник_вказівок::адреса, рядок);

            змінна позиція_коду_параметра = покласти_константу_коду(М, код, код_значення_параметра);
            В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок, позиція_коду_параметра);

            звільнити(М, код_значення_параметра);
            знищити_контекст(М, контекст_значення_параметра);
          } інакше {
            В1::покласти_вказівку_ПокластиПусто(М, код.будівельник_вказівок::адреса, рядок);
          }

          В1::покласти_вказівку_СтворитиПараметр(М, код.будівельник_вказівок::адреса, рядок);

          п += 1;
        }

        В1::покласти_вказівку_ПокластиПусто(М, код.будівельник_вказівок::адреса, рядок);

        змінна код_дії = створити_код(М, код.шлях);
        змінна контекст_дії = створити_контекст(М);

        змінна успіх_перекладу_коду_дії = перекласти(М, значення_коду_т8, слова, дані.тіло, так, контекст_дії, код_дії, вихід_помилки);
        якщо успіх_перекладу_коду_дії == ні {
          знищити_код(М, код_дії);
          знищити_контекст(М, контекст_дії);
          результат = ні;
          стрибнути вихід;
        }

        змінна позиція_коду_дії = покласти_константу_коду(М, код, код_дії);
        В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок, позиція_коду_дії); // код
        В1::покласти_вказівку_СтворитиДію(М, код.будівельник_вказівок::адреса, рядок, н32(дані.кількість_параметрів));
        звільнити(М, код_дії);
        знищити_контекст(М, контекст_дії);

        вернути так;
      }

      якщо елемент.вид == розбирач::ВидСполукиСтруктура {
        змінна дані = елемент.дані як розбирач::ДаніСполукиСтруктура;

        якщо дані.ідентифікатор.заповнено {
          змінна позиція_назви = позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, дані.ідентифікатор.значення));
          В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок, позиція_назви);
        } інакше {
          В1::покласти_вказівку_ПокластиПусто(М, код.будівельник_вказівок::адреса, рядок);
        }

        якщо дані.предок == пусто {
          В1::покласти_вказівку_ПокластиСтруктуруПредмет(М, код.будівельник_вказівок::адреса, рядок);
        } інакше {
          змінна успіх_компіляції_предка = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.предок, вихід_помилки);
          якщо успіх_компіляції_предка == ні {
            вернути успіх_компіляції_предка;
          }
        }

        змінна п: натуральне = 0;
        поки п < дані.кількість_параметрів {
          змінна параметр = дані.параметри[п];

          змінна позиція_назви_параметра = позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, параметр.ідентифікатор));
          В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок, позиція_назви_параметра);

          В1::покласти_вказівку_ПокластиПусто(М, код.будівельник_вказівок::адреса, рядок);

          якщо параметр.значення != пусто {
            змінна код_значення_параметра = створити_код(М, код.шлях);
            змінна контекст_значення_параметра = створити_контекст(М);

            змінна успіх_перекладу_коду = перекласти_сполуку(М, значення_коду_т8, слова, контекст_значення_параметра, код_значення_параметра, параметр.значення, вихід_помилки);
            якщо успіх_перекладу_коду == ні {
              знищити_код(М, код_значення_параметра);
              знищити_контекст(М, контекст_значення_параметра);
              результат = ні;
              стрибнути вихід;
            }

            В1::покласти_вказівку_Вернути(М, код_значення_параметра.будівельник_вказівок::адреса, рядок);

            змінна позиція_коду_параметра = покласти_константу_коду(М, код, код_значення_параметра);
            В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок, позиція_коду_параметра);

            звільнити(М, код_значення_параметра);
            знищити_контекст(М, контекст_значення_параметра);
          } інакше {
            В1::покласти_вказівку_ПокластиПусто(М, код.будівельник_вказівок::адреса, рядок);
          }

          В1::покласти_вказівку_СтворитиПараметр(М, код.будівельник_вказівок::адреса, рядок);

          п += 1;
        }

        В1::покласти_вказівку_СтворитиСтруктуру(М, код.будівельник_вказівок::адреса, рядок, н32(дані.кількість_параметрів));

        вернути так;
      }

      якщо елемент.вид == розбирач::ВидСполукиЧисло {
        змінна дані = елемент.дані як розбирач::ДаніСполукиЧисло;

        змінна слово = слова.дані[дані.позиція_слова];

        змінна розібране_число: д64 = 0.0;
        якщо не розібрати_число_з_т8(розбирач::отримати_значення_слова(значення_коду_т8, слова, слово), розібране_число::адреса) {
          вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
            повідомлення = копія_т8(М, "Не вдалось розібрати число"),
            позиція_слова = 0
          };
          вернути ні;
        }

        змінна позиція_константи = покласти_константу_числа(М, код, розібране_число);
        В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок, позиція_константи);

        вернути так;
      }

      якщо елемент.вид == розбирач::ВидСполукиТекст {
        змінна дані = елемент.дані як розбирач::ДаніСполукиТекст;

        змінна значення_тексту_т8 = розбирач::отримати_значення_тексту(значення_коду_т8, слова, елемент);

        змінна оброблене_значення_тексту_т8 = т8 { 0, пусто };
        якщо не отримати_оброблену_копію_т8_тексту(М, значення_тексту_т8, оброблене_значення_тексту_т8::адреса) {
          вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
            повідомлення = копія_т8(М, "Не вдалось розібрати текст"),
            позиція_слова = 0
          };
          вернути ні;
        }

        змінна позиція_константи: н32 = 0;

        якщо не дані.ідентифікатор.заповнено {
          якщо оброблене_значення_тексту_т8.розмір == 0 {
            позиція_константи = покласти_константу_тексту(М, код, "");
          } інакше {
            позиція_константи = покласти_константу_тексту(М, код, оброблене_значення_тексту_т8);
          }
        } інакше {
          звільнити_памʼять(М, оброблене_значення_тексту_т8.дані);
          вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
            повідомлення = копія_т8(М, "Невідомий тип тексту"),
            позиція_слова = 0
          };
          вернути ні;
        }

        звільнити_памʼять(М, оброблене_значення_тексту_т8.дані);

        В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок, позиція_константи);

        вернути так;
      }

      якщо елемент.вид == розбирач::ВидСполукиЗбитийТекст {
        змінна дані = елемент.дані як розбирач::ДаніСполукиЗбитийТекст;

        змінна п: натуральне = 0;
        поки п < дані.кількість_гілок {
          змінна успіх_компіляції_значення = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.сполуки[п], вихід_помилки);
          якщо успіх_компіляції_значення == ні {
            вернути успіх_компіляції_значення;
          }

          п += 1;
        }

        якщо не дані.ідентифікатор.заповнено {
          В1::покласти_вказівку_ЗбитиТекст(М, код.будівельник_вказівок::адреса, рядок, н32(дані.кількість_гілок));
        } інакше {
          вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
            повідомлення = копія_т8(М, "Невідомий тип тексту"),
            позиція_слова = 0
          };
          вернути ні;
        }

        вернути так;
      }

      якщо елемент.вид == розбирач::ВидСполукиСимвол {
        змінна дані = елемент.дані як розбирач::ДаніСполукиСимвол;

        змінна значення_символу_т8 = розбирач::отримати_значення_символу(значення_коду_т8, слова, елемент);

        змінна оброблене_значення_символу_т8 = т8 { 0, пусто };
        якщо не отримати_оброблену_копію_т8_тексту(М, значення_символу_т8, оброблене_значення_символу_т8::адреса) {
          вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
            повідомлення = копія_т8(М, "Не вдалось розібрати символ"),
            позиція_слова = 0
          };
          вернути ні;
        }

        змінна позиція_константи: н32 = 0;
        якщо не дані.ідентифікатор.заповнено {
          якщо оброблене_значення_символу_т8.розмір == 0 {
            вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
              повідомлення = копія_т8(М, "Пустий символ"),
              позиція_слова = 0
            };
            звільнити_памʼять(М, оброблене_значення_символу_т8.дані);
            вернути ні;
          } інакше {
            позиція_константи = покласти_константу_числа(М, код, д64(оброблене_значення_символу_т8.дані[0]));
          }
        } інакше {
          вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
            повідомлення = копія_т8(М, "Невідомий тип символа"),
            позиція_слова = 0
          };
          звільнити_памʼять(М, оброблене_значення_символу_т8.дані);
          вернути ні;
        }

        звільнити_памʼять(М, оброблене_значення_символу_т8.дані);

        В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок, позиція_константи);

        вернути так;
      }

      якщо елемент.вид == розбирач::ВидСполукиОперація {
        змінна дані = елемент.дані як розбирач::ДаніСполукиОперація;

        змінна успіх_компіляції_ліво = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.ліво, вихід_помилки);
        якщо не успіх_компіляції_ліво {
          вернути успіх_компіляції_ліво;
        }

        якщо дані.операція == розбирач::ВидОпераціїІ {
          змінна позиція_вказівки_стрибнути_якщо_ні = н32(код.будівельник_вказівок.вказівки.розмір);

          В1::покласти_вказівку_СтрибнутиЯкщоНіЗалишивши(М, код.будівельник_вказівок::адреса, рядок, 0);
          В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);

          змінна успіх_компіляції_право = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.право, вихід_помилки);
          якщо не успіх_компіляції_право {
            вернути успіх_компіляції_право;
          }

          В1::перезаписати_аргумент_вказівки(М, код.будівельник_вказівок::адреса, позиція_вказівки_стрибнути_якщо_ні + 1, н32(код.будівельник_вказівок.вказівки.розмір));

          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїАБО {
          змінна позиція_вказівки_стрибнути_якщо_так = н32(код.будівельник_вказівок.вказівки.розмір);

          В1::покласти_вказівку_СтрибнутиЯкщоТакЗалишивши(М, код.будівельник_вказівок::адреса, рядок, 0);
          В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);

          змінна успіх_компіляції_право = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.право, вихід_помилки);
          якщо не успіх_компіляції_право {
            вернути успіх_компіляції_право;
          }

          В1::перезаписати_аргумент_вказівки(М, код.будівельник_вказівок::адреса, позиція_вказівки_стрибнути_якщо_так + 1, н32(код.будівельник_вказівок.вказівки.розмір));

          вернути так;
        }

        змінна успіх_компіляції_право = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.право, вихід_помилки);
        якщо не успіх_компіляції_право {
          вернути успіх_компіляції_право;
        }

        якщо дані.операція == розбирач::ВидОпераціїДодавання {
          В1::покласти_вказівку_Додати(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїВіднімання {
          В1::покласти_вказівку_Відняти(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїМноження {
          В1::покласти_вказівку_Помножити(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїДілення {
          В1::покласти_вказівку_Поділити(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїМодуль {
          В1::покласти_вказівку_ОтриматиОстачуДілення(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїДіленняНаціло {
          В1::покласти_вказівку_ОтриматиНеповнуЧасткуДілення(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїПіднесенняДоСтепеня {
          В1::покласти_вказівку_ПіднестиДоСтепеня(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїЗсувВліво {
          В1::покласти_вказівку_ЗсунутиВліво(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїЗсувВправо {
          В1::покласти_вказівку_ЗсунутиВправо(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїЗсувВправоЗнаковий {
          В1::покласти_вказівку_ЗсунутиВправоЗіЗаповненням(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїДІ {
          В1::покласти_вказівку_ДвійковеІ(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїДАБО {
          В1::покласти_вказівку_ДвійковеАБО(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїВАБО {
          В1::покласти_вказівку_ДвійковеВиключнеАБО(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїМенше {
          В1::покласти_вказівку_Менше(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїБільше {
          В1::покласти_вказівку_Більше(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїМеншеРівне {
          В1::покласти_вказівку_НеБільше(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїБільшеРівне {
          В1::покласти_вказівку_НеМенше(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїРівне {
          В1::покласти_вказівку_Рівно(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїНерівне {
          В1::покласти_вказівку_НеРівно(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїМістить {
          В1::покласти_вказівку_Містить(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїНеМістить {
          В1::покласти_вказівку_НеМістить(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїЄ {
          В1::покласти_вказівку_Є(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїНеЄ {
          В1::покласти_вказівку_НеЄ(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        }

        вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
          повідомлення = копія_т8(М, "Невідома операція"),
          позиція_слова = 0
        };
        вернути ні;
      }

      якщо елемент.вид == розбирач::ВидСполукиЗначенняЯкщо {
        змінна дані = елемент.дані як розбирач::ДаніСполукиЗначенняЯкщо;

        змінна успіх_компіляції_умови = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.умова, вихід_помилки);
        якщо успіх_компіляції_умови == ні {
          вернути успіх_компіляції_умови;
        }

        змінна позиція_вказівки_стрибнути_якщо_ні = н32(код.будівельник_вказівок.вказівки.розмір);
        В1::покласти_вказівку_СтрибнутиЯкщоНі(М, код.будівельник_вказівок::адреса, рядок, 0);

        змінна успіх_компіляції_так = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.значення_так, вихід_помилки);
        якщо успіх_компіляції_так == ні {
          вернути успіх_компіляції_так;
        }

        змінна позиція_вказівки_виходу_з_так = н32(код.будівельник_вказівок.вказівки.розмір);
        В1::покласти_вказівку_Стрибнути(М, код.будівельник_вказівок::адреса, рядок, 0);
        В1::перезаписати_аргумент_вказівки(М, код.будівельник_вказівок::адреса, позиція_вказівки_стрибнути_якщо_ні + 1, н32(код.будівельник_вказівок.вказівки.розмір));

        змінна успіх_компіляції_ні = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.значення_ні, вихід_помилки);
        якщо успіх_компіляції_ні == ні {
          вернути успіх_компіляції_ні;
        }

        В1::перезаписати_аргумент_вказівки(М, код.будівельник_вказівок::адреса, позиція_вказівки_виходу_з_так + 1, н32(код.будівельник_вказівок.вказівки.розмір));

        вернути так;
      }

      якщо елемент.вид == розбирач::ВидСполукиСамоОперація {
        змінна дані = елемент.дані як розбирач::ДаніСполукиСамоОперація;

        змінна успіх_компіляції_предмета = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.предмет, вихід_помилки);
        якщо успіх_компіляції_предмета == ні {
          вернути успіх_компіляції_предмета;
        }

        якщо дані.операція == розбирач::ВидСамоОпераціїЛогічнеНі {
          В1::покласти_вказівку_Заперечити(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        }

        якщо дані.операція == розбирач::ВидСамоОпераціїДвійковеНі {
          В1::покласти_вказівку_ДвійковеНЕ(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        }

        якщо дані.операція == розбирач::ВидСамоОпераціїПлюс {
          В1::покласти_вказівку_Числове(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        }

        якщо дані.операція == розбирач::ВидСамоОпераціїМінус {
          В1::покласти_вказівку_Відʼємне(М, код.будівельник_вказівок::адреса, рядок);
          вернути так;
        }

        вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
          повідомлення = копія_т8(М, "Невідома операція"),
          позиція_слова = 0
        };
        вернути ні;
      }

      якщо елемент.вид == розбирач::ВидСполукиМодуль {
        змінна дані = елемент.дані як розбирач::ДаніСполукиМодуль;

        якщо дані.ідентифікатор.заповнено {
          змінна позиція_назви = позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, дані.ідентифікатор.значення));
          В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок, позиція_назви);
        } інакше {
          В1::покласти_вказівку_ПокластиПусто(М, код.будівельник_вказівок::адреса, рядок);
        }

        змінна код_модуля = створити_код(М, код.шлях);
        змінна контекст_модуля = створити_контекст(М);

        змінна успіх_перекладу_коду_дії = перекласти(М, значення_коду_т8, слова, дані.тіло, ні, контекст_модуля, код_модуля, вихід_помилки);
        якщо успіх_перекладу_коду_дії == ні {
          знищити_код(М, код_модуля);
          знищити_контекст(М, контекст_модуля);
          результат = ні;
          стрибнути вихід;
        }

        змінна позиція_коду_дії = покласти_константу_коду(М, код, код_модуля);
        В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок, позиція_коду_дії);
        В1::покласти_вказівку_СтворитиМодуль(М, код.будівельник_вказівок::адреса, рядок);

        звільнити(М, код_модуля);
        знищити_контекст(М, контекст_модуля);

        вернути так;
      }

      якщо елемент.вид == розбирач::ВидСполукиСписок {
        змінна дані = елемент.дані як розбирач::ДаніСполукиСписок;

        В1::покласти_вказівку_СтворитиСписок(М, код.будівельник_вказівок::адреса, рядок, н32(дані.кількість_елементів));

        змінна п: натуральне = 0;
        поки п < дані.кількість_елементів {
          змінна елемент_списку = дані.елементи[п];

          змінна успіх_компіляції_елементу_списку = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент_списку, вихід_помилки);
          якщо успіх_компіляції_елементу_списку == ні {
            вернути успіх_компіляції_елементу_списку;
          }

          В1::покласти_вказівку_ПокластиВСписок(М, код.будівельник_вказівок::адреса, рядок);

          п += 1;
        }

        вернути так;
      }

      якщо елемент.вид == розбирач::ВидСполукиСловник {
        змінна дані = елемент.дані як розбирач::ДаніСполукиСловник;

        В1::покласти_вказівку_СтворитиСловник(М, код.будівельник_вказівок::адреса, рядок, н32(дані.кількість_елементів));

        змінна п: н32 = 0;
        поки п < н32(дані.кількість_елементів) {
          змінна елемент_словника = дані.елементи[п];

          змінна успіх_компіляції_ключа_словника_списку = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент_словника.ключ, вихід_помилки);
          якщо успіх_компіляції_ключа_словника_списку == ні {
            вернути успіх_компіляції_ключа_словника_списку;
          }

          змінна успіх_компіляції_значення_словника_списку = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент_словника.значення, вихід_помилки);
          якщо успіх_компіляції_значення_словника_списку == ні {
            вернути успіх_компіляції_значення_словника_списку;
          }

          В1::покласти_вказівку_ПокластиВСловник(М, код.будівельник_вказівок::адреса, рядок);

          п += 1;
        }

        вернути так;
      }

      якщо елемент.вид == розбирач::ВидСполукиВидалити {
        змінна дані = елемент.дані як розбирач::ДаніСполукиВидалити;

        змінна позиція_назви = позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, дані.ідентифікатор));
        В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок, позиція_назви);
        В1::покласти_вказівку_Видалити(М, код.будівельник_вказівок::адреса, рядок);

        вернути так;
      }

      якщо елемент.вид == розбирач::ВидСполукиВидалитиВластивість {
        змінна дані = елемент.дані як розбирач::ДаніСполукиВидалитиВластивість;

        змінна успіх_компіляції_предмета = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.предмет, вихід_помилки);
        якщо успіх_компіляції_предмета == ні {
          вернути успіх_компіляції_предмета;
        }

        змінна позиція_назви = позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, дані.ідентифікатор));
        В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок, позиція_назви);
        В1::покласти_вказівку_ВидалитиВластивість(М, код.будівельник_вказівок::адреса, рядок);

        вернути так;
      }

      якщо елемент.вид == розбирач::ВидСполукиВидалитиЕлемент {
        змінна дані = елемент.дані як розбирач::ДаніСполукиВидалитиЕлемент;

        змінна успіх_компіляції_предмета = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.предмет, вихід_помилки);
        якщо успіх_компіляції_предмета == ні {
          вернути успіх_компіляції_предмета;
        }

        змінна успіх_компіляції_ключа = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.ключ, вихід_помилки);
        якщо успіх_компіляції_ключа == ні {
          вернути успіх_компіляції_ключа;
        }

        В1::покласти_вказівку_ВидалитиЕлемент(М, код.будівельник_вказівок::адреса, рядок);

        вернути так;
      }

      якщо елемент.вид == розбирач::ВидСполукиДіапазон {
        змінна дані = елемент.дані як розбирач::ДаніСполукиДіапазон;

        змінна успіх_компіляції_від = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.від, вихід_помилки);
        якщо успіх_компіляції_від == ні {
          вернути успіх_компіляції_від;
        }

        змінна успіх_компіляції_до = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.до, вихід_помилки);
        якщо успіх_компіляції_до == ні {
          вернути успіх_компіляції_до;
        }

        В1::покласти_вказівку_СтворитиДіапазон(М, код.будівельник_вказівок::адреса, рядок, логічне(дані.включно));

        вернути так;
      }

      якщо елемент.вид == розбирач::ВидСполукиЧекати {
        вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
          повідомлення = копія_т8(М, "Інструкція чекати наразі не підтримується"),
          позиція_слова = 0
        };
        вернути ні;
      }

      вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
        повідомлення = копія_т8(М, "Виявлено невідомий вид сполуки"),
        позиція_слова = 0
      };
      вернути ні;

    вихід:
      вернути результат;
    }

    місцева дія створити_код(М: адреса<Машина>, шлях: адреса<ПредметШляху>): адреса<Код> {
      змінна код = виділити<Код>(М);
      код.шлях = шлях;
      код.накопичувач_констант = зробити_накопичувач<адреса<Предмет>>(М);
      код.будівельник_вказівок = БудівельникВказівок {
        місцезнаходження = зробити_накопичувач<МісцезнаходженняВказівок>(М),
        вказівки = зробити_накопичувач<п8>(М)
      };
      вернути код;
    }

    місцева дія знищити_код(М: адреса<Машина>, код: адреса<Код>) {
      звільнити_памʼять(М, код.накопичувач_констант.дані);
      звільнити_памʼять(М, код.будівельник_вказівок.вказівки.дані);
      звільнити(М, код);
    }

    місцева дія створити_контекст(М: адреса<Машина>): адреса<КонтекстПерекладу> {
      змінна контекст = виділити<КонтекстПерекладу>(М);
      вернути контекст;
    }

    місцева дія знищити_контекст(М: адреса<Машина>, контекст: адреса<КонтекстПерекладу>) {
      звільнити(М, контекст);
    }

    місцева дія створити_предмет_коду_з_коду_перекладача(М: адреса<Машина>, код_перекладача: адреса<Код>) -> адреса<ПредметКоду> {
      вернути створити_предмет_коду(
        М,
        код_перекладача.шлях,
        Послідовність<адреса<Предмет>> { код_перекладача.накопичувач_констант.розмір, код_перекладача.накопичувач_констант.дані },
        Послідовність<МісцезнаходженняВказівок> { код_перекладача.будівельник_вказівок.місцезнаходження.розмір, код_перекладача.будівельник_вказівок.місцезнаходження.дані },
        створити_предмет_байтів_без_копіювання(М, код_перекладача.будівельник_вказівок.вказівки.розмір, код_перекладача.будівельник_вказівок.вказівки.дані)
      );
    }

    місцева дія перекласти(М: адреса<Машина>, значення_коду_т8: т8, слова: розбирач::Слова, сполуки: розбирач::Сполуки, вернути_в_кінці: логічне, контекст: адреса<КонтекстПерекладу>, код: адреса<Код>, вихід_помилки: адреса<ПомилкаПерекладуВМаМа>): логічне {
      // потім: обробляти вернути_в_кінці в кожному елементі
      змінна пе: натуральне = 0;
      
      поки пе < сполуки.розмір {
        змінна елемент = сполуки.дані[пе];
        
        змінна рядок = н32(розбирач::отримати_рядок_з_місцезнаходження(значення_коду_т8, слова, елемент.місцезнаходження));
        
        якщо елемент.вид == розбирач::ВидСполукиНіщо {
          вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
            повідомлення = копія_т8(М, "Виявлено сполуку Ніщо"),
            позиція_слова = 0
          };
          вернути ні;
        }
        
        якщо елемент.вид == розбирач::ВидСполукиВизначити {
          змінна дані = елемент.дані як розбирач::ДаніСполукиВизначити;
         
          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.значення, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }
         
          змінна позиція_назви = позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, дані.ідентифікатор));
          В1::покласти_вказівку_Визначити(М, код.будівельник_вказівок::адреса, рядок, позиція_назви);
        } інакше якщо елемент.вид == розбирач::ВидСполукиВизначитиЗзовні {
          змінна дані = елемент.дані як розбирач::ДаніСполукиВизначитиЗзовні;

          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.значення, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          змінна позиція_назви = позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, дані.ідентифікатор));
          В1::покласти_вказівку_ВизначитиЗзовні(М, код.будівельник_вказівок::адреса, рядок, позиція_назви);
        } інакше якщо елемент.вид == розбирач::ВидСполукиЗвернутись {
          змінна дані = елемент.дані як розбирач::ДаніСполукиЗвернутись;

          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          якщо вернути_в_кінці {
            якщо пе == сполуки.розмір - 1 {
              В1::покласти_вказівку_Вернути(М, код.будівельник_вказівок::адреса, рядок);
            } інакше {
              В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
            }
          } інакше {
            В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиОтримати {
          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          якщо вернути_в_кінці {
            якщо пе == сполуки.розмір - 1 {
              В1::покласти_вказівку_Вернути(М, код.будівельник_вказівок::адреса, рядок);
            } інакше {
              В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
            }
          } інакше {
            В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиОтриматиЕлемент {
          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          якщо вернути_в_кінці {
            якщо пе == сполуки.розмір - 1 {
              В1::покласти_вказівку_Вернути(М, код.будівельник_вказівок::адреса, рядок);
            } інакше {
              В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
            }
          } інакше {
            В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиЗмінити {
          змінна дані = елемент.дані як розбирач::ДаніСполукиЗмінити;

          змінна успіх_компіляції_предмета = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.предмет, вихід_помилки);
          якщо успіх_компіляції_предмета == ні {
            вернути успіх_компіляції_предмета;
          }

          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.значення, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          змінна позиція_назви = позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, дані.ідентифікатор));
          В1::покласти_вказівку_ЗмінитиВластивість(М, код.будівельник_вказівок::адреса, рядок, позиція_назви);
        } інакше якщо елемент.вид == розбирач::ВидСполукиЗмінитиЕлемент {
          змінна дані = елемент.дані як розбирач::ДаніСполукиЗмінитиЕлемент;

          змінна успіх_компіляції_предмета = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.предмет, вихід_помилки);
          якщо успіх_компіляції_предмета == ні {
            вернути успіх_компіляції_предмета;
          }

          змінна успіх_компіляції_позиції = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.ключ, вихід_помилки);
          якщо успіх_компіляції_позиції == ні {
            вернути успіх_компіляції_позиції;
          }

          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.значення, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          В1::покласти_вказівку_ЗмінитиЕлемент(М, код.будівельник_вказівок::адреса, рядок);
        } інакше якщо елемент.вид == розбирач::ВидСполукиВиконати {
          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          якщо вернути_в_кінці {
            якщо пе == сполуки.розмір - 1 {
              В1::покласти_вказівку_Вернути(М, код.будівельник_вказівок::адреса, рядок);
            } інакше {
              В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
            }
          } інакше {
            В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиДія {
          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          змінна дані = елемент.дані як розбирач::ДаніСполукиДія;

          якщо не дані.ідентифікатор.заповнено {
            В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
          } інакше {
            якщо дані.структура_ == пусто {
              змінна позиція_назви = позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, дані.ідентифікатор.значення));
              В1::покласти_вказівку_Визначити(М, код.будівельник_вказівок::адреса, рядок, позиція_назви);
            } інакше {
              змінна успіх_компіляції_структури = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.структура_, вихід_помилки);
              якщо успіх_компіляції_структури == ні {
                вернути успіх_компіляції_структури;
              }

              змінна позиція_назви = позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, дані.ідентифікатор.значення));
              В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок, позиція_назви);
              В1::покласти_вказівку_ЗаписатиМетод(М, код.будівельник_вказівок::адреса, рядок, логічне(дані.власна));
              В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
            }
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиСтруктура {
          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          змінна дані = елемент.дані як розбирач::ДаніСполукиСтруктура;

          якщо не дані.ідентифікатор.заповнено {
            В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
          } інакше {
            змінна позиція_назви = позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, дані.ідентифікатор.значення));
            В1::покласти_вказівку_Визначити(М, код.будівельник_вказівок::адреса, рядок, позиція_назви);
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиЧисло {
          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          якщо вернути_в_кінці {
            якщо пе == сполуки.розмір - 1 {
              В1::покласти_вказівку_Вернути(М, код.будівельник_вказівок::адреса, рядок);
            } інакше {
              В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
            }
          } інакше {
            В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиТекст {
          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          якщо вернути_в_кінці {
            якщо пе == сполуки.розмір - 1 {
              В1::покласти_вказівку_Вернути(М, код.будівельник_вказівок::адреса, рядок);
            } інакше {
              В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
            }
          } інакше {
            В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиЗбитийТекст {
          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          якщо вернути_в_кінці {
            якщо пе == сполуки.розмір - 1 {
              В1::покласти_вказівку_Вернути(М, код.будівельник_вказівок::адреса, рядок);
            } інакше {
              В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
            }
          } інакше {
            В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиСимвол {
          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          якщо вернути_в_кінці {
            якщо пе == сполуки.розмір - 1 {
              В1::покласти_вказівку_Вернути(М, код.будівельник_вказівок::адреса, рядок);
            } інакше {
              В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
            }
          } інакше {
            В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиОперація {
          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          якщо вернути_в_кінці {
            якщо пе == сполуки.розмір - 1 {
              В1::покласти_вказівку_Вернути(М, код.будівельник_вказівок::адреса, рядок);
            } інакше {
              В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
            }
          } інакше {
            В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиЯкщо {
          змінна дані = елемент.дані як розбирач::ДаніСполукиЯкщо;

          змінна успіх_компіляції_умови = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.умова, вихід_помилки);
          якщо успіх_компіляції_умови == ні {
            вернути успіх_компіляції_умови;
          }

          змінна позиція_вказівки_якщо_ні = н32(код.будівельник_вказівок.вказівки.розмір);
          В1::покласти_вказівку_СтрибнутиЯкщоНі(М, код.будівельник_вказівок::адреса, рядок, 0);

          змінна контекст_якщо = створити_контекст(М);

          якщо дані.тіло.розмір != 0 {
            змінна успіх_компіляції_тіла = перекласти(М, значення_коду_т8, слова, дані.тіло, ні, контекст_якщо, код, вихід_помилки);
            якщо успіх_компіляції_тіла == ні {
              знищити_контекст(М, контекст_якщо);
              вернути успіх_компіляції_тіла;
            }
          }

          змінна позиція_вказівки_якщо_так = н32(код.будівельник_вказівок.вказівки.розмір);
          В1::покласти_вказівку_Стрибнути(М, код.будівельник_вказівок::адреса, рядок, 0);
          В1::перезаписати_аргумент_вказівки(М, код.будівельник_вказівок::адреса, позиція_вказівки_якщо_ні + 1, н32(код.будівельник_вказівок.вказівки.розмір));

          якщо дані.тіло_інакше.розмір != 0 {
            змінна успіх_компіляції_тіла_інакше = перекласти(М, значення_коду_т8, слова, дані.тіло_інакше, ні, контекст_якщо, код, вихід_помилки);
            якщо успіх_компіляції_тіла_інакше == ні {
              знищити_контекст(М, контекст_якщо);
              вернути успіх_компіляції_тіла_інакше;
            }
          }

          знищити_контекст(М, контекст_якщо);

          В1::перезаписати_аргумент_вказівки(М, код.будівельник_вказівок::адреса, позиція_вказівки_якщо_так + 1, н32(код.будівельник_вказівок.вказівки.розмір));
        } інакше якщо елемент.вид == розбирач::ВидСполукиПоки {
          змінна дані = елемент.дані як розбирач::ДаніСполукиПоки;

          змінна позиція_вказівки_початку_поки = н32(код.будівельник_вказівок.вказівки.розмір);
          змінна позиція_вказівки_якщо_ні: н32 = 0;

          якщо дані.умова != пусто {
            змінна успіх_компіляції_умови = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.умова, вихід_помилки);
            якщо успіх_компіляції_умови == ні {
              вернути успіх_компіляції_умови;
            }

            позиція_вказівки_якщо_ні = н32(код.будівельник_вказівок.вказівки.розмір);
            В1::покласти_вказівку_СтрибнутиЯкщоНі(М, код.будівельник_вказівок::адреса, рядок, 0);
          }

          змінна контекст_поки = створити_контекст(М);

          змінна успіх_компіляції_тіла = перекласти(М, значення_коду_т8, слова, дані.тіло, ні, контекст_поки, код, вихід_помилки);
          якщо успіх_компіляції_тіла == ні {
            знищити_контекст(М, контекст_поки);
            вернути успіх_компіляції_тіла;
          }

          знищити_контекст(М, контекст_поки);

          В1::покласти_вказівку_Стрибнути(М, код.будівельник_вказівок::адреса, рядок, позиція_вказівки_початку_поки);

          якщо дані.умова != пусто {
            В1::перезаписати_аргумент_вказівки(М, код.будівельник_вказівок::адреса, позиція_вказівки_якщо_ні + 1, н32(код.будівельник_вказівок.вказівки.розмір));
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиВернути {
          змінна дані = елемент.дані як розбирач::ДаніСполукиВернути;

          якщо дані.значення == пусто {
            В1::покласти_вказівку_ПокластиПусто(М, код.будівельник_вказівок::адреса, рядок);
          } інакше {
            змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.значення, вихід_помилки);
            якщо не успіх_перекладу_елемента {
              вернути успіх_перекладу_елемента;
            }
          }

          В1::покласти_вказівку_Вернути(М, код.будівельник_вказівок::адреса, рядок);
        } інакше якщо елемент.вид == розбирач::ВидСполукиЗначенняЯкщо {
          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          якщо вернути_в_кінці {
            якщо пе == сполуки.розмір - 1 {
              В1::покласти_вказівку_Вернути(М, код.будівельник_вказівок::адреса, рядок);
            } інакше {
              В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
            }
          } інакше {
            В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиСамоОперація {
          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          якщо вернути_в_кінці {
            якщо пе == сполуки.розмір - 1 {
              В1::покласти_вказівку_Вернути(М, код.будівельник_вказівок::адреса, рядок);
            } інакше {
              В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
            }
          } інакше {
            В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиМодуль {
          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          змінна дані = елемент.дані як розбирач::ДаніСполукиМодуль;

          якщо не дані.ідентифікатор.заповнено {
            В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
          } інакше {
            змінна позиція_назви = позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, дані.ідентифікатор.значення));
            В1::покласти_вказівку_Визначити(М, код.будівельник_вказівок::адреса, рядок, позиція_назви);
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиСписок {
          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          якщо вернути_в_кінці {
            якщо пе == сполуки.розмір - 1 {
              В1::покласти_вказівку_Вернути(М, код.будівельник_вказівок::адреса, рядок);
            } інакше {
              В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
            }
          } інакше {
            В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиСловник {
          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          якщо вернути_в_кінці {
            якщо пе == сполуки.розмір - 1 {
              В1::покласти_вказівку_Вернути(М, код.будівельник_вказівок::адреса, рядок);
            } інакше {
              В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
            }
          } інакше {
            В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиВзяти {
          змінна дані = елемент.дані як розбирач::ДаніСполукиВзяти;

          якщо дані.тип.заповнено {
            якщо слова.дані[дані.тип.значення.позиція_слова].вид == розбирач::ВидСловаМодуль {
              змінна позиція_назви_типу = позиція_назви_з_т8(М, код, "модуль");
              В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок, позиція_назви_типу);
            } інакше {
              змінна позиція_назви_типу = позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, дані.тип.значення));
              В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок, позиція_назви_типу);
            }
          } інакше {
            В1::покласти_вказівку_ПокластиПусто(М, код.будівельник_вказівок::адреса, рядок);
          }

          змінна позиція_останьої_назви: н32 = 0;

          змінна п: н32 = 0;
          поки п < н32(дані.довжина_шляху) {
            змінна елемент_шляху = дані.шлях[п];
            змінна позиція_назви = позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, елемент_шляху));
            В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок, позиція_назви);
            якщо п == н32(дані.довжина_шляху) - 1 {
              позиція_останьої_назви = позиція_назви;
            }
            п += 1;
          }

          В1::покласти_вказівку_Взяти(М, код.будівельник_вказівок::адреса, рядок, н32(дані.довжина_шляху));

          якщо не дані.ідентифікатор_як.заповнено {
            якщо дані.кількість_елементів == 0 {
              В1::покласти_вказівку_Визначити(М, код.будівельник_вказівок::адреса, рядок, позиція_останьої_назви);
            } інакше {
              змінна пе: н32 = 0;
              поки пе < н32(дані.кількість_елементів) {
                змінна елемент = дані.елементи[пе];

                В1::покласти_вказівку_Дублювати(М, код.будівельник_вказівок::адреса, рядок);
                В1::покласти_вказівку_ОтриматиВластивість(М, код.будівельник_вказівок::адреса, рядок, позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, елемент.ідентифікатор)));

                якщо не елемент.ідентифікатор_як.заповнено {
                  В1::покласти_вказівку_Визначити(М, код.будівельник_вказівок::адреса, рядок,позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, елемент.ідентифікатор)));
                } інакше {
                  В1::покласти_вказівку_Визначити(М, код.будівельник_вказівок::адреса, рядок, позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, елемент.ідентифікатор_як.значення)));
                }

                пе += 1;
              }
            }
          } інакше {
            В1::покласти_вказівку_Визначити(М, код.будівельник_вказівок::адреса, рядок, позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, дані.ідентифікатор_як.значення)));
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиСпробувати {
          змінна дані = елемент.дані як розбирач::ДаніСполукиСпробувати;

          якщо не дані.ідентифікатор_зловити.заповнено {
            В1::покласти_вказівку_ПокластиПусто(М, код.будівельник_вказівок::адреса, рядок);
          } інакше {
            змінна позиція_назви = позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, дані.ідентифікатор_зловити.значення));
            В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок, позиція_назви);
          }

          змінна позиція_вказівки_почати_спробу = н32(код.будівельник_вказівок.вказівки.розмір);
          В1::покласти_вказівку_ПочатиСпробу(М, код.будівельник_вказівок::адреса, рядок, 0);

          змінна успіх_компіляції_тіла = перекласти(М, значення_коду_т8, слова, дані.тіло, ні, контекст, код, вихід_помилки);
          якщо успіх_компіляції_тіла == ні {
            вернути успіх_компіляції_тіла;
          }

          змінна позиція_вказівки_закінчити_спробу = н32(код.будівельник_вказівок.вказівки.розмір);
          В1::покласти_вказівку_ЗакінчитиСпробу(М, код.будівельник_вказівок::адреса, рядок, 0);
          В1::перезаписати_аргумент_вказівки(М, код.будівельник_вказівок::адреса, позиція_вказівки_почати_спробу + 1, н32(код.будівельник_вказівок.вказівки.розмір));

          змінна успіх_компіляції_тіла_зловити = перекласти(М, значення_коду_т8, слова, дані.тіло_зловити, ні, контекст, код, вихід_помилки);
          якщо успіх_компіляції_тіла_зловити == ні {
            вернути успіх_компіляції_тіла_зловити;
          }

          В1::перезаписати_аргумент_вказівки(М, код.будівельник_вказівок::адреса, позиція_вказівки_закінчити_спробу + 1, н32(код.будівельник_вказівок.вказівки.розмір));
        } інакше якщо елемент.вид == розбирач::ВидСполукиВпасти {
          змінна дані = елемент.дані як розбирач::ДаніСполукиВпасти;

          якщо дані.значення == пусто {
            В1::покласти_вказівку_ПокластиПусто(М, код.будівельник_вказівок::адреса, рядок);
          } інакше {
            змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.значення, вихід_помилки);
            якщо не успіх_перекладу_елемента {
              вернути успіх_перекладу_елемента;
            }
          }
          В1::покласти_вказівку_Впасти(М, код.будівельник_вказівок::адреса, рядок);
        } інакше якщо елемент.вид == розбирач::ВидСполукиДати {
          змінна дані = елемент.дані як розбирач::ДаніСполукиДати;

          змінна п: н32 = 0;
          поки п < н32(дані.кількість_елементів) {
            змінна елемент = дані.елементи[п];

            змінна позиція_назви = позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, елемент.ідентифікатор));
            В1::покласти_вказівку_Звернутись(М, код.будівельник_вказівок::адреса, рядок, позиція_назви); // предмет

            якщо елемент.ідентифікатор_як.заповнено {
              змінна позиція_назви_як = позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, елемент.ідентифікатор_як.значення));
              В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок, позиція_назви_як); // назва
            } інакше {
              В1::покласти_вказівку_ПокластиКонстанту(М, код.будівельник_вказівок::адреса, рядок, позиція_назви); // назва
            }

            В1::покласти_вказівку_Дати(М, код.будівельник_вказівок::адреса, рядок);

            п += 1;
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиПеребрати {
          змінна дані = елемент.дані як розбирач::ДаніСполукиПеребрати;

          змінна успіх_компіляції_предмета = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.предмет, вихід_помилки);
          якщо успіх_компіляції_предмета == ні {
            вернути успіх_компіляції_предмета;
          }

          В1::покласти_вказівку_ОтриматиПеребір(М, код.будівельник_вказівок::адреса, рядок);
          змінна позиція_вказівки_початку_перебору = н32(код.будівельник_вказівок.вказівки.розмір);

          В1::покласти_вказівку_ПеребратиДалі(М, код.будівельник_вказівок::адреса, рядок);
          змінна позиція_вказівки_якщо_ні = н32(код.будівельник_вказівок.вказівки.розмір);

          В1::покласти_вказівку_СтрибнутиЯкщоНі(М, код.будівельник_вказівок::адреса, рядок, 0);
          В1::покласти_вказівку_Дублювати(М, код.будівельник_вказівок::адреса, рядок);
          В1::покласти_вказівку_ОтриматиВластивість(М, код.будівельник_вказівок::адреса, рядок, позиція_назви_з_т8(М, код, "значення"));
          В1::покласти_вказівку_Визначити(М, код.будівельник_вказівок::адреса, рядок, позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, дані.ідентифікатор.значення)));

          змінна успіх_компіляції_тіла = перекласти(М, значення_коду_т8, слова, дані.тіло, ні, контекст, код, вихід_помилки);
          якщо успіх_компіляції_тіла == ні {
            вернути успіх_компіляції_тіла;
          }

          В1::покласти_вказівку_Стрибнути(М, код.будівельник_вказівок::адреса, рядок, позиція_вказівки_початку_перебору);
          В1::перезаписати_аргумент_вказівки(М, код.будівельник_вказівок::адреса, позиція_вказівки_якщо_ні + 1, н32(код.будівельник_вказівок.вказівки.розмір));
          В1::покласти_вказівку_ПокластиПусто(М, код.будівельник_вказівок::адреса, рядок);
          В1::покласти_вказівку_Визначити(М, код.будівельник_вказівок::адреса, рядок, позиція_назви_з_т8(М, код, розбирач::отримати_значення_ідентифікатора(значення_коду_т8, слова, дані.ідентифікатор.значення)));
          В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
        } інакше якщо елемент.вид == розбирач::ВидСполукиЦикл {
          змінна дані = елемент.дані як розбирач::ДаніСполукиЦикл;

          змінна успіх_компіляції_старту = перекласти(М, значення_коду_т8, слова, дані.старт, ні, контекст, код, вихід_помилки);
          якщо успіх_компіляції_старту == ні {
            вернути успіх_компіляції_старту;
          }

          змінна позиція_вказівки_початку_циклу = н32(код.будівельник_вказівок.вказівки.розмір);
          змінна позиція_вказівки_якщо_ні: н32 = 0;

          якщо дані.умова != пусто {
            змінна успіх_компіляції_умови = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, дані.умова, вихід_помилки);
            якщо успіх_компіляції_умови == ні {
              вернути успіх_компіляції_умови;
            }

            позиція_вказівки_якщо_ні = н32(код.будівельник_вказівок.вказівки.розмір);
            В1::покласти_вказівку_СтрибнутиЯкщоНі(М, код.будівельник_вказівок::адреса, рядок, 0);
          }

          змінна контекст_циклу = створити_контекст(М);

          змінна успіх_компіляції_тіла = перекласти(М, значення_коду_т8, слова, дані.тіло, ні, контекст_циклу, код, вихід_помилки);
          якщо успіх_компіляції_тіла == ні {
            знищити_контекст(М, контекст_циклу);
            вернути успіх_компіляції_тіла;
          }

          змінна успіх_компіляції_ітерації = перекласти(М, значення_коду_т8, слова, дані.ітерація, ні, контекст_циклу, код, вихід_помилки);
          якщо успіх_компіляції_ітерації == ні {
            знищити_контекст(М, контекст_циклу);
            вернути успіх_компіляції_ітерації;
          }

          знищити_контекст(М, контекст_циклу);

          В1::покласти_вказівку_Стрибнути(М, код.будівельник_вказівок::адреса, рядок, позиція_вказівки_початку_циклу);

          якщо дані.умова != пусто {
            В1::перезаписати_аргумент_вказівки(М, код.будівельник_вказівок::адреса, позиція_вказівки_якщо_ні + 1, н32(код.будівельник_вказівок.вказівки.розмір));
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиВічнийЦикл {
          змінна дані = елемент.дані як розбирач::ДаніСполукиВічнийЦикл;

          змінна позиція_вказівки_початку_циклу = н32(код.будівельник_вказівок.вказівки.розмір);

          змінна контекст_циклу = створити_контекст(М);

          змінна успіх_компіляції_тіла = перекласти(М, значення_коду_т8, слова, дані.тіло, ні, контекст_циклу, код, вихід_помилки);
          якщо успіх_компіляції_тіла == ні {
            знищити_контекст(М, контекст_циклу);
            вернути успіх_компіляції_тіла;
          }

          знищити_контекст(М, контекст_циклу);

          В1::покласти_вказівку_Стрибнути(М, код.будівельник_вказівок::адреса, рядок, позиція_вказівки_початку_циклу);
        } інакше якщо елемент.вид == розбирач::ВидСполукиВидалити {
          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          якщо вернути_в_кінці {
            якщо пе == сполуки.розмір - 1 {
              В1::покласти_вказівку_Вернути(М, код.будівельник_вказівок::адреса, рядок);
            } інакше {
              В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
            }
          } інакше {
            В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиВидалитиВластивість {
          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          якщо вернути_в_кінці {
            якщо пе == сполуки.розмір - 1 {
              В1::покласти_вказівку_Вернути(М, код.будівельник_вказівок::адреса, рядок);
            } інакше {
              В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
            }
          } інакше {
            В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиВидалитиЕлемент {
          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          якщо вернути_в_кінці {
            якщо пе == сполуки.розмір - 1 {
              В1::покласти_вказівку_Вернути(М, код.будівельник_вказівок::адреса, рядок);
            } інакше {
              В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
            }
          } інакше {
            В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиДіапазон {
          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          якщо вернути_в_кінці {
            якщо пе == сполуки.розмір - 1 {
              В1::покласти_вказівку_Вернути(М, код.будівельник_вказівок::адреса, рядок);
            } інакше {
              В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
            }
          } інакше {
            В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидСполукиЧекати {
          змінна успіх_перекладу_елемента = перекласти_сполуку(М, значення_коду_т8, слова, контекст, код, елемент, вихід_помилки);
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }

          якщо вернути_в_кінці {
            якщо пе == сполуки.розмір - 1 {
              В1::покласти_вказівку_Вернути(М, код.будівельник_вказівок::адреса, рядок);
            } інакше {
              В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
            }
          } інакше {
            В1::покласти_вказівку_Забрати(М, код.будівельник_вказівок::адреса, рядок);
          }
        } інакше {
          вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
            повідомлення = копія_т8(М, "Виявлено невідомий вид сполуки"),
            позиція_слова = 0
          };
          вернути ні;
        }
        
        пе += 1;
      }

      вернути так;
    }
  }
}