взяти визначення ./перекладач;
взяти визначення КД;

секція мавка {
  секція перекладач {
    дія перевірити_чи_ю8_рівні(а: ю8, б: ю8): логічне {
      вернути КД::перевірити_чи_ю8_рівні(а, б);
    }

    дія виділити_копію_т8(система: адреса<Система>, значення: т8): т8 {
      ціль копія = т8 {
        значення.розмір,
        виділити_памʼять<п8>(система, значення.розмір)
      };
      змінна ціль п: позитивне = 0;
      поки п < значення.розмір {
        копія.дані[п] = значення.дані[п];
        п += 1;
      }
      вернути копія;
    }

    дія система_КД_виділити_сиру_памʼять(системаКД: адреса<КД::Система>, розмір: позитивне): памʼять<п8> {
      ціль система = системаКД.дані як адреса<Система>;
      вернути виділити_памʼять<п8>(система, розмір);
    }

    дія система_КД_перевиділити_сиру_памʼять(системаКД: адреса<КД::Система>, значення: памʼять<п8>, новий_розмір: позитивне): памʼять<п8> {
      ціль система = системаКД.дані як адреса<Система>;
      вернути перевиділити_памʼять<п8>(система, значення, новий_розмір);
    }

    дія система_КД_звільнити_сиру_памʼять(системаКД: адреса<КД::Система>, значення: невідома_памʼять) {
      ціль система = системаКД.дані як адреса<Система>;
      звільнити_памʼять(система, значення);
    }

    дія перекодувати_ю8_в_т8(система: адреса<Система>, вхід: ю8, вихід: адреса<т8>, з_нульовим_байтом_в_кінці: логічне): логічне {
      ціль системаКД = КД::Система {
        дані = система,
        виділити_сиру_памʼять = система_КД_виділити_сиру_памʼять,
        перевиділити_сиру_памʼять = система_КД_перевиділити_сиру_памʼять,
        звільнити_сиру_памʼять = система_КД_звільнити_сиру_памʼять,
      };
      вернути КД::перекодувати_ю8_в_т8(системаКД::адреса, вхід, вихід, з_нульовим_байтом_в_кінці);
    }

    дія перекодувати_ю8_в_ю32(система: адреса<Система>, вхід: ю8, вихід: адреса<ю32>, з_нульовим_байтом_в_кінці: логічне): логічне {
      ціль системаКД = КД::Система {
        дані = система,
        виділити_сиру_памʼять = система_КД_виділити_сиру_памʼять,
        перевиділити_сиру_памʼять = система_КД_перевиділити_сиру_памʼять,
        звільнити_сиру_памʼять = система_КД_звільнити_сиру_памʼять,
      };
      вернути КД::перекодувати_ю8_в_ю32(системаКД::адреса, вхід, вихід, з_нульовим_байтом_в_кінці);
    }

    дія перекодувати_ю32_в_ю8(система: адреса<Система>, вхід: ю32, вихід: адреса<ю8>, з_нульовим_байтом_в_кінці: логічне): логічне {
      ціль системаКД = КД::Система {
        дані = система,
        виділити_сиру_памʼять = система_КД_виділити_сиру_памʼять,
        перевиділити_сиру_памʼять = система_КД_перевиділити_сиру_памʼять,
        звільнити_сиру_памʼять = система_КД_звільнити_сиру_памʼять,
      };
      вернути КД::перекодувати_ю32_в_ю8(системаКД::адреса, вхід, вихід, з_нульовим_байтом_в_кінці);
    }

    дія перекодувати_т8_в_ю8(система: адреса<Система>, вхід: т8, вихід: адреса<ю8>, з_нульовим_байтом_в_кінці: логічне): логічне {
      ціль системаКД = КД::Система {
        дані = система,
        виділити_сиру_памʼять = система_КД_виділити_сиру_памʼять,
        перевиділити_сиру_памʼять = система_КД_перевиділити_сиру_памʼять,
        звільнити_сиру_памʼять = система_КД_звільнити_сиру_памʼять,
      };
      вернути КД::перекодувати_т8_в_ю8(системаКД::адреса, вхід, вихід, з_нульовим_байтом_в_кінці);
    }
  }
}

дія перевірити_чи_ю8_починається_на(значення: ю8, починається_на: ю8, п: адреса<позитивне>): логічне {
  змінна ціль пп: позитивне = 0;
  поки пп < починається_на.розмір {
    ціль ппп = п::вміст + пп;
    якщо ппп >= значення.розмір {
      вернути ні;
    }
    якщо значення.дані[ппп] != починається_на.дані[пп] {
      вернути ні;
    }
    пп += 1;
  }
  п::вміст = п::вміст + пп - 1;
  вернути так;
}

дія розібрати_число_з_ю8(значення: ю8, вихід: адреса<д64>): логічне {
  змінна ціль відʼємне = ні;
  змінна ціль п: позитивне = 0;
  якщо значення.дані[п] == 45 {
    відʼємне = так;
    п += 1;
  }
  якщо перевірити_чи_ю8_починається_на(значення, ю8"0д", п::адреса) {
    п += 1;
    змінна ціль значення_0д: ц64 = 0;
    поки п < значення.розмір {
      значення_0д *= 2;
      якщо значення.дані[п] == 48 {
      } інакше якщо значення.дані[п] == 49 {
        значення_0д += 1;
      } інакше {
        вернути ні;
      }
      п += 1;
    }
    якщо відʼємне {
      вихід::вміст = д64(ц64(0) - значення_0д);
      вернути так;
    }
    вихід::вміст = д64(значення_0д);
    вернути так;
  }
  якщо перевірити_чи_ю8_починається_на(значення, ю8"0ш", п::адреса) {
    п += 1;
    змінна ціль значення_0ш: ц64 = 0;
    поки п < значення.розмір {
      змінна ціль с: п8 = 0;
      якщо перевірити_чи_ю8_починається_на(значення, ю8"0", п::адреса) {
        с = 0;
      } інакше якщо перевірити_чи_ю8_починається_на(значення, ю8"1", п::адреса) {
        с = 1;
      } інакше якщо перевірити_чи_ю8_починається_на(значення, ю8"2", п::адреса) {
        с = 2;
      } інакше якщо перевірити_чи_ю8_починається_на(значення, ю8"3", п::адреса) {
        с = 3;
      } інакше якщо перевірити_чи_ю8_починається_на(значення, ю8"4", п::адреса) {
        с = 4;
      } інакше якщо перевірити_чи_ю8_починається_на(значення, ю8"5", п::адреса) {
        с = 5;
      } інакше якщо перевірити_чи_ю8_починається_на(значення, ю8"6", п::адреса) {
        с = 6;
      } інакше якщо перевірити_чи_ю8_починається_на(значення, ю8"7", п::адреса) {
        с = 7;
      } інакше якщо перевірити_чи_ю8_починається_на(значення, ю8"8", п::адреса) {
        с = 8;
      } інакше якщо перевірити_чи_ю8_починається_на(значення, ю8"9", п::адреса) {
        с = 9;
      } інакше якщо перевірити_чи_ю8_починається_на(значення, ю8"А", п::адреса) {
        с = 10;
      } інакше якщо перевірити_чи_ю8_починається_на(значення, ю8"Б", п::адреса) {
        с = 11;
      } інакше якщо перевірити_чи_ю8_починається_на(значення, ю8"В", п::адреса) {
        с = 12;
      } інакше якщо перевірити_чи_ю8_починається_на(значення, ю8"Г", п::адреса) {
        с = 13;
      } інакше якщо перевірити_чи_ю8_починається_на(значення, ю8"Д", п::адреса) {
        с = 14;
      } інакше якщо перевірити_чи_ю8_починається_на(значення, ю8"Е", п::адреса) {
        с = 15;
      } інакше якщо перевірити_чи_ю8_починається_на(значення, ю8"а", п::адреса) {
        с = 10;
      } інакше якщо перевірити_чи_ю8_починається_на(значення, ю8"б", п::адреса) {
        с = 11;
      } інакше якщо перевірити_чи_ю8_починається_на(значення, ю8"в", п::адреса) {
        с = 12;
      } інакше якщо перевірити_чи_ю8_починається_на(значення, ю8"г", п::адреса) {
        с = 13;
      } інакше якщо перевірити_чи_ю8_починається_на(значення, ю8"д", п::адреса) {
        с = 14;
      } інакше якщо перевірити_чи_ю8_починається_на(значення, ю8"е", п::адреса) {
        с = 15;
      } інакше {
        вернути ні;
      }
      значення_0ш = (значення_0ш << 4) | (ц64(с) & 15);
      п += 1;
    }
    якщо відʼємне {
      вихід::вміст = д64(ц64(0) - значення_0ш);
      вернути так;
    }
    вихід::вміст = д64(значення_0ш);
    вернути так;
  }
  змінна ціль результат: д64 = 0;
  змінна ціль символ_: п8 = значення.дані[0];
  поки п < значення.розмір {
    символ_ = значення.дані[п];
    якщо символ_ == 48 { // 0
      результат = результат * 10;
    } інакше якщо символ_ == 49 { // 1
      результат = результат * 10 + 1;
    } інакше якщо символ_ == 50 { // 2
      результат = результат * 10 + 2;
    } інакше якщо символ_ == 51 { // 3
      результат = результат * 10 + 3;
    } інакше якщо символ_ == 52 { // 4
      результат = результат * 10 + 4;
    } інакше якщо символ_ == 53 { // 5
      результат = результат * 10 + 5;
    } інакше якщо символ_ == 54 { // 6
      результат = результат * 10 + 6;
    } інакше якщо символ_ == 55 { // 7
      результат = результат * 10 + 7;
    } інакше якщо символ_ == 56 { // 8
      результат = результат * 10 + 8;
    } інакше якщо символ_ == 57 { // 9
      результат = результат * 10 + 9;
    } інакше якщо символ_ == 95 { // _
      // ігноруємо
    } інакше якщо символ_ == 46 { // .
      п += 1;
      символ_ = значення.дані[п];
      змінна ціль дробна_частина: д64 = 0;
      змінна ціль дільник: д64 = 1;
      поки п < значення.розмір {
        символ_ = значення.дані[п];
        якщо символ_ == 48 { // 0
          дробна_частина = дробна_частина * 10;
        } інакше якщо символ_ == 49 { // 1
          дробна_частина = дробна_частина * 10 + 1;
        } інакше якщо символ_ == 50 { // 2
          дробна_частина = дробна_частина * 10 + 2;
        } інакше якщо символ_ == 51 { // 3
          дробна_частина = дробна_частина * 10 + 3;
        } інакше якщо символ_ == 52 { // 4
          дробна_частина = дробна_частина * 10 + 4;
        } інакше якщо символ_ == 53 { // 5
          дробна_частина = дробна_частина * 10 + 5;
        } інакше якщо символ_ == 54 { // 6
          дробна_частина = дробна_частина * 10 + 6;
        } інакше якщо символ_ == 55 { // 7
          дробна_частина = дробна_частина * 10 + 7;
        } інакше якщо символ_ == 56 { // 8
          дробна_частина = дробна_частина * 10 + 8;
        } інакше якщо символ_ == 57 { // 9
          дробна_частина = дробна_частина * 10 + 9;
        } інакше якщо символ_ == 95 { // _
          // ігноруємо
        } інакше {
          вернути ні;
        }
        п += 1;
        дільник = дільник * 10;
      }
      результат = результат + дробна_частина / дільник;
      вихід::вміст = результат;
      вернути так;
    } інакше {
      вернути ні;
    }
    п += 1;
  }
  вихід::вміст = результат;
  вернути так;
}

секція мавка {
  секція перекладач {
    синонім ВПокластиПусто = 1;
    синонім ВПокластиТак = 2;
    синонім ВПокластиНі = 3;
    синонім ВПокластиКонстанту = 4;
    синонім ВСтворитиДію = 5;
    синонім ВСтворитиСтруктуру = 6;
    синонім ВСтворитиМодуль = 7;
    синонім ВСтворитиСписок = 8;
    синонім ВПокластиВСписок = 9;
    синонім ВСтворитиСловник = 10;
    синонім ВПокластиВСловник = 11;
    синонім ВПокластиСтруктуруПредмет = 12;
    синонім ВПокластиЯ = 13;
    синонім ВЗаписатиМетод = 14;
    синонім ВЗаписатиСпецДію = 15;
    синонім ВСтворитиДіапазон = 16;
    синонім ВВизначити = 20;
    синонім ВЗвернутись = 21;
    синонім ВВиконати = 23;
    синонім ВОтриматиВластивість = 24;
    синонім ВЗмінитиВластивість = 25;
    синонім ВВиконатиВластивість = 26;
    синонім ВОтриматиЕлемент = 28;
    синонім ВЗмінитиЕлемент = 29;
    синонім ВОтриматиПеребір = 30;
    синонім ВВизначитиЗзовні = 31;
    синонім ВВиконатиЗПредка = 33;
    синонім ВВидалити = 34;
    синонім ВВидалитиВластивість = 35;
    синонім ВВидалитиЕлемент = 36;
    синонім ВДодати = 50;
    синонім ВВідняти = 51;
    синонім ВПомножити = 52;
    синонім ВПоділити = 53;
    синонім ВОтриматиОстачуДілення = 54;
    синонім ВОтриматиНеповнуЧасткуДілення = 55;
    синонім ВПіднестиДоСтепеня = 56;
    синонім ВЗсунутиВліво = 57;
    синонім ВЗсунутиВправо = 58;
    синонім ВЗсунутиВправоЗіЗаповненням = 59;
    синонім ВДвійковеІ = 60;
    синонім ВДвійковеАБО = 61;
    синонім ВДвійковеВиключнеАБО = 62;
    синонім ВДвійковеНЕ = 63;
    синонім ВМенше = 70;
    синонім ВБільше = 71;
    синонім ВНеБільше = 72;
    синонім ВНеМенше = 73;
    синонім ВРівно = 74;
    синонім ВНеРівно = 75;
    синонім ВМістить = 76;
    синонім ВНеМістить = 77;
    синонім ВЄ = 78;
    синонім ВНеЄ = 79;
    синонім ВВідʼємне = 80;
    синонім ВЧислове = 81;
    синонім ВЗаперечити = 82;
    синонім ВЗбільшити = 83;
    синонім ВЗбільшитиПопереднє = 84;
    синонім ВЗменшити = 85;
    синонім ВПочатиСпробу = 100;
    синонім ВВпасти = 101;
    синонім ВЗакінчитиСпробу = 102;
    синонім ВВзяти = 103;
    синонім ВДати = 104;
    синонім ВПеребратиДалі = 106;
    синонім ВЗбитиТекст = 107;
    синонім ВЗбитиЮнікод = 108;
    синонім ВСтворитиПараметр = 133;
    синонім ВСтворитиТип = 134;
    синонім ВСтрибнути = 200;
    синонім ВСтрибнутиЯкщоНі = 201;
    синонім ВЗабрати = 202;
    синонім ВВернути = 203;
    синонім ВСтрибнутиЯкщоНіЗалишивши = 204;
    синонім ВСтрибнутиЯкщоТак = 205;
    синонім ВСтрибнутиЯкщоТакЗалишивши = 206;
    синонім ВДублювати = 207;
    синонім ВДублюватиПопереднє = 208;

    дія додати_вказівку_до_коду(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, вказівка: п8): позитивне {
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, вказівка);
      ціль рядок_як_памʼять_п8 = рядок::адреса як памʼять<п8>;
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[0]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[1]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[2]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[3]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[4]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[5]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[6]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[7]);
      вернути код.накопичувач_вказівок.розмір - 1;
    }

    дія записати_позитивне_в_код_за_позицією(система: адреса<Система>, код: адреса<Код>, позиція: позитивне, значення: позитивне) {
      ціль значення_як_памʼять_п8 = значення::адреса як памʼять<п8>;
      код.накопичувач_вказівок.дані[позиція] = значення_як_памʼять_п8[0];
      код.накопичувач_вказівок.дані[позиція + 1] = значення_як_памʼять_п8[1];
      код.накопичувач_вказівок.дані[позиція + 2] = значення_як_памʼять_п8[2];
      код.накопичувач_вказівок.дані[позиція + 3] = значення_як_памʼять_п8[3];
      код.накопичувач_вказівок.дані[позиція + 4] = значення_як_памʼять_п8[4];
      код.накопичувач_вказівок.дані[позиція + 5] = значення_як_памʼять_п8[5];
      код.накопичувач_вказівок.дані[позиція + 6] = значення_як_памʼять_п8[6];
      код.накопичувач_вказівок.дані[позиція + 7] = значення_як_памʼять_п8[7];
    }

    дія додати_вказівку_до_коду_з_аргументом(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, вказівка: п8, аргумент: позитивне): позитивне {
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, вказівка);
      ціль рядок_як_памʼять_п8 = рядок::адреса як памʼять<п8>;
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[0]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[1]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[2]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[3]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[4]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[5]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[6]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[7]);
      ціль аргумент_як_памʼять_п8 = аргумент::адреса як памʼять<п8>;
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, аргумент_як_памʼять_п8[0]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, аргумент_як_памʼять_п8[1]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, аргумент_як_памʼять_п8[2]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, аргумент_як_памʼять_п8[3]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, аргумент_як_памʼять_п8[4]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, аргумент_як_памʼять_п8[5]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, аргумент_як_памʼять_п8[6]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, аргумент_як_памʼять_п8[7]);
      вернути код.накопичувач_вказівок.розмір - 1;
    }

    дія додати_вказівку_до_коду_з_двома_аргументами(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, вказівка: п8, аргумент: позитивне, другий_аргумент: позитивне): позитивне {
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, вказівка);
      ціль рядок_як_памʼять_п8 = рядок::адреса як памʼять<п8>;
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[0]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[1]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[2]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[3]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[4]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[5]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[6]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, рядок_як_памʼять_п8[7]);
      ціль аргумент_як_памʼять_п8 = аргумент::адреса як памʼять<п8>;
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, аргумент_як_памʼять_п8[0]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, аргумент_як_памʼять_п8[1]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, аргумент_як_памʼять_п8[2]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, аргумент_як_памʼять_п8[3]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, аргумент_як_памʼять_п8[4]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, аргумент_як_памʼять_п8[5]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, аргумент_як_памʼять_п8[6]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, аргумент_як_памʼять_п8[7]);
      ціль другий_аргумент_як_памʼять_п8 = другий_аргумент::адреса як памʼять<п8>;
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, другий_аргумент_як_памʼять_п8[0]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, другий_аргумент_як_памʼять_п8[1]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, другий_аргумент_як_памʼять_п8[2]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, другий_аргумент_як_памʼять_п8[3]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, другий_аргумент_як_памʼять_п8[4]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, другий_аргумент_як_памʼять_п8[5]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, другий_аргумент_як_памʼять_п8[6]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_вказівок::адреса, другий_аргумент_як_памʼять_п8[7]);
      вернути код.накопичувач_вказівок.розмір - 1;
    }

    дія покласти_вказівку_ПокластиПусто(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВПокластиПусто);
    }

    дія покласти_вказівку_ПокластиТак(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВПокластиТак);
    }

    дія покласти_вказівку_ПокластиНі(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВПокластиНі);
    }

    дія покласти_вказівку_ПокластиКонстанту(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, позиція_константи: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВПокластиКонстанту, позиція_константи);
    }

    дія покласти_вказівку_СтворитиДію(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, кількість_параметрів: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВСтворитиДію, кількість_параметрів);
    }

    дія покласти_вказівку_СтворитиСтруктуру(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, кількість_параметрів: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВСтворитиСтруктуру, кількість_параметрів);
    }

    дія покласти_вказівку_СтворитиМодуль(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВСтворитиМодуль);
    }

    дія покласти_вказівку_СтворитиСписок(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, вмісткість: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВСтворитиСписок, вмісткість);
    }

    дія покласти_вказівку_ПокластиВСписок(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВПокластиВСписок);
    }

    дія покласти_вказівку_СтворитиСловник(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, вмісткість: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВСтворитиСловник, вмісткість);
    }

    дія покласти_вказівку_ПокластиВСловник(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВПокластиВСловник);
    }

    дія покласти_вказівку_ПокластиСтруктуруПредмет(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВПокластиСтруктуруПредмет);
    }

    дія покласти_вказівку_ПокластиЯ(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВПокластиЯ);
    }

    дія покласти_вказівку_ЗаписатиМетод(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, власна: логічне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВЗаписатиМетод, позитивне(власна));
    }

    дія покласти_вказівку_ЗаписатиСпецДію(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, власна: логічне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВЗаписатиСпецДію, позитивне(власна));
    }

    дія покласти_вказівку_СтворитиДіапазон(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, включно: логічне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВСтворитиДіапазон, позитивне(включно));
    }

    дія покласти_вказівку_Визначити(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, позиція_константи_назви: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВВизначити, позиція_константи_назви);
    }

    дія покласти_вказівку_Звернутись(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, позиція_константи_назви: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВЗвернутись, позиція_константи_назви);
    }

    дія покласти_вказівку_Виконати(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, кількість_аргументів: позитивне, кількість_іменованих_аргументів: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_двома_аргументами(система, код, рядок, ВВиконати, кількість_аргументів, кількість_іменованих_аргументів);
    }

    дія покласти_вказівку_ОтриматиВластивість(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, позиція_константи_назви: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВОтриматиВластивість, позиція_константи_назви);
    }

    дія покласти_вказівку_ЗмінитиВластивість(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, позиція_константи_назви: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВЗмінитиВластивість, позиція_константи_назви);
    }

    дія покласти_вказівку_ВиконатиВластивість(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, кількість_аргументів: позитивне, кількість_іменованих_аргументів: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_двома_аргументами(система, код, рядок, ВВиконатиВластивість, кількість_аргументів, кількість_іменованих_аргументів);
    }

    дія покласти_вказівку_ОтриматиЕлемент(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВОтриматиЕлемент);
    }

    дія покласти_вказівку_ЗмінитиЕлемент(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВЗмінитиЕлемент);
    }

    дія покласти_вказівку_ОтриматиПеребір(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВОтриматиПеребір);
    }

    дія покласти_вказівку_ВизначитиЗзовні(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, позиція_константи_назви: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВВизначитиЗзовні, позиція_константи_назви);
    }

    дія покласти_вказівку_ВиконатиЗПредка(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, кількість_аргументів: позитивне, кількість_іменованих_аргументів: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_двома_аргументами(система, код, рядок, ВВиконатиЗПредка, кількість_аргументів, кількість_іменованих_аргументів);
    }

    дія покласти_вказівку_Видалити(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВВидалити);
    }

    дія покласти_вказівку_ВидалитиВластивість(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВВидалитиВластивість);
    }

    дія покласти_вказівку_ВидалитиЕлемент(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВВидалитиЕлемент);
    }

    дія покласти_вказівку_Додати(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВДодати);
    }

    дія покласти_вказівку_Відняти(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВВідняти);
    }

    дія покласти_вказівку_Помножити(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВПомножити);
    }

    дія покласти_вказівку_Поділити(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВПоділити);
    }

    дія покласти_вказівку_ОтриматиОстачуДілення(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВОтриматиОстачуДілення);
    }

    дія покласти_вказівку_ОтриматиНеповнуЧасткуДілення(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВОтриматиНеповнуЧасткуДілення);
    }

    дія покласти_вказівку_ПіднестиДоСтепеня(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВПіднестиДоСтепеня);
    }

    дія покласти_вказівку_ЗсунутиВліво(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВЗсунутиВліво);
    }

    дія покласти_вказівку_ЗсунутиВправо(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВЗсунутиВправо);
    }

    дія покласти_вказівку_ЗсунутиВправоЗіЗаповненням(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВЗсунутиВправоЗіЗаповненням);
    }

    дія покласти_вказівку_ДвійковеІ(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВДвійковеІ);
    }

    дія покласти_вказівку_ДвійковеАБО(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВДвійковеАБО);
    }

    дія покласти_вказівку_ДвійковеВиключнеАБО(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВДвійковеВиключнеАБО);
    }

    дія покласти_вказівку_ДвійковеНЕ(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВДвійковеНЕ);
    }

    дія покласти_вказівку_Менше(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВМенше);
    }

    дія покласти_вказівку_Більше(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВБільше);
    }

    дія покласти_вказівку_НеБільше(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВНеБільше);
    }

    дія покласти_вказівку_НеМенше(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВНеМенше);
    }

    дія покласти_вказівку_Рівно(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВРівно);
    }

    дія покласти_вказівку_НеРівно(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВНеРівно);
    }

    дія покласти_вказівку_Містить(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВМістить);
    }

    дія покласти_вказівку_НеМістить(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВНеМістить);
    }

    дія покласти_вказівку_Є(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВЄ);
    }

    дія покласти_вказівку_НеЄ(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВНеЄ);
    }

    дія покласти_вказівку_Відʼємне(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВВідʼємне);
    }

    дія покласти_вказівку_Числове(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВЧислове);
    }

    дія покласти_вказівку_Заперечити(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВЗаперечити);
    }

    дія покласти_вказівку_Збільшити(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВЗбільшити);
    }

    дія покласти_вказівку_ЗбільшитиПопереднє(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВЗбільшитиПопереднє);
    }

    дія покласти_вказівку_Зменшити(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВЗменшити);
    }

    дія покласти_вказівку_ПочатиСпробу(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, позиція_вказівки_зловити: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВПочатиСпробу, позиція_вказівки_зловити);
    }

    дія покласти_вказівку_Впасти(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВВпасти);
    }

    дія покласти_вказівку_ЗакінчитиСпробу(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, позиція_вказівки_виходу: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВЗакінчитиСпробу, позиція_вказівки_виходу);
    }

    дія покласти_вказівку_Взяти(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, кількість_назв: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВВзяти, кількість_назв);
    }

    дія покласти_вказівку_Дати(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВДати);
    }

    дія покласти_вказівку_ПеребратиДалі(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВПеребратиДалі);
    }

    дія покласти_вказівку_ЗбитиТекст(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, кількість_предметів: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВЗбитиТекст, кількість_предметів);
    }

    дія покласти_вказівку_ЗбитиЮнікод(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, кількість_предметів: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВЗбитиЮнікод, кількість_предметів);
    }

    дія покласти_вказівку_СтворитиПараметр(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВСтворитиПараметр);
    }

    дія покласти_вказівку_СтворитиТип(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, кількість_допустимих: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВСтворитиТип, кількість_допустимих);
    }

    дія покласти_вказівку_Стрибнути(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, позиція_вказівки: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВСтрибнути, позиція_вказівки);
    }

    дія покласти_вказівку_СтрибнутиЯкщоНі(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, позиція_вказівки: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВСтрибнутиЯкщоНі, позиція_вказівки);
    }

    дія покласти_вказівку_Забрати(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВЗабрати);
    }

    дія покласти_вказівку_Вернути(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВВернути);
    }

    дія покласти_вказівку_СтрибнутиЯкщоНіЗалишивши(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, позиція_вказівки: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВСтрибнутиЯкщоНіЗалишивши, позиція_вказівки);
    }

    дія покласти_вказівку_СтрибнутиЯкщоТак(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, позиція_вказівки: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВСтрибнутиЯкщоТак, позиція_вказівки);
    }

    дія покласти_вказівку_СтрибнутиЯкщоТакЗалишивши(система: адреса<Система>, код: адреса<Код>, рядок: позитивне, позиція_вказівки: позитивне): позитивне {
      вернути додати_вказівку_до_коду_з_аргументом(система, код, рядок, ВСтрибнутиЯкщоТакЗалишивши, позиція_вказівки);
    }

    дія покласти_вказівку_Дублювати(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВДублювати);
    }

    дія покласти_вказівку_ДублюватиПопереднє(система: адреса<Система>, код: адреса<Код>, рядок: позитивне): позитивне {
      вернути додати_вказівку_до_коду(система, код, рядок, ВДублюватиПопереднє);
    }

    дія покласти_константу_назви(система: адреса<Система>, код: адреса<Код>, значення: т8): позитивне {
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, ВидКонстантиНазва);
      ціль розмір_значення_як_памʼять_п8 = значення.розмір::адреса як памʼять<п8>;
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[0]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[1]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[2]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[3]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[4]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[5]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[6]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[7]);
      змінна ціль п: позитивне = 0;
      поки п < значення.розмір {
        покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, значення.дані[п]);
        п += 1;
      }
      код.кількість_констант += 1;
      вернути код.кількість_констант - 1;
    }

    дія позиція_назви_з_ю8(система: адреса<Система>, код: адреса<Код>, значення: ю8): позитивне {
      змінна ціль значення_т8 = т8 { 0, пусто };
      якщо перекодувати_ю8_в_т8(система, значення, значення_т8::адреса, ні) == ні {
        // потім: помилка
      }
      ціль позиція_константи = покласти_константу_назви(система, код, значення_т8);
      звільнити_памʼять(система, значення_т8.дані);
      вернути позиція_константи;
    }

    дія покласти_константу_числа(система: адреса<Система>, код: адреса<Код>, значення: д64): позитивне {
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, ВидКонстантиЧисло);
      ціль значення_як_памʼять_п8 = значення::адреса як памʼять<п8>;
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, значення_як_памʼять_п8[0]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, значення_як_памʼять_п8[1]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, значення_як_памʼять_п8[2]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, значення_як_памʼять_п8[3]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, значення_як_памʼять_п8[4]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, значення_як_памʼять_п8[5]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, значення_як_памʼять_п8[6]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, значення_як_памʼять_п8[7]);
      код.кількість_констант += 1;
      вернути код.кількість_констант - 1;
    }

    дія покласти_константу_тексту(система: адреса<Система>, код: адреса<Код>, значення: т8): позитивне {
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, ВидКонстантиТекст);
      ціль розмір_значення_як_памʼять_п8 = значення.розмір::адреса як памʼять<п8>;
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[0]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[1]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[2]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[3]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[4]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[5]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[6]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[7]);
      змінна ціль п: позитивне = 0;
      поки п < значення.розмір {
        покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, значення.дані[п]);
        п += 1;
      }
      код.кількість_констант += 1;
      вернути код.кількість_констант - 1;
    }

    дія покласти_константу_юнікоду8(система: адреса<Система>, код: адреса<Код>, значення: ю8): позитивне {
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, ВидКонстантиЮнікод8);
      ціль розмір_значення_як_памʼять_п8 = значення.розмір::адреса як памʼять<п8>;
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[0]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[1]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[2]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[3]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[4]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[5]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[6]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_як_памʼять_п8[7]);
      змінна ціль п: позитивне = 0;
      поки п < значення.розмір {
        покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, значення.дані[п]);
        п += 1;
      }
      код.кількість_констант += 1;
      вернути код.кількість_констант - 1;
    }

    дія покласти_константу_коду(система: адреса<Система>, код: адреса<Код>, значення: адреса<Код>): позитивне {
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, ВидКонстантиКод);
      ціль розмір_значення_накопичувача_констант_як_памʼять_п8 = значення.накопичувач_констант.розмір::адреса як памʼять<п8>;
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_накопичувача_констант_як_памʼять_п8[0]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_накопичувача_констант_як_памʼять_п8[1]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_накопичувача_констант_як_памʼять_п8[2]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_накопичувача_констант_як_памʼять_п8[3]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_накопичувача_констант_як_памʼять_п8[4]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_накопичувача_констант_як_памʼять_п8[5]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_накопичувача_констант_як_памʼять_п8[6]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_накопичувача_констант_як_памʼять_п8[7]);
      змінна ціль п: позитивне = 0;
      поки п < значення.накопичувач_констант.розмір {
        покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, значення.накопичувач_констант.дані[п]);
        п += 1;
      }
      ціль розмір_значення_накопичувача_вказівок_як_памʼять_п8 = значення.накопичувач_вказівок.розмір::адреса як памʼять<п8>;
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_накопичувача_вказівок_як_памʼять_п8[0]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_накопичувача_вказівок_як_памʼять_п8[1]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_накопичувача_вказівок_як_памʼять_п8[2]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_накопичувача_вказівок_як_памʼять_п8[3]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_накопичувача_вказівок_як_памʼять_п8[4]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_накопичувача_вказівок_як_памʼять_п8[5]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_накопичувача_вказівок_як_памʼять_п8[6]);
      покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, розмір_значення_накопичувача_вказівок_як_памʼять_п8[7]);
      п = 0;
      поки п < значення.накопичувач_вказівок.розмір {
        покласти_в_накопичувач<п8>(система, код.накопичувач_констант::адреса, значення.накопичувач_вказівок.дані[п]);
        п += 1;
      }
      код.кількість_констант += 1;
      вернути код.кількість_констант - 1;
    }

    дія перекласти_гілку_в_МаМа(система: адреса<Система>, контекст: адреса<КонтекстПерекладу>, код: адреса<Код>, елемент: адреса<розбирач::Гілка>, вихід_помилки: адреса<ПомилкаПерекладуВМаМа>): логічне {
      змінна ціль результат = так;
      ціль рядок = розбирач::отримати_рядок_з_місцезнаходження(контекст.значення_ю8, контекст.слова, елемент.місцезнаходження);
      якщо елемент.вид == розбирач::ВидГілкиЗвернутись {
        ціль дані = елемент.дані як розбирач::ДаніГілкиЗвернутись;
        ціль значення_ідентифікатора = розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані.ідентифікатор);
        якщо перевірити_чи_ю8_рівні(значення_ідентифікатора, ю8"я") {
          покласти_вказівку_ПокластиЯ(система, код, рядок);
        } інакше якщо перевірити_чи_ю8_рівні(значення_ідентифікатора, ю8"так") {
          покласти_вказівку_ПокластиТак(система, код, рядок);
        } інакше якщо перевірити_чи_ю8_рівні(значення_ідентифікатора, ю8"ні") {
          покласти_вказівку_ПокластиНі(система, код, рядок);
        } інакше якщо перевірити_чи_ю8_рівні(значення_ідентифікатора, ю8"пусто") {
          покласти_вказівку_ПокластиПусто(система, код, рядок);
        } інакше якщо перевірити_чи_ю8_рівні(значення_ідентифікатора, ю8"__ФАЙЛ_ЮНІКОД__") {
//          ціль шлях_до_файлу_мавки = код.шлях_до_файлу як адреса<Шлях>;
//          ціль предмет_юнікоду = виділити_предмет_юнікоду_з_ю8(М, шлях_до_файлу_мавки.значення);
//          ціль позиція_константи = покласти_константу(М, предмет_юнікоду як адреса<Предмет>);
//          покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_константи);
        } інакше якщо перевірити_чи_ю8_рівні(значення_ідентифікатора, ю8"__ПАПКА_ЮНІКОД__") {
//          ціль шлях_до_папки = ю8 { 0, пусто };
//          якщо система::отримати_абсолютний_батьківський_шлях(обчислювач, код.шлях_до_файлу, шлях_до_папки::адреса) == 0 {
//            ПОМЕРТИ(М, ю8"Не вдалося отримати батьківську директорію");
//          }
//          ціль предмет_юнікоду = виділити_предмет_юнікоду_з_ю8(М, шлях_до_папки);
//          звільнити_памʼять(обчислювач, шлях_до_папки.дані);
//          ціль позиція_константи = покласти_константу(М, предмет_юнікоду як адреса<Предмет>);
//          покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_константи);
        } інакше якщо перевірити_чи_ю8_рівні(значення_ідентифікатора, ю8"__РЯДОК__") {
//          ціль предмет_числа = виділити_предмет_числа(М, д64(рядок));
//          ціль позиція_константи = покласти_константу(М, предмет_числа як адреса<Предмет>);
//          покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_константи);
        } інакше якщо перевірити_чи_ю8_рівні(значення_ідентифікатора, ю8"__СТОВПЕЦЬ__") {
//          ціль предмет_числа = виділити_предмет_числа(М, д64(розбирач::отримати_стовпець_з_місцезнаходження(контекст.значення_ю8, контекст.слова, елемент.місцезнаходження)));
//          ціль позиція_константи = покласти_константу(М, предмет_числа як адреса<Предмет>);
//          покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_константи);
        } інакше {
          ціль позиція_назви = позиція_назви_з_ю8(система, код, значення_ідентифікатора);
          покласти_вказівку_Звернутись(система, код, рядок, позиція_назви);
        }
        вернути так;
      } інакше якщо елемент.вид == розбирач::ВидГілкиОтримати {
        ціль дані = елемент.дані як розбирач::ДаніГілкиОтримати;
        ціль успіх_компіляції_предмета = перекласти_гілку_в_МаМа(система, контекст, код, дані.предмет, вихід_помилки);
        якщо успіх_компіляції_предмета == ні {
          вернути успіх_компіляції_предмета;
        }
        ціль позиція_назви = позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані.ідентифікатор));
        покласти_вказівку_ОтриматиВластивість(система, код, рядок, позиція_назви);
        вернути так;
      } інакше якщо елемент.вид == розбирач::ВидГілкиОтриматиЕлемент {
        ціль дані = елемент.дані як розбирач::ДаніГілкиОтриматиЕлемент;
        ціль успіх_компіляції_предмета = перекласти_гілку_в_МаМа(система, контекст, код, дані.предмет, вихід_помилки);
        якщо успіх_компіляції_предмета == ні {
          вернути успіх_компіляції_предмета;
        }
        ціль успіх_компіляції_ключа = перекласти_гілку_в_МаМа(система, контекст, код, дані.ключ, вихід_помилки);
        якщо успіх_компіляції_ключа == ні {
          вернути успіх_компіляції_ключа;
        }
        покласти_вказівку_ОтриматиЕлемент(система, код, рядок);
        вернути так;
      } інакше якщо елемент.вид == розбирач::ВидГілкиВиконати {
        ціль дані = елемент.дані як розбирач::ДаніГілкиВиконати;

        якщо дані.предмет.вид == розбирач::ВидГілкиОтримати {
          ціль дані_отримання = дані.предмет.дані як розбирач::ДаніГілкиОтримати;
          ціль успіх_компіляції_предмета = перекласти_гілку_в_МаМа(система, контекст, код, дані_отримання.предмет, вихід_помилки);
          якщо успіх_компіляції_предмета == ні {
            вернути успіх_компіляції_предмета;
          }
          ціль позиція_назви_прохання = позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані_отримання.ідентифікатор));
          покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_назви_прохання);
        } інакше {
          ціль успіх_компіляції_предмета = перекласти_гілку_в_МаМа(система, контекст, код, дані.предмет, вихід_помилки);
          якщо успіх_компіляції_предмета == ні {
            вернути успіх_компіляції_предмета;
          }
        }
        змінна ціль кількість_аргументів_без_назви: позитивне = 0;
        змінна ціль кількість_аргументів_з_назвою: позитивне = 0;
        змінна ціль п: позитивне = 0;
        поки п < дані.кількість_аргументів {
          ціль аргумент = дані.аргументи[п];
          ціль рядок_аргумента = розбирач::отримати_рядок_з_місцезнаходження(контекст.значення_ю8, контекст.слова, аргумент.місцезнаходження);
          якщо аргумент.ідентифікатор.заповнено == позитивне(так) {
            ціль позиція_назви_аргумента = позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, аргумент.ідентифікатор.значення));
            покласти_вказівку_ПокластиКонстанту(система, код, рядок_аргумента, позиція_назви_аргумента);
            ціль успіх_компіляції_аргумента = перекласти_гілку_в_МаМа(система, контекст, код, аргумент.значення, вихід_помилки);
            якщо успіх_компіляції_аргумента == ні {
              вернути успіх_компіляції_аргумента;
            }
            кількість_аргументів_з_назвою += 1;
          } інакше {
            якщо кількість_аргументів_з_назвою > 0 {
              вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
                повідомлення = виділити_копію_т8(система, "Іменовані аргументи не можуть йти перед позиційними"),
                позиція_слова = 0
              };
              вернути ні;
            }
            ціль успіх_компіляції_аргумента = перекласти_гілку_в_МаМа(система, контекст, код, аргумент.значення, вихід_помилки);
            якщо успіх_компіляції_аргумента == ні {
              вернути успіх_компіляції_аргумента;
            }
            кількість_аргументів_без_назви += 1;
          }
          п += 1;
        }
        якщо дані.предмет.вид == розбирач::ВидГілкиОтримати {
          покласти_вказівку_ВиконатиВластивість(система, код, рядок, кількість_аргументів_без_назви, кількість_аргументів_з_назвою);
        } інакше {
          покласти_вказівку_Виконати(система, код, рядок, кількість_аргументів_без_назви, кількість_аргументів_з_назвою);
        }
        вернути так;
      } інакше якщо елемент.вид == розбирач::ВидГілкиДія {
        ціль дані = елемент.дані як розбирач::ДаніГілкиДія;
//        якщо дані.власна == позитивне(так) {
//          вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
//            повідомлення = виділити_копію_т8(система, "Неможливо перекласти дію"),
//            позиція_слова = 0
//          };
//          результат = ні;
//          стрибнути вихід;
//        }
//        якщо дані.спец == позитивне(так) {
//          вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
//            повідомлення = виділити_копію_т8(система, "Неможливо перекласти дію"),
//            позиція_слова = 0
//          };
//          результат = ні;
//          стрибнути вихід;
//        }
        якщо дані.тривала == позитивне(так) {
          вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
            повідомлення = виділити_копію_т8(система, "Тривалі дії наразі не підтримуються"),
            позиція_слова = 0
          };
          результат = ні;
          стрибнути вихід;
        }
        якщо дані.ідентифікатор.заповнено == позитивне(так) {
          ціль позиція_назви = позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані.ідентифікатор.значення));
          покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_назви); // назва
        } інакше {
          покласти_вказівку_ПокластиПусто(система, код, рядок); // назва
        }
        змінна ціль п: позитивне = 0;
        поки п < дані.кількість_параметрів {
          ціль параметр = дані.параметри[п];
          ціль позиція_назви_параметра = позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, параметр.ідентифікатор));
          покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_назви_параметра);
          якщо параметр.тип.заповнено == позитивне(так) {
            змінна ціль птп: позитивне = 0;
            поки птп < параметр.тип.значення.кількість_гілок {
              ціль тип = параметр.тип.значення.гілки[птп];
              ціль успіх_компіляції_типу = перекласти_гілку_в_МаМа(система, контекст, код, тип, вихід_помилки);
              якщо успіх_компіляції_типу == ні {
                вернути успіх_компіляції_типу;
              }
              птп = птп + 1;
            }
            покласти_вказівку_СтворитиТип(система, код, рядок, параметр.тип.значення.кількість_гілок);
          } інакше {
            покласти_вказівку_ПокластиПусто(система, код, рядок);
          }
          якщо параметр.значення != пусто {
            ціль код_значення_параметра = створити_код(система);
            ціль контекст_значення_параметра = створити_контекст(система, контекст.значення_ю8, контекст.слова);
            ціль успіх_перекладу_коду = перекласти_гілку_в_МаМа(система, контекст_значення_параметра, код_значення_параметра, параметр.значення, вихід_помилки);
            якщо успіх_перекладу_коду == ні {
              знищити_код(система, код_значення_параметра);
              знищити_контекст(система, контекст_значення_параметра);
              результат = ні;
              стрибнути вихід;
            }
            покласти_вказівку_Вернути(система, код_значення_параметра, рядок);
            ціль позиція_коду_параметра = покласти_константу_коду(система, код, код_значення_параметра);
            покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_коду_параметра);
            знищити_код(система, код_значення_параметра);
            знищити_контекст(система, контекст_значення_параметра);
          } інакше {
            покласти_вказівку_ПокластиПусто(система, код, рядок);
          }
          покласти_вказівку_СтворитиПараметр(система, код, рядок);
          п = п + 1;
        }
        якщо дані.тип_результату.заповнено == позитивне(так) {
          змінна ціль птп: позитивне = 0;
          поки птп < дані.тип_результату.значення.кількість_гілок {
            ціль тип = дані.тип_результату.значення.гілки[птп];
            ціль успіх_компіляції_типу = перекласти_гілку_в_МаМа(система, контекст, код, тип, вихід_помилки);
            якщо успіх_компіляції_типу == ні {
              вернути успіх_компіляції_типу;
            }
            птп = птп + 1;
          }
          покласти_вказівку_СтворитиТип(система, код, рядок, дані.тип_результату.значення.кількість_гілок);
        } інакше {
          покласти_вказівку_ПокластиПусто(система, код, рядок); // тип результату
        }
        ціль код_дії = створити_код(система);
        ціль контекст_дії = створити_контекст(система, контекст.значення_ю8, контекст.слова);
        ціль успіх_перекладу_коду_дії = перекласти_в_МаМа(система, контекст_дії, дані.тіло, так, код_дії, вихід_помилки);
        якщо успіх_перекладу_коду_дії == ні {
          знищити_код(система, код_дії);
          знищити_контекст(система, контекст_дії);
          результат = ні;
          стрибнути вихід;
        }
        ціль позиція_коду_дії = покласти_константу_коду(система, код, код_дії);
        покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_коду_дії); // код
        покласти_вказівку_СтворитиДію(система, код, рядок, дані.кількість_параметрів);
        знищити_код(система, код_дії);
        знищити_контекст(система, контекст_дії);
        вернути так;
      } інакше якщо елемент.вид == розбирач::ВидГілкиСтруктура {
        ціль дані = елемент.дані як розбирач::ДаніГілкиСтруктура;
        якщо дані.ідентифікатор.заповнено == позитивне(так) {
          ціль позиція_назви = позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані.ідентифікатор.значення));
          покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_назви);
        } інакше {
          покласти_вказівку_ПокластиПусто(система, код, рядок);
        }
        якщо дані.предок == пусто {
          покласти_вказівку_ПокластиСтруктуруПредмет(система, код, рядок);
        } інакше {
          ціль успіх_компіляції_предка = перекласти_гілку_в_МаМа(система, контекст, код, дані.предок, вихід_помилки);
          якщо успіх_компіляції_предка == ні {
            вернути успіх_компіляції_предка;
          }
        }
        змінна ціль п: позитивне = 0;
        поки п < дані.кількість_параметрів {
          ціль параметр = дані.параметри[п];
          ціль позиція_назви_параметра = позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, параметр.ідентифікатор));
          покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_назви_параметра);
          якщо параметр.тип.заповнено == позитивне(так) {
            змінна ціль птп: позитивне = 0;
            поки птп < параметр.тип.значення.кількість_гілок {
              ціль тип = параметр.тип.значення.гілки[птп];
              ціль успіх_компіляції_типу = перекласти_гілку_в_МаМа(система, контекст, код, тип, вихід_помилки);
              якщо успіх_компіляції_типу == ні {
                вернути успіх_компіляції_типу;
              }
              птп = птп + 1;
            }
            покласти_вказівку_СтворитиТип(система, код, рядок, параметр.тип.значення.кількість_гілок);
          } інакше {
            покласти_вказівку_ПокластиПусто(система, код, рядок);
          }
          якщо параметр.значення != пусто {
            ціль код_значення_параметра = створити_код(система);
            ціль контекст_значення_параметра = створити_контекст(система, контекст.значення_ю8, контекст.слова);
            ціль успіх_перекладу_коду = перекласти_гілку_в_МаМа(система, контекст_значення_параметра, код_значення_параметра, параметр.значення, вихід_помилки);
            якщо успіх_перекладу_коду == ні {
              знищити_код(система, код_значення_параметра);
              знищити_контекст(система, контекст_значення_параметра);
              результат = ні;
              стрибнути вихід;
            }
            покласти_вказівку_Вернути(система, код_значення_параметра, рядок);
            ціль позиція_коду_параметра = покласти_константу_коду(система, код, код_значення_параметра);
            покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_коду_параметра);
            знищити_код(система, код_значення_параметра);
            знищити_контекст(система, контекст_значення_параметра);
          } інакше {
            покласти_вказівку_ПокластиПусто(система, код, рядок);
          }
          покласти_вказівку_СтворитиПараметр(система, код, рядок);
          п = п + 1;
        }
        покласти_вказівку_СтворитиСтруктуру(система, код, рядок, дані.кількість_параметрів);
        вернути так;
      } інакше якщо елемент.вид == розбирач::ВидГілкиЧисло {
        ціль дані = елемент.дані як розбирач::ДаніГілкиЧисло;
        ціль слово = контекст.слова.дані[дані.позиція_слова];
        змінна ціль розібране_число: д64 = 0.0;
        якщо розібрати_число_з_ю8(розбирач::отримати_ю8_слова(контекст.значення_ю8, контекст.слова, слово), розібране_число::адреса) == ні {
          вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
            повідомлення = виділити_копію_т8(система, "Не вдалось розібрати число"),
            позиція_слова = 0
          };
          вернути ні;
        }
        ціль позиція_константи = покласти_константу_числа(система, код, розібране_число);
        покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_константи);
        вернути так;
      } інакше якщо елемент.вид == розбирач::ВидГілкиТекст {
        ціль дані = елемент.дані як розбирач::ДаніГілкиТекст;
        ціль значення_тексту_ю8 = розбирач::отримати_ю8_тексту(контекст.значення_ю8, контекст.слова, елемент);
        змінна ціль позиція_константи: позитивне = 0;
        якщо дані.ідентифікатор.заповнено == позитивне(ні) {
          якщо значення_тексту_ю8.розмір == 0 {
            позиція_константи = покласти_константу_тексту(система, код, "");
          } інакше {
            ціль значення_т8 = т8 { 0, пусто };
            якщо перекодувати_ю8_в_т8(система, значення_тексту_ю8, значення_т8::адреса, ні) == ні {
              вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
                повідомлення = виділити_копію_т8(система, "Не вдалось отримати значення т8"),
                позиція_слова = 0
              };
              вернути ні;
            }
            позиція_константи = покласти_константу_тексту(система, код, значення_т8);
            звільнити_памʼять(система, значення_т8.дані);
          }
        } інакше якщо перевірити_чи_ю8_рівні(розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані.ідентифікатор.значення), ю8"ю") {
          позиція_константи = покласти_константу_юнікоду8(система, код, значення_тексту_ю8);
        } інакше {
          вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
            повідомлення = виділити_копію_т8(система, "Невідомий тип тексту"),
            позиція_слова = 0
          };
          вернути ні;
        }
        покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_константи);
        вернути так;
      } інакше якщо елемент.вид == розбирач::ВидГілкиЗбитийТекст {
        ціль дані = елемент.дані як розбирач::ДаніГілкиЗбитийТекст;
        змінна ціль п: позитивне = 0;
        поки п < дані.кількість_гілок {
          ціль успіх_компіляції_значення = перекласти_гілку_в_МаМа(система, контекст, код, дані.гілки[п], вихід_помилки);
          якщо успіх_компіляції_значення == ні {
            вернути успіх_компіляції_значення;
          }
          п += 1;
        }
        якщо дані.ідентифікатор.заповнено == позитивне(ні) {
          покласти_вказівку_ЗбитиТекст(система, код, рядок, дані.кількість_гілок);
        } інакше якщо перевірити_чи_ю8_рівні(розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані.ідентифікатор.значення), ю8"ю") {
          покласти_вказівку_ЗбитиЮнікод(система, код, рядок, дані.кількість_гілок);
        } інакше {
          вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
            повідомлення = виділити_копію_т8(система, "Невідомий тип тексту"),
            позиція_слова = 0
          };
          вернути ні;
        }
        вернути так;
      } інакше якщо елемент.вид == розбирач::ВидГілкиСимвол {
        ціль дані = елемент.дані як розбирач::ДаніГілкиСимвол;
        ціль значення_символу_ю8 = розбирач::отримати_ю8_символу(контекст.значення_ю8, контекст.слова, елемент);
        змінна ціль позиція_константи: позитивне = 0;
        якщо дані.ідентифікатор.заповнено == позитивне(ні) {
          якщо значення_символу_ю8.розмір == 0 {
            вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
              повідомлення = виділити_копію_т8(система, "Пустий символ"),
              позиція_слова = 0
            };
            вернути ні;
          } інакше {
            ціль значення_т8 = т8 { 0, пусто };
            якщо перекодувати_ю8_в_т8(система, значення_символу_ю8, значення_т8::адреса, ні) == ні {
              вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
                повідомлення = виділити_копію_т8(система, "Не вдалось перекодувати в т8"),
                позиція_слова = 0
              };
              вернути ні;
            }
            якщо значення_т8.розмір > 1 {
              вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
                повідомлення = виділити_копію_т8(система, "Символ не один"),
                позиція_слова = 0
              };
              вернути ні;
            }
            позиція_константи = покласти_константу_числа(система, код, д64(значення_т8.дані[0]));
            звільнити_памʼять(система, значення_т8.дані);
          }
        } інакше якщо перевірити_чи_ю8_рівні(розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані.ідентифікатор.значення), ю8"ю") {
          ціль значення_ю32 = ю32 { 0, пусто };
          якщо перекодувати_ю8_в_ю32(система, значення_символу_ю8, значення_ю32::адреса, ні) == ні {
            вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
              повідомлення = виділити_копію_т8(система, "Не вдалось перекодувати в ю32"),
              позиція_слова = 0
            };
            вернути ні;
          }
          якщо значення_ю32.розмір == 0 {
            вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
              повідомлення = виділити_копію_т8(система, "Пустий символ"),
              позиція_слова = 0
            };
            вернути ні;
          }
          якщо значення_ю32.розмір > 1 {
            вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
              повідомлення = виділити_копію_т8(система, "Символ не один"),
              позиція_слова = 0
            };
            вернути ні;
          }
          позиція_константи = покласти_константу_числа(система, код, д64(значення_ю32.дані[0]));
          звільнити_памʼять(система, значення_ю32.дані);
        } інакше {
          вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
            повідомлення = виділити_копію_т8(система, "Невідомий тип символа"),
            позиція_слова = 0
          };
          вернути ні;
        }
        покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_константи);
        вернути так;
      } інакше якщо елемент.вид == розбирач::ВидГілкиОперація {
        ціль дані = елемент.дані як розбирач::ДаніГілкиОперація;
        ціль успіх_компіляції_ліво = перекласти_гілку_в_МаМа(система, контекст, код, дані.ліво, вихід_помилки);
        якщо успіх_компіляції_ліво == ні {
          вернути успіх_компіляції_ліво;
        }
        якщо дані.операція == розбирач::ВидОпераціїІ {
          ціль позиція_вказівки_стрибнути_якщо_ні = код.накопичувач_вказівок.розмір;
          покласти_вказівку_СтрибнутиЯкщоНіЗалишивши(система, код, рядок, 0);
          покласти_вказівку_Забрати(система, код, рядок);
          ціль успіх_компіляції_право = перекласти_гілку_в_МаМа(система, контекст, код, дані.право, вихід_помилки);
          якщо успіх_компіляції_право == ні {
            вернути успіх_компіляції_право;
          }
          записати_позитивне_в_код_за_позицією(система, код, позиція_вказівки_стрибнути_якщо_ні + 8 + 1, код.накопичувач_вказівок.розмір);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїАБО {
          ціль позиція_вказівки_стрибнути_якщо_так = код.накопичувач_вказівок.розмір;
          покласти_вказівку_СтрибнутиЯкщоТакЗалишивши(система, код, рядок, 0);
          покласти_вказівку_Забрати(система, код, рядок);
          ціль успіх_компіляції_право = перекласти_гілку_в_МаМа(система, контекст, код, дані.право, вихід_помилки);
          якщо успіх_компіляції_право == ні {
            вернути успіх_компіляції_право;
          }
          записати_позитивне_в_код_за_позицією(система, код, позиція_вказівки_стрибнути_якщо_так + 8 + 1, код.накопичувач_вказівок.розмір);
          вернути так;
        }
        ціль успіх_компіляції_право = перекласти_гілку_в_МаМа(система, контекст, код, дані.право, вихід_помилки);
        якщо успіх_компіляції_право  == ні {
          вернути успіх_компіляції_право;
        }
        якщо дані.операція == розбирач::ВидОпераціїДодавання {
          покласти_вказівку_Додати(система, код, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїВіднімання {
          покласти_вказівку_Відняти(система, код, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїМноження {
          покласти_вказівку_Помножити(система, код, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїДілення {
          покласти_вказівку_Поділити(система, код, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїМодуль {
          покласти_вказівку_ОтриматиОстачуДілення(система, код, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїДіленняНаціло {
          покласти_вказівку_ОтриматиНеповнуЧасткуДілення(система, код, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїПіднесенняДоСтепеня {
          покласти_вказівку_ПіднестиДоСтепеня(система, код, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїЗсувВліво {
          покласти_вказівку_ЗсунутиВліво(система, код, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїЗсувВправо {
          покласти_вказівку_ЗсунутиВправо(система, код, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїЗсувВправоЗнаковий {
          покласти_вказівку_ЗсунутиВправоЗіЗаповненням(система, код, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїДІ {
          покласти_вказівку_ДвійковеІ(система, код, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїДАБО {
          покласти_вказівку_ДвійковеАБО(система, код, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїВАБО {
          покласти_вказівку_ДвійковеВиключнеАБО(система, код, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїМенше {
          покласти_вказівку_Менше(система, код, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїБільше {
          покласти_вказівку_Більше(система, код, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїМеншеРівне {
          покласти_вказівку_НеБільше(система, код, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїБільшеРівне {
          покласти_вказівку_НеМенше(система, код, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїРівне {
          покласти_вказівку_Рівно(система, код, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїНерівне {
          покласти_вказівку_НеРівно(система, код, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїМістить {
          покласти_вказівку_Містить(система, код, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїНеМістить {
          покласти_вказівку_НеМістить(система, код, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїЄ {
          покласти_вказівку_Є(система, код, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїНеЄ {
          покласти_вказівку_НеЄ(система, код, рядок);
          вернути так;
        } інакше {
          вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
            повідомлення = виділити_копію_т8(система, "Невідома операція"),
            позиція_слова = 0
          };
          вернути ні;
        }
      } інакше якщо елемент.вид == розбирач::ВидГілкиЗначенняЯкщо {
        ціль дані = елемент.дані як розбирач::ДаніГілкиЗначенняЯкщо;
        ціль успіх_компіляції_умови = перекласти_гілку_в_МаМа(система, контекст, код, дані.умова, вихід_помилки);
        якщо успіх_компіляції_умови == ні {
          вернути успіх_компіляції_умови;
        }
        ціль позиція_вказівки_стрибнути_якщо_ні = код.накопичувач_вказівок.розмір;
        покласти_вказівку_СтрибнутиЯкщоНі(система, код, рядок, 0);
        ціль успіх_компіляції_так = перекласти_гілку_в_МаМа(система, контекст, код, дані.значення_так, вихід_помилки);
        якщо успіх_компіляції_так == ні {
          вернути успіх_компіляції_так;
        }
        ціль позиція_вказівки_виходу_з_так = код.накопичувач_вказівок.розмір;
        покласти_вказівку_Стрибнути(система, код, рядок, 0);
        записати_позитивне_в_код_за_позицією(система, код, позиція_вказівки_стрибнути_якщо_ні + 8 + 1, код.накопичувач_вказівок.розмір);
        ціль успіх_компіляції_ні = перекласти_гілку_в_МаМа(система, контекст, код, дані.значення_ні, вихід_помилки);
        якщо успіх_компіляції_ні == ні {
          вернути успіх_компіляції_ні;
        }
        записати_позитивне_в_код_за_позицією(система, код, позиція_вказівки_виходу_з_так + 8 + 1, код.накопичувач_вказівок.розмір);
        вернути так;
      } інакше якщо елемент.вид == розбирач::ВидГілкиСамоОперація {
        ціль дані = елемент.дані як розбирач::ДаніГілкиСамоОперація;
        ціль успіх_компіляції_предмета = перекласти_гілку_в_МаМа(система, контекст, код, дані.предмет, вихід_помилки);
        якщо успіх_компіляції_предмета == ні {
          вернути успіх_компіляції_предмета;
        }
        якщо дані.операція == розбирач::ВидСамоОпераціїЛогічнеНі {
          покласти_вказівку_Заперечити(система, код, рядок);
          вернути так;
        }
        якщо дані.операція == розбирач::ВидСамоОпераціїДвійковеНі {
          покласти_вказівку_ДвійковеНЕ(система, код, рядок);
          вернути так;
        }
        якщо дані.операція == розбирач::ВидСамоОпераціїПлюс {
          покласти_вказівку_Числове(система, код, рядок);
          вернути так;
        }
        якщо дані.операція == розбирач::ВидСамоОпераціїМінус {
          покласти_вказівку_Відʼємне(система, код, рядок);
          вернути так;
        }
        вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
          повідомлення = виділити_копію_т8(система, "Невідома операція"),
          позиція_слова = 0
        };
        вернути ні;
      } інакше якщо елемент.вид == розбирач::ВидГілкиМодуль {
        ціль дані = елемент.дані як розбирач::ДаніГілкиМодуль;
        якщо дані.ідентифікатор.заповнено == позитивне(так) {
          ціль позиція_назви = позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані.ідентифікатор.значення));
          покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_назви);
        } інакше {
          покласти_вказівку_ПокластиПусто(система, код, рядок);
        }
        ціль код_модуля = створити_код(система);
        ціль контекст_модуля = створити_контекст(система, контекст.значення_ю8, контекст.слова);
        ціль успіх_перекладу_коду_дії = перекласти_в_МаМа(система, контекст_модуля, дані.тіло, ні, код_модуля, вихід_помилки);
        якщо успіх_перекладу_коду_дії == ні {
          знищити_код(система, код_модуля);
          знищити_контекст(система, контекст_модуля);
          результат = ні;
          стрибнути вихід;
        }
        ціль позиція_коду_дії = покласти_константу_коду(система, код, код_модуля);
        покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_коду_дії);
        покласти_вказівку_СтворитиМодуль(система, код, рядок);
        знищити_код(система, код_модуля);
        знищити_контекст(система, контекст_модуля);
        вернути так;
      } інакше якщо елемент.вид == розбирач::ВидГілкиСписок {
        ціль дані = елемент.дані як розбирач::ДаніГілкиСписок;
        покласти_вказівку_СтворитиСписок(система, код, рядок, дані.кількість_елементів);
        змінна ціль п: позитивне = 0;
        поки п < дані.кількість_елементів {
          ціль елемент_списку = дані.елементи[п];
          ціль успіх_компіляції_елементу_списку = перекласти_гілку_в_МаМа(система, контекст, код, елемент_списку, вихід_помилки);
          якщо успіх_компіляції_елементу_списку == ні {
            вернути успіх_компіляції_елементу_списку;
          }
          покласти_вказівку_ПокластиВСписок(система, код, рядок);
          п += 1;
        }
        вернути так;
      } інакше якщо елемент.вид == розбирач::ВидГілкиСловник {
        ціль дані = елемент.дані як розбирач::ДаніГілкиСловник;
        покласти_вказівку_СтворитиСловник(система, код, рядок, дані.кількість_елементів);
        змінна ціль п: позитивне = 0;
        поки п < дані.кількість_елементів {
          ціль елемент_словника = дані.елементи[п];
          ціль успіх_компіляції_ключа_словника_списку = перекласти_гілку_в_МаМа(система, контекст, код, елемент_словника.ключ, вихід_помилки);
          якщо успіх_компіляції_ключа_словника_списку == ні {
            вернути успіх_компіляції_ключа_словника_списку;
          }
          ціль успіх_компіляції_значення_словника_списку = перекласти_гілку_в_МаМа(система, контекст, код, елемент_словника.значення, вихід_помилки);
          якщо успіх_компіляції_значення_словника_списку == ні {
            вернути успіх_компіляції_значення_словника_списку;
          }
          покласти_вказівку_ПокластиВСловник(система, код, рядок);
          п += 1;
        }
        вернути так;
      } інакше якщо елемент.вид == розбирач::ВидГілкиВидалити {
        ціль дані = елемент.дані як розбирач::ДаніГілкиВидалити;
        ціль позиція_назви = позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані.ідентифікатор));
        покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_назви);
        покласти_вказівку_Видалити(система, код, рядок);
        вернути так;
      } інакше якщо елемент.вид == розбирач::ВидГілкиВидалитиВластивість {
        ціль дані = елемент.дані як розбирач::ДаніГілкиВидалитиВластивість;
        ціль успіх_компіляції_предмета = перекласти_гілку_в_МаМа(система, контекст, код, дані.предмет, вихід_помилки);
        якщо успіх_компіляції_предмета == ні {
          вернути успіх_компіляції_предмета;
        }
        ціль позиція_назви = позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані.ідентифікатор));
        покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_назви);
        покласти_вказівку_ВидалитиВластивість(система, код, рядок);
        вернути так;
      } інакше якщо елемент.вид == розбирач::ВидГілкиВидалитиЕлемент {
        ціль дані = елемент.дані як розбирач::ДаніГілкиВидалитиЕлемент;
        ціль успіх_компіляції_предмета = перекласти_гілку_в_МаМа(система, контекст, код, дані.предмет, вихід_помилки);
        якщо успіх_компіляції_предмета == ні {
          вернути успіх_компіляції_предмета;
        }
        ціль успіх_компіляції_ключа = перекласти_гілку_в_МаМа(система, контекст, код, дані.ключ, вихід_помилки);
        якщо успіх_компіляції_ключа == ні {
          вернути успіх_компіляції_ключа;
        }
        покласти_вказівку_ВидалитиЕлемент(система, код, рядок);
        вернути так;
      } інакше якщо елемент.вид == розбирач::ВидГілкиДіапазон {
        ціль дані = елемент.дані як розбирач::ДаніГілкиДіапазон;
        ціль успіх_компіляції_від = перекласти_гілку_в_МаМа(система, контекст, код, дані.від, вихід_помилки);
        якщо успіх_компіляції_від == ні {
          вернути успіх_компіляції_від;
        }
        ціль успіх_компіляції_до = перекласти_гілку_в_МаМа(система, контекст, код, дані.до, вихід_помилки);
        якщо успіх_компіляції_до == ні {
          вернути успіх_компіляції_до;
        }
        покласти_вказівку_СтворитиДіапазон(система, код, рядок, логічне(дані.включно));
        вернути так;
      } інакше якщо елемент.вид == розбирач::ВидГілкиЧекати {
        вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
          повідомлення = виділити_копію_т8(система, "Інструкція чекати наразі не підтримується"),
          позиція_слова = 0
        };
        вернути ні;
      } інакше {
        вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
          повідомлення = виділити_копію_т8(система, "Виявлено невідомий вид гілки"),
          позиція_слова = 0
        };
        вернути ні;
      }
      вихід:
      вернути результат;
    }

    зовнішня дія створити_код(система: адреса<Система>): адреса<Код> {
      ціль код = виділити<Код>(система);
      код.накопичувач_констант = зробити_накопичувач<п8>(система);
      код.кількість_констант = 0;
      код.накопичувач_вказівок = зробити_накопичувач<п8>(система);
      вернути код;
    }

    зовнішня дія знищити_код(система: адреса<Система>, код: адреса<Код>) {
      звільнити_памʼять(система, код.накопичувач_констант.дані);
      звільнити_памʼять(система, код.накопичувач_вказівок.дані);
      звільнити(система, код);
    }

    зовнішня дія створити_контекст(система: адреса<Система>, значення_ю8: ю8, слова: розбирач::Слова): адреса<КонтекстПерекладу> {
      ціль контекст = виділити<КонтекстПерекладу>(система);
      контекст.значення_ю8 = значення_ю8;
      контекст.слова = слова;
      вернути контекст;
    }

    зовнішня дія знищити_контекст(система: адреса<Система>, контекст: адреса<КонтекстПерекладу>) {
      звільнити(система, контекст);
    }

    зовнішня дія перекласти_в_МаМа(система: адреса<Система>, контекст: адреса<КонтекстПерекладу>, гілки: розбирач::Гілки, вернути_в_кінці: логічне, код: адреса<Код>, вихід_помилки: адреса<ПомилкаПерекладуВМаМа>): логічне {
      // потім: обробляти вернути_в_кінці в кожному елементі
      змінна ціль пе: позитивне = 0;
      поки пе < гілки.розмір {
        ціль елемент = гілки.дані[пе];
        ціль рядок = розбирач::отримати_рядок_з_місцезнаходження(контекст.значення_ю8, контекст.слова, елемент.місцезнаходження);
        якщо елемент.вид == розбирач::ВидГілкиНіщо {
          вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
            повідомлення = виділити_копію_т8(система, "Виявлено гілку Ніщо"),
            позиція_слова = 0
          };
          вернути ні;
        } інакше якщо елемент.вид == розбирач::ВидГілкиВизначити {
          ціль дані = елемент.дані як розбирач::ДаніГілкиВизначити;
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, дані.значення, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          ціль позиція_назви = позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані.ідентифікатор));
          покласти_вказівку_Визначити(система, код, рядок, позиція_назви);
        } інакше якщо елемент.вид == розбирач::ВидГілкиВизначитиЗзовні {
          ціль дані = елемент.дані як розбирач::ДаніГілкиВизначитиЗзовні;
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, дані.значення, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          ціль позиція_назви = позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані.ідентифікатор));
          покласти_вказівку_ВизначитиЗзовні(система, код, рядок, позиція_назви);
        } інакше якщо елемент.вид == розбирач::ВидГілкиЗвернутись {
          ціль дані = елемент.дані як розбирач::ДаніГілкиЗвернутись;
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, елемент, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          якщо вернути_в_кінці {
            якщо пе == гілки.розмір - 1 {
              покласти_вказівку_Вернути(система, код, рядок);
            } інакше {
              покласти_вказівку_Забрати(система, код, рядок);
            }
          } інакше {
            покласти_вказівку_Забрати(система, код, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиОтримати {
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, елемент, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          якщо вернути_в_кінці {
            якщо пе == гілки.розмір - 1 {
              покласти_вказівку_Вернути(система, код, рядок);
            } інакше {
              покласти_вказівку_Забрати(система, код, рядок);
            }
          } інакше {
            покласти_вказівку_Забрати(система, код, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиОтриматиЕлемент {
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, елемент, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          якщо вернути_в_кінці {
            якщо пе == гілки.розмір - 1 {
              покласти_вказівку_Вернути(система, код, рядок);
            } інакше {
              покласти_вказівку_Забрати(система, код, рядок);
            }
          } інакше {
            покласти_вказівку_Забрати(система, код, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиЗмінити {
          ціль дані = елемент.дані як розбирач::ДаніГілкиЗмінити;
          ціль успіх_компіляції_предмета = перекласти_гілку_в_МаМа(система, контекст, код, дані.предмет, вихід_помилки);
          якщо успіх_компіляції_предмета == ні {
            вернути успіх_компіляції_предмета;
          }
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, дані.значення, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          ціль позиція_назви = позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані.ідентифікатор));
          покласти_вказівку_ЗмінитиВластивість(система, код, рядок, позиція_назви);
        } інакше якщо елемент.вид == розбирач::ВидГілкиЗмінитиЕлемент {
          ціль дані = елемент.дані як розбирач::ДаніГілкиЗмінитиЕлемент;
          ціль успіх_компіляції_предмета = перекласти_гілку_в_МаМа(система, контекст, код, дані.предмет, вихід_помилки);
          якщо успіх_компіляції_предмета == ні {
            вернути успіх_компіляції_предмета;
          }
          ціль успіх_компіляції_позиції = перекласти_гілку_в_МаМа(система, контекст, код, дані.ключ, вихід_помилки);
          якщо успіх_компіляції_позиції == ні {
            вернути успіх_компіляції_позиції;
          }
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, дані.значення, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          покласти_вказівку_ЗмінитиЕлемент(система, код, рядок);
        } інакше якщо елемент.вид == розбирач::ВидГілкиВиконати {
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, елемент, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          якщо вернути_в_кінці {
            якщо пе == гілки.розмір - 1 {
              покласти_вказівку_Вернути(система, код, рядок);
            } інакше {
              покласти_вказівку_Забрати(система, код, рядок);
            }
          } інакше {
            покласти_вказівку_Забрати(система, код, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиДія {
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, елемент, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          ціль дані = елемент.дані як розбирач::ДаніГілкиДія;
          якщо дані.ідентифікатор.заповнено == позитивне(ні) {
            покласти_вказівку_Забрати(система, код, рядок);
          } інакше {
            якщо дані.структура_ == пусто {
              ціль позиція_назви = позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані.ідентифікатор.значення));
              покласти_вказівку_Визначити(система, код, рядок, позиція_назви);
            } інакше {
              ціль успіх_компіляції_структури = перекласти_гілку_в_МаМа(система, контекст, код, дані.структура_, вихід_помилки);
              якщо успіх_компіляції_структури == ні {
                вернути успіх_компіляції_структури;
              }
              ціль позиція_назви = позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані.ідентифікатор.значення));
              покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_назви);
              якщо дані.спец == позитивне(так) {
                покласти_вказівку_ЗаписатиСпецДію(система, код, рядок, логічне(дані.власна));
              } інакше {
                покласти_вказівку_ЗаписатиМетод(система, код, рядок, логічне(дані.власна));
              }
              покласти_вказівку_Забрати(система, код, рядок);
            }
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиСтруктура {
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, елемент, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          ціль дані = елемент.дані як розбирач::ДаніГілкиСтруктура;
          якщо дані.ідентифікатор.заповнено == позитивне(ні) {
            покласти_вказівку_Забрати(система, код, рядок);
          } інакше {
            ціль позиція_назви = позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані.ідентифікатор.значення));
            покласти_вказівку_Визначити(система, код, рядок, позиція_назви);
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиЧисло {
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, елемент, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          якщо вернути_в_кінці {
            якщо пе == гілки.розмір - 1 {
              покласти_вказівку_Вернути(система, код, рядок);
            } інакше {
              покласти_вказівку_Забрати(система, код, рядок);
            }
          } інакше {
            покласти_вказівку_Забрати(система, код, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиТекст {
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, елемент, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          якщо вернути_в_кінці {
            якщо пе == гілки.розмір - 1 {
              покласти_вказівку_Вернути(система, код, рядок);
            } інакше {
              покласти_вказівку_Забрати(система, код, рядок);
            }
          } інакше {
            покласти_вказівку_Забрати(система, код, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиЗбитийТекст {
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, елемент, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          якщо вернути_в_кінці {
            якщо пе == гілки.розмір - 1 {
              покласти_вказівку_Вернути(система, код, рядок);
            } інакше {
              покласти_вказівку_Забрати(система, код, рядок);
            }
          } інакше {
            покласти_вказівку_Забрати(система, код, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиСимвол {
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, елемент, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          якщо вернути_в_кінці {
            якщо пе == гілки.розмір - 1 {
              покласти_вказівку_Вернути(система, код, рядок);
            } інакше {
              покласти_вказівку_Забрати(система, код, рядок);
            }
          } інакше {
            покласти_вказівку_Забрати(система, код, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиОперація {
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, елемент, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          якщо вернути_в_кінці {
            якщо пе == гілки.розмір - 1 {
              покласти_вказівку_Вернути(система, код, рядок);
            } інакше {
              покласти_вказівку_Забрати(система, код, рядок);
            }
          } інакше {
            покласти_вказівку_Забрати(система, код, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиЯкщо {
          ціль дані = елемент.дані як розбирач::ДаніГілкиЯкщо;
          ціль успіх_компіляції_умови = перекласти_гілку_в_МаМа(система, контекст, код, дані.умова, вихід_помилки);
          якщо успіх_компіляції_умови == ні {
            вернути успіх_компіляції_умови;
          }
          ціль позиція_вказівки_якщо_ні = код.накопичувач_вказівок.розмір;
          покласти_вказівку_СтрибнутиЯкщоНі(система, код, рядок, 0);
          ціль контекст_якщо = створити_контекст(система, контекст.значення_ю8, контекст.слова);
          якщо дані.тіло.розмір != 0 {
            ціль успіх_компіляції_тіла = перекласти_в_МаМа(система, контекст_якщо, дані.тіло, ні, код, вихід_помилки);
            якщо успіх_компіляції_тіла == ні {
              знищити_контекст(система, контекст_якщо);
              вернути успіх_компіляції_тіла;
            }
          }
          ціль позиція_вказівки_якщо_так = код.накопичувач_вказівок.розмір;
          покласти_вказівку_Стрибнути(система, код, рядок, 0);
          записати_позитивне_в_код_за_позицією(система, код, позиція_вказівки_якщо_ні + 8 + 1, код.накопичувач_вказівок.розмір);
          якщо дані.тіло_інакше.розмір != 0 {
            ціль успіх_компіляції_тіла_інакше = перекласти_в_МаМа(система, контекст_якщо, дані.тіло_інакше, ні, код, вихід_помилки);
            якщо успіх_компіляції_тіла_інакше == ні {
              знищити_контекст(система, контекст_якщо);
              вернути успіх_компіляції_тіла_інакше;
            }
          }
          знищити_контекст(система, контекст_якщо);
          записати_позитивне_в_код_за_позицією(система, код, позиція_вказівки_якщо_так + 8 + 1, код.накопичувач_вказівок.розмір);
        } інакше якщо елемент.вид == розбирач::ВидГілкиПоки {
          ціль дані = елемент.дані як розбирач::ДаніГілкиПоки;
          ціль позиція_вказівки_початку_поки = код.накопичувач_вказівок.розмір;
          змінна ціль позиція_вказівки_якщо_ні: позитивне = 0;
          якщо дані.умова != пусто {
            ціль успіх_компіляції_умови = перекласти_гілку_в_МаМа(система, контекст, код, дані.умова, вихід_помилки);
            якщо успіх_компіляції_умови == ні {
              вернути успіх_компіляції_умови;
            }
            позиція_вказівки_якщо_ні = код.накопичувач_вказівок.розмір;
            покласти_вказівку_СтрибнутиЯкщоНі(система, код, рядок, 0);
          }
          ціль контекст_поки = створити_контекст(система, контекст.значення_ю8, контекст.слова);
          ціль успіх_компіляції_тіла = перекласти_в_МаМа(система, контекст_поки, дані.тіло, ні, код, вихід_помилки);
          якщо успіх_компіляції_тіла == ні {
            знищити_контекст(система, контекст_поки);
            вернути успіх_компіляції_тіла;
          }
          знищити_контекст(система, контекст_поки);
          покласти_вказівку_Стрибнути(система, код, рядок, позиція_вказівки_початку_поки);
          якщо дані.умова != пусто {
            записати_позитивне_в_код_за_позицією(система, код, позиція_вказівки_якщо_ні + 8 + 1, код.накопичувач_вказівок.розмір);
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиВернути {
          ціль дані = елемент.дані як розбирач::ДаніГілкиВернути;
          якщо дані.значення == пусто {
            покласти_вказівку_ПокластиПусто(система, код, рядок);
          } інакше {
            ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, дані.значення, вихід_помилки);
            якщо успіх_перекладу_елемента == ні {
              вернути успіх_перекладу_елемента;
            }
          }
          покласти_вказівку_Вернути(система, код, рядок);
        } інакше якщо елемент.вид == розбирач::ВидГілкиЗначенняЯкщо {
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, елемент, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          якщо вернути_в_кінці {
            якщо пе == гілки.розмір - 1 {
              покласти_вказівку_Вернути(система, код, рядок);
            } інакше {
              покласти_вказівку_Забрати(система, код, рядок);
            }
          } інакше {
            покласти_вказівку_Забрати(система, код, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиСамоОперація {
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, елемент, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          якщо вернути_в_кінці {
            якщо пе == гілки.розмір - 1 {
              покласти_вказівку_Вернути(система, код, рядок);
            } інакше {
              покласти_вказівку_Забрати(система, код, рядок);
            }
          } інакше {
            покласти_вказівку_Забрати(система, код, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиМодуль {
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, елемент, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          ціль дані = елемент.дані як розбирач::ДаніГілкиМодуль;
          якщо дані.ідентифікатор.заповнено == позитивне(ні) {
            покласти_вказівку_Забрати(система, код, рядок);
          } інакше {
            ціль позиція_назви = позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані.ідентифікатор.значення));
            покласти_вказівку_Визначити(система, код, рядок, позиція_назви);
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиСписок {
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, елемент, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          якщо вернути_в_кінці {
            якщо пе == гілки.розмір - 1 {
              покласти_вказівку_Вернути(система, код, рядок);
            } інакше {
              покласти_вказівку_Забрати(система, код, рядок);
            }
          } інакше {
            покласти_вказівку_Забрати(система, код, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиСловник {
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, елемент, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          якщо вернути_в_кінці {
            якщо пе == гілки.розмір - 1 {
              покласти_вказівку_Вернути(система, код, рядок);
            } інакше {
              покласти_вказівку_Забрати(система, код, рядок);
            }
          } інакше {
            покласти_вказівку_Забрати(система, код, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиВзяти {
          ціль дані = елемент.дані як розбирач::ДаніГілкиВзяти;
          якщо дані.тип.заповнено == позитивне(так) {
            якщо контекст.слова.дані[дані.тип.значення.позиція_слова].вид == розбирач::ВидСловаМодуль {
              ціль позиція_назви_типу = позиція_назви_з_ю8(система, код, ю8"модуль");
              покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_назви_типу);
            } інакше {
              ціль позиція_назви_типу = позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані.тип.значення));
              покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_назви_типу);
            }
          } інакше {
            покласти_вказівку_ПокластиПусто(система, код, рядок);
          }
          змінна ціль позиція_останьої_назви: позитивне = 0;
          змінна ціль п: позитивне = 0;
          поки п < дані.довжина_шляху {
            ціль елемент_шляху = дані.шлях[п];
            ціль позиція_назви = позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, елемент_шляху));
            покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_назви);
            якщо п == дані.довжина_шляху - 1 {
              позиція_останьої_назви = позиція_назви;
            }
            п += 1;
          }
          покласти_вказівку_Взяти(система, код, рядок, дані.довжина_шляху);
          якщо дані.ідентифікатор_як.заповнено == позитивне(ні) {
            якщо дані.кількість_елементів == 0 {
              покласти_вказівку_Визначити(система, код, рядок, позиція_останьої_назви);
            } інакше {
              змінна ціль пе: позитивне = 0;
              поки пе < дані.кількість_елементів {
                ціль елемент = дані.елементи[пе];
                покласти_вказівку_Дублювати(система, код, рядок);
                покласти_вказівку_ОтриматиВластивість(система, код, рядок, позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, елемент.ідентифікатор)));
                якщо елемент.ідентифікатор_як.заповнено == позитивне(ні) {
                  покласти_вказівку_Визначити(система, код, рядок,позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, елемент.ідентифікатор)));
                } інакше {
                  покласти_вказівку_Визначити(система, код, рядок, позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, елемент.ідентифікатор_як.значення)));
                }
                пе += 1;
              }
            }
          } інакше {
            покласти_вказівку_Визначити(система, код, рядок, позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані.ідентифікатор_як.значення)));
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиСпробувати {
          ціль дані = елемент.дані як розбирач::ДаніГілкиСпробувати;
          якщо дані.ідентифікатор_зловити.заповнено == позитивне(ні) {
            покласти_вказівку_ПокластиПусто(система, код, рядок);
          } інакше {
            ціль позиція_назви = позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані.ідентифікатор_зловити.значення));
            покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_назви);
          }
          ціль позиція_вказівки_почати_спробу = код.накопичувач_вказівок.розмір;
          покласти_вказівку_ПочатиСпробу(система, код, рядок, 0);
          ціль успіх_компіляції_тіла = перекласти_в_МаМа(система, контекст, дані.тіло, ні, код, вихід_помилки);
          якщо успіх_компіляції_тіла == ні {
            вернути успіх_компіляції_тіла;
          }
          ціль позиція_вказівки_закінчити_спробу = код.накопичувач_вказівок.розмір;
          покласти_вказівку_ЗакінчитиСпробу(система, код, рядок, 0);
          записати_позитивне_в_код_за_позицією(система, код, позиція_вказівки_почати_спробу + 8 + 1, код.накопичувач_вказівок.розмір);
          ціль успіх_компіляції_тіла_зловити = перекласти_в_МаМа(система, контекст, дані.тіло_зловити, ні, код, вихід_помилки);
          якщо успіх_компіляції_тіла_зловити == ні {
            вернути успіх_компіляції_тіла_зловити;
          }
          записати_позитивне_в_код_за_позицією(система, код, позиція_вказівки_закінчити_спробу + 8 + 1, код.накопичувач_вказівок.розмір);
        } інакше якщо елемент.вид == розбирач::ВидГілкиВпасти {
          ціль дані = елемент.дані як розбирач::ДаніГілкиВпасти;
          якщо дані.значення == пусто {
            покласти_вказівку_ПокластиПусто(система, код, рядок);
          } інакше {
            ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, дані.значення, вихід_помилки);
            якщо успіх_перекладу_елемента == ні {
              вернути успіх_перекладу_елемента;
            }
          }
          покласти_вказівку_Впасти(система, код, рядок);
        } інакше якщо елемент.вид == розбирач::ВидГілкиДати {
          ціль дані = елемент.дані як розбирач::ДаніГілкиДати;
          змінна ціль п: позитивне = 0;
          поки п < дані.кількість_елементів {
            ціль елемент = дані.елементи[п];
            ціль позиція_назви = позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, елемент.ідентифікатор));
            покласти_вказівку_Звернутись(система, код, рядок, позиція_назви); // предмет
            якщо елемент.ідентифікатор_як.заповнено == позитивне(так) {
              ціль позиція_назви_як = позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, елемент.ідентифікатор_як.значення));
              покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_назви_як); // назва
            } інакше {
              покласти_вказівку_ПокластиКонстанту(система, код, рядок, позиція_назви); // назва
            }
            покласти_вказівку_Дати(система, код, рядок);
            п += 1;
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиПеребрати {
          ціль дані = елемент.дані як розбирач::ДаніГілкиПеребрати;
          ціль успіх_компіляції_предмета = перекласти_гілку_в_МаМа(система, контекст, код, дані.предмет, вихід_помилки);
          якщо успіх_компіляції_предмета == ні {
            вернути успіх_компіляції_предмета;
          }
          покласти_вказівку_ОтриматиПеребір(система, код, рядок);
          ціль позиція_вказівки_початку_перебору = код.накопичувач_вказівок.розмір;
          покласти_вказівку_ПеребратиДалі(система, код, рядок);
          ціль позиція_вказівки_якщо_ні = код.накопичувач_вказівок.розмір;
          покласти_вказівку_СтрибнутиЯкщоНі(система, код, рядок, 0);
          покласти_вказівку_Дублювати(система, код, рядок);
          покласти_вказівку_ОтриматиВластивість(система, код, рядок, позиція_назви_з_ю8(система, код, ю8"значення"));
          покласти_вказівку_Визначити(система, код, рядок, позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані.ідентифікатор.значення)));
          ціль успіх_компіляції_тіла = перекласти_в_МаМа(система, контекст, дані.тіло, ні, код, вихід_помилки);
          якщо успіх_компіляції_тіла == ні {
            вернути успіх_компіляції_тіла;
          }
          покласти_вказівку_Стрибнути(система, код, рядок, позиція_вказівки_початку_перебору);
          записати_позитивне_в_код_за_позицією(система, код, позиція_вказівки_якщо_ні + 8 + 1, код.накопичувач_вказівок.розмір);
          покласти_вказівку_ПокластиПусто(система, код, рядок);
          покласти_вказівку_Визначити(система, код, рядок, позиція_назви_з_ю8(система, код, розбирач::отримати_ю8_ідентифікатора(контекст.значення_ю8, контекст.слова, дані.ідентифікатор.значення)));
          покласти_вказівку_Забрати(система, код, рядок);
        } інакше якщо елемент.вид == розбирач::ВидГілкиЦикл {
          ціль дані = елемент.дані як розбирач::ДаніГілкиЦикл;
          ціль успіх_компіляції_старту = перекласти_в_МаМа(система, контекст, дані.старт, ні, код, вихід_помилки);
          якщо успіх_компіляції_старту == ні {
            вернути успіх_компіляції_старту;
          }
          ціль позиція_вказівки_початку_циклу = код.накопичувач_вказівок.розмір;
          змінна ціль позиція_вказівки_якщо_ні: позитивне = 0;
          якщо дані.умова != пусто {
            ціль успіх_компіляції_умови = перекласти_гілку_в_МаМа(система, контекст, код, дані.умова, вихід_помилки);
            якщо успіх_компіляції_умови == ні {
              вернути успіх_компіляції_умови;
            }
            позиція_вказівки_якщо_ні = код.накопичувач_вказівок.розмір;
            покласти_вказівку_СтрибнутиЯкщоНі(система, код, рядок, 0);
          }
          ціль контекст_циклу = створити_контекст(система, контекст.значення_ю8, контекст.слова);
          ціль успіх_компіляції_тіла = перекласти_в_МаМа(система, контекст_циклу, дані.тіло, ні, код, вихід_помилки);
          якщо успіх_компіляції_тіла == ні {
            знищити_контекст(система, контекст_циклу);
            вернути успіх_компіляції_тіла;
          }
          ціль успіх_компіляції_ітерації = перекласти_в_МаМа(система, контекст_циклу, дані.ітерація, ні, код, вихід_помилки);
          якщо успіх_компіляції_ітерації == ні {
            знищити_контекст(система, контекст_циклу);
            вернути успіх_компіляції_ітерації;
          }
          знищити_контекст(система, контекст_циклу);
          покласти_вказівку_Стрибнути(система, код, рядок, позиція_вказівки_початку_циклу);
          якщо дані.умова != пусто {
            записати_позитивне_в_код_за_позицією(система, код, позиція_вказівки_якщо_ні + 8 + 1, код.накопичувач_вказівок.розмір);
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиВічнийЦикл {
          ціль дані = елемент.дані як розбирач::ДаніГілкиВічнийЦикл;
          ціль позиція_вказівки_початку_циклу = код.накопичувач_вказівок.розмір;
          ціль контекст_циклу = створити_контекст(система, контекст.значення_ю8, контекст.слова);
          ціль успіх_компіляції_тіла = перекласти_в_МаМа(система, контекст_циклу, дані.тіло, ні, код, вихід_помилки);
          якщо успіх_компіляції_тіла == ні {
            знищити_контекст(система, контекст_циклу);
            вернути успіх_компіляції_тіла;
          }
          знищити_контекст(система, контекст_циклу);
          покласти_вказівку_Стрибнути(система, код, рядок, позиція_вказівки_початку_циклу);
        } інакше якщо елемент.вид == розбирач::ВидГілкиВидалити {
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, елемент, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          якщо вернути_в_кінці {
            якщо пе == гілки.розмір - 1 {
              покласти_вказівку_Вернути(система, код, рядок);
            } інакше {
              покласти_вказівку_Забрати(система, код, рядок);
            }
          } інакше {
            покласти_вказівку_Забрати(система, код, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиВидалитиВластивість {
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, елемент, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          якщо вернути_в_кінці {
            якщо пе == гілки.розмір - 1 {
              покласти_вказівку_Вернути(система, код, рядок);
            } інакше {
              покласти_вказівку_Забрати(система, код, рядок);
            }
          } інакше {
            покласти_вказівку_Забрати(система, код, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиВидалитиЕлемент {
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, елемент, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          якщо вернути_в_кінці {
            якщо пе == гілки.розмір - 1 {
              покласти_вказівку_Вернути(система, код, рядок);
            } інакше {
              покласти_вказівку_Забрати(система, код, рядок);
            }
          } інакше {
            покласти_вказівку_Забрати(система, код, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиДіапазон {
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, елемент, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          якщо вернути_в_кінці {
            якщо пе == гілки.розмір - 1 {
              покласти_вказівку_Вернути(система, код, рядок);
            } інакше {
              покласти_вказівку_Забрати(система, код, рядок);
            }
          } інакше {
            покласти_вказівку_Забрати(система, код, рядок);
          }
        } інакше якщо елемент.вид == розбирач::ВидГілкиЧекати {
          ціль успіх_перекладу_елемента = перекласти_гілку_в_МаМа(система, контекст, код, елемент, вихід_помилки);
          якщо успіх_перекладу_елемента == ні {
            вернути успіх_перекладу_елемента;
          }
          якщо вернути_в_кінці {
            якщо пе == гілки.розмір - 1 {
              покласти_вказівку_Вернути(система, код, рядок);
            } інакше {
              покласти_вказівку_Забрати(система, код, рядок);
            }
          } інакше {
            покласти_вказівку_Забрати(система, код, рядок);
          }
        } інакше {
          вихід_помилки::вміст = ПомилкаПерекладуВМаМа {
            повідомлення = виділити_копію_т8(система, "Виявлено невідомий вид гілки"),
            позиція_слова = 0
          };
          вернути ні;
        }
        пе = пе + 1;
      }

      вернути так;
    }

    зовнішня дія вивести_КодМаМа(система: адреса<Система>, вихідний_потік: адреса<ВихіднийПотік>, код: адреса<Код>) {
      змінна ціль п: позитивне = 0;
      поки п < код.накопичувач_констант.розмір {
        ціль вид_константи = код.накопичувач_констант.дані[п];
        якщо вид_константи == ВидКонстантиНазва {
          п += 1;
          ціль адреса_на_розмір_назви = код.накопичувач_констант.дані[п]::адреса як адреса<позитивне>;
          ціль розмір_назви = адреса_на_розмір_назви::вміст;
          п += 7;
          п += розмір_назви;
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Назва");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вид_константи == ВидКонстантиЧисло {
          п += 1;
          ціль адреса_на_значення = код.накопичувач_констант.дані[п]::адреса як адреса<д64>;
          ціль значення = адреса_на_значення::вміст;
          п += 7;
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Число");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вид_константи == ВидКонстантиТекст {
          п += 1;
          ціль адреса_на_розмір_тексту = код.накопичувач_констант.дані[п]::адреса як адреса<позитивне>;
          ціль розмір_тексту = адреса_на_розмір_тексту::вміст;
          п += 7;
          п += розмір_тексту;
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Текст");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вид_константи == ВидКонстантиЮнікод8 {
          п += 1;
          ціль адреса_на_розмір_юнікоду8 = код.накопичувач_констант.дані[п]::адреса як адреса<позитивне>;
          ціль розмір_юнікоду8 = адреса_на_розмір_юнікоду8::вміст;
          п += 7;
          п += розмір_юнікоду8;
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Юнікод8");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вид_константи == ВидКонстантиЮнікод32 {
          п += 1;
          ціль адреса_на_розмір_юнікоду32 = код.накопичувач_констант.дані[п]::адреса як адреса<позитивне>;
          ціль розмір_юнікоду32 = адреса_на_розмір_юнікоду32::вміст;
          п += 7;
          п += (розмір_юнікоду32 * 4);
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Юнікод32");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вид_константи == ВидКонстантиКод {
          п += 1;
          ціль адреса_на_розмір_констант = код.накопичувач_констант.дані[п]::адреса як адреса<позитивне>;
          ціль розмір_констант = адреса_на_розмір_констант::вміст;
          п += 7;
          п += (розмір_констант);
          п += 1;
          ціль адреса_на_розмір_вказівок = код.накопичувач_констант.дані[п]::адреса як адреса<позитивне>;
          ціль розмір_вказівок = адреса_на_розмір_вказівок::вміст;
          п += 7;
          п += (розмір_вказівок);
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Код");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"НЕВІДОМА_КОНСТАНТА");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        }
        п += 1;
      }
      п = 0;
      поки п < код.накопичувач_вказівок.розмір {
        ціль вказівка = код.накопичувач_вказівок.дані[п];
        ціль рядок_вказівки: позитивне = 0;
        п += 8;
        якщо вказівка == ВПокластиПусто {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВПокластиПусто");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВПокластиТак {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВПокластиТак");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВПокластиНі {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВПокластиНі");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВПокластиКонстанту {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВПокластиКонстанту");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВСтворитиДію {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВСтворитиДію");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВСтворитиСтруктуру {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВСтворитиСтруктуру");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВСтворитиМодуль {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВСтворитиМодуль");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВСтворитиСписок {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВСтворитиСписок");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВПокластиВСписок {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВПокластиВСписок");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВСтворитиСловник {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВСтворитиСловник");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВПокластиВСловник {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВПокластиВСловник");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВПокластиСтруктуруПредмет {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВПокластиСтруктуруПредмет");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВПокластиЯ {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВПокластиЯ");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВЗаписатиМетод {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВЗаписатиМетод");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВЗаписатиСпецДію {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВЗаписатиСпецДію");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВСтворитиДіапазон {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВСтворитиДіапазон");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВВизначити {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВВизначити");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВЗвернутись {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВЗвернутись");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВВиконати {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВВиконати");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
          п += 8;
        } інакше якщо вказівка == ВОтриматиВластивість {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВОтриматиВластивість");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВЗмінитиВластивість {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВЗмінитиВластивість");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВВиконатиВластивість {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВВиконатиВластивість");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
          п += 8;
        } інакше якщо вказівка == ВОтриматиЕлемент {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВОтриматиЕлемент");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВЗмінитиЕлемент {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВЗмінитиЕлемент");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВОтриматиПеребір {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВОтриматиПеребір");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВВизначитиЗзовні {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВВизначитиЗзовні");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВВиконатиЗПредка {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВВиконатиЗПредка");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
          п += 8;
        } інакше якщо вказівка == ВВидалити {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВВидалити");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВВидалитиВластивість {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВВидалитиВластивість");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВВидалитиЕлемент {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВВидалитиЕлемент");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВДодати {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВДодати");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВВідняти {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВВідняти");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВПомножити {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВПомножити");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВПоділити {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВПоділити");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВОтриматиОстачуДілення {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВОтриматиОстачуДілення");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВОтриматиНеповнуЧасткуДілення {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВОтриматиНеповнуЧасткуДілення");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВПіднестиДоСтепеня {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВПіднестиДоСтепеня");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВЗсунутиВліво {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВЗсунутиВліво");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВЗсунутиВправо {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВЗсунутиВправо");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВЗсунутиВправоЗіЗаповненням {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВЗсунутиВправоЗіЗаповненням");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВДвійковеІ {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВДвійковеІ");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВДвійковеАБО {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВДвійковеАБО");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВДвійковеВиключнеАБО {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВДвійковеВиключнеАБО");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВДвійковеНЕ {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВДвійковеНЕ");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВМенше {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВМенше");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВБільше {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВБільше");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВНеБільше {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВНеБільше");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВНеМенше {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВНеМенше");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВРівно {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВРівно");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВНеРівно {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВНеРівно");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВМістить {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВМістить");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВНеМістить {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВНеМістить");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВЄ {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВЄ");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВНеЄ {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВНеЄ");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВВідʼємне {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВВідʼємне");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВЧислове {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВЧислове");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВЗаперечити {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВЗаперечити");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВЗбільшити {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВЗбільшити");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВЗбільшитиПопереднє {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВЗбільшитиПопереднє");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВЗменшити {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВЗменшити");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВПочатиСпробу {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВПочатиСпробу");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВВпасти {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВВпасти");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВЗакінчитиСпробу {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВЗакінчитиСпробу");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВВзяти {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВВзяти");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВДати {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВДати");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВПеребратиДалі {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВПеребратиДалі");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВЗбитиТекст {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВЗбитиТекст");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВЗбитиЮнікод {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВЗбитиЮнікод");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВСтворитиПараметр {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВСтворитиПараметр");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВСтворитиТип {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВСтворитиТип");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВСтрибнути {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВСтрибнути");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВСтрибнутиЯкщоНі {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВСтрибнутиЯкщоНі");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВЗабрати {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВЗабрати");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВВернути {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВВернути");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВСтрибнутиЯкщоНіЗалишивши {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВСтрибнутиЯкщоНіЗалишивши");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВСтрибнутиЯкщоТак {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВСтрибнутиЯкщоТак");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВСтрибнутиЯкщоТакЗалишивши {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВСтрибнутиЯкщоТакЗалишивши");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
          п += 8;
        } інакше якщо вказівка == ВДублювати {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВДублювати");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше якщо вказівка == ВДублюватиПопереднє {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВДублюватиПопереднє");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        } інакше {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"НЕВІДОМА_ВКАЗІВКА");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\n");
        }
        п += 1;
      }
    }
  }
}