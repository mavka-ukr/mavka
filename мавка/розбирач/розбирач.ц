взяти визначення ./розбирач;

секція мавка {
  секція розбирач {
    структура Накопичувач<Т> {
      розмір: позитивне;
      вмісткість: позитивне;
      дані: памʼять<Т>;
    }

    дія зробити_накопичувач<Т>(система: адреса<Система>): Накопичувач<Т> {
      вернути Накопичувач<Т> {
        розмір = 0,
        вмісткість = 0,
        дані = пусто
      };
    }

    дія покласти_в_накопичувач<Т>(система: адреса<Система>, накопичувач: адреса<Накопичувач<Т>>, дані: Т) {
      якщо накопичувач.розмір == накопичувач.вмісткість {
        накопичувач.вмісткість += 1;
        накопичувач.дані = перевиділити_памʼять<Т>(система, накопичувач.дані, накопичувач.вмісткість);
      }
      накопичувач.дані[накопичувач.розмір] = дані;
      накопичувач.розмір += 1;
    }

    дія звільнити_дані_накопичувача<Т>(система: адреса<Система>, накопичувач: Накопичувач<Т>) {
      звільнити_памʼять(система, накопичувач.дані);
    }

    дія дописати_ю8_у_вихідний_потік(система: адреса<Система>, вихідний_потік: адреса<ВихіднийПотік>, значення_ю8: ю8) {
      вихідний_потік.дописати(система, вихідний_потік, значення_ю8.розмір, значення_ю8.дані);
    }

    дія дописати_п64_у_вихідний_потік(система: адреса<Система>, вихідний_потік: адреса<ВихіднийПотік>, значення: п64) {
//      змінна значення_ю8 = ю8 { 0, пусто };
//      значення_ю8.розмір = позитивне(лонг_ту_чарс(лонг(значення), значення_ю8.дані::адреса як адреса<памʼять<п8>>));
//      вихідний_потік.дописати(система, вихідний_потік, значення_ю8.розмір, значення_ю8.дані);
    }
  }
}

секція мавка {
  секція розбирач {
    місцева дія визначити_розмір_символа_юнікоду(перший_байт: п8): п8 {
      якщо (перший_байт & 128) == 0 {
        вернути 1;
      }
      якщо (перший_байт & 224) == 192 {
        вернути 2;
      }
      якщо (перший_байт & 240) == 224 {
        вернути 3;
      }
      якщо (перший_байт & 248) == 240 {
        вернути 4;
      }
      вернути 0;
    }

    дія виділити_копію_ю8(система: адреса<Система>, вхід: ю8, вихід: адреса<ю8>): логічне {
      змінна дані = виділити_памʼять<п8>(система, вхід.розмір);
      змінна п: позитивне = 0;
      поки п < вхід.розмір {
        дані[п] = вхід.дані[п];
        п += 1;
      }
      вихід::вміст = ю8 { вхід.розмір, дані };
      вернути так;
    }
  }
}

секція мавка {
  секція розбирач {
    дія перевірити_чи_початок_ідентифікатора(система: адреса<Система>, значення_ю8: ю8, позиція_початку: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>): логічне;
    дія перевірити_чи_продовження_ідентифікатора(система: адреса<Система>, значення_ю8: ю8, позиція_початку: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>): логічне;
    дія перевірити_чи_має_ю8_за_позицією_початку(система: адреса<Система>, значення_ю8: ю8, позиція_початку: ПозиціяСлова, значення: ю8, вихід_позиції_кінця: адреса<ПозиціяСлова>): логічне;
    дія перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система: адреса<Система>, значення_ю8: ю8, позиція_початку: ПозиціяСлова, значення: ю8, вихід_позиції_кінця: адреса<ПозиціяСлова>, вихід_це_ідентифікатор: адреса<логічне>): логічне;
    дія перевірити_чи_число(система: адреса<Система>, значення_ю8: ю8, позиція_початку: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>): логічне;
    дія перевірити_чи_має_ідентифікатор_за_позицією_початку(система: адреса<Система>, значення_ю8: ю8, позиція_початку: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>): логічне;

    дія перевірити_чи_початок_ідентифікатора(система: адреса<Система>, значення_ю8: ю8, позиція_початку: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>): логічне {
      якщо позиція_початку.позиція_символа >= значення_ю8.розмір {
        вернути ні;
      }
      якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"а", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"б", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"в", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"г", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"д", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"е", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"є", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"ж", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"з", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"и", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"і", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"ї", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"й", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"к", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"л", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"м", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"н", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"о", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"п", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"р", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"с", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"т", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"у", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"ф", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"х", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"ц", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"ч", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"ш", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"щ", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"ь", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"ю", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"я", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"ґ", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"А", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Б", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"В", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Г", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Д", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Е", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Є", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Ж", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"З", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"И", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"І", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Ї", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Й", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"К", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Л", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"М", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Н", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"О", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"П", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Р", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"С", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Т", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"У", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Ф", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Х", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Ц", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Ч", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Ш", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Щ", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Ь", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Ю", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Я", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Ґ", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"_", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"ʼ", вихід_позиції_кінця) {
      } інакше {
        вернути ні;
      }
      вернути так;
    }

    дія перевірити_чи_продовження_ідентифікатора(система: адреса<Система>, значення_ю8: ю8, позиція_початку: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>): логічне {
      якщо позиція_початку.позиція_символа >= значення_ю8.розмір {
        вернути ні;
      }
      якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"а", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"б", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"в", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"г", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"д", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"е", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"є", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"ж", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"з", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"и", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"і", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"ї", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"й", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"к", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"л", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"м", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"н", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"о", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"п", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"р", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"с", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"т", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"у", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"ф", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"х", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"ц", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"ч", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"ш", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"щ", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"ь", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"ю", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"я", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"ґ", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"А", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Б", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"В", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Г", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Д", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Е", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Є", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Ж", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"З", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"И", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"І", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Ї", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Й", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"К", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Л", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"М", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Н", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"О", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"П", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Р", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"С", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Т", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"У", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Ф", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Х", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Ц", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Ч", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Ш", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Щ", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Ь", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Ю", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Я", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Ґ", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"_", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"ʼ", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"0", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"1", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"2", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"3", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"4", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"5", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"6", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"7", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"8", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"9", вихід_позиції_кінця) {
      } інакше {
        вернути ні;
      }
      вернути так;
    }

    дія перевірити_чи_має_ю8_за_позицією_початку(система: адреса<Система>, значення_ю8: ю8, позиція_початку: ПозиціяСлова, значення: ю8, вихід_позиції_кінця: адреса<ПозиціяСлова>): логічне {
      якщо позиція_початку.позиція_символа >= значення_ю8.розмір {
        вернути ні;
      }
      вихід_позиції_кінця::вміст = позиція_початку;
      змінна п: позитивне = 0;
      поки п < значення.розмір {
        змінна розмір_символа = визначити_розмір_символа_юнікоду(значення.дані[п]);
        якщо розмір_символа == 1 {
          якщо (позиція_початку.позиція_символа + п) >= значення_ю8.розмір {
            вернути ні;
          }
          якщо значення_ю8.дані[позиція_початку.позиція_символа + п] != значення.дані[п] {
            вернути ні;
          }
          якщо значення.дані[п] == ЮНІКОД_РОЗРИВ {
            вихід_позиції_кінця.позиція_символа = позиція_початку.позиція_символа + п;
            вихід_позиції_кінця.рядок += 1;
          } інакше {
            вихід_позиції_кінця.позиція_символа = позиція_початку.позиція_символа + п;
            вихід_позиції_кінця.рядок = позиція_початку.рядок;
          }
          п += 1;
        } інакше якщо розмір_символа == 2 {
          якщо (позиція_початку.позиція_символа + п + 1) >= значення_ю8.розмір {
            вернути ні;
          }
          якщо значення_ю8.дані[позиція_початку.позиція_символа + п] != значення.дані[п] {
            вернути ні;
          }
          якщо значення_ю8.дані[позиція_початку.позиція_символа + п + 1] != значення.дані[п + 1] {
            вернути ні;
          }
          вихід_позиції_кінця.позиція_символа = позиція_початку.позиція_символа + п + 1;
          вихід_позиції_кінця.рядок = позиція_початку.рядок;
          п += 2;
        } інакше якщо розмір_символа == 3 {
          якщо (позиція_початку.позиція_символа + п + 1 + 1) >= значення_ю8.розмір {
            вернути ні;
          }
          якщо значення_ю8.дані[позиція_початку.позиція_символа + п] != значення.дані[п] {
            вернути ні;
          }
          якщо значення_ю8.дані[позиція_початку.позиція_символа + п + 1] != значення.дані[п + 1] {
            вернути ні;
          }
          якщо значення_ю8.дані[позиція_початку.позиція_символа + п + 1 + 1] != значення.дані[п + 1 + 1] {
            вернути ні;
          }
          вихід_позиції_кінця.позиція_символа = позиція_початку.позиція_символа + п + 1 + 1;
          вихід_позиції_кінця.рядок = позиція_початку.рядок;
          п += 3;
        } інакше якщо розмір_символа == 4 {
          якщо (позиція_початку.позиція_символа + п + 1 + 1 + 1) >= значення_ю8.розмір {
            вернути ні;
          }
          якщо значення_ю8.дані[позиція_початку.позиція_символа + п] != значення.дані[п] {
            вернути ні;
          }
          якщо значення_ю8.дані[позиція_початку.позиція_символа + п + 1] != значення.дані[п + 1] {
            вернути ні;
          }
          якщо значення_ю8.дані[позиція_початку.позиція_символа + п + 1 + 1] != значення.дані[п + 1 + 1] {
            вернути ні;
          }
          якщо значення_ю8.дані[позиція_початку.позиція_символа + п + 1 + 1 + 1] != значення.дані[п + 1 + 1 + 1] {
            вернути ні;
          }
          вихід_позиції_кінця.позиція_символа = позиція_початку.позиція_символа + п + 1 + 1 + 1;
          вихід_позиції_кінця.рядок = позиція_початку.рядок;
          п += 4;
        } інакше {
          вернути ні;
        }
      }
      вернути так;
    }

    дія перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система: адреса<Система>, значення_ю8: ю8, позиція_початку: ПозиціяСлова, значення: ю8, вихід_позиції_кінця: адреса<ПозиціяСлова>, вихід_це_ідентифікатор: адреса<логічне>): логічне {
      якщо позиція_початку.позиція_символа >= значення_ю8.розмір {
        вернути ні;
      }
      вихід_позиції_кінця::вміст = позиція_початку;
      змінна п: позитивне = 0;
      поки п < значення.розмір {
        змінна розмір_символа = визначити_розмір_символа_юнікоду(значення.дані[п]);
        якщо розмір_символа == 1 {
          якщо (позиція_початку.позиція_символа + п) >= значення_ю8.розмір {
            вернути ні;
          }
          якщо значення_ю8.дані[позиція_початку.позиція_символа + п] != значення.дані[п] {
            вернути ні;
          }
          вихід_позиції_кінця.позиція_символа = позиція_початку.позиція_символа + п;
          вихід_позиції_кінця.рядок = позиція_початку.рядок;
          п += 1;
        } інакше якщо розмір_символа == 2 {
          якщо (позиція_початку.позиція_символа + п + 1) >= значення_ю8.розмір {
            вернути ні;
          }
          якщо значення_ю8.дані[позиція_початку.позиція_символа + п] != значення.дані[п] {
            вернути ні;
          }
          якщо значення_ю8.дані[позиція_початку.позиція_символа + п + 1] != значення.дані[п + 1] {
            вернути ні;
          }
          вихід_позиції_кінця.позиція_символа = позиція_початку.позиція_символа + п + 1;
          вихід_позиції_кінця.рядок = позиція_початку.рядок;
          п += 2;
        } інакше якщо розмір_символа == 3 {
          якщо (позиція_початку.позиція_символа + п + 1 + 1) >= значення_ю8.розмір {
            вернути ні;
          }
          якщо значення_ю8.дані[позиція_початку.позиція_символа + п] != значення.дані[п] {
            вернути ні;
          }
          якщо значення_ю8.дані[позиція_початку.позиція_символа + п + 1] != значення.дані[п + 1] {
            вернути ні;
          }
          якщо значення_ю8.дані[позиція_початку.позиція_символа + п + 1 + 1] != значення.дані[п + 1 + 1] {
            вернути ні;
          }
          вихід_позиції_кінця.позиція_символа = позиція_початку.позиція_символа + п + 1 + 1;
          вихід_позиції_кінця.рядок = позиція_початку.рядок;
          п += 3;
        } інакше якщо розмір_символа == 4 {
          якщо (позиція_початку.позиція_символа + п + 1 + 1 + 1) >= значення_ю8.розмір {
            вернути ні;
          }
          якщо значення_ю8.дані[позиція_початку.позиція_символа + п] != значення.дані[п] {
            вернути ні;
          }
          якщо значення_ю8.дані[позиція_початку.позиція_символа + п + 1] != значення.дані[п + 1] {
            вернути ні;
          }
          якщо значення_ю8.дані[позиція_початку.позиція_символа + п + 1 + 1] != значення.дані[п + 1 + 1] {
            вернути ні;
          }
          якщо значення_ю8.дані[позиція_початку.позиція_символа + п + 1 + 1 + 1] != значення.дані[п + 1 + 1 + 1] {
            вернути ні;
          }
          вихід_позиції_кінця.позиція_символа = позиція_початку.позиція_символа + п + 1 + 1 + 1;
          вихід_позиції_кінця.рядок = позиція_початку.рядок;
          п += 4;
        } інакше {
          вернути ні;
        }
      }
      якщо (позиція_початку.позиція_символа + п) >= значення_ю8.розмір {
        вернути так;
      }
      змінна пкп = ПозиціяСлова { 0, 0, 0 };
      якщо перевірити_чи_продовження_ідентифікатора(система, значення_ю8, ПозиціяСлова { позиція_початку.позиція_символа + п, вихід_позиції_кінця.рядок, вихід_позиції_кінця.стовпець }, пкп::адреса) {
        вихід_це_ідентифікатор::вміст = так;
        вернути ні;
      }
      вернути так;
    }

    дія перевірити_чи_продовження_0ш(система: адреса<Система>, значення_ю8: ю8, позиція_початку: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>): логічне {
      якщо позиція_початку.позиція_символа >= значення_ю8.розмір {
        вернути ні;
      }
      якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"а", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"б", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"в", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"г", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"д", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"е", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"А", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Б", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"В", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Г", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Д", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"Е", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"0", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"1", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"2", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"3", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"4", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"5", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"6", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"7", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"8", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"9", вихід_позиції_кінця) {
      } інакше {
        вернути ні;
      }
      вернути так;
    }

    дія перевірити_чи_продовження_0д(система: адреса<Система>, значення_ю8: ю8, позиція_початку: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>): логічне {
      якщо позиція_початку.позиція_символа >= значення_ю8.розмір {
        вернути ні;
      }
      якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"0", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, позиція_початку, ю8"1", вихід_позиції_кінця) {
      } інакше {
        вернути ні;
      }
      вернути так;
    }

    дія перевірити_чи_число(система: адреса<Система>, значення_ю8: ю8, позиція_початку: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>): логічне {
      змінна має_крапку: логічне = ні;
      змінна має_символ_після_крапки: логічне = ні;
      змінна п = позиція_початку;
      якщо п.позиція_символа >= значення_ю8.розмір {
        вернути ні;
      }
      якщо значення_ю8.дані[п.позиція_символа] == ЮНІКОД_0 {
        п.позиція_символа += 1;
        якщо п.позиція_символа >= значення_ю8.розмір {
          п.позиція_символа -= 1;
          вихід_позиції_кінця::вміст = п;
          вернути так;
        } інакше {
          якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"ш", п::адреса) {
            п.позиція_символа += 1;
            якщо перевірити_чи_продовження_0ш(система, значення_ю8, п, п::адреса) == ні {
              вернути ні;
            }
            п.позиція_символа += 1;
            поки перевірити_чи_продовження_0ш(система, значення_ю8, п, п::адреса) {
              п.позиція_символа += 1;
            }
            п.позиція_символа -= 1;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"Ш", п::адреса) {
            п.позиція_символа += 1;
            якщо перевірити_чи_продовження_0ш(система, значення_ю8, п, п::адреса) == ні {
              вернути ні;
            }
            п.позиція_символа += 1;
            поки перевірити_чи_продовження_0ш(система, значення_ю8, п, п::адреса) {
              п.позиція_символа += 1;
            }
            п.позиція_символа -= 1;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"д", п::адреса) {
            п.позиція_символа += 1;
            якщо перевірити_чи_продовження_0д(система, значення_ю8, п, п::адреса) == ні {
              вернути ні;
            }
            п.позиція_символа += 1;
            поки перевірити_чи_продовження_0д(система, значення_ю8, п, п::адреса) {
              п.позиція_символа += 1;
            }
            п.позиція_символа -= 1;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          } інакше якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"Д", п::адреса) {
            п.позиція_символа += 1;
            якщо перевірити_чи_продовження_0д(система, значення_ю8, п, п::адреса) == ні {
              вернути ні;
            }
            п.позиція_символа += 1;
            поки перевірити_чи_продовження_0д(система, значення_ю8, п, п::адреса) {
              п.позиція_символа += 1;
            }
            п.позиція_символа -= 1;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          }
        }
      } інакше якщо значення_ю8.дані[п.позиція_символа] == ЮНІКОД_1 {
        п.позиція_символа += 1;
      } інакше якщо значення_ю8.дані[п.позиція_символа] == ЮНІКОД_2 {
        п.позиція_символа += 1;
      } інакше якщо значення_ю8.дані[п.позиція_символа] == ЮНІКОД_3 {
        п.позиція_символа += 1;
      } інакше якщо значення_ю8.дані[п.позиція_символа] == ЮНІКОД_4 {
        п.позиція_символа += 1;
      } інакше якщо значення_ю8.дані[п.позиція_символа] == ЮНІКОД_5 {
        п.позиція_символа += 1;
      } інакше якщо значення_ю8.дані[п.позиція_символа] == ЮНІКОД_6 {
        п.позиція_символа += 1;
      } інакше якщо значення_ю8.дані[п.позиція_символа] == ЮНІКОД_7 {
        п.позиція_символа += 1;
      } інакше якщо значення_ю8.дані[п.позиція_символа] == ЮНІКОД_8 {
        п.позиція_символа += 1;
      } інакше якщо значення_ю8.дані[п.позиція_символа] == ЮНІКОД_9 {
        п.позиція_символа += 1;
      } інакше {
        вернути ні;
      }
      перевірка_продовження_числа:
      якщо п.позиція_символа >= значення_ю8.розмір {
        якщо має_крапку {
          якщо має_символ_після_крапки {
            п.позиція_символа -= 1;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          } інакше {
            вернути ні;
          }
        }
        п.позиція_символа -= 1;
        вихід_позиції_кінця::вміст = п;
        вернути так;
      }
      якщо значення_ю8.дані[п.позиція_символа] == ЮНІКОД_КРАПКА {
        якщо має_крапку {
          якщо має_символ_після_крапки {
            п.позиція_символа -= 1;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          } інакше {
            п.позиція_символа -= 2;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          }
        } інакше {
          має_крапку = так;
          п.позиція_символа += 1;
          стрибнути перевірка_продовження_числа;
        }
      }
      якщо значення_ю8.дані[п.позиція_символа] == ЮНІКОД_0 {
        якщо має_крапку { має_символ_після_крапки = так; }
        п.позиція_символа += 1;
        стрибнути перевірка_продовження_числа;
      }
      якщо значення_ю8.дані[п.позиція_символа] == ЮНІКОД_1 {
        якщо має_крапку { має_символ_після_крапки = так; }
        п.позиція_символа += 1;
        стрибнути перевірка_продовження_числа;
      }
      якщо значення_ю8.дані[п.позиція_символа] == ЮНІКОД_2 {
        якщо має_крапку { має_символ_після_крапки = так; }
        п.позиція_символа += 1;
        стрибнути перевірка_продовження_числа;
      }
      якщо значення_ю8.дані[п.позиція_символа] == ЮНІКОД_3 {
        якщо має_крапку { має_символ_після_крапки = так; }
        п.позиція_символа += 1;
        стрибнути перевірка_продовження_числа;
      }
      якщо значення_ю8.дані[п.позиція_символа] == ЮНІКОД_4 {
        якщо має_крапку { має_символ_після_крапки = так; }
        п.позиція_символа += 1;
        стрибнути перевірка_продовження_числа;
      }
      якщо значення_ю8.дані[п.позиція_символа] == ЮНІКОД_5 {
        якщо має_крапку { має_символ_після_крапки = так; }
        п.позиція_символа += 1;
        стрибнути перевірка_продовження_числа;
      }
      якщо значення_ю8.дані[п.позиція_символа] == ЮНІКОД_6 {
        якщо має_крапку { має_символ_після_крапки = так; }
        п.позиція_символа += 1;
        стрибнути перевірка_продовження_числа;
      }
      якщо значення_ю8.дані[п.позиція_символа] == ЮНІКОД_7 {
        якщо має_крапку { має_символ_після_крапки = так; }
        п.позиція_символа += 1;
        стрибнути перевірка_продовження_числа;
      }
      якщо значення_ю8.дані[п.позиція_символа] == ЮНІКОД_8 {
        якщо має_крапку { має_символ_після_крапки = так; }
        п.позиція_символа += 1;
        стрибнути перевірка_продовження_числа;
      }
      якщо значення_ю8.дані[п.позиція_символа] == ЮНІКОД_9 {
        якщо має_крапку { має_символ_після_крапки = так; }
        п.позиція_символа += 1;
        стрибнути перевірка_продовження_числа;
      }
      якщо має_крапку {
        якщо має_символ_після_крапки {
          п.позиція_символа -= 1;
          вихід_позиції_кінця::вміст = п;
          вернути так;
        } інакше {
          вернути ні;
        }
      }
      п.позиція_символа -= 1;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія перевірити_чи_має_ідентифікатор_за_позицією_початку(система: адреса<Система>, значення_ю8: ю8, позиція_початку: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>): логічне {
      якщо позиція_початку.позиція_символа >= значення_ю8.розмір {
        вернути ні;
      }
      змінна п = позиція_початку;
      якщо перевірити_чи_початок_ідентифікатора(система, значення_ю8, п, п::адреса) {
      } інакше {
        вихід_позиції_кінця::вміст = п;
        вернути ні;
      }
      п.позиція_символа += 1;
      змінна є_продовження: логічне = так;
      поки є_продовження {
        якщо перевірити_чи_продовження_ідентифікатора(система, значення_ю8, п, п::адреса) {
          п.позиція_символа += 1;
        } інакше {
          вихід_позиції_кінця::вміст = п;
          є_продовження = ні;
        }
      }
      п.позиція_символа -= 1;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія розібрати_ю8_на_слова_0(система: адреса<Система>, значення_ю8: ю8, позиція_початку: ПозиціяСлова, до_закритої_дужки: логічне, вихід_позиції_кінця: адреса<ПозиціяСлова>, вихід: адреса<Слова>, вихід_помилки: адреса<ПомилкаРозборуНаСлова>): логічне {
      змінна накопичувач_слів = зробити_накопичувач<Слово>(система);

      змінна п = позиція_початку;
      змінна позиція_помилки = ПозиціяСлова { 0, 0, 0 };
      поки п.позиція_символа < значення_ю8.розмір {
        якщо значення_ю8.дані[п.позиція_символа] == ЮНІКОД_ПРОПУСК {
          стрибнути далі;
        }
        змінна позиція_кінця = ПозиціяСлова { 0, 1, 1 };
        змінна це_ідентифікатор: логічне = ні;
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"кінець", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаКінець,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"дія", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаДія,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"структура", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСтруктура,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"перебрати", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаПеребрати,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"цикл", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаЦикл,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"як", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаЯк,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"якщо", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаЯкщо,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"чекати", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаЧекати,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"взяти", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаВзяти,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"дати", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаДати,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"є", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаЄ,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"вернути", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаВернути,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"тривала", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаТривала,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"власна", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаВласна,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"і", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаІ,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"інакше", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаІнакше,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"або", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаАбо,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"спробувати", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСпробувати,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"зловити", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаЗловити,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"впасти", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаВпасти,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"поки", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаПоки,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"модуль", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаМодуль,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"рівно", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаРівно,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"більше", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаБільше,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"менше", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаМенше,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"містить", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаМістить,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"не", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаНе,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"це", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаЦе,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"перелік", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаПерелік,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"композиція", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаКомпозиція,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"зовнішня", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаЗовнішня,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"внутрішня", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаВнутрішня,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"місцева", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаМісцева,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"властивість", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаВластивість,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ключове_слово_ю8_за_позицією_початку(система, значення_ю8, п, ю8"видалити", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаВидалити,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"=", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволРівно,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8">", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволБільше,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"<", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволМенше,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8".", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволКрапка,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"+", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволПлюс,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"-", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволМінус,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"*", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволПомножити,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"/", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволПоділити,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"%", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволЗалишку,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"∧", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволПірамідка,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"&", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволІ,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"|", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволАбо,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"(", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволВідкритаДужка,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8")", позиція_кінця::адреса) {
          якщо до_закритої_дужки {
            вихід::вміст = Слова {
              накопичувач_слів.розмір,
              накопичувач_слів.дані
            };
            вихід_позиції_кінця::вміст = позиція_кінця;
            вернути так;
          }
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволЗакритаДужка,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"[", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволКвадратнаВідкритаДужка,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"]", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволКвадратнаЗакритаДужка,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"?", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволЗнакПитання,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8":", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволДвокрапка,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"~", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволТильда,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"!", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволЗнакОклику,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8",", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволКома,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"\р", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволМіжряд,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { ... }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"'", позиція_кінця::адреса) {
          змінна пп = позиція_кінця;
          пп.позиція_символа += 1;
          змінна закінчено: логічне = ні;
          поки пп.позиція_символа < значення_ю8.розмір {
            якщо значення_ю8.дані[пп.позиція_символа] == ЮНІКОД_ОБЕРНЕНА_ПОХИЛА {
              пп.позиція_символа += 1;
              стрибнути далі3;
            }
            якщо значення_ю8.дані[пп.позиція_символа] == ЮНІКОД_ЛАПКА {
              закінчено = так;
              стрибнути закінчити_перебір_символів;
            }
            якщо значення_ю8.дані[пп.позиція_символа] == ЮНІКОД_РОЗРИВ {
              пп.рядок += 1;
              стрибнути закінчити_перебір_символів;
            }
            далі3:
            пп.позиція_символа += 1;
          }
          закінчити_перебір_символів:
          якщо закінчено {
            покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
              вид = ВидСловаСимвол,
              позиція_початку = п,
              позиція_кінця = пп,
              значення = ю8 { (пп.позиція_символа - п.позиція_символа) - 1, значення_ю8.дані[п.позиція_символа + 1]::адреса як памʼять<п8> }
            });
            п = пп;
            стрибнути далі;
          }
          стрибнути вийти_з_помилкою;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"\"\"\"", позиція_кінця::адреса) {
          змінна пп = позиція_кінця;
          пп.позиція_символа += 1;
          змінна закінчено = ні;
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаПочатокЗбитогоТексту,
            позиція_початку = п,
            позиція_кінця = пп,
            значення = ю8 { ... }
          });
          п = пп;
          п.позиція_символа -= 1;
          поки пп.позиція_символа < значення_ю8.розмір {
            якщо значення_ю8.дані[пп.позиція_символа] == ЮНІКОД_ОБЕРНЕНА_ПОХИЛА {
              пп.позиція_символа += 1;
              стрибнути багаторяд_далі1;
            }
            якщо значення_ю8.дані[пп.позиція_символа] == ЮНІКОД_ВІДСОТОК {
              пп.позиція_символа += 1;
              якщо значення_ю8.дані[пп.позиція_символа] == ЮНІКОД_ВІДКРИТА_ДУЖКА {
                покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
                  вид = ВидСловаЧастинаЗбитогоТексту,
                  позиція_початку = п,
                  позиція_кінця = пп,
                  значення = ю8 { пп.позиція_символа - п.позиція_символа - 1 - 1, значення_ю8.дані[п.позиція_символа + 1]::адреса як памʼять<п8> }
                });
                покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
                  вид = ВидСловаРоздільникЗбитогоТексту,
                  позиція_початку = п,
                  позиція_кінця = пп,
                  значення = ю8 { ... }
                });
                п = пп;
                пп.позиція_символа += 1;
                змінна слова = Слова { 0, пусто };
                змінна помилка_розбору_на_слова = ПомилкаРозборуНаСлова { ... };
                якщо розібрати_ю8_на_слова_0(система, значення_ю8, пп, так, пп::адреса, слова::адреса, помилка_розбору_на_слова::адреса) {
                  змінна ппп: позитивне = 0;
                  поки ппп < слова.розмір {
                    покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, слова.дані[ппп]);
                    ппп += 1;
                  }
                  звільнити_памʼять(система, слова.дані);
                  покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
                    вид = ВидСловаРоздільникЗбитогоТексту,
                    позиція_початку = п,
                    позиція_кінця = пп,
                    значення = ю8 { ... }
                  });
                  п = пп;
                  стрибнути багаторяд_далі1;
                } інакше {
                  вихід_помилки::вміст = помилка_розбору_на_слова;
                  вернути ні;
                }
              } інакше {
                пп.позиція_символа -= 1;
              }
            }
            якщо значення_ю8.дані[пп.позиція_символа] == ЮНІКОД_ОБЕРНЕНА_ПОХИЛА {
              стрибнути багаторяд_далі1;
            }
            якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, пп, ю8"\"\"\"", пп::адреса) {
              закінчено = так;
              стрибнути закінчити_перебір_багаторядкового_тексту;
            }
            багаторяд_далі1:
            пп.позиція_символа += 1;
          }
          закінчити_перебір_багаторядкового_тексту:
          якщо закінчено {
            покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
              вид = ВидСловаЧастинаЗбитогоТексту,
              позиція_початку = п,
              позиція_кінця = пп,
              значення = ю8 { пп.позиція_символа - п.позиція_символа - 3, значення_ю8.дані[п.позиція_символа + 1]::адреса як памʼять<п8> }
            });
            п = пп;
            покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
              вид = ВидСловаКінецьЗбитогоТексту,
              позиція_початку = п,
              позиція_кінця = пп,
              значення = ю8 { ... }
            });
            стрибнути далі;
          }
          стрибнути вийти_з_помилкою;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8"\"", позиція_кінця::адреса) {
          змінна пп = позиція_кінця;
          пп.позиція_символа += 1;
          змінна закінчено = ні;
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаПочатокЗбитогоТексту,
            позиція_початку = п,
            позиція_кінця = пп,
            значення = ю8 { ... }
          });
          поки пп.позиція_символа < значення_ю8.розмір {
            якщо значення_ю8.дані[пп.позиція_символа] == ЮНІКОД_ОБЕРНЕНА_ПОХИЛА {
              пп.позиція_символа += 1;
              стрибнути далі1;
            }
            якщо значення_ю8.дані[пп.позиція_символа] == ЮНІКОД_ВІДСОТОК {
              пп.позиція_символа += 1;
              якщо значення_ю8.дані[пп.позиція_символа] == ЮНІКОД_ВІДКРИТА_ДУЖКА {
                покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
                  вид = ВидСловаЧастинаЗбитогоТексту,
                  позиція_початку = п,
                  позиція_кінця = пп,
                  значення = ю8 { пп.позиція_символа - п.позиція_символа - 1 - 1, значення_ю8.дані[п.позиція_символа + 1]::адреса як памʼять<п8> }
                });
                покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
                  вид = ВидСловаРоздільникЗбитогоТексту,
                  позиція_початку = п,
                  позиція_кінця = пп,
                  значення = ю8 { ... }
                });
                п = пп;
                пп.позиція_символа += 1;
                змінна слова = Слова { 0, пусто };
                змінна помилка_розбору_на_слова = ПомилкаРозборуНаСлова { ... };
                якщо розібрати_ю8_на_слова_0(система, значення_ю8, пп, так, пп::адреса, слова::адреса, помилка_розбору_на_слова::адреса) {
                  змінна ппп: позитивне = 0;
                  поки ппп < слова.розмір {
                    покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, слова.дані[ппп]);
                    ппп += 1;
                  }
                  звільнити_памʼять(система, слова.дані);
                  покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
                    вид = ВидСловаРоздільникЗбитогоТексту,
                    позиція_початку = п,
                    позиція_кінця = пп,
                    значення = ю8 { ... }
                  });
                  п = пп;
                  стрибнути далі1;
                } інакше {
                  вихід_помилки::вміст = помилка_розбору_на_слова;
                  вернути ні;
                }
              } інакше {
                пп.позиція_символа -= 1;
              }
            }
            якщо значення_ю8.дані[пп.позиція_символа] == ЮНІКОД_ДВОЛАПКА {
              закінчено = так;
              стрибнути закінчити_перебір_тексту;
            }
            якщо значення_ю8.дані[пп.позиція_символа] == ЮНІКОД_РОЗРИВ {
              пп.рядок += 1;
              стрибнути закінчити_перебір_тексту;
            }
            далі1:
            пп.позиція_символа += 1;
          }
          закінчити_перебір_тексту:
          якщо закінчено {
            покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
              вид = ВидСловаЧастинаЗбитогоТексту,
              позиція_початку = п,
              позиція_кінця = пп,
              значення = ю8 { пп.позиція_символа - п.позиція_символа - 1, значення_ю8.дані[п.позиція_символа + 1]::адреса як памʼять<п8> }
            });
            п = пп;
            покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
              вид = ВидСловаКінецьЗбитогоТексту,
              позиція_початку = п,
              позиція_кінця = пп,
              значення = ю8 { ... }
            });
            стрибнути далі;
          }
          стрибнути вийти_з_помилкою;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8";;", позиція_кінця::адреса) {
          змінна пп = позиція_кінця;
          пп.позиція_символа += 1;
          змінна закінчено: логічне = ні;
          поки пп.позиція_символа < значення_ю8.розмір {
            якщо значення_ю8.дані[пп.позиція_символа] == ЮНІКОД_РОЗРИВ {
              пп.рядок += 1;
              закінчено = так;
              стрибнути закінчити_перебір_коментаря;
            }
            пп.позиція_символа += 1;
          }
          закінчити_перебір_коментаря:
  //        покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
  //          вид = ВидСловаКоментар,
  //          позиція_початку = п,
  //          позиція_кінця = пп - 1
  //        });
          якщо закінчено {
            покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
              вид = ВидСловаСимволМіжряд,
              позиція_початку = пп,
              позиція_кінця = пп,
              значення = ю8 { ... }
            });
          }
          п = пп;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, п, ю8";*", позиція_кінця::адреса) {
          змінна пп = позиція_кінця;
          пп.позиція_символа += 1;
          змінна закінчено: логічне = ні;
          поки пп.позиція_символа < значення_ю8.розмір {
            якщо значення_ю8.дані[пп.позиція_символа] == ЮНІКОД_РОЗРИВ {
              пп.рядок += 1;
            }
            якщо перевірити_чи_має_ю8_за_позицією_початку(система, значення_ю8, пп, ю8"*;", пп::адреса) {
              закінчено = так;
              стрибнути закінчити_перебір_багаторядкового_коментаря;
            }
            пп.позиція_символа += 1;
          }
          закінчити_перебір_багаторядкового_коментаря:
          якщо закінчено {
  //          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
  //            вид = ВидСловаБагаторядковийКоментар,
  //            позиція_початку = п,
  //            позиція_кінця = пп
  //          });
            п = пп;
            стрибнути далі;
          }
          стрибнути вийти_з_помилкою;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        якщо перевірити_чи_число(система, значення_ю8, п, позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаЧисло,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { (позиція_кінця.позиція_символа - п.позиція_символа) + 1, значення_ю8.дані[п.позиція_символа]::адреса як памʼять<п8> }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        перевірка_ідентифікатора:
        якщо перевірити_чи_має_ідентифікатор_за_позицією_початку(система, значення_ю8, п, позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
            вид = ВидСловаІдентифікатор,
            позиція_початку = п,
            позиція_кінця = позиція_кінця,
            значення = ю8 { (позиція_кінця.позиція_символа - п.позиція_символа) + 1, значення_ю8.дані[п.позиція_символа]::адреса як памʼять<п8> }
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_символа == 0 {
          позиція_кінця = п;
        }
        якщо позиція_кінця.позиція_символа > позиція_помилки.позиція_символа {
          позиція_помилки = позиція_кінця;
        }
        стрибнути вийти_з_помилкою;
        далі:
        п.позиція_символа += 1;
      }
      покласти_в_накопичувач<Слово>(система, накопичувач_слів::адреса, Слово {
        вид = ВидСловаКІНЕЦЬСЛІВ,
        позиція_початку = ПозиціяСлова { 0, 0, 0 },
        позиція_кінця = ПозиціяСлова { 0, 0, 0 },
        значення = ю8 { 0, пусто }
      });

      вихід::вміст = Слова {
        накопичувач_слів.розмір,
        накопичувач_слів.дані
      };
      вихід_позиції_кінця::вміст = п;
      вернути так;

      вийти_з_помилкою:
      звільнити_памʼять(система, накопичувач_слів.дані);
      вихід_помилки::вміст = ПомилкаРозборуНаСлова {
        позиція_символа = позиція_помилки.позиція_символа,
        рядок = позиція_помилки.рядок,
        стовпець = позиція_помилки.стовпець
      };
      вернути ні;
    }

    місцева дія розібрати_ю8_на_слова(система: адреса<Система>, значення_ю8: ю8, вихід: адреса<Слова>, вихід_помилки: адреса<ПомилкаРозборуНаСлова>): логічне {
      змінна позиція_кінця = ПозиціяСлова { 0, 0, 0 };
      вернути розібрати_ю8_на_слова_0(система, значення_ю8, ПозиціяСлова { 0, 1, 1 }, ні, позиція_кінця::адреса, вихід, вихід_помилки);
    }

    місцева дія вивести_слово(система: адреса<Система>, вихідний_потік: адреса<ВихіднийПотік>, значення_ю8: ю8, слово: Слово) {
      дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"[");
      дописати_п64_у_вихідний_потік(система, вихідний_потік, слово.позиція_початку.рядок);
      дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8":");
      дописати_п64_у_вихідний_потік(система, вихідний_потік, слово.позиція_початку.стовпець);
      дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8" ");
      дописати_п64_у_вихідний_потік(система, вихідний_потік, слово.позиція_кінця.рядок);
      дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8":");
      дописати_п64_у_вихідний_потік(система, вихідний_потік, слово.позиція_кінця.стовпець);
      дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"] ");
      якщо слово.вид == ВидСловаАбо {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Або");
      } інакше якщо слово.вид == ВидСловаБільше {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Більше");
      } інакше якщо слово.вид == ВидСловаВзяти {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Взяти");
      } інакше якщо слово.вид == ВидСловаВласна {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Власна");
      } інакше якщо слово.вид == ВидСловаВпасти {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Впасти");
      } інакше якщо слово.вид == ВидСловаВидалити {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Видалити");
      } інакше якщо слово.вид == ВидСловаВнутрішня {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Внутрішня");
      } інакше якщо слово.вид == ВидСловаВластивість {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Властивість");
      } інакше якщо слово.вид == ВидСловаВернути {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Вернути");
      } інакше якщо слово.вид == ВидСловаДія {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Дія");
      } інакше якщо слово.вид == ВидСловаДати {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Дати");
      } інакше якщо слово.вид == ВидСловаЄ {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Є");
      } інакше якщо слово.вид == ВидСловаЗовнішня {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Зовнішня");
      } інакше якщо слово.вид == ВидСловаЗловити {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Зловити");
      } інакше якщо слово.вид == ВидСловаІ {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"І");
      } інакше якщо слово.вид == ВидСловаІнакше {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Інакше");
      } інакше якщо слово.вид == ВидСловаКомпозиція {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Композиція");
      } інакше якщо слово.вид == ВидСловаКінець {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Кінець");
      } інакше якщо слово.вид == ВидСловаМодуль {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Модуль");
      } інакше якщо слово.вид == ВидСловаМенше {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Менше");
      } інакше якщо слово.вид == ВидСловаМістить {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Містить");
      } інакше якщо слово.вид == ВидСловаМісцева {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Місцева");
      } інакше якщо слово.вид == ВидСловаНе {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Не");
      } інакше якщо слово.вид == ВидСловаПоки {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Поки");
      } інакше якщо слово.вид == ВидСловаПерелік {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Перелік");
      } інакше якщо слово.вид == ВидСловаПеребрати {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Перебрати");
      } інакше якщо слово.вид == ВидСловаРівно {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Рівно");
      } інакше якщо слово.вид == ВидСловаСтруктура {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Структура");
      } інакше якщо слово.вид == ВидСловаСпробувати {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Спробувати");
      } інакше якщо слово.вид == ВидСловаСпец {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Спец");
      } інакше якщо слово.вид == ВидСловаТривала {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Тривала");
      } інакше якщо слово.вид == ВидСловаЦикл {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Цикл");
      } інакше якщо слово.вид == ВидСловаЦе {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Це");
      } інакше якщо слово.вид == ВидСловаЧекати {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Чекати");
      } інакше якщо слово.вид == ВидСловаЯк {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Як");
      } інакше якщо слово.вид == ВидСловаЯкщо {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Якщо");
      } інакше якщо слово.вид == ВидСловаСимволРівно {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволРівно");
      } інакше якщо слово.вид == ВидСловаСимволБільше {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволБільше");
      } інакше якщо слово.вид == ВидСловаСимволМенше {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволМенше");
      } інакше якщо слово.вид == ВидСловаСимволКрапка {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволКрапка");
      } інакше якщо слово.вид == ВидСловаСимволПлюс {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволПлюс");
      } інакше якщо слово.вид == ВидСловаСимволМінус {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволМінус");
      } інакше якщо слово.вид == ВидСловаСимволПомножити {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволПомножити");
      } інакше якщо слово.вид == ВидСловаСимволПоділити {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволПоділити");
      } інакше якщо слово.вид == ВидСловаСимволЗалишку {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволЗалишку");
      } інакше якщо слово.вид == ВидСловаСимволПірамідка {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволПірамідка");
      } інакше якщо слово.вид == ВидСловаСимволІ {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволІ");
      } інакше якщо слово.вид == ВидСловаСимволАбо {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволАбо");
      } інакше якщо слово.вид == ВидСловаСимволВідкритаДужка {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволВідкритаДужка");
      } інакше якщо слово.вид == ВидСловаСимволЗакритаДужка {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволЗакритаДужка");
      } інакше якщо слово.вид == ВидСловаСимволКвадратнаВідкритаДужка {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволКвадратнаВідкритаДужка");
      } інакше якщо слово.вид == ВидСловаСимволКвадратнаЗакритаДужка {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволКвадратнаЗакритаДужка");
      } інакше якщо слово.вид == ВидСловаСимволЗнакПитання {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволЗнакПитання");
      } інакше якщо слово.вид == ВидСловаСимволДвокрапка {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволДвокрапка");
      } інакше якщо слово.вид == ВидСловаСимволТильда {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволТильда");
      } інакше якщо слово.вид == ВидСловаСимволОднолапка {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволОднолапка");
      } інакше якщо слово.вид == ВидСловаСимволДволапка {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволДволапка");
      } інакше якщо слово.вид == ВидСловаСимволЗнакОклику {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволЗнакОклику");
      } інакше якщо слово.вид == ВидСловаСимволКома {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволКома");
      } інакше якщо слово.вид == ВидСловаСимволМіжряд {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СимволМіжряд");
      } інакше якщо слово.вид == ВидСловаЧисло {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Число");
      } інакше якщо слово.вид == ВидСловаСимвол {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Символ");
      } інакше якщо слово.вид == ВидСловаТекст {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Текст");
      } інакше якщо слово.вид == ВидСловаБагаторядковийТекст {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"БагаторядковийТекст");
      } інакше якщо слово.вид == ВидСловаКоментар {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Коментар");
      } інакше якщо слово.вид == ВидСловаБагаторядковийКоментар {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"БагаторядковийКоментар");
      } інакше якщо слово.вид == ВидСловаІдентифікатор {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Ідентифікатор");
      } інакше якщо слово.вид == ВидСловаПочатокЗбитогоТексту {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ПочатокЗбитогоТексту");
      } інакше якщо слово.вид == ВидСловаРоздільникЗбитогоТексту {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"РоздільникЗбитогоТексту");
      } інакше якщо слово.вид == ВидСловаКінецьЗбитогоТексту {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"КінецьЗбитогоТексту");
      } інакше якщо слово.вид == ВидСловаЧастинаЗбитогоТексту {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ЧастинаЗбитогоТексту");
      } інакше якщо слово.вид == ВидСловаКІНЕЦЬСЛІВ {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"КІНЕЦЬСЛІВ");
      } інакше {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"!!! НЕВІДОМЕ СЛОВО !!!");
      }
    }

    місцева дія вивести_слова(система: адреса<Система>, вихідний_потік: адреса<ВихіднийПотік>, значення_ю8: ю8, слова: Слова) {
      змінна п: позитивне = 0;
      поки п < слова.розмір {
        вивести_слово(система, вихідний_потік, значення_ю8, слова.дані[п]);
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\р");
        п += 1;
      }
    }

    місцева дія звільнити_слова(система: адреса<Система>, слова: Слова) {
      звільнити_памʼять(система, слова.дані);
    }

    місцева дія звільнити_помилку_розбору_на_слова(система: адреса<Система>, помилка: ПомилкаРозборуНаСлова) {
      // ...
    }

    місцева дія отримати_ю8_помилки_розбору_на_слова(система: адреса<Система>, помилка: ПомилкаРозборуНаСлова, вихід: адреса<ю8>): логічне {
      виділити_копію_ю8(система, ю8"Не вдалось розібрати на слова", вихід);
      вернути так;
    }

    місцева дія отримати_рядок_помилки_розбору_на_слова(система: адреса<Система>, помилка: ПомилкаРозборуНаСлова): позитивне {
      вернути помилка.рядок;
    }

    місцева дія отримати_стовпець_помилки_розбору_на_слова(система: адреса<Система>, помилка: ПомилкаРозборуНаСлова): позитивне {
      вернути помилка.стовпець;
    }

    місцева дія отримати_ю8_ідентифікатора(значення_ю8: ю8, слова: Слова, ідентифікатор: Ідентифікатор): ю8 {
      вернути слова.дані[ідентифікатор.позиція_слова].значення;
    }

    місцева дія отримати_ю8_слова(значення_ю8: ю8, слова: Слова, слово: Слово): ю8 {
      вернути слово.значення;
    }

    місцева дія отримати_ю8_тексту(значення_ю8: ю8, слова: Слова, сполука_тексту: адреса<Сполука>): ю8 {
      змінна дані = сполука_тексту.дані як ДаніСполукиТекст;
      змінна слово = слова.дані[дані.позиція_слова];
      вернути слово.значення;
    }

    місцева дія отримати_ю8_символу(значення_ю8: ю8, слова: Слова, сполука_символу: адреса<Сполука>): ю8 {
      змінна дані = сполука_символу.дані як ДаніСполукиСимвол;
      змінна слово = слова.дані[дані.позиція_слова];
      вернути слово.значення;
    }

    місцева дія отримати_рядок_з_місцезнаходження(значення_ю8: ю8, слова: Слова, місцезнаходження: Місцезнаходження): позитивне {
      вернути слова.дані[місцезнаходження.позиція_слова].позиція_початку.рядок;
    }

    місцева дія отримати_стовпець_з_місцезнаходження(значення_ю8: ю8, слова: Слова, місцезнаходження: Місцезнаходження): позитивне {
      вернути слова.дані[місцезнаходження.позиція_слова].позиція_початку.стовпець;
    }
  }
}

секція мавка {
  секція розбирач {
    дія зробити_повну_копію_сполуки(система: адреса<Система>, сполука: адреса<Сполука>): адреса<Сполука>;
    дія зробити_повну_копію_тіла(система: адреса<Система>, тіло: Сполуки): Сполуки;
    дія зробити_повну_копію_типу(система: адреса<Система>, тип: Тип): Тип;
    дія зробити_повну_копію_можливо_типу(система: адреса<Система>, тип: можливо<Тип>): можливо<Тип>;
    дія зробити_повну_копію_параметра(система: адреса<Система>, параметр: Параметр): Параметр;
    дія зробити_повну_копію_параметрів(система: адреса<Система>, кількість_параметрів: позитивне, параметри: памʼять<Параметр>): памʼять<Параметр>;
    дія зробити_повну_копію_аргумента(система: адреса<Система>, аргумент: Аргумент): Аргумент;
    дія зробити_повну_копію_аргументів(система: адреса<Система>, кількість_аргументів: позитивне, аргументи: памʼять<Аргумент>): памʼять<Аргумент>;
    дія зробити_повну_копію_гілок(система: адреса<Система>, кількість_гілок: позитивне, сполуки: памʼять<адреса<Сполука>>): памʼять<адреса<Сполука>>;
    дія зробити_повну_копію_елемента_словника(система: адреса<Система>, елемент: ЕлементСловника): ЕлементСловника;
    дія зробити_повну_копію_елементів_словника(система: адреса<Система>, кількість_елементів: позитивне, елементи: памʼять<ЕлементСловника>): памʼять<ЕлементСловника>;
    дія зробити_повну_копію_ідентифікаторів(система: адреса<Система>, кількість_ідентифікаторів: позитивне, ідентифікатори: памʼять<Ідентифікатор>): памʼять<Ідентифікатор>;
    дія зробити_повну_копію_елемента_взяти(система: адреса<Система>, елемент: ЕлементВзяти): ЕлементВзяти;
    дія зробити_повну_копію_елементів_взяти(система: адреса<Система>, кількість_елементів: позитивне, елементи: памʼять<ЕлементВзяти>): памʼять<ЕлементВзяти>;
    дія зробити_повну_копію_елемента_дати(система: адреса<Система>, елемент: ЕлементДати): ЕлементДати;
    дія зробити_повну_копію_елементів_дати(система: адреса<Система>, кількість_елементів: позитивне, елементи: памʼять<ЕлементДати>): памʼять<ЕлементДати>;
    дія звільнити_сполуку(система: адреса<Система>, сполука: адреса<Сполука>);
    дія звільнити_тіло(система: адреса<Система>, тіло: Сполуки);
    дія звільнити_тип(система: адреса<Система>, тип: Тип);
    дія звільнити_параметри(система: адреса<Система>, кількість_параметрів: позитивне, параметри: памʼять<Параметр>);
    дія звільнити_аргументи(система: адреса<Система>, кількість_аргументів: позитивне, аргументи: памʼять<Аргумент>);
    дія звільнити_елементи_словника(система: адреса<Система>, кількість_елементів: позитивне, елементи: памʼять<ЕлементСловника>);

    дія зробити_повну_копію_сполуки(система: адреса<Система>, сполука: адреса<Сполука>): адреса<Сполука> {
      якщо сполука == пусто {
        вернути пусто;
      }
      змінна копія = виділити<Сполука>(система);
      копія.вид = сполука.вид;
      якщо сполука.вид == ВидСполукиВизначити {
        змінна дані = сполука.дані як ДаніСполукиВизначити;
        копія.дані = ДаніСполукиВизначити {
          ідентифікатор = дані.ідентифікатор,
          значення = зробити_повну_копію_сполуки(система, дані.значення)
        };
      } інакше якщо сполука.вид == ВидСполукиЗвернутись {
        змінна дані = сполука.дані як ДаніСполукиЗвернутись;
        копія.дані = ДаніСполукиЗвернутись {
          ідентифікатор = дані.ідентифікатор
        };
      } інакше якщо сполука.вид == ВидСполукиОтримати {
        змінна дані = сполука.дані як ДаніСполукиОтримати;
        копія.дані = ДаніСполукиОтримати {
          предмет = зробити_повну_копію_сполуки(система, дані.предмет),
          ідентифікатор = дані.ідентифікатор
        };
      } інакше якщо сполука.вид == ВидСполукиОтриматиЕлемент {
        змінна дані = сполука.дані як ДаніСполукиОтриматиЕлемент;
        копія.дані = ДаніСполукиОтриматиЕлемент {
          предмет = зробити_повну_копію_сполуки(система, дані.предмет),
          ключ = зробити_повну_копію_сполуки(система, дані.ключ)
        };
      } інакше якщо сполука.вид == ВидСполукиЗмінити {
        змінна дані = сполука.дані як ДаніСполукиЗмінити;
        копія.дані = ДаніСполукиЗмінити {
          предмет = зробити_повну_копію_сполуки(система, дані.предмет),
          ідентифікатор = дані.ідентифікатор,
          значення = зробити_повну_копію_сполуки(система, дані.значення)
        };
      } інакше якщо сполука.вид == ВидСполукиЗмінитиЕлемент {
        змінна дані = сполука.дані як ДаніСполукиЗмінитиЕлемент;
        копія.дані = ДаніСполукиЗмінитиЕлемент {
          предмет = зробити_повну_копію_сполуки(система, дані.предмет),
          ключ = зробити_повну_копію_сполуки(система, дані.ключ),
          значення = зробити_повну_копію_сполуки(система, дані.значення)
        };
      } інакше якщо сполука.вид == ВидСполукиВиконати {
        змінна дані = сполука.дані як ДаніСполукиВиконати;
        копія.дані = ДаніСполукиВиконати {
          предмет = зробити_повну_копію_сполуки(система, дані.предмет),
          кількість_аргументів = дані.кількість_аргументів,
          аргументи = зробити_повну_копію_аргументів(система, дані.кількість_аргументів, дані.аргументи)
        };
      } інакше якщо сполука.вид == ВидСполукиДія {
        змінна дані = сполука.дані як ДаніСполукиДія;
        копія.дані = ДаніСполукиДія {
          тривала = дані.тривала,
          власна = дані.власна,
          структура_ = зробити_повну_копію_сполуки(система, дані.структура_),
          ідентифікатор = дані.ідентифікатор,
          кількість_параметрів = дані.кількість_параметрів,
          параметри = зробити_повну_копію_параметрів(система, дані.кількість_параметрів, дані.параметри),
          тип_результату = зробити_повну_копію_можливо_типу(система, дані.тип_результату),
          тіло = зробити_повну_копію_тіла(система, дані.тіло)
        };
      } інакше якщо сполука.вид == ВидСполукиСтруктура {
        змінна дані = сполука.дані як ДаніСполукиСтруктура;
        копія.дані = ДаніСполукиСтруктура {
          ідентифікатор = дані.ідентифікатор,
          предок = зробити_повну_копію_сполуки(система, дані.предок),
          кількість_параметрів = дані.кількість_параметрів,
          параметри = зробити_повну_копію_параметрів(система, дані.кількість_параметрів, дані.параметри)
        };
      } інакше якщо сполука.вид == ВидСполукиЧисло {
        змінна дані = сполука.дані як ДаніСполукиЧисло;
        копія.дані = ДаніСполукиЧисло {
          позиція_слова = дані.позиція_слова
        };
      } інакше якщо сполука.вид == ВидСполукиТекст {
        змінна дані = сполука.дані як ДаніСполукиТекст;
        копія.дані = ДаніСполукиТекст {
          ідентифікатор = дані.ідентифікатор,
          позиція_слова = дані.позиція_слова
        };
      } інакше якщо сполука.вид == ВидСполукиОперація {
        змінна дані = сполука.дані як ДаніСполукиОперація;
        копія.дані = ДаніСполукиОперація {
          ліво = зробити_повну_копію_сполуки(система, дані.ліво),
          операція = дані.операція,
          право = зробити_повну_копію_сполуки(система, дані.право)
        };
      } інакше якщо сполука.вид == ВидСполукиЯкщо {
        змінна дані = сполука.дані як ДаніСполукиЯкщо;
        копія.дані = ДаніСполукиЯкщо {
          умова = зробити_повну_копію_сполуки(система, дані.умова),
          тіло = зробити_повну_копію_тіла(система, дані.тіло),
          тіло_інакше = зробити_повну_копію_тіла(система, дані.тіло_інакше)
        };
      } інакше якщо сполука.вид == ВидСполукиПоки {
        змінна дані = сполука.дані як ДаніСполукиПоки;
        копія.дані = ДаніСполукиПоки {
          умова = зробити_повну_копію_сполуки(система, дані.умова),
          тіло = зробити_повну_копію_тіла(система, дані.тіло)
        };
      } інакше якщо сполука.вид == ВидСполукиВернути {
        змінна дані = сполука.дані як ДаніСполукиВернути;
        копія.дані = ДаніСполукиВернути {
          значення = зробити_повну_копію_сполуки(система, дані.значення)
        };
      } інакше якщо сполука.вид == ВидСполукиЗначенняЯкщо {
        змінна дані = сполука.дані як ДаніСполукиЗначенняЯкщо;
        копія.дані = ДаніСполукиЗначенняЯкщо {
          умова = зробити_повну_копію_сполуки(система, дані.умова),
          значення_так = зробити_повну_копію_сполуки(система, дані.значення_так),
          значення_ні = зробити_повну_копію_сполуки(система, дані.значення_ні)
        };
      } інакше якщо сполука.вид == ВидСполукиСамоОперація {
        змінна дані = сполука.дані як ДаніСполукиСамоОперація;
        копія.дані = ДаніСполукиСамоОперація {
          операція = дані.операція,
          предмет = зробити_повну_копію_сполуки(система, дані.предмет)
        };
      } інакше якщо сполука.вид == ВидСполукиВзяти {
        змінна дані = сполука.дані як ДаніСполукиВзяти;
        копія.дані = ДаніСполукиВзяти {
          тип = дані.тип,
          довжина_шляху = дані.довжина_шляху,
          шлях = зробити_повну_копію_ідентифікаторів(система, дані.довжина_шляху, дані.шлях),
          ідентифікатор_як = дані.ідентифікатор_як,
          кількість_елементів = дані.кількість_елементів,
          елементи = зробити_повну_копію_елементів_взяти(система, дані.кількість_елементів, дані.елементи)
        };
      } інакше якщо сполука.вид == ВидСполукиСпробувати {
        змінна дані = сполука.дані як ДаніСполукиСпробувати;
        копія.дані = ДаніСполукиСпробувати {
          тіло = зробити_повну_копію_тіла(система, дані.тіло),
          ідентифікатор_зловити = дані.ідентифікатор_зловити,
          тіло_зловити = зробити_повну_копію_тіла(система, дані.тіло_зловити)
        };
      } інакше якщо сполука.вид == ВидСполукиВпасти {
        змінна дані = сполука.дані як ДаніСполукиВпасти;
        копія.дані = ДаніСполукиВпасти {
          значення = зробити_повну_копію_сполуки(система, дані.значення)
        };
      } інакше якщо сполука.вид == ВидСполукиДати {
        змінна дані = сполука.дані як ДаніСполукиДати;
        копія.дані = ДаніСполукиДати {
          кількість_елементів = дані.кількість_елементів,
          елементи = зробити_повну_копію_елементів_дати(система, дані.кількість_елементів, дані.елементи)
        };
      } інакше якщо сполука.вид == ВидСполукиМодуль {
        змінна дані = сполука.дані як ДаніСполукиМодуль;
        копія.дані = ДаніСполукиМодуль {
          ідентифікатор = дані.ідентифікатор,
          тіло = зробити_повну_копію_тіла(система, дані.тіло)
        };
      } інакше якщо сполука.вид == ВидСполукиСписок {
        змінна дані = сполука.дані як ДаніСполукиСписок;
        копія.дані = ДаніСполукиСписок {
          кількість_елементів = дані.кількість_елементів,
          елементи = зробити_повну_копію_гілок(система, дані.кількість_елементів, дані.елементи)
        };
      } інакше якщо сполука.вид == ВидСполукиСловник {
        змінна дані = сполука.дані як ДаніСполукиСловник;
        копія.дані = ДаніСполукиСловник {
          кількість_елементів = дані.кількість_елементів,
          елементи = зробити_повну_копію_елементів_словника(система, дані.кількість_елементів, дані.елементи)
        };
      } інакше якщо сполука.вид == ВидСполукиСимвол {
        змінна дані = сполука.дані як ДаніСполукиСимвол;
        копія.дані = ДаніСполукиСимвол {
          ідентифікатор = дані.ідентифікатор,
          позиція_слова = дані.позиція_слова
        };
      } інакше якщо сполука.вид == ВидСполукиПеребрати {
        змінна дані = сполука.дані як ДаніСполукиПеребрати;
        копія.дані = ДаніСполукиПеребрати {
          предмет = зробити_повну_копію_сполуки(система, дані.предмет),
          ідентифікатор = дані.ідентифікатор,
          тіло = зробити_повну_копію_тіла(система, дані.тіло)
        };
      } інакше якщо сполука.вид == ВидСполукиЦикл {
        змінна дані = сполука.дані як ДаніСполукиЦикл;
        копія.дані = ДаніСполукиЦикл {
          старт = зробити_повну_копію_тіла(система, дані.старт),
          умова = зробити_повну_копію_сполуки(система, дані.умова),
          тіло = зробити_повну_копію_тіла(система, дані.тіло),
          ітерація = зробити_повну_копію_тіла(система, дані.ітерація)
        };
      } інакше якщо сполука.вид == ВидСполукиВизначитиЗзовні {
        змінна дані = сполука.дані як ДаніСполукиВизначитиЗзовні;
        копія.дані = ДаніСполукиВизначитиЗзовні {
          ідентифікатор = дані.ідентифікатор,
          значення = зробити_повну_копію_сполуки(система, дані.значення)
        };
      } інакше якщо сполука.вид == ВидСполукиВічнийЦикл {
        змінна дані = сполука.дані як ДаніСполукиВічнийЦикл;
        копія.дані = ДаніСполукиВічнийЦикл {
          тіло = зробити_повну_копію_тіла(система, дані.тіло)
        };
      } інакше якщо сполука.вид == ВидСполукиВидалити {
        змінна дані = сполука.дані як ДаніСполукиВидалити;
        копія.дані = ДаніСполукиВидалити {
          ідентифікатор = дані.ідентифікатор
        };
      } інакше якщо сполука.вид == ВидСполукиВидалитиВластивість {
        змінна дані = сполука.дані як ДаніСполукиВидалитиВластивість;
        копія.дані = ДаніСполукиВидалитиВластивість {
          предмет = зробити_повну_копію_сполуки(система, дані.предмет),
          ідентифікатор = дані.ідентифікатор
        };
      } інакше якщо сполука.вид == ВидСполукиВидалитиЕлемент {
        змінна дані = сполука.дані як ДаніСполукиВидалитиЕлемент;
        копія.дані = ДаніСполукиВидалитиЕлемент {
          предмет = зробити_повну_копію_сполуки(система, дані.предмет),
          ключ = зробити_повну_копію_сполуки(система, дані.ключ)
        };
      } інакше якщо сполука.вид == ВидСполукиЧекати {
        змінна дані = сполука.дані як ДаніСполукиЧекати;
        копія.дані = ДаніСполукиЧекати {
          значення = зробити_повну_копію_сполуки(система, дані.значення)
        };
      } інакше якщо сполука.вид == ВидСполукиДіапазон {
        змінна дані = сполука.дані як ДаніСполукиДіапазон;
        копія.дані = ДаніСполукиДіапазон {
          від = зробити_повну_копію_сполуки(система, дані.від),
          до = зробити_повну_копію_сполуки(система, дані.до),
          включно = дані.включно
        };
      } інакше якщо сполука.вид == ВидСполукиЗбитийТекст {
        змінна дані = сполука.дані як ДаніСполукиЗбитийТекст;
        копія.дані = ДаніСполукиЗбитийТекст {
          ідентифікатор = дані.ідентифікатор,
          кількість_гілок = дані.кількість_гілок,
          сполуки = зробити_повну_копію_гілок(система, дані.кількість_гілок, дані.сполуки)
        };
      } інакше {
//        надрукувати_ю8(ю8"НЕВІДОМИЙ ВИД ГІЛКИ ДЛЯ КОПІЮВАННЯ");
      }
      копія.місцезнаходження = сполука.місцезнаходження;
      вернути копія;
    }
  
    дія зробити_повну_копію_тіла(система: адреса<Система>, тіло: Сполуки): Сполуки {
      вернути Сполуки { тіло.розмір, зробити_повну_копію_гілок(система, тіло.розмір, тіло.дані) };
    }
  
    дія зробити_повну_копію_типу(система: адреса<Система>, тип: Тип): Тип {
      вернути Тип { тип.кількість_гілок, зробити_повну_копію_гілок(система, тип.кількість_гілок, тип.сполуки) };
    }
  
    дія зробити_повну_копію_можливо_типу(система: адреса<Система>, тип: можливо<Тип>): можливо<Тип> {
      якщо тип.заповнено == позитивне(так) {
        вернути можливо<Тип> { позитивне(так), зробити_повну_копію_типу(система, тип.значення) };
      }
      вернути можливо<Тип> { позитивне(ні), ... };
    }
  
    дія зробити_повну_копію_параметра(система: адреса<Система>, параметр: Параметр): Параметр {
      вернути Параметр {
        ідентифікатор = параметр.ідентифікатор,
        тип = зробити_повну_копію_можливо_типу(система, параметр.тип),
        значення = зробити_повну_копію_сполуки(система, параметр.значення),
        місцезнаходження = параметр.місцезнаходження
      };
    }
  
    дія зробити_повну_копію_параметрів(система: адреса<Система>, кількість_параметрів: позитивне, параметри: памʼять<Параметр>): памʼять<Параметр> {
      якщо кількість_параметрів == 0 {
        вернути пусто;
      }
      змінна нові_параметри = виділити_памʼять<Параметр>(система, кількість_параметрів);
      змінна п: позитивне = 0;
      поки п < кількість_параметрів {
        нові_параметри[п] = зробити_повну_копію_параметра(система, параметри[п]);
        п += 1;
      }
      вернути нові_параметри;
    }
  
    дія зробити_повну_копію_аргумента(система: адреса<Система>, аргумент: Аргумент): Аргумент {
      вернути Аргумент {
        ідентифікатор = аргумент.ідентифікатор,
        значення = зробити_повну_копію_сполуки(система, аргумент.значення),
        місцезнаходження = аргумент.місцезнаходження
      };
    }
  
    дія зробити_повну_копію_аргументів(система: адреса<Система>, кількість_аргументів: позитивне, аргументи: памʼять<Аргумент>): памʼять<Аргумент> {
      якщо кількість_аргументів == 0 {
        вернути пусто;
      }
      змінна нові_аргументи = виділити_памʼять<Аргумент>(система, кількість_аргументів);
      змінна п: позитивне = 0;
      поки п < кількість_аргументів {
        нові_аргументи[п] = зробити_повну_копію_аргумента(система, аргументи[п]);
        п += 1;
      }
      вернути нові_аргументи;
    }
  
    дія зробити_повну_копію_гілок(система: адреса<Система>, кількість_гілок: позитивне, сполуки: памʼять<адреса<Сполука>>): памʼять<адреса<Сполука>> {
      якщо кількість_гілок == 0 {
        вернути пусто;
      }
      змінна нові_сполуки = виділити_памʼять<адреса<Сполука>>(система, кількість_гілок);
      змінна п: позитивне = 0;
      поки п < кількість_гілок {
        нові_сполуки[п] = зробити_повну_копію_сполуки(система, сполуки[п]);
        п += 1;
      }
      вернути нові_сполуки;
    }
  
    дія зробити_повну_копію_елемента_словника(система: адреса<Система>, елемент: ЕлементСловника): ЕлементСловника {
      вернути ЕлементСловника {
        ключ = зробити_повну_копію_сполуки(система, елемент.ключ),
        значення = зробити_повну_копію_сполуки(система, елемент.значення),
        місцезнаходження = елемент.місцезнаходження
      };
    }
  
    дія зробити_повну_копію_елементів_словника(система: адреса<Система>, кількість_елементів: позитивне, елементи: памʼять<ЕлементСловника>): памʼять<ЕлементСловника> {
      якщо кількість_елементів == 0 {
        вернути пусто;
      }
      змінна нові_елементи = виділити_памʼять<ЕлементСловника>(система, кількість_елементів);
      змінна п: позитивне = 0;
      поки п < кількість_елементів {
        нові_елементи[п] = зробити_повну_копію_елемента_словника(система, елементи[п]);
        п += 1;
      }
      вернути нові_елементи;
    }
  
    дія зробити_повну_копію_ідентифікаторів(система: адреса<Система>, кількість_ідентифікаторів: позитивне, ідентифікатори: памʼять<Ідентифікатор>): памʼять<Ідентифікатор> {
      якщо кількість_ідентифікаторів == 0 {
        вернути пусто;
      }
      змінна нові_ідентифікатори = виділити_памʼять<Ідентифікатор>(система, кількість_ідентифікаторів);
      змінна п: позитивне = 0;
      поки п < кількість_ідентифікаторів {
        нові_ідентифікатори[п] = ідентифікатори[п];
        п += 1;
      }
      вернути нові_ідентифікатори;
    }
  
    дія зробити_повну_копію_елемента_взяти(система: адреса<Система>, елемент: ЕлементВзяти): ЕлементВзяти {
      вернути елемент;
    }
  
    дія зробити_повну_копію_елементів_взяти(система: адреса<Система>, кількість_елементів: позитивне, елементи: памʼять<ЕлементВзяти>): памʼять<ЕлементВзяти> {
      якщо кількість_елементів == 0 {
        вернути пусто;
      }
      змінна нові_елементи = виділити_памʼять<ЕлементВзяти>(система, кількість_елементів);
      змінна п: позитивне = 0;
      поки п < кількість_елементів {
        нові_елементи[п] = зробити_повну_копію_елемента_взяти(система, елементи[п]);
        п += 1;
      }
      вернути нові_елементи;
    }
  
    дія зробити_повну_копію_елемента_дати(система: адреса<Система>, елемент: ЕлементДати): ЕлементДати {
      вернути елемент;
    }
  
    дія зробити_повну_копію_елементів_дати(система: адреса<Система>, кількість_елементів: позитивне, елементи: памʼять<ЕлементДати>): памʼять<ЕлементДати> {
      якщо кількість_елементів == 0 {
        вернути пусто;
      }
      змінна нові_елементи = виділити_памʼять<ЕлементДати>(система, кількість_елементів);
      змінна п: позитивне = 0;
      поки п < кількість_елементів {
        нові_елементи[п] = зробити_повну_копію_елемента_дати(система, елементи[п]);
        п += 1;
      }
      вернути нові_елементи;
    }
  
    дія звільнити_сполуку(система: адреса<Система>, сполука: адреса<Сполука>) {
      якщо сполука != пусто {
        якщо сполука.вид == ВидСполукиВизначити {
          змінна дані = сполука.дані як ДаніСполукиВизначити;
          звільнити_сполуку(система, дані.значення);
        } інакше якщо сполука.вид == ВидСполукиОтримати {
          змінна дані = сполука.дані як ДаніСполукиОтримати;
          звільнити_сполуку(система, дані.предмет);
        } інакше якщо сполука.вид == ВидСполукиОтриматиЕлемент {
          змінна дані = сполука.дані як ДаніСполукиОтриматиЕлемент;
          звільнити_сполуку(система, дані.предмет);
          звільнити_сполуку(система, дані.ключ);
        } інакше якщо сполука.вид == ВидСполукиЗмінити {
          змінна дані = сполука.дані як ДаніСполукиЗмінити;
          звільнити_сполуку(система, дані.предмет);
          звільнити_сполуку(система, дані.значення);
        } інакше якщо сполука.вид == ВидСполукиЗмінитиЕлемент {
          змінна дані = сполука.дані як ДаніСполукиЗмінитиЕлемент;
          звільнити_сполуку(система, дані.предмет);
          звільнити_сполуку(система, дані.ключ);
          звільнити_сполуку(система, дані.значення);
        } інакше якщо сполука.вид == ВидСполукиВиконати {
          змінна дані = сполука.дані як ДаніСполукиВиконати;
          звільнити_сполуку(система, дані.предмет);
          звільнити_аргументи(система, дані.кількість_аргументів, дані.аргументи);
        } інакше якщо сполука.вид == ВидСполукиДія {
          змінна дані = сполука.дані як ДаніСполукиДія;
          звільнити_сполуку(система, дані.структура_);
          звільнити_параметри(система, дані.кількість_параметрів, дані.параметри);
          якщо дані.тип_результату.заповнено == позитивне(так) {
            звільнити_тип(система, дані.тип_результату.значення);
          }
          звільнити_тіло(система, дані.тіло);
        } інакше якщо сполука.вид == ВидСполукиСтруктура {
          змінна дані = сполука.дані як ДаніСполукиСтруктура;
          звільнити_сполуку(система, дані.предок);
          звільнити_параметри(система, дані.кількість_параметрів, дані.параметри);
        } інакше якщо сполука.вид == ВидСполукиОперація {
          змінна дані = сполука.дані як ДаніСполукиОперація;
          звільнити_сполуку(система, дані.ліво);
          звільнити_сполуку(система, дані.право);
        } інакше якщо сполука.вид == ВидСполукиЯкщо {
          змінна дані = сполука.дані як ДаніСполукиЯкщо;
          звільнити_сполуку(система, дані.умова);
          звільнити_тіло(система, дані.тіло);
          звільнити_тіло(система, дані.тіло_інакше);
        } інакше якщо сполука.вид == ВидСполукиПоки {
          змінна дані = сполука.дані як ДаніСполукиПоки;
          звільнити_сполуку(система, дані.умова);
          звільнити_тіло(система, дані.тіло);
        } інакше якщо сполука.вид == ВидСполукиВернути {
          змінна дані = сполука.дані як ДаніСполукиВернути;
          звільнити_сполуку(система, дані.значення);
        } інакше якщо сполука.вид == ВидСполукиЗначенняЯкщо {
          змінна дані = сполука.дані як ДаніСполукиЗначенняЯкщо;
          звільнити_сполуку(система, дані.умова);
          звільнити_сполуку(система, дані.значення_так);
          звільнити_сполуку(система, дані.значення_ні);
        } інакше якщо сполука.вид == ВидСполукиСамоОперація {
          змінна дані = сполука.дані як ДаніСполукиСамоОперація;
          звільнити_сполуку(система, дані.предмет);
        } інакше якщо сполука.вид == ВидСполукиВзяти {
          змінна дані = сполука.дані як ДаніСполукиВзяти;
          звільнити_памʼять(система, дані.шлях);
          звільнити_памʼять(система, дані.елементи);
        } інакше якщо сполука.вид == ВидСполукиСпробувати {
          змінна дані = сполука.дані як ДаніСполукиСпробувати;
          звільнити_тіло(система, дані.тіло);
          звільнити_тіло(система, дані.тіло_зловити);
        } інакше якщо сполука.вид == ВидСполукиВпасти {
          змінна дані = сполука.дані як ДаніСполукиВпасти;
          звільнити_сполуку(система, дані.значення);
        } інакше якщо сполука.вид == ВидСполукиДати {
          змінна дані = сполука.дані як ДаніСполукиДати;
          звільнити_памʼять(система, дані.елементи);
        } інакше якщо сполука.вид == ВидСполукиМодуль {
          змінна дані = сполука.дані як ДаніСполукиМодуль;
          звільнити_тіло(система, дані.тіло);
        } інакше якщо сполука.вид == ВидСполукиСписок {
          змінна дані = сполука.дані як ДаніСполукиСписок;
          звільнити_сполуки(система, Сполуки { дані.кількість_елементів, дані.елементи });
        } інакше якщо сполука.вид == ВидСполукиСловник {
          змінна дані = сполука.дані як ДаніСполукиСловник;
          звільнити_елементи_словника(система, дані.кількість_елементів, дані.елементи);
        } інакше якщо сполука.вид == ВидСполукиПеребрати {
          змінна дані = сполука.дані як ДаніСполукиПеребрати;
          звільнити_сполуку(система, дані.предмет);
          звільнити_тіло(система, дані.тіло);
        } інакше якщо сполука.вид == ВидСполукиЦикл {
          змінна дані = сполука.дані як ДаніСполукиЦикл;
          звільнити_тіло(система, дані.старт);
          звільнити_сполуку(система, дані.умова);
          звільнити_тіло(система, дані.тіло);
          звільнити_тіло(система, дані.ітерація);
        } інакше якщо сполука.вид == ВидСполукиВизначитиЗзовні {
          змінна дані = сполука.дані як ДаніСполукиВизначитиЗзовні;
          звільнити_сполуку(система, дані.значення);
        } інакше якщо сполука.вид == ВидСполукиВічнийЦикл {
          змінна дані = сполука.дані як ДаніСполукиВічнийЦикл;
          звільнити_тіло(система, дані.тіло);
        } інакше якщо сполука.вид == ВидСполукиВидалитиВластивість {
          змінна дані = сполука.дані як ДаніСполукиВидалитиВластивість;
          звільнити_сполуку(система, дані.предмет);
        } інакше якщо сполука.вид == ВидСполукиВидалитиЕлемент {
          змінна дані = сполука.дані як ДаніСполукиВидалитиЕлемент;
          звільнити_сполуку(система, дані.предмет);
          звільнити_сполуку(система, дані.ключ);
        } інакше якщо сполука.вид == ВидСполукиЧекати {
          змінна дані = сполука.дані як ДаніСполукиЧекати;
          звільнити_сполуку(система, дані.значення);
        } інакше якщо сполука.вид == ВидСполукиДіапазон {
          змінна дані = сполука.дані як ДаніСполукиДіапазон;
          звільнити_сполуку(система, дані.від);
          звільнити_сполуку(система, дані.до);
        } інакше якщо сполука.вид == ВидСполукиЗбитийТекст {
          змінна дані = сполука.дані як ДаніСполукиЗбитийТекст;
          звільнити_сполуки(система, Сполуки { дані.кількість_гілок, дані.сполуки });
        }
        звільнити(система, сполука);
      }
    }
  
    дія звільнити_тіло(система: адреса<Система>, тіло: Сполуки) {
      змінна п: позитивне = 0;
      поки п < тіло.розмір {
        звільнити_сполуку(система, тіло.дані[п]);
        п += 1;
      }
      звільнити_памʼять(система, тіло.дані);
    }
  
    дія звільнити_тип(система: адреса<Система>, тип: Тип) {
      змінна п: позитивне = 0;
      поки п < тип.кількість_гілок {
        звільнити_сполуку(система, тип.сполуки[п]);
        п += 1;
      }
      звільнити_памʼять(система, тип.сполуки);
    }
  
    дія звільнити_параметри(система: адреса<Система>, кількість_параметрів: позитивне, параметри: памʼять<Параметр>) {
      змінна п: позитивне = 0;
      поки п < кількість_параметрів {
        якщо параметри[п].тип.заповнено == позитивне(так) {
          звільнити_тип(система, параметри[п].тип.значення);
        }
        звільнити_сполуку(система, параметри[п].значення);
        п += 1;
      }
      звільнити_памʼять(система, параметри);
    }
  
    дія звільнити_аргументи(система: адреса<Система>, кількість_аргументів: позитивне, аргументи: памʼять<Аргумент>) {
      змінна п: позитивне = 0;
      поки п < кількість_аргументів {
        звільнити_сполуку(система, аргументи[п].значення);
        п += 1;
      }
      звільнити_памʼять(система, аргументи);
    }
  
    дія звільнити_елементи_словника(система: адреса<Система>, кількість_елементів: позитивне, елементи: памʼять<ЕлементСловника>) {
      змінна п: позитивне = 0;
      поки п < кількість_елементів {
        звільнити_сполуку(система, елементи[п].ключ);
        звільнити_сполуку(система, елементи[п].значення);
        п += 1;
      }
      звільнити_памʼять(система, елементи);
    }

    дія зʼїсти_міжрядки(слова: Слова, позиція_початку: позитивне, вихід_позиції_кінця: адреса<позитивне>): логічне;
    дія спробувати_розібрати_заперечення(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_двійкове_заперечення(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_префікс_плюс(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_префікс_мінус(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_видалити(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_чекати(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_частинку(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_атом(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_аргумент(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<Аргумент>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_молекулу(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_молекулу__хвіст(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, позиція_початку_молекули: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, сполука_атома: адреса<Сполука>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_мікрооперацію(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_операцію(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, в_гнізді: логічне, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_операцію_1(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, сполука_ліво: адреса<Сполука>, мін: позитивне, в_гнізді: логічне, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_значення(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, в_гнізді: логічне, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_вернути(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_впасти(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_елемент_взяти(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<ЕлементВзяти>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_взяти(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_елемент_дати(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<ЕлементДати>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_дати(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_елемент_тіла(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_тіло(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<Сполуки>, вихід_позиції_кінця: адреса<позитивне>, вид_слова_закінчення: позитивне, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_тип(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<Тип>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_параметр(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<Параметр>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_дію(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_структуру(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_модуль(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_якщо(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_поки(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_цикл(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_перебрати(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;
    дія спробувати_розібрати_спробувати(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне;

    дія зʼїсти_міжрядки(слова: Слова, позиція_початку: позитивне, вихід_позиції_кінця: адреса<позитивне>): логічне {
      якщо слова.дані[позиція_початку].вид != ВидСловаСимволМіжряд {
        вернути ні;
      }
      змінна п = позиція_початку;
      поки слова.дані[п].вид == ВидСловаСимволМіжряд {
        п += 1;
      }
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія спробувати_розібрати_заперечення(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      якщо слова.дані[п].вид != ВидСловаСимволЗнакОклику {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;
      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: позитивне = 0;
      якщо спробувати_розібрати_мікрооперацію(система, слова, п, сполука_значення::адреса, п::адреса, позиція_помилки_сполуки_значення::адреса) {
      } інакше {
        вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
        вернути ні;
      }
      змінна сполука_самооперація = виділити<Сполука>(система);
      сполука_самооперація.вид = ВидСполукиСамоОперація;
      сполука_самооперація.дані = ДаніСполукиСамоОперація {
        операція = ВидСамоОпераціїЛогічнеНі,
        предмет = сполука_значення
      };
      сполука_самооперація.місцезнаходження = Місцезнаходження { позиція_початку };
      вихід::вміст = сполука_самооперація;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія спробувати_розібрати_двійкове_заперечення(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      якщо слова.дані[п].вид != ВидСловаСимволТильда {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;
      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: позитивне = 0;
      якщо спробувати_розібрати_мікрооперацію(система, слова, п, сполука_значення::адреса, п::адреса, позиція_помилки_сполуки_значення::адреса) {
      } інакше {
        вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
        вернути ні;
      }
      змінна сполука_самооперація = виділити<Сполука>(система);
      сполука_самооперація.вид = ВидСполукиСамоОперація;
      сполука_самооперація.дані = ДаніСполукиСамоОперація {
        операція = ВидСамоОпераціїДвійковеНі,
        предмет = сполука_значення
      };
      сполука_самооперація.місцезнаходження = Місцезнаходження { позиція_початку };
      вихід::вміст = сполука_самооперація;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія спробувати_розібрати_префікс_плюс(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      якщо слова.дані[п].вид != ВидСловаСимволПлюс {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;
      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: позитивне = 0;
      якщо спробувати_розібрати_мікрооперацію(система, слова, п, сполука_значення::адреса, п::адреса, позиція_помилки_сполуки_значення::адреса) {
      } інакше {
        вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
        вернути ні;
      }
      змінна сполука_самооперація = виділити<Сполука>(система);
      сполука_самооперація.вид = ВидСполукиСамоОперація;
      сполука_самооперація.дані = ДаніСполукиСамоОперація {
        операція = ВидСамоОпераціїПлюс,
        предмет = сполука_значення
      };
      сполука_самооперація.місцезнаходження = Місцезнаходження { позиція_початку };
      вихід::вміст = сполука_самооперація;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія спробувати_розібрати_префікс_мінус(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      якщо слова.дані[п].вид != ВидСловаСимволМінус {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;
      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: позитивне = 0;
      якщо спробувати_розібрати_мікрооперацію(система, слова, п, сполука_значення::адреса, п::адреса, позиція_помилки_сполуки_значення::адреса) {
      } інакше {
        вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
        вернути ні;
      }
      змінна сполука_самооперація = виділити<Сполука>(система);
      сполука_самооперація.вид = ВидСполукиСамоОперація;
      сполука_самооперація.дані = ДаніСполукиСамоОперація {
        операція = ВидСамоОпераціїМінус,
        предмет = сполука_значення
      };
      сполука_самооперація.місцезнаходження = Місцезнаходження { позиція_початку };
      вихід::вміст = сполука_самооперація;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія спробувати_розібрати_видалити(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      якщо слова.дані[п].вид != ВидСловаВидалити {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;
      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: позитивне = 0;
      якщо спробувати_розібрати_молекулу(система, слова, п, сполука_значення::адреса, п::адреса, позиція_помилки_сполуки_значення::адреса) {
      } інакше {
        вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
        вернути ні;
      }
      якщо сполука_значення.вид == ВидСполукиЗвернутись {
        змінна дані = сполука_значення.дані як ДаніСполукиЗвернутись;
        змінна сполука_видалити = виділити<Сполука>(система);
        сполука_видалити.вид = ВидСполукиВидалити;
        сполука_видалити.дані = ДаніСполукиВидалити {
          ідентифікатор = дані.ідентифікатор
        };
        сполука_видалити.місцезнаходження = Місцезнаходження { позиція_початку };
        вихід::вміст = сполука_видалити;
        вихід_позиції_кінця::вміст = п;
        звільнити(система, сполука_значення);
        вернути так;
      }
      якщо сполука_значення.вид == ВидСполукиОтримати {
        змінна дані = сполука_значення.дані як ДаніСполукиОтримати;
        змінна сполука_видалити_властивість = виділити<Сполука>(система);
        сполука_видалити_властивість.вид = ВидСполукиВидалитиВластивість;
        сполука_видалити_властивість.дані = ДаніСполукиВидалитиВластивість {
          предмет = дані.предмет,
          ідентифікатор = дані.ідентифікатор
        };
        сполука_видалити_властивість.місцезнаходження = Місцезнаходження { позиція_початку };
        вихід::вміст = сполука_видалити_властивість;
        вихід_позиції_кінця::вміст = п;
        звільнити(система, сполука_значення);
        вернути так;
      }
      якщо сполука_значення.вид == ВидСполукиОтриматиЕлемент {
        змінна дані = сполука_значення.дані як ДаніСполукиОтриматиЕлемент;
        змінна сполука_видалити_елемент = виділити<Сполука>(система);
        сполука_видалити_елемент.вид = ВидСполукиВидалитиЕлемент;
        сполука_видалити_елемент.дані = ДаніСполукиВидалитиЕлемент {
          предмет = дані.предмет,
          ключ = дані.ключ
        };
        сполука_видалити_елемент.місцезнаходження = Місцезнаходження { позиція_початку };
        вихід::вміст = сполука_видалити_елемент;
        вихід_позиції_кінця::вміст = п;
        звільнити(система, сполука_значення);
        вернути так;
      }
      вихід_позиції_помилки::вміст = п;
      вернути ні;
    }

    дія спробувати_розібрати_чекати(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      якщо слова.дані[п].вид != ВидСловаЧекати {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;
      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: позитивне = 0;
      якщо спробувати_розібрати_мікрооперацію(система, слова, п, сполука_значення::адреса, п::адреса, позиція_помилки_сполуки_значення::адреса) {
      } інакше {
        вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
        вернути ні;
      }
      змінна сполука_чекати = виділити<Сполука>(система);
      сполука_чекати.вид = ВидСполукиЧекати;
      сполука_чекати.дані = ДаніСполукиЧекати {
        значення = сполука_значення
      };
      сполука_чекати.місцезнаходження = Місцезнаходження { позиція_початку };
      вихід::вміст = сполука_чекати;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія спробувати_розібрати_частинку(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      якщо слова.дані[п].вид == ВидСловаСимволВідкритаДужка {
        п += 1;
        зʼїсти_міжрядки(слова, п, п::адреса);
        змінна сполука_гнізда: адреса<Сполука> = пусто;
        змінна позиція_помилки_сполуки_гнізда: позитивне = 0;
        якщо спробувати_розібрати_значення(система, слова, п, сполука_гнізда::адреса, п::адреса, так, позиція_помилки_сполуки_гнізда::адреса) {
          п += 1;
          зʼїсти_міжрядки(слова, п, п::адреса);
          якщо слова.дані[п].вид == ВидСловаСимволЗакритаДужка {
            вихід::вміст = сполука_гнізда;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          } інакше {
            позиція_помилки_сполуки_гнізда = п;
            звільнити_сполуку(система, сполука_гнізда);
          }
        }
        вихід_позиції_помилки::вміст = позиція_помилки_сполуки_гнізда;
        вернути ні;
      }
      п = позиція_початку;
      якщо слова.дані[п].вид == ВидСловаІдентифікатор {
        змінна позиція_ідентифікатора = п;
        п += 1;
        якщо слова.дані[п].вид == ВидСловаТекст {
          змінна сполука_тексту = виділити<Сполука>(система);
          сполука_тексту.вид = ВидСполукиТекст;
          сполука_тексту.дані = ДаніСполукиТекст {
            ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { позиція_ідентифікатора } },
            позиція_слова = п
          };
          сполука_тексту.місцезнаходження = Місцезнаходження { позиція_ідентифікатора };
          вихід::вміст = сполука_тексту;
          вихід_позиції_кінця::вміст = п;
          вернути так;
        } інакше якщо слова.дані[п].вид == ВидСловаБагаторядковийТекст {
          змінна сполука_тексту = виділити<Сполука>(система);
          сполука_тексту.вид = ВидСполукиТекст;
          сполука_тексту.дані = ДаніСполукиТекст {
            ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { позиція_ідентифікатора } },
            позиція_слова = п
          };
          сполука_тексту.місцезнаходження = Місцезнаходження { позиція_ідентифікатора };
          вихід::вміст = сполука_тексту;
          вихід_позиції_кінця::вміст = п;
          вернути так;
        } інакше якщо слова.дані[п].вид == ВидСловаСимвол {
          змінна сполука_символа = виділити<Сполука>(система);
          сполука_символа.вид = ВидСполукиСимвол;
          сполука_символа.дані = ДаніСполукиСимвол {
            ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { позиція_ідентифікатора } },
            позиція_слова = п
          };
          сполука_символа.місцезнаходження = Місцезнаходження { позиція_ідентифікатора };
          вихід::вміст = сполука_символа;
          вихід_позиції_кінця::вміст = п;
          вернути так;
        } інакше якщо слова.дані[п].вид == ВидСловаПочатокЗбитогоТексту {
          п += 1;
          змінна накопичувач_гілок = зробити_накопичувач<адреса<Сполука>>(система);
          поки п < слова.розмір {
            змінна сполука_значення: адреса<Сполука> = пусто;
            змінна позиція_помилки_збитого_тексту: позитивне = 0;
            якщо слова.дані[п].вид == ВидСловаЧастинаЗбитогоТексту {
              змінна сполука_тексту = виділити<Сполука>(система);
              сполука_тексту.вид = ВидСполукиТекст;
              сполука_тексту.дані = ДаніСполукиТекст {
                ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { позиція_ідентифікатора } },
                позиція_слова = п
              };
              сполука_тексту.місцезнаходження = Місцезнаходження { позиція_ідентифікатора };
              покласти_в_накопичувач<адреса<Сполука>>(система, накопичувач_гілок::адреса, сполука_тексту);
              п += 1;
            } інакше якщо спробувати_розібрати_значення(система, слова, п, сполука_значення::адреса, п::адреса, ні, позиція_помилки_збитого_тексту::адреса) {
              покласти_в_накопичувач<адреса<Сполука>>(система, накопичувач_гілок::адреса, сполука_значення);
              п += 1;
            } інакше {
              вихід_позиції_помилки::вміст = позиція_помилки_збитого_тексту;
              звільнити_сполуки(система, Сполуки { накопичувач_гілок.розмір, накопичувач_гілок.дані });
              вернути ні;
            }
            якщо слова.дані[п].вид == ВидСловаРоздільникЗбитогоТексту {
              п += 1;
            } інакше якщо слова.дані[п].вид == ВидСловаКінецьЗбитогоТексту {
              стрибнути вихід_збитого_тексту_з_ідентифікатором;
            } інакше {
              вихід_позиції_помилки::вміст = п;
              звільнити_сполуки(система, Сполуки { накопичувач_гілок.розмір, накопичувач_гілок.дані });
              вернути ні;
            }
          }
          вихід_збитого_тексту_з_ідентифікатором:
          якщо накопичувач_гілок.розмір == 1 {
            змінна сполука = накопичувач_гілок.дані[0];
            звільнити_памʼять(система, накопичувач_гілок.дані);
            вихід::вміст = сполука;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          } інакше {
            змінна сполука_збитого_тексту = виділити<Сполука>(система);
            сполука_збитого_тексту.вид = ВидСполукиЗбитийТекст;
            сполука_збитого_тексту.дані = ДаніСполукиЗбитийТекст {
              ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { позиція_ідентифікатора } },
              кількість_гілок = накопичувач_гілок.розмір,
              сполуки = накопичувач_гілок.дані,
            };
            сполука_збитого_тексту.місцезнаходження = Місцезнаходження { п };
            вихід::вміст = сполука_збитого_тексту;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          }
        } інакше {
          п -= 1;
        }
        змінна сполука_звернення = виділити<Сполука>(система);
        сполука_звернення.вид = ВидСполукиЗвернутись;
        сполука_звернення.дані = ДаніСполукиЗвернутись {
          ідентифікатор = Ідентифікатор { п }
        };
        сполука_звернення.місцезнаходження = Місцезнаходження { п };
        вихід::вміст = сполука_звернення;
        вихід_позиції_кінця::вміст = п;
        вернути так;
      }
      якщо слова.дані[п].вид == ВидСловаЧисло {
        змінна сполука_числа = виділити<Сполука>(система);
        сполука_числа.вид = ВидСполукиЧисло;
        сполука_числа.дані = ДаніСполукиЧисло {
          позиція_слова = п
        };
        сполука_числа.місцезнаходження = Місцезнаходження { п };
        вихід::вміст = сполука_числа;
        вихід_позиції_кінця::вміст = п;
        вернути так;
      }
      якщо слова.дані[п].вид == ВидСловаТекст {
        змінна сполука_тексту = виділити<Сполука>(система);
        сполука_тексту.вид = ВидСполукиТекст;
        сполука_тексту.дані = ДаніСполукиТекст {
          ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), ... },
          позиція_слова = п
        };
        сполука_тексту.місцезнаходження = Місцезнаходження { п };
        вихід::вміст = сполука_тексту;
        вихід_позиції_кінця::вміст = п;
        вернути так;
      }
      якщо слова.дані[п].вид == ВидСловаБагаторядковийТекст {
        змінна сполука_тексту = виділити<Сполука>(система);
        сполука_тексту.вид = ВидСполукиТекст;
        сполука_тексту.дані = ДаніСполукиТекст {
          ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), ... },
          позиція_слова = п
        };
        сполука_тексту.місцезнаходження = Місцезнаходження { п };
        вихід::вміст = сполука_тексту;
        вихід_позиції_кінця::вміст = п;
        вернути так;
      }
      якщо слова.дані[п].вид == ВидСловаСимвол {
        змінна сполука_символа = виділити<Сполука>(система);
        сполука_символа.вид = ВидСполукиСимвол;
        сполука_символа.дані = ДаніСполукиСимвол {
          ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), ... },
          позиція_слова = п
        };
        сполука_символа.місцезнаходження = Місцезнаходження { п };
        вихід::вміст = сполука_символа;
        вихід_позиції_кінця::вміст = п;
        вернути так;
      }
      якщо слова.дані[п].вид == ВидСловаПочатокЗбитогоТексту {
        п += 1;
        змінна накопичувач_гілок = зробити_накопичувач<адреса<Сполука>>(система);
        поки п < слова.розмір {
          змінна сполука_значення: адреса<Сполука> = пусто;
          змінна позиція_помилки_збитого_тексту: позитивне = 0;
          якщо слова.дані[п].вид == ВидСловаЧастинаЗбитогоТексту {
            змінна сполука_тексту = виділити<Сполука>(система);
            сполука_тексту.вид = ВидСполукиТекст;
            сполука_тексту.дані = ДаніСполукиТекст {
              ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), ... },
              позиція_слова = п
            };
            сполука_тексту.місцезнаходження = Місцезнаходження { п };
            покласти_в_накопичувач<адреса<Сполука>>(система, накопичувач_гілок::адреса, сполука_тексту);
            п += 1;
          } інакше якщо спробувати_розібрати_значення(система, слова, п, сполука_значення::адреса, п::адреса, ні, позиція_помилки_збитого_тексту::адреса) {
            покласти_в_накопичувач<адреса<Сполука>>(система, накопичувач_гілок::адреса, сполука_значення);
            п += 1;
          } інакше {
            вихід_позиції_помилки::вміст = позиція_помилки_збитого_тексту;
            звільнити_сполуки(система, Сполуки { накопичувач_гілок.розмір, накопичувач_гілок.дані });
            вернути ні;
          }
          якщо слова.дані[п].вид == ВидСловаРоздільникЗбитогоТексту {
            п += 1;
          } інакше якщо слова.дані[п].вид == ВидСловаКінецьЗбитогоТексту {
            стрибнути вихід_збитого_тексту;
          } інакше {
            вихід_позиції_помилки::вміст = п;
            звільнити_сполуки(система, Сполуки { накопичувач_гілок.розмір, накопичувач_гілок.дані });
            вернути ні;
          }
        }
        вихід_збитого_тексту:
        якщо накопичувач_гілок.розмір == 1 {
          змінна сполука = накопичувач_гілок.дані[0];
          звільнити_памʼять(система, накопичувач_гілок.дані);
          вихід::вміст = сполука;
          вихід_позиції_кінця::вміст = п;
          вернути так;
        } інакше {
          змінна сполука_збитого_тексту = виділити<Сполука>(система);
          сполука_збитого_тексту.вид = ВидСполукиЗбитийТекст;
          сполука_збитого_тексту.дані = ДаніСполукиЗбитийТекст {
            ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), ... },
            кількість_гілок = накопичувач_гілок.розмір,
            сполуки = накопичувач_гілок.дані,
          };
          сполука_збитого_тексту.місцезнаходження = Місцезнаходження { п };
          вихід::вміст = сполука_збитого_тексту;
          вихід_позиції_кінця::вміст = п;
          вернути так;
        }
      }
      вихід_позиції_помилки::вміст = п;
      вернути ні;
    }

    дія спробувати_розібрати_атом(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      якщо слова.дані[п].вид == ВидСловаСимволКвадратнаВідкритаДужка {
        змінна позиція_початку_списку = п;
        п += 1;
        зʼїсти_міжрядки(слова, п, п::адреса);
        якщо слова.дані[п].вид == ВидСловаСимволКвадратнаЗакритаДужка {
          змінна сполука_списку = виділити<Сполука>(система);
          сполука_списку.вид = ВидСполукиСписок;
          сполука_списку.дані = ДаніСполукиСписок {
            кількість_елементів = 0,
            елементи = пусто
          };
          сполука_списку.місцезнаходження = Місцезнаходження { позиція_початку_списку };
          вихід::вміст = сполука_списку;
          вихід_позиції_кінця::вміст = п;
          вернути так;
        }
        якщо слова.дані[п].вид == ВидСловаСимволРівно {
          п += 1;
          зʼїсти_міжрядки(слова, п, п::адреса);
          якщо слова.дані[п].вид == ВидСловаСимволКвадратнаЗакритаДужка {
            змінна сполука_словника = виділити<Сполука>(система);
            сполука_словника.вид = ВидСполукиСловник;
            сполука_словника.дані = ДаніСполукиСловник {
              кількість_елементів = 0,
              елементи = пусто
            };
            сполука_словника.місцезнаходження = Місцезнаходження { позиція_початку_списку };
            вихід::вміст = сполука_словника;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          }
          вихід_позиції_помилки::вміст = п;
          вернути ні;
        }
        змінна елементи_списку = зробити_накопичувач<адреса<Сполука>>(система);
        змінна елементи_словника = зробити_накопичувач<ЕлементСловника>(система);
        поки п < слова.розмір {
          змінна сполука_ключа_елемента: адреса<Сполука> = пусто;
          змінна сполука_значення_елемента: адреса<Сполука> = пусто;
          змінна позиція_помилки_елемента: позитивне = 0;
          якщо спробувати_розібрати_значення(система, слова, п, сполука_ключа_елемента::адреса, п::адреса, ні, позиція_помилки_елемента::адреса) {
            п += 1;
            зʼїсти_міжрядки(слова, п, п::адреса);
            якщо слова.дані[п].вид == ВидСловаСимволРівно {
              п += 1;
              зʼїсти_міжрядки(слова, п, п::адреса);
              якщо спробувати_розібрати_значення(система, слова, п, сполука_значення_елемента::адреса, п::адреса, ні, позиція_помилки_елемента::адреса) {
                п += 1;
              } інакше {
                звільнити_сполуку(система, сполука_ключа_елемента);
                звільнити_сполуки(система, Сполуки { елементи_списку.розмір, елементи_списку.дані });
                звільнити_елементи_словника(система, елементи_словника.розмір, елементи_словника.дані);
                вихід_позиції_помилки::вміст = позиція_помилки_елемента;
                вернути ні;
              }
            } інакше {
              сполука_значення_елемента = сполука_ключа_елемента;
              сполука_ключа_елемента = пусто;
            }


          } інакше {
            звільнити_сполуки(система, Сполуки { елементи_списку.розмір, елементи_списку.дані });
            звільнити_елементи_словника(система, елементи_словника.розмір, елементи_словника.дані);
            вихід_позиції_помилки::вміст = позиція_помилки_елемента;
            вернути ні;
          }
          якщо сполука_ключа_елемента == пусто {
            якщо елементи_словника.розмір != 0 {
              звільнити_сполуку(система, сполука_ключа_елемента);
              звільнити_сполуку(система, сполука_значення_елемента);
              звільнити_сполуки(система, Сполуки { елементи_списку.розмір, елементи_списку.дані });
              звільнити_елементи_словника(система, елементи_словника.розмір, елементи_словника.дані);
              вихід_позиції_помилки::вміст = позиція_помилки_елемента;
              вернути ні;
            }
            покласти_в_накопичувач<адреса<Сполука>>(система, елементи_списку::адреса, сполука_значення_елемента);
          } інакше {
            якщо елементи_списку.розмір != 0 {
              звільнити_сполуку(система, сполука_ключа_елемента);
              звільнити_сполуку(система, сполука_значення_елемента);
              звільнити_сполуки(система, Сполуки { елементи_списку.розмір, елементи_списку.дані });
              звільнити_елементи_словника(система, елементи_словника.розмір, елементи_словника.дані);
              вихід_позиції_помилки::вміст = позиція_помилки_елемента;
              вернути ні;
            }
            покласти_в_накопичувач<ЕлементСловника>(система, елементи_словника::адреса, ЕлементСловника {
              ключ = сполука_ключа_елемента,
              значення = сполука_значення_елемента,
              місцезнаходження = Місцезнаходження { позиція_початку }
            });
          }
          зʼїсти_міжрядки(слова, п, п::адреса);
          якщо слова.дані[п].вид == ВидСловаСимволКома {
            п += 1;
            зʼїсти_міжрядки(слова, п, п::адреса);
          } інакше якщо слова.дані[п].вид == ВидСловаСимволКвадратнаЗакритаДужка {
            якщо елементи_словника.розмір != 0 {
              змінна сполука_словника = виділити<Сполука>(система);
              сполука_словника.вид = ВидСполукиСловник;
              сполука_словника.дані = ДаніСполукиСловник {
                кількість_елементів = елементи_словника.розмір,
                елементи = елементи_словника.дані
              };
              сполука_словника.місцезнаходження = Місцезнаходження { позиція_початку_списку };
              вихід::вміст = сполука_словника;
              вихід_позиції_кінця::вміст = п;
              вернути так;
            } інакше {
              змінна сполука_списку = виділити<Сполука>(система);
              сполука_списку.вид = ВидСполукиСписок;
              сполука_списку.дані = ДаніСполукиСписок {
                кількість_елементів = елементи_списку.розмір,
                елементи = елементи_списку.дані
              };
              сполука_списку.місцезнаходження = Місцезнаходження { позиція_початку_списку };
              вихід::вміст = сполука_списку;
              вихід_позиції_кінця::вміст = п;
              вернути так;
            }
          } інакше {
            звільнити_сполуки(система, Сполуки { елементи_списку.розмір, елементи_списку.дані });
            звільнити_елементи_словника(система, елементи_словника.розмір, елементи_словника.дані);
          }
        }
        звільнити_сполуки(система, Сполуки { елементи_списку.розмір, елементи_списку.дані });
        звільнити_елементи_словника(система, елементи_словника.розмір, елементи_словника.дані);
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п = позиція_початку;
      якщо спробувати_розібрати_частинку(система, слова, п, вихід, вихід_позиції_кінця, вихід_позиції_помилки) {
        вернути так;
      }
      вернути ні;
    }

    дія спробувати_розібрати_аргумент(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<Аргумент>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      змінна має_ідентифікатор = ні;
      змінна позиція_ідентифікатора = п;
      якщо слова.дані[п].вид == ВидСловаІдентифікатор {
        має_ідентифікатор = так;
        п += 1;
        зʼїсти_міжрядки(слова, п, п::адреса);
        якщо слова.дані[п].вид == ВидСловаСимволРівно {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволРівно {
            має_ідентифікатор = ні;
            п = позиція_ідентифікатора;
          } інакше {
            зʼїсти_міжрядки(слова, п, п::адреса);
          }
        } інакше {
          має_ідентифікатор = ні;
          п = позиція_ідентифікатора;
        }
      }
      змінна сполука_значення_аргумента: адреса<Сполука> = пусто;
      змінна позиція_помилки_аргумента: позитивне = 0;
      якщо спробувати_розібрати_значення(система, слова, п, сполука_значення_аргумента::адреса, п::адреса, ні, позиція_помилки_аргумента::адреса) {
        якщо має_ідентифікатор {
          вихід::вміст = Аргумент {
            ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { позиція_ідентифікатора } },
            значення = сполука_значення_аргумента,
            місцезнаходження = Місцезнаходження { позиція_початку }
          };
        } інакше {
          вихід::вміст = Аргумент {
            ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), ... },
            значення = сполука_значення_аргумента,
            місцезнаходження = Місцезнаходження { позиція_початку }
          };
        }
        вихід_позиції_кінця::вміст = п;
        вернути так;
      }
      вихід_позиції_помилки::вміст = позиція_помилки_аргумента;
      вернути ні;
    }

    //
    // --- з рекурсією ---
    // молекула = (молекула ('.' ідентифікатор)) | атом;
    //
    // --- без рекурсії ---
    // молекула = атом хвіст_молекули;
    // хвіст_молекули = ('.' ідентифікатор хвіст_молекули) | ;
    //
    дія спробувати_розібрати_молекулу(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      змінна сполука_атома: адреса<Сполука> = пусто;
      змінна позиція_помилки_атома: позитивне = 0;
      якщо спробувати_розібрати_атом(система, слова, п, сполука_атома::адреса, п::адреса, позиція_помилки_атома::адреса) {
        п += 1;
        змінна сполука_хвоста: адреса<Сполука> = пусто;
        змінна позиція_помилки_хвоста: позитивне = 0;
        якщо спробувати_розібрати_молекулу__хвіст(система, слова, п, позиція_початку, сполука_хвоста::адреса, п::адреса, сполука_атома, позиція_помилки_хвоста::адреса) {
          вихід::вміст = сполука_хвоста;
          вихід_позиції_кінця::вміст = п;
          вернути так;
        } інакше {
          п -= 1;
        }
        вихід::вміст = сполука_атома;
        вихід_позиції_кінця::вміст = п;
        вернути так;
      } інакше {
        вихід_позиції_помилки::вміст = позиція_помилки_атома;
        стрибнути звільнити_і_вийти;
      }
      звільнити_і_вийти:
      вернути ні;
    }

    дія спробувати_розібрати_молекулу__хвіст(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, позиція_початку_молекули: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, сполука_атома: адреса<Сполука>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      змінна п_перед_зʼїданням = п;
      якщо зʼїсти_міжрядки(слова, п, п::адреса) {
        якщо слова.дані[п].вид == ВидСловаСимволКрапка {
          стрибнути отримання_властивості;
        } інакше {
          п = п_перед_зʼїданням;
        }
      }
      якщо слова.дані[п].вид == ВидСловаСимволКрапка { // отримати властивість
        отримання_властивості:
        п += 1;
        зʼїсти_міжрядки(слова, п, п::адреса);
        якщо слова.дані[п].вид == ВидСловаІдентифікатор {
          змінна сполука_отримати_властивість = виділити<Сполука>(система);
          сполука_отримати_властивість.вид = ВидСполукиОтримати;
          сполука_отримати_властивість.дані = ДаніСполукиОтримати {
            предмет = сполука_атома,
            ідентифікатор = Ідентифікатор { п }
          };
          сполука_отримати_властивість.місцезнаходження = Місцезнаходження { позиція_початку_молекули };
          п += 1;
          змінна позиція_помилки_молекули_хвоста: позитивне = 0;
          якщо спробувати_розібрати_молекулу__хвіст(система, слова, п, позиція_початку_молекули, вихід, вихід_позиції_кінця, сполука_отримати_властивість, позиція_помилки_молекули_хвоста::адреса) {
            вернути так;
          } інакше {
            звільнити(система, сполука_отримати_властивість);
            вихід_позиції_помилки::вміст = позиція_помилки_молекули_хвоста;
            вернути ні;
          }
        }
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      } інакше якщо слова.дані[п].вид == ВидСловаСимволКвадратнаВідкритаДужка { // отримати елемент
        п += 1;
        зʼїсти_міжрядки(слова, п, п::адреса);
        змінна сполука_ключа: адреса<Сполука> = пусто;
        змінна позиція_помилки_ключа: позитивне = 0;
        якщо спробувати_розібрати_молекулу(система, слова, п, сполука_ключа::адреса, п::адреса, позиція_помилки_ключа::адреса) {
          п += 1;
        } інакше {
          вихід_позиції_помилки::вміст = позиція_помилки_ключа;
          вернути ні;
        }
        змінна сполука_отримати_елемент = виділити<Сполука>(система);
        сполука_отримати_елемент.вид = ВидСполукиОтриматиЕлемент;
        сполука_отримати_елемент.дані = ДаніСполукиОтриматиЕлемент {
          предмет = сполука_атома,
          ключ = сполука_ключа
        };
        сполука_отримати_елемент.місцезнаходження = Місцезнаходження { позиція_початку_молекули };
        зʼїсти_міжрядки(слова, п, п::адреса);
        якщо слова.дані[п].вид == ВидСловаСимволКвадратнаЗакритаДужка {
          п += 1;
          змінна позиція_помилки_молекули_хвоста: позитивне = 0;
          якщо спробувати_розібрати_молекулу__хвіст(система, слова, п, позиція_початку_молекули, вихід, вихід_позиції_кінця, сполука_отримати_елемент, позиція_помилки_молекули_хвоста::адреса) {
            вернути так;
          } інакше {
            звільнити(система, сполука_ключа);
            звільнити(система, сполука_отримати_елемент);
            вихід_позиції_помилки::вміст = позиція_помилки_молекули_хвоста;
            вернути ні;
          }
        }
        звільнити(система, сполука_ключа);
        звільнити(система, сполука_отримати_елемент);
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      } інакше якщо слова.дані[п].вид == ВидСловаСимволВідкритаДужка { // виконати дію
        п += 1;
        зʼїсти_міжрядки(слова, п, п::адреса);
        змінна аргументи = зробити_накопичувач<Аргумент>(система);
        якщо слова.дані[п].вид == ВидСловаСимволЗакритаДужка {
          п += 1;
          стрибнути виклик__хвіст;
        }
        поки п < слова.розмір {
          змінна аргумент = Аргумент { ... };
          змінна позиція_помилки_аргумента: позитивне = 0;
          якщо спробувати_розібрати_аргумент(система, слова, п, аргумент::адреса, п::адреса, позиція_помилки_аргумента::адреса) {
            покласти_в_накопичувач<Аргумент>(система, аргументи::адреса, аргумент);
            п += 1;
            зʼїсти_міжрядки(слова, п, п::адреса);
            якщо слова.дані[п].вид == ВидСловаСимволЗакритаДужка {
              п += 1;
              стрибнути виклик__хвіст;
            } інакше якщо слова.дані[п].вид == ВидСловаСимволКома {
              п += 1;
              зʼїсти_міжрядки(слова, п, п::адреса);
            } інакше {
              звільнити_аргументи(система, аргументи.розмір, аргументи.дані);
              вихід_позиції_помилки::вміст = п;
              вернути ні;
            }
          } інакше {
            звільнити_аргументи(система, аргументи.розмір, аргументи.дані);
            вихід_позиції_помилки::вміст = позиція_помилки_аргумента;
            вернути ні;
          }
        }
        якщо слова.дані[п].вид == ВидСловаСимволЗакритаДужка {
          п += 1;
          виклик__хвіст:
          змінна сполука_виконати = виділити<Сполука>(система);
          сполука_виконати.вид = ВидСполукиВиконати;
          сполука_виконати.дані = ДаніСполукиВиконати {
            предмет = сполука_атома,
            кількість_аргументів = аргументи.розмір,
            аргументи = аргументи.дані,
          };
          сполука_виконати.місцезнаходження = Місцезнаходження { позиція_початку_молекули };
          змінна позиція_помилки_молекули_хвоста: позитивне = 0;
          якщо спробувати_розібрати_молекулу__хвіст(система, слова, п, позиція_початку_молекули, вихід, вихід_позиції_кінця, сполука_виконати, позиція_помилки_молекули_хвоста::адреса) {
            вернути так;
          } інакше {
            звільнити_аргументи(система, аргументи.розмір, аргументи.дані);
            вихід_позиції_помилки::вміст = позиція_помилки_молекули_хвоста;
            вернути ні;
          }
        }
        звільнити_аргументи(система, аргументи.розмір, аргументи.дані);
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      вихід::вміст = сполука_атома;
      вихід_позиції_кінця::вміст = п - 1;
      вернути так;
    }

    дія спробувати_розібрати_мікрооперацію(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      змінна сполука_молекули: адреса<Сполука> = пусто;
      змінна позиція_помилки_молекули: позитивне = 0;
      якщо спробувати_розібрати_молекулу(система, слова, п, сполука_молекули::адреса, п::адреса, позиція_помилки_молекули::адреса) {
        п += 1;
        якщо слова.дані[п].вид == ВидСловаСимволКрапка {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволКрапка {
            п += 1;
            змінна включно = ні;
            якщо слова.дані[п].вид == ВидСловаСимволРівно {
              включно = так;
              п += 1;
            }
            змінна сполука_молекули_право: адреса<Сполука> = пусто;
            змінна позиція_помилки_молекули_право: позитивне = 0;
            якщо спробувати_розібрати_молекулу(система, слова, п, сполука_молекули_право::адреса, п::адреса, позиція_помилки_молекули_право::адреса) {
              змінна сполука_діапазон = виділити<Сполука>(система);
              сполука_діапазон.вид = ВидСполукиДіапазон;
              сполука_діапазон.дані = ДаніСполукиДіапазон {
                від = сполука_молекули,
                до = сполука_молекули_право,
                включно = позитивне(включно)
              };
              сполука_діапазон.місцезнаходження = Місцезнаходження { позиція_початку };
              вихід::вміст = сполука_діапазон;
              вихід_позиції_кінця::вміст = п;
              вернути так;
            } інакше {
              вихід_позиції_помилки::вміст = позиція_помилки_молекули_право;
              вернути ні;
            }
          } інакше {
            вихід::вміст = сполука_молекули;
            вихід_позиції_кінця::вміст = п - 2;
            вернути так;
          }
        } інакше {
          вихід::вміст = сполука_молекули;
          вихід_позиції_кінця::вміст = п - 1;
          вернути так;
        }
      }
      змінна позиція_помилки: позитивне = позиція_помилки_молекули;
      змінна найдовша_позиція_помилки: позитивне = позиція_помилки;
      якщо спробувати_розібрати_заперечення(система, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }
      якщо спробувати_розібрати_двійкове_заперечення(система, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }
      якщо спробувати_розібрати_префікс_плюс(система, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }
      якщо спробувати_розібрати_префікс_мінус(система, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }
      якщо спробувати_розібрати_видалити(система, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }
      якщо спробувати_розібрати_чекати(система, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }
      вихід_позиції_помилки::вміст = найдовша_позиція_помилки;
      вернути ні;
    }

    дія спробувати_розібрати_операцію(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, в_гнізді: логічне, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      змінна сполука_ліво: адреса<Сполука> = пусто;
      змінна позиція_помилки_ліво: позитивне = 0;
      якщо спробувати_розібрати_мікрооперацію(система, слова, п, сполука_ліво::адреса, п::адреса, позиція_помилки_ліво::адреса) {
        п += 1;
        змінна сполука_результату: адреса<Сполука> = пусто;
        змінна позиція_помилки_сполуки_результату: позитивне = 0;
        якщо спробувати_розібрати_операцію_1(система, слова, п, сполука_результату::адреса, п::адреса, сполука_ліво, 0, в_гнізді, позиція_помилки_сполуки_результату::адреса) {
          вихід::вміст = сполука_результату;
          вихід_позиції_кінця::вміст = п;
          вернути так;
        } інакше {
          вихід::вміст = сполука_ліво;
          вихід_позиції_кінця::вміст = п - 1;
          вернути так;
        }
      } інакше {
        вихід_позиції_помилки::вміст = позиція_помилки_ліво;
        стрибнути звільнити_і_вийти;
      }
      звільнити_і_вийти:
      вернути ні;
    }

    структура ІнформаціяОперації {
      вид_операції: позитивне;
      кількість_слів: позитивне;
      пріоритет: позитивне;
    }
  
    дія дізнатись_інформацію_операції(слова: Слова, позиція: позитивне): ІнформаціяОперації {
      якщо слова.дані[позиція].вид == ВидСловаКІНЕЦЬСЛІВ {
        вернути ІнформаціяОперації { 0, 0, 0 };
      }
      змінна вид = слова.дані[позиція].вид;
      змінна вид_далі = слова.дані[позиція + 1].вид;
      якщо вид == ВидСловаСимволПлюс {
        вернути ІнформаціяОперації { ВидОпераціїДодавання, 1, 97 };
      }
      якщо вид == ВидСловаСимволМінус {
        вернути ІнформаціяОперації { ВидОпераціїВіднімання, 1, 97 };
      }
      якщо вид == ВидСловаСимволПомножити {
        якщо вид_далі == ВидСловаСимволПомножити {
          вернути ІнформаціяОперації { ВидОпераціїПіднесенняДоСтепеня, 2, 100 };
        }
        вернути ІнформаціяОперації { ВидОпераціїМноження, 1, 98 };
      }
      якщо вид == ВидСловаСимволПоділити {
        якщо вид_далі == ВидСловаСимволПоділити {
          вернути ІнформаціяОперації { ВидОпераціїДіленняНаціло, 2, 99 };
        }
        вернути ІнформаціяОперації { ВидОпераціїДілення, 1, 98 };
      }
      якщо вид == ВидСловаСимволЗалишку {
        вернути ІнформаціяОперації { ВидОпераціїМодуль, 1, 98 };
      }
      якщо вид == ВидСловаСимволБільше {
        якщо вид_далі == ВидСловаСимволБільше {
          якщо слова.дані[позиція + 2].вид == ВидСловаСимволБільше {
            вернути ІнформаціяОперації { ВидОпераціїЗсувВправоЗнаковий, 3, 96 };
          }
          вернути ІнформаціяОперації { ВидОпераціїЗсувВправо, 2, 96 };
        }
        якщо вид_далі == ВидСловаСимволРівно {
          вернути ІнформаціяОперації { ВидОпераціїБільшеРівне, 2, 95 };
        }
        вернути ІнформаціяОперації { ВидОпераціїБільше, 1, 95 };
      }
      якщо вид == ВидСловаСимволМенше {
        якщо вид_далі == ВидСловаСимволМенше {
          вернути ІнформаціяОперації { ВидОпераціїЗсувВліво, 2, 96 };
        }
        якщо вид_далі == ВидСловаСимволРівно {
          вернути ІнформаціяОперації { ВидОпераціїМеншеРівне, 2, 95 };
        }
        вернути ІнформаціяОперації { ВидОпераціїМенше, 1, 95 };
      }
      якщо вид == ВидСловаБільше {
        вернути ІнформаціяОперації { ВидОпераціїБільше, 1, 95 };
      }
      якщо вид == ВидСловаМенше {
        вернути ІнформаціяОперації { ВидОпераціїМенше, 1, 95 };
      }
      якщо вид == ВидСловаМістить {
        вернути ІнформаціяОперації { ВидОпераціїМістить, 1, 93 };
      }
      якщо вид == ВидСловаЄ {
        вернути ІнформаціяОперації { ВидОпераціїЄ, 1, 93 };
      }
      якщо вид == ВидСловаНе {
        якщо вид_далі == ВидСловаБільше {
          вернути ІнформаціяОперації { ВидОпераціїМеншеРівне, 2, 95 };
        }
        якщо вид_далі == ВидСловаМенше {
          вернути ІнформаціяОперації { ВидОпераціїБільшеРівне, 2, 95 };
        }
        якщо вид_далі == ВидСловаРівно {
          вернути ІнформаціяОперації { ВидОпераціїНерівне, 2, 94 };
        }
        якщо вид_далі == ВидСловаМістить {
          вернути ІнформаціяОперації { ВидОпераціїНеМістить, 2, 93 };
        }
        якщо вид_далі == ВидСловаЄ {
          вернути ІнформаціяОперації { ВидОпераціїНеЄ, 2, 93 };
        }
      }
      якщо вид == ВидСловаСимволЗнакОклику {
        якщо вид_далі == ВидСловаСимволРівно {
          вернути ІнформаціяОперації { ВидОпераціїНерівне, 2, 94 };
        }
      }
      якщо вид == ВидСловаСимволРівно {
        якщо вид_далі == ВидСловаСимволРівно {
          вернути ІнформаціяОперації { ВидОпераціїРівне, 2, 94 };
        }
      }
      якщо вид == ВидСловаРівно {
        вернути ІнформаціяОперації { ВидОпераціїРівне, 1, 94 };
      }
      якщо вид == ВидСловаСимволІ {
        якщо вид_далі == ВидСловаСимволІ {
          вернути ІнформаціяОперації { ВидОпераціїІ, 2, 89 };
        }
        вернути ІнформаціяОперації { ВидОпераціїДІ, 1, 92 };
      }
      якщо вид == ВидСловаІ {
        вернути ІнформаціяОперації { ВидОпераціїІ, 1, 89 };
      }
      якщо вид == ВидСловаСимволПірамідка {
        вернути ІнформаціяОперації { ВидОпераціїВАБО, 1, 91 };
      }
      якщо вид == ВидСловаСимволАбо {
        якщо вид_далі == ВидСловаСимволАбо {
          вернути ІнформаціяОперації { ВидОпераціїАБО, 2, 88 };
        }
        вернути ІнформаціяОперації { ВидОпераціїДАБО, 1, 90 };
      }
      якщо вид == ВидСловаАбо {
        вернути ІнформаціяОперації { ВидОпераціїАБО, 1, 88 };
      }
      вернути ІнформаціяОперації { 0, 0, 0 };
    }
  
    дія перевірити_оп1(інформація_операції: ІнформаціяОперації, мін: позитивне): логічне {
      якщо інформація_операції.вид_операції == 0 {
        вернути ні;
      }
      якщо інформація_операції.пріоритет >= мін {
        вернути так;
      }
      вернути ні;
    }
  
    дія перевірити_оп2(інформація_операції: ІнформаціяОперації, збережена_інформація_операції: ІнформаціяОперації): логічне {
      якщо інформація_операції.вид_операції == 0 {
        вернути ні;
      }
      якщо інформація_операції.пріоритет > збережена_інформація_операції.пріоритет {
        вернути так;
      }
      якщо інформація_операції.вид_операції == ВидОпераціїПіднесенняДоСтепеня {
        вернути інформація_операції.пріоритет == збережена_інформація_операції.пріоритет;
      }
      вернути ні;
    }

    дія спробувати_розібрати_операцію_1(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, сполука_ліво: адреса<Сполука>, мін: позитивне, в_гнізді: логічне, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      змінна має_міжряд = ні;
      якщо в_гнізді == так {
        якщо слова.дані[п].вид == ВидСловаСимволМіжряд {
          має_міжряд = так;
          п += 1;
        }
      }
      змінна інформація_операції = дізнатись_інформацію_операції(слова, п);
      поки перевірити_оп1(інформація_операції, мін) {
        має_міжряд = ні;
        змінна збережена_інформація_операції = інформація_операції;
        п += інформація_операції.кількість_слів;
        якщо в_гнізді == так {
          зʼїсти_міжрядки(слова, п, п::адреса);
        }
        змінна сполука_право: адреса<Сполука> = пусто;
        змінна позиція_помилки_право: позитивне = 0;
        якщо спробувати_розібрати_мікрооперацію(система, слова, п, сполука_право::адреса, п::адреса, позиція_помилки_право::адреса) {
          п += 1;
          якщо в_гнізді == так {
            зʼїсти_міжрядки(слова, п, п::адреса);
          }
          інформація_операції = дізнатись_інформацію_операції(слова, п);
          поки перевірити_оп2(інформація_операції, збережена_інформація_операції) {
            змінна рсп = ні;
            змінна позиція_помилки_рсп: позитивне = 0;
            якщо інформація_операції.пріоритет > збережена_інформація_операції.пріоритет {
              рсп = спробувати_розібрати_операцію_1(система, слова, п, сполука_право::адреса, п::адреса, сполука_право, збережена_інформація_операції.пріоритет + 1, в_гнізді, позиція_помилки_рсп::адреса);
            } інакше {
              рсп = спробувати_розібрати_операцію_1(система, слова, п, сполука_право::адреса, п::адреса, сполука_право, збережена_інформація_операції.пріоритет, в_гнізді, позиція_помилки_рсп::адреса);
            }
            якщо рсп {
              п += 1;
            } інакше {
              звільнити_сполуку(система, сполука_право);
              вихід_позиції_помилки::вміст = позиція_помилки_рсп;
              вернути ні;
            }
            інформація_операції = дізнатись_інформацію_операції(слова, п);
          }
          змінна нова_сполука_ліво = виділити<Сполука>(система);
          нова_сполука_ліво.вид = ВидСполукиОперація;
          нова_сполука_ліво.дані = ДаніСполукиОперація {
            ліво = сполука_ліво,
            операція = збережена_інформація_операції.вид_операції,
            право = сполука_право,
          };
          нова_сполука_ліво.місцезнаходження = Місцезнаходження { позиція_початку };
          сполука_ліво = нова_сполука_ліво;
          якщо в_гнізді == так {
            якщо слова.дані[п].вид == ВидСловаСимволМіжряд {
              має_міжряд = так;
              п += 1;
            }
          }
          інформація_операції = дізнатись_інформацію_операції(слова, п);
        } інакше {
          вихід_позиції_помилки::вміст = позиція_помилки_право;
          вернути ні;
        }
      }
      вихід::вміст = сполука_ліво;
      якщо має_міжряд {
        вихід_позиції_кінця::вміст = п - 2;
      } інакше {
        вихід_позиції_кінця::вміст = п - 1;
      }
      вернути так;
    }

    дія спробувати_розібрати_значення(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, в_гнізді: логічне, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна найдовша_позиція_помилки: позитивне = 0;
      змінна позиція_помилки: позитивне = 0;
      якщо спробувати_розібрати_дію(система, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }
      якщо спробувати_розібрати_структуру(система, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }
      якщо спробувати_розібрати_модуль(система, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }
      змінна п = позиція_початку;
      змінна сполука_операція: адреса<Сполука> = пусто;
      змінна позиція_кінця_сполуки_операція: позитивне = 0;
      якщо спробувати_розібрати_операцію(система, слова, п, сполука_операція::адреса, позиція_кінця_сполуки_операція::адреса, в_гнізді, позиція_помилки::адреса) {
        п = позиція_кінця_сполуки_операція;
        п += 1;
        якщо слова.дані[п].вид == ВидСловаЯкщо {
          п += 1;
          змінна сполука_операція_значення: адреса<Сполука> = пусто;
          якщо спробувати_розібрати_операцію(система, слова, п, сполука_операція_значення::адреса, п::адреса, в_гнізді, позиція_помилки::адреса) {
            п += 1;
            якщо слова.дані[п].вид == ВидСловаІнакше {
              п += 1;
              змінна сполука_операція_значення_інакше: адреса<Сполука> = пусто;
              якщо спробувати_розібрати_операцію(система, слова, п, сполука_операція_значення_інакше::адреса, п::адреса, в_гнізді, позиція_помилки::адреса) {
                змінна сполука_значення_якщо = виділити<Сполука>(система);
                сполука_значення_якщо.вид = ВидСполукиЗначенняЯкщо;
                сполука_значення_якщо.дані = ДаніСполукиЗначенняЯкщо {
                  умова = сполука_операція_значення,
                  значення_так = сполука_операція,
                  значення_ні = сполука_операція_значення_інакше,
                };
                сполука_значення_якщо.місцезнаходження = Місцезнаходження { позиція_початку };
                вихід::вміст = сполука_значення_якщо;
                вихід_позиції_кінця::вміст = п;
                вернути так;
              } інакше {
                звільнити_сполуку(система, сполука_операція);
                звільнити_сполуку(система, сполука_операція_значення);
                якщо позиція_помилки > найдовша_позиція_помилки {
                  найдовша_позиція_помилки = позиція_помилки;
                }
                вихід_позиції_помилки::вміст = найдовша_позиція_помилки;
                вернути ні;
              }
            } інакше {
              звільнити_сполуку(система, сполука_операція);
              звільнити_сполуку(система, сполука_операція_значення);
              вихід_позиції_помилки::вміст = п;
              вернути ні;
            }
          } інакше {
            звільнити_сполуку(система, сполука_операція);
            якщо позиція_помилки > найдовша_позиція_помилки {
              найдовша_позиція_помилки = позиція_помилки;
            }
            вихід_позиції_помилки::вміст = найдовша_позиція_помилки;
            вернути ні;
          }
        } інакше {
          п -= 1;
        }
        вихід::вміст = сполука_операція;
        вихід_позиції_кінця::вміст = позиція_кінця_сполуки_операція;
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }
      вихід_позиції_помилки::вміст = найдовша_позиція_помилки;
      вернути ні;
    }

    дія спробувати_розібрати_вернути(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      якщо слова.дані[п].вид != ВидСловаВернути {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;
      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: позитивне = 0;
      якщо спробувати_розібрати_значення(система, слова, п, сполука_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення::адреса) {
      } інакше {
        п -= 1;
      }
      змінна сполука_вернути = виділити<Сполука>(система);
      сполука_вернути.вид = ВидСполукиВернути;
      сполука_вернути.дані = ДаніСполукиВернути {
        значення = сполука_значення
      };
      сполука_вернути.місцезнаходження = Місцезнаходження { позиція_початку };
      вихід::вміст = сполука_вернути;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія спробувати_розібрати_впасти(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      якщо слова.дані[п].вид != ВидСловаВпасти {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;
      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: позитивне = 0;
      якщо спробувати_розібрати_значення(система, слова, п, сполука_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення::адреса) {
      } інакше {
        п -= 1;
      }
      змінна сполука_впасти = виділити<Сполука>(система);
      сполука_впасти.вид = ВидСполукиВпасти;
      сполука_впасти.дані = ДаніСполукиВпасти {
        значення = сполука_значення
      };
      сполука_впасти.місцезнаходження = Місцезнаходження { позиція_початку };
      вихід::вміст = сполука_впасти;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія спробувати_розібрати_елемент_взяти(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<ЕлементВзяти>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      змінна позиція_ідентифікатора = п;
      якщо слова.дані[п].вид != ВидСловаІдентифікатор {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;
      змінна має_ідентифікатор_як = ні;
      змінна позиція_ідентифікатора_як = п + 1;
      якщо слова.дані[п].вид == ВидСловаЯк {
        п += 1;
        якщо слова.дані[п].вид != ВидСловаІдентифікатор {
          вихід_позиції_помилки::вміст = п;
          вернути ні;
        }
        має_ідентифікатор_як = так;
        позиція_ідентифікатора_як = п;
      } інакше {
        п -= 1;
      }
      вихід::вміст = ЕлементВзяти {
        ідентифікатор = Ідентифікатор { позиція_ідентифікатора },
        ідентифікатор_як = можливо<Ідентифікатор> { позитивне(має_ідентифікатор_як), Ідентифікатор { позиція_ідентифікатора_як } },
        місцезнаходження = Місцезнаходження { позиція_початку }
      };
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія спробувати_розібрати_взяти(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      змінна шлях = зробити_накопичувач<Ідентифікатор>(система);
      якщо слова.дані[п].вид != ВидСловаВзяти {
        звільнити_дані_накопичувача<Ідентифікатор>(система, шлях);
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;
      змінна позиція_виду_взяти = п;
      якщо слова.дані[п].вид == ВидСловаМодуль {
        п += 1;
      } інакше якщо слова.дані[п].вид == ВидСловаІдентифікатор {
        п += 1;
      } інакше {
        звільнити_дані_накопичувача<Ідентифікатор>(система, шлях);
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      поки п < слова.розмір {
        якщо слова.дані[п].вид == ВидСловаІдентифікатор {
          покласти_в_накопичувач<Ідентифікатор>(система, шлях::адреса, Ідентифікатор { п });
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволКрапка {
            п += 1;
          } інакше {
            стрибнути після_шляху;
          }
        } інакше {
          звільнити_дані_накопичувача<Ідентифікатор>(система, шлях);
        вихід_позиції_помилки::вміст = п;
          вернути ні;
        }
      }
      після_шляху:
      якщо слова.дані[п].вид == ВидСловаЯк {
        п += 1;
        змінна ідентифікатор_як = п;
        якщо слова.дані[п].вид != ВидСловаІдентифікатор {
          звільнити_дані_накопичувача<Ідентифікатор>(система, шлях);
          вихід_позиції_помилки::вміст = п;
          вернути ні;
        }
        змінна сполука_взяти = виділити<Сполука>(система);
        сполука_взяти.вид = ВидСполукиВзяти;
        сполука_взяти.дані = ДаніСполукиВзяти {
          тип = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { позиція_виду_взяти } },
          довжина_шляху = шлях.розмір,
          шлях = шлях.дані,
          ідентифікатор_як = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { ідентифікатор_як } },
          кількість_елементів = 0,
          елементи = пусто
        };
        сполука_взяти.місцезнаходження = Місцезнаходження { позиція_початку };
        вихід::вміст = сполука_взяти;
        вихід_позиції_кінця::вміст = п;
        вернути так;
      } інакше якщо слова.дані[п].вид == ВидСловаСимволКвадратнаВідкритаДужка {
        п += 1;
        змінна елементи = зробити_накопичувач<ЕлементВзяти>(система);
        поки п < слова.розмір {
          змінна елемент_взяти = ЕлементВзяти { ... };
          змінна позиція_помилки_елемента_взяти: позитивне = 0;
          якщо спробувати_розібрати_елемент_взяти(система, слова, п, елемент_взяти::адреса, п::адреса, позиція_помилки_елемента_взяти::адреса) {
            покласти_в_накопичувач<ЕлементВзяти>(система, елементи::адреса, елемент_взяти);
            п += 1;
            якщо слова.дані[п].вид == ВидСловаСимволКома {
              п += 1;
            } інакше якщо слова.дані[п].вид == ВидСловаСимволКвадратнаЗакритаДужка {
              змінна сполука_взяти = виділити<Сполука>(система);
              сполука_взяти.вид = ВидСполукиВзяти;
              сполука_взяти.дані = ДаніСполукиВзяти {
                тип = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { позиція_виду_взяти } },
                довжина_шляху = шлях.розмір,
                шлях = шлях.дані,
                ідентифікатор_як = можливо<Ідентифікатор> { позитивне(ні), ... },
                кількість_елементів = елементи.розмір,
                елементи = елементи.дані
              };
              сполука_взяти.місцезнаходження = Місцезнаходження { позиція_початку };
              вихід::вміст = сполука_взяти;
              вихід_позиції_кінця::вміст = п;
              вернути так;
            } інакше {
              звільнити_дані_накопичувача<Ідентифікатор>(система, шлях);
              звільнити_дані_накопичувача<ЕлементВзяти>(система, елементи);
              вихід_позиції_помилки::вміст = п;
              вернути ні;
            }
          } інакше {
            звільнити_дані_накопичувача<Ідентифікатор>(система, шлях);
            звільнити_дані_накопичувача<ЕлементВзяти>(система, елементи);
            вихід_позиції_помилки::вміст = позиція_помилки_елемента_взяти;
            вернути ні;
          }
        }
        звільнити_дані_накопичувача<Ідентифікатор>(система, шлях);
        звільнити_дані_накопичувача<ЕлементВзяти>(система, елементи);
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      } інакше {
        змінна сполука_взяти = виділити<Сполука>(система);
        сполука_взяти.вид = ВидСполукиВзяти;
        сполука_взяти.дані = ДаніСполукиВзяти {
          тип = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { позиція_виду_взяти } },
          довжина_шляху = шлях.розмір,
          шлях = шлях.дані,
          ідентифікатор_як = можливо<Ідентифікатор> { позитивне(ні), ... },
          кількість_елементів = 0,
          елементи = пусто
        };
        сполука_взяти.місцезнаходження = Місцезнаходження { позиція_початку };
        вихід::вміст = сполука_взяти;
        вихід_позиції_кінця::вміст = п - 1;
        вернути так;
      }
      звільнити_дані_накопичувача<Ідентифікатор>(система, шлях);
      вихід_позиції_помилки::вміст = п;
      вернути ні;
    }

    дія спробувати_розібрати_елемент_дати(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<ЕлементДати>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      змінна позиція_ідентифікатора = п;
      якщо слова.дані[п].вид != ВидСловаІдентифікатор {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;
      змінна має_ідентифікатор_як = ні;
      змінна позиція_ідентифікатора_як = п + 1;
      якщо слова.дані[п].вид == ВидСловаЯк {
        п += 1;
        якщо слова.дані[п].вид != ВидСловаІдентифікатор {
          вихід_позиції_помилки::вміст = п;
          вернути ні;
        }
        має_ідентифікатор_як = так;
        позиція_ідентифікатора_як = п;
      } інакше {
        п -= 1;
      }
      вихід::вміст = ЕлементДати {
        ідентифікатор = Ідентифікатор { позиція_ідентифікатора },
        ідентифікатор_як = можливо<Ідентифікатор> { позитивне(має_ідентифікатор_як), Ідентифікатор { позиція_ідентифікатора_як } },
        місцезнаходження = Місцезнаходження { позиція_початку }
      };
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія спробувати_розібрати_дати(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      якщо слова.дані[п].вид != ВидСловаДати {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;
      змінна елементи = зробити_накопичувач<ЕлементДати>(система);
      поки п < слова.розмір {
        змінна елемент_дати = ЕлементДати { ... };
        змінна позиція_помилки_елемента_дати: позитивне = 0;
        якщо спробувати_розібрати_елемент_дати(система, слова, п, елемент_дати::адреса, п::адреса, позиція_помилки_елемента_дати::адреса) {
          покласти_в_накопичувач<ЕлементДати>(система, елементи::адреса, елемент_дати);
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволКома {
            п += 1;
          } інакше {
            п -= 1;
            стрибнути завершення;
          }
        } інакше {
          звільнити_дані_накопичувача<ЕлементДати>(система, елементи);
          вихід_позиції_помилки::вміст = позиція_помилки_елемента_дати;
          вернути ні;
        }
      }
      завершення:
      змінна сполука_дати = виділити<Сполука>(система);
      сполука_дати.вид = ВидСполукиДати;
      сполука_дати.дані = ДаніСполукиДати {
        кількість_елементів = елементи.розмір,
        елементи = елементи.дані
      };
      сполука_дати.місцезнаходження = Місцезнаходження { позиція_початку };
      вихід::вміст = сполука_дати;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія спробувати_розібрати_елемент_тіла(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна позиція_помилки: позитивне = 0;
      змінна найдовша_позиція_помилки: позитивне = 0;
      якщо спробувати_розібрати_вернути(система, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }
      якщо спробувати_розібрати_впасти(система, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }
      якщо спробувати_розібрати_взяти(система, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }
      якщо спробувати_розібрати_дати(система, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }
      якщо спробувати_розібрати_якщо(система, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }
      якщо спробувати_розібрати_поки(система, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }
      якщо спробувати_розібрати_цикл(система, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }
      якщо спробувати_розібрати_перебрати(система, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }
      якщо спробувати_розібрати_спробувати(система, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }
      змінна п = позиція_початку;
      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: позитивне = 0;
      якщо спробувати_розібрати_значення(система, слова, п, сполука_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення::адреса) {
        п += 1;
        змінна вид_операції: позитивне = 0;
        якщо слова.дані[п].вид == ВидСловаСимволПлюс {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволРівно {
            вид_операції = ВидОпераціїДодавання;
            стрибнути спроба2;
          } інакше {
            п -= 2;
            стрибнути вихід;
          }
        } інакше якщо слова.дані[п].вид == ВидСловаСимволМінус {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволРівно {
            вид_операції = ВидОпераціїВіднімання;
            стрибнути спроба2;
          } інакше {
            п -= 2;
            стрибнути вихід;
          }
        } інакше якщо слова.дані[п].вид == ВидСловаСимволПомножити {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволПомножити {
            п += 1;
            якщо слова.дані[п].вид == ВидСловаСимволРівно {
              вид_операції = ВидОпераціїПіднесенняДоСтепеня;
              стрибнути спроба2;
            } інакше {
              п -= 3;
              стрибнути вихід;
            }
          } інакше якщо слова.дані[п].вид == ВидСловаСимволРівно {
            вид_операції = ВидОпераціїМноження;
            стрибнути спроба2;
          } інакше {
            п -= 2;
            стрибнути вихід;
          }
        } інакше якщо слова.дані[п].вид == ВидСловаСимволПоділити {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволПоділити {
            п += 1;
            якщо слова.дані[п].вид == ВидСловаСимволРівно {
              вид_операції = ВидОпераціїДіленняНаціло;
              стрибнути спроба2;
            } інакше {
              п -= 3;
              стрибнути вихід;
            }
          } інакше якщо слова.дані[п].вид == ВидСловаСимволРівно {
            вид_операції = ВидОпераціїДілення;
            стрибнути спроба2;
          } інакше {
            п -= 2;
            стрибнути вихід;
          }
        } інакше якщо слова.дані[п].вид == ВидСловаСимволЗалишку {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволРівно {
            вид_операції = ВидОпераціїМодуль;
            стрибнути спроба2;
          } інакше {
            п -= 2;
            стрибнути вихід;
          }
        } інакше якщо слова.дані[п].вид == ВидСловаСимволІ {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволРівно {
            вид_операції = ВидОпераціїДІ;
            стрибнути спроба2;
          } інакше {
            п -= 2;
            стрибнути вихід;
          }
        } інакше якщо слова.дані[п].вид == ВидСловаСимволАбо {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволРівно {
            вид_операції = ВидОпераціїДАБО;
            стрибнути спроба2;
          } інакше {
            п -= 2;
            стрибнути вихід;
          }
        } інакше якщо слова.дані[п].вид == ВидСловаСимволПірамідка {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволРівно {
            вид_операції = ВидОпераціїВАБО;
            стрибнути спроба2;
          } інакше {
            п -= 2;
            стрибнути вихід;
          }
        } інакше якщо слова.дані[п].вид == ВидСловаСимволБільше {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволБільше {
            п += 1;
            якщо слова.дані[п].вид == ВидСловаСимволБільше {
              п += 1;
              якщо слова.дані[п].вид == ВидСловаСимволРівно {
                вид_операції = ВидОпераціїЗсувВправоЗнаковий;
                стрибнути спроба2;
              } інакше {
                п -= 4;
                стрибнути вихід;
              }
            } інакше якщо слова.дані[п].вид == ВидСловаСимволРівно {
              вид_операції = ВидОпераціїЗсувВправо;
              стрибнути спроба2;
            } інакше {
              п -= 3;
              стрибнути вихід;
            }
          } інакше {
            п -= 2;
            стрибнути вихід;
          }
        } інакше якщо слова.дані[п].вид == ВидСловаСимволМенше {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволМенше {
            п += 1;
            якщо слова.дані[п].вид == ВидСловаСимволРівно {
              вид_операції = ВидОпераціїЗсувВліво;
              стрибнути спроба2;
            } інакше {
              п -= 3;
              стрибнути вихід;
            }
          } інакше {
            п -= 2;
            стрибнути вихід;
          }
        } інакше якщо слова.дані[п].вид == ВидСловаСимволРівно {
          стрибнути спроба;
        } інакше якщо слова.дані[п].вид == ВидСловаЦе {
          стрибнути спроба;
        } інакше якщо слова.дані[п].вид == ВидСловаСимволДвокрапка {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволРівно {
            стрибнути спроба_ззовні;
          } інакше {
            п -= 2;
            стрибнути вихід;
          }
          стрибнути спроба;
        } інакше {
          п -= 1;
          стрибнути вихід;
        }
        спроба:
        якщо сполука_значення.вид == ВидСполукиЗвернутись {
          змінна дані = сполука_значення.дані як ДаніСполукиЗвернутись;
          змінна ідентифікатор = дані.ідентифікатор;
          п += 1;
          змінна сполука_значення_значення: адреса<Сполука> = пусто;
          змінна позиція_помилки_сполуки_значення_значення: позитивне = 0;
          якщо спробувати_розібрати_значення(система, слова, п, сполука_значення_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення_значення::адреса) {
            змінна сполука_визначити = виділити<Сполука>(система);
            сполука_визначити.вид = ВидСполукиВизначити;
            сполука_визначити.дані = ДаніСполукиВизначити {
              ідентифікатор = ідентифікатор,
              значення = сполука_значення_значення
            };
            сполука_визначити.місцезнаходження = сполука_значення.місцезнаходження;
            вихід::вміст = сполука_визначити;
            вихід_позиції_кінця::вміст = п;
            звільнити(система, сполука_значення);
            вернути так;
          } інакше {
            звільнити_сполуку(система, сполука_значення);
            вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення_значення;
            вернути ні;
          }
        } інакше якщо сполука_значення.вид == ВидСполукиОтримати {
          змінна дані = сполука_значення.дані як ДаніСполукиОтримати;
          змінна предмет = дані.предмет;
          змінна ідентифікатор = дані.ідентифікатор;
          п += 1;
          змінна сполука_значення_значення: адреса<Сполука> = пусто;
          змінна позиція_помилки_сполуки_значення_значення: позитивне = 0;
          якщо спробувати_розібрати_значення(система, слова, п, сполука_значення_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення_значення::адреса) {
            змінна сполука_змінити_властивість = виділити<Сполука>(система);
            сполука_змінити_властивість.вид = ВидСполукиЗмінити;
            сполука_змінити_властивість.дані = ДаніСполукиЗмінити {
              предмет = предмет,
              ідентифікатор = ідентифікатор,
              значення = сполука_значення_значення
            };
            сполука_змінити_властивість.місцезнаходження = сполука_значення.місцезнаходження;
            вихід::вміст = сполука_змінити_властивість;
            вихід_позиції_кінця::вміст = п;
            звільнити(система, сполука_значення);
            вернути так;
          } інакше {
            звільнити_сполуку(система, сполука_значення);
            вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення_значення;
            вернути ні;
          }
        } інакше якщо сполука_значення.вид == ВидСполукиОтриматиЕлемент {
          змінна дані = сполука_значення.дані як ДаніСполукиОтриматиЕлемент;
          змінна предмет = дані.предмет;
          змінна ключ = дані.ключ;
          п += 1;
          змінна сполука_значення_значення: адреса<Сполука> = пусто;
          змінна позиція_помилки_сполуки_значення_значення: позитивне = 0;
          якщо спробувати_розібрати_значення(система, слова, п, сполука_значення_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення_значення::адреса) {
            змінна сполука_змінити_елемент = виділити<Сполука>(система);
            сполука_змінити_елемент.вид = ВидСполукиЗмінитиЕлемент;
            сполука_змінити_елемент.дані = ДаніСполукиЗмінитиЕлемент {
              предмет = предмет,
              ключ = ключ,
              значення = сполука_значення_значення
            };
            сполука_змінити_елемент.місцезнаходження = сполука_значення.місцезнаходження;
            вихід::вміст = сполука_змінити_елемент;
            вихід_позиції_кінця::вміст = п;
            звільнити(система, сполука_значення);
            вернути так;
          } інакше {
            звільнити_сполуку(система, сполука_значення);
            вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення_значення;
            вернути ні;
          }
        } інакше {
          вихід_позиції_помилки::вміст = п;
          вернути ні;
        }
        спроба_ззовні:
        якщо сполука_значення.вид == ВидСполукиЗвернутись {
          змінна дані = сполука_значення.дані як ДаніСполукиЗвернутись;
          змінна ідентифікатор = дані.ідентифікатор;
          п += 1;
          змінна сполука_значення_значення: адреса<Сполука> = пусто;
          змінна позиція_помилки_сполуки_значення_значення: позитивне = 0;
          якщо спробувати_розібрати_значення(система, слова, п, сполука_значення_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення_значення::адреса) {
            змінна сполука_визначити_ззовні = виділити<Сполука>(система);
            сполука_визначити_ззовні.вид = ВидСполукиВизначитиЗзовні;
            сполука_визначити_ззовні.дані = ДаніСполукиВизначитиЗзовні {
              ідентифікатор = ідентифікатор,
              значення = сполука_значення_значення
            };
            сполука_визначити_ззовні.місцезнаходження = сполука_значення.місцезнаходження;
            вихід::вміст = сполука_визначити_ззовні;
            вихід_позиції_кінця::вміст = п;
            звільнити(система, сполука_значення);
            вернути так;
          } інакше {
            звільнити_сполуку(система, сполука_значення);
            вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення_значення;
            вернути ні;
          }
        } інакше {
          вихід_позиції_помилки::вміст = п;
          вернути ні;
        }
        спроба2:
        якщо сполука_значення.вид == ВидСполукиЗвернутись {
          змінна дані = сполука_значення.дані як ДаніСполукиЗвернутись;
          змінна ідентифікатор = дані.ідентифікатор;
          п += 1;
          змінна сполука_значення_значення: адреса<Сполука> = пусто;
          змінна позиція_помилки_сполуки_значення_значення: позитивне = 0;
          якщо спробувати_розібрати_значення(система, слова, п, сполука_значення_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення_значення::адреса) {
            змінна сполука_операція = виділити<Сполука>(система);
            сполука_операція.вид = ВидСполукиОперація;
            сполука_операція.дані = ДаніСполукиОперація {
              ліво = сполука_значення,
              операція = вид_операції,
              право = сполука_значення_значення
            };
            сполука_операція.місцезнаходження = сполука_значення.місцезнаходження;
            змінна сполука_визначити = виділити<Сполука>(система);
            сполука_визначити.вид = ВидСполукиВизначити;
            сполука_визначити.дані = ДаніСполукиВизначити {
              ідентифікатор = ідентифікатор,
              значення = сполука_операція
            };
            сполука_визначити.місцезнаходження = сполука_значення.місцезнаходження;
            вихід::вміст = сполука_визначити;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          } інакше {
            звільнити_сполуку(система, сполука_значення);
            вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення_значення;
            вернути ні;
          }
        } інакше якщо сполука_значення.вид == ВидСполукиОтримати {
          змінна дані = сполука_значення.дані як ДаніСполукиОтримати;
          змінна предмет = дані.предмет;
          змінна ідентифікатор = дані.ідентифікатор;
          п += 1;
          змінна сполука_значення_значення: адреса<Сполука> = пусто;
          змінна позиція_помилки_сполуки_значення_значення: позитивне = 0;
          якщо спробувати_розібрати_значення(система, слова, п, сполука_значення_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення_значення::адреса) {
            змінна сполука_операція = виділити<Сполука>(система);
            сполука_операція.вид = ВидСполукиОперація;
            сполука_операція.дані = ДаніСполукиОперація {
              ліво = сполука_значення,
              операція = вид_операції,
              право = сполука_значення_значення
            };
            сполука_операція.місцезнаходження = сполука_значення.місцезнаходження;
            змінна сполука_змінити_властивість = виділити<Сполука>(система);
            сполука_змінити_властивість.вид = ВидСполукиЗмінити;
            сполука_змінити_властивість.дані = ДаніСполукиЗмінити {
              предмет = зробити_повну_копію_сполуки(система, предмет),
              ідентифікатор = ідентифікатор,
              значення = сполука_операція
            };
            сполука_змінити_властивість.місцезнаходження = сполука_значення.місцезнаходження;
            вихід::вміст = сполука_змінити_властивість;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          } інакше {
            звільнити_сполуку(система, сполука_значення);
            вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення_значення;
            вернути ні;
          }
        } інакше якщо сполука_значення.вид == ВидСполукиОтриматиЕлемент {
          змінна дані = сполука_значення.дані як ДаніСполукиОтриматиЕлемент;
          змінна предмет = дані.предмет;
          змінна ключ = дані.ключ;
          п += 1;
          змінна сполука_значення_значення: адреса<Сполука> = пусто;
          змінна позиція_помилки_сполуки_значення_значення: позитивне = 0;
          якщо спробувати_розібрати_значення(система, слова, п, сполука_значення_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення_значення::адреса) {
            змінна сполука_операція = виділити<Сполука>(система);
            сполука_операція.вид = ВидСполукиОперація;
            сполука_операція.дані = ДаніСполукиОперація {
              ліво = сполука_значення,
              операція = вид_операції,
              право = сполука_значення_значення
            };
            сполука_операція.місцезнаходження = сполука_значення.місцезнаходження;
            змінна сполука_змінити_елемент = виділити<Сполука>(система);
            сполука_змінити_елемент.вид = ВидСполукиЗмінитиЕлемент;
            сполука_змінити_елемент.дані = ДаніСполукиЗмінитиЕлемент {
              предмет = зробити_повну_копію_сполуки(система, предмет),
              ключ = зробити_повну_копію_сполуки(система, ключ),
              значення = сполука_операція
            };
            сполука_змінити_елемент.місцезнаходження = сполука_значення.місцезнаходження;
            вихід::вміст = сполука_змінити_елемент;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          } інакше {
            звільнити_сполуку(система, сполука_значення);
            вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення_значення;
            вернути ні;
          }
        } інакше {
          вихід_позиції_помилки::вміст = п;
          вернути ні;
        }
        вихід:
        вихід::вміст = сполука_значення;
        вихід_позиції_кінця::вміст = п;
        вернути так;
      }
      вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
      вернути ні;
    }

    дія спробувати_розібрати_тіло(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<Сполуки>, вихід_позиції_кінця: адреса<позитивне>, вид_слова_закінчення: позитивне, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      зʼїсти_міжрядки(слова, п, п::адреса);
      змінна елементи = зробити_накопичувач<адреса<Сполука>>(система);
      поки п < слова.розмір {
        якщо слова.дані[п].вид == вид_слова_закінчення {
          вихід::вміст = Сполуки { елементи.розмір, елементи.дані };
          вихід_позиції_кінця::вміст = п;
          вернути так;
        }
        змінна сполука_елемента_тіла: адреса<Сполука> = пусто;
        змінна позиція_помилки_елемента_тіла: позитивне = 0;
        якщо спробувати_розібрати_елемент_тіла(система, слова, п, сполука_елемента_тіла::адреса, п::адреса, позиція_помилки_елемента_тіла::адреса) {
          покласти_в_накопичувач<адреса<Сполука>>(система, елементи::адреса, сполука_елемента_тіла);
          п += 1;
          якщо зʼїсти_міжрядки(слова, п, п::адреса) {
          } інакше якщо слова.дані[п].вид == вид_слова_закінчення {
            вихід::вміст = Сполуки { елементи.розмір, елементи.дані };
            вихід_позиції_кінця::вміст = п;
            вернути так;
          } інакше {
            звільнити_сполуки(система, Сполуки { елементи.розмір, елементи.дані });
            вихід_позиції_помилки::вміст = п;
            вернути ні;
          }
        } інакше {
          звільнити_сполуки(система, Сполуки { елементи.розмір, елементи.дані });
          вихід_позиції_помилки::вміст = позиція_помилки_елемента_тіла;
          вернути ні;
        }
      }
      звільнити_сполуки(система, Сполуки { елементи.розмір, елементи.дані });
      вихід_позиції_помилки::вміст = п;
      вернути ні;
    }

    дія спробувати_розібрати_тип(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<Тип>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      змінна типи = зробити_накопичувач<адреса<Сполука>>(система);
      поки п < слова.розмір {
        змінна сполука_типу: адреса<Сполука> = пусто;
        змінна позиція_помилки_молекули: позитивне = 0;
        якщо спробувати_розібрати_молекулу(система, слова, п, сполука_типу::адреса, п::адреса, позиція_помилки_молекули::адреса) {
          покласти_в_накопичувач<адреса<Сполука>>(система, типи::адреса, сполука_типу);
          п += 1;
          якщо слова.дані[п].вид == ВидСловаАбо {
            п += 1;
          } інакше {
            вихід::вміст = Тип {
              кількість_гілок = типи.розмір,
              сполуки = типи.дані,
            };
            вихід_позиції_кінця::вміст = п - 1;
            вернути так;
          }
        } інакше {
          звільнити_сполуки(система, Сполуки { типи.розмір, типи.дані });
          вихід_позиції_помилки::вміст = позиція_помилки_молекули;
          вернути ні;
        }
      }
      звільнити_сполуки(система, Сполуки { типи.розмір, типи.дані });
      вихід_позиції_помилки::вміст = п;
      вернути ні;
    }

    дія спробувати_розібрати_параметр(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<Параметр>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна п = позиція_початку;
      змінна сполука_значення: адреса<Сполука> = пусто;
      // ідентифікатор параметра
      змінна позиція_ідентифікатора = п;
      якщо слова.дані[п].вид != ВидСловаІдентифікатор {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;
      // тип параметра
      змінна тип = Тип { ... };
      змінна позиція_помилки_типу: позитивне = 0;
      якщо спробувати_розібрати_тип(система, слова, п, тип::адреса, п::адреса, позиція_помилки_типу::адреса) {
        п += 1;
        якщо слова.дані[п].вид == ВидСловаСимволРівно {
          п += 1;
          змінна позиція_помилки_сполуки_значення: позитивне = 0;
          якщо спробувати_розібрати_значення(система, слова, п, сполука_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення::адреса) {
          } інакше {
            звільнити_тип(система, тип);
            вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
            вернути ні;
          }
        } інакше {
          п -= 1;
        }
        вихід::вміст = Параметр {
          ідентифікатор = Ідентифікатор { позиція_ідентифікатора },
          тип = можливо<Тип> { позитивне(так), тип },
          значення = сполука_значення,
          місцезнаходження = Місцезнаходження { позиція_початку }
        };
        вихід_позиції_кінця::вміст = п;
      } інакше {
        якщо слова.дані[п].вид == ВидСловаСимволРівно {
          п += 1;
          змінна позиція_помилки_сполуки_значення: позитивне = 0;
          якщо спробувати_розібрати_значення(система, слова, п, сполука_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення::адреса) {
          } інакше {
            звільнити_сполуку(система, сполука_значення);
            вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
            вернути ні;
          }
        } інакше {
          п -= 1;
        }
        вихід::вміст = Параметр {
          ідентифікатор = Ідентифікатор { позиція_ідентифікатора },
          тип = можливо<Тип> { позитивне(ні), ... },
          значення = сполука_значення,
          місцезнаходження = Місцезнаходження { позиція_початку }
        };
        вихід_позиції_кінця::вміст = п;
      }
      вернути так;
    }

    дія спробувати_розібрати_дію(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна дані_сполуки_дія = ДаніСполукиДія {
        тривала = позитивне(ні),
        власна = позитивне(ні),
        структура_ = пусто,
        ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), ... },
        кількість_параметрів = 0,
        параметри = пусто,
        тип_результату = можливо<Тип> { позитивне(ні), ... },
        тіло = Сполуки { 0, пусто }
      };
      змінна п = позиція_початку;
      // дія власна?
      якщо слова.дані[п].вид == ВидСловаВласна {
        дані_сполуки_дія.власна = позитивне(так);
        п += 1;
      }
      // дія тривала?
      якщо слова.дані[п].вид == ВидСловаТривала {
        дані_сполуки_дія.тривала = позитивне(так);
        п += 1;
      }
      // дія?
      якщо слова.дані[п].вид != ВидСловаДія {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      // структура та/або ідентифікатор дії
      якщо слова.дані[п].вид == ВидСловаІдентифікатор {
        дані_сполуки_дія.ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { п } };
        п += 1;
        якщо слова.дані[п].вид == ВидСловаСимволКрапка {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаІдентифікатор {
            змінна сполука_звернення = виділити<Сполука>(система);
            сполука_звернення.вид = ВидСполукиЗвернутись;
            сполука_звернення.дані = ДаніСполукиЗвернутись {
              ідентифікатор = дані_сполуки_дія.ідентифікатор.значення
            };
            сполука_звернення.місцезнаходження = Місцезнаходження { п };
            дані_сполуки_дія.структура_ = сполука_звернення;
            дані_сполуки_дія.ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { п } };
            п += 1;
          } інакше {
            вихід_позиції_помилки::вміст = п;
            стрибнути звільнити_і_вийти;
          }
        }
      }
      якщо слова.дані[п].вид != ВидСловаСимволВідкритаДужка {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      зʼїсти_міжрядки(слова, п, п::адреса);
      // параметри дії
      змінна параметри = зробити_накопичувач<Параметр>(система);
      поки п < слова.розмір {
        якщо слова.дані[п].вид == ВидСловаСимволЗакритаДужка {
          п += 1;
          стрибнути після_параметрів;
        }
        змінна параметр = Параметр { ... };
        змінна позиція_помилки_параметра: позитивне = 0;
        якщо спробувати_розібрати_параметр(система, слова, п, параметр::адреса, п::адреса, позиція_помилки_параметра::адреса) {
          покласти_в_накопичувач<Параметр>(система, параметри::адреса, параметр);
          п += 1;
        } інакше {
          вихід_позиції_помилки::вміст = позиція_помилки_параметра;
          стрибнути звільнити_і_вийти;
        }
        зʼїсти_міжрядки(слова, п, п::адреса);
        якщо слова.дані[п].вид == ВидСловаСимволКома {
          п += 1;
          зʼїсти_міжрядки(слова, п, п::адреса);
        } інакше якщо слова.дані[п].вид == ВидСловаСимволЗакритаДужка {
          п += 1;
          стрибнути після_параметрів;
        } інакше {
          звільнити_параметри(система, параметри.розмір, параметри.дані);
          вихід_позиції_помилки::вміст = п;
          стрибнути звільнити_і_вийти;
        }
      }
      після_параметрів:
      дані_сполуки_дія.кількість_параметрів = параметри.розмір;
      дані_сполуки_дія.параметри = параметри.дані;
      // тип результату дії
      якщо слова.дані[п].вид == ВидСловаСимволМіжряд {
        стрибнути розбір_тіла;
      } інакше якщо слова.дані[п].вид == ВидСловаСимволДвокрапка {
        стрибнути розбір_короткого_тіла;
      } інакше {
        змінна позиція_помилки_типу_результату: позитивне = 0;
        якщо спробувати_розібрати_тип(система, слова, п, дані_сполуки_дія.тип_результату.значення::адреса, п::адреса, позиція_помилки_типу_результату::адреса) {
          дані_сполуки_дія.тип_результату.заповнено = позитивне(так);
          п += 1;
        } інакше {
          вихід_позиції_помилки::вміст = позиція_помилки_типу_результату;
          стрибнути звільнити_і_вийти;
        }
      }
      якщо слова.дані[п].вид == ВидСловаСимволМіжряд {
        стрибнути розбір_тіла;
      } інакше {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      // тіло дії
      розбір_короткого_тіла:
      п += 1;
      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: позитивне = 0;
      якщо спробувати_розібрати_елемент_тіла(система, слова, п, сполука_значення::адреса, п::адреса, позиція_помилки_сполуки_значення::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
        стрибнути звільнити_і_вийти;
      }
      дані_сполуки_дія.тіло.дані = перевиділити_памʼять<адреса<Сполука>>(система, дані_сполуки_дія.тіло.дані, 1);
      дані_сполуки_дія.тіло.дані[0] = сполука_значення;
      дані_сполуки_дія.тіло.розмір = 1;
      стрибнути після_тіла;
      розбір_тіла:
      п += 1;
      змінна позиція_помилки_тіла: позитивне = 0;
      якщо спробувати_розібрати_тіло(система, слова, п, дані_сполуки_дія.тіло::адреса, п::адреса, ВидСловаКінець, позиція_помилки_тіла::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_тіла;
        стрибнути звільнити_і_вийти;
      }
      після_тіла:
      змінна сполука_дія = виділити<Сполука>(система);
      сполука_дія.вид = ВидСполукиДія;
      сполука_дія.дані = дані_сполуки_дія;
      сполука_дія.місцезнаходження = Місцезнаходження {
        позиція_початку
      };
      вихід::вміст = сполука_дія;
      вихід_позиції_кінця::вміст = п;
      вернути так;
      звільнити_і_вийти:
      звільнити_параметри(система, дані_сполуки_дія.кількість_параметрів, дані_сполуки_дія.параметри);
      якщо дані_сполуки_дія.тип_результату.заповнено == позитивне(так) {
        звільнити_тип(система, дані_сполуки_дія.тип_результату.значення);
      }
      звільнити_тіло(система, дані_сполуки_дія.тіло);
      вернути ні;
    }

    дія спробувати_розібрати_структуру(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна дані_сполуки_структура = ДаніСполукиСтруктура {
        ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), ... },
        предок = пусто,
        кількість_параметрів = 0,
        параметри = пусто
      };
      змінна п = позиція_початку;
      // структура?
      якщо слова.дані[п].вид != ВидСловаСтруктура {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      // ідентифікатор структури
      якщо слова.дані[п].вид == ВидСловаІдентифікатор {
        дані_сполуки_структура.ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { п } };
        п += 1;
      }
      // предок структури
      якщо слова.дані[п].вид == ВидСловаЄ {
        п += 1;
        змінна позиція_помилки_молекули: позитивне = 0;
        якщо спробувати_розібрати_молекулу(система, слова, п, дані_сполуки_структура.предок::адреса, п::адреса, позиція_помилки_молекули::адреса) {
          п += 1;
        } інакше {
          вихід_позиції_помилки::вміст = позиція_помилки_молекули;
          стрибнути звільнити_і_вийти;
        }
      }
      якщо слова.дані[п].вид != ВидСловаСимволМіжряд {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      зʼїсти_міжрядки(слова, п, п::адреса);
      // параметри структури
      змінна параметри = зробити_накопичувач<Параметр>(система);
      поки п < слова.розмір {
        якщо слова.дані[п].вид == ВидСловаКінець {
          стрибнути після_параметрів;
        }
        змінна параметр = Параметр { ... };
        змінна позиція_помилки_параметра: позитивне = 0;
        якщо спробувати_розібрати_параметр(система, слова, п, параметр::адреса, п::адреса, позиція_помилки_параметра::адреса) {
          покласти_в_накопичувач<Параметр>(система, параметри::адреса, параметр);
          п += 1;
        } інакше {
          вихід_позиції_помилки::вміст = позиція_помилки_параметра;
          стрибнути звільнити_і_вийти;
        }
        якщо зʼїсти_міжрядки(слова, п, п::адреса) {
        } інакше якщо слова.дані[п].вид == ВидСловаКінець {
          стрибнути після_параметрів;
        } інакше {
          звільнити_параметри(система, параметри.розмір, параметри.дані);
          вихід_позиції_помилки::вміст = п;
          стрибнути звільнити_і_вийти;
        }
      }
      після_параметрів:
      дані_сполуки_структура.кількість_параметрів = параметри.розмір;
      дані_сполуки_структура.параметри = параметри.дані;
      змінна сполука_структура = виділити<Сполука>(система);
      сполука_структура.вид = ВидСполукиСтруктура;
      сполука_структура.дані = дані_сполуки_структура;
      сполука_структура.місцезнаходження = Місцезнаходження {
        позиція_початку
      };
      вихід::вміст = сполука_структура;
      вихід_позиції_кінця::вміст = п;
      вернути так;
      звільнити_і_вийти:
      звільнити_сполуку(система, дані_сполуки_структура.предок);
      звільнити_параметри(система, дані_сполуки_структура.кількість_параметрів, дані_сполуки_структура.параметри);
      вернути ні;
    }

    дія спробувати_розібрати_модуль(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна дані_сполуки_модуль = ДаніСполукиМодуль {
        ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), ... },
        тіло = Сполуки { 0, пусто }
      };
      змінна п = позиція_початку;
      // модуль?
      якщо слова.дані[п].вид != ВидСловаМодуль {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      // ідентифікатор модуля
      якщо слова.дані[п].вид == ВидСловаІдентифікатор {
        дані_сполуки_модуль.ідентифікатор = можливо<Ідентифікатор> { позитивне(так), Ідентифікатор { п } };
        п += 1;
      }
      якщо слова.дані[п].вид != ВидСловаСимволМіжряд {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      // тіло модуля
      змінна позиція_помилки_тіла: позитивне = 0;
      якщо спробувати_розібрати_тіло(система, слова, п, дані_сполуки_модуль.тіло::адреса, п::адреса, ВидСловаКінець, позиція_помилки_тіла::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_тіла;
        стрибнути звільнити_і_вийти;
      }
      змінна сполука_модуль = виділити<Сполука>(система);
      сполука_модуль.вид = ВидСполукиМодуль;
      сполука_модуль.дані = дані_сполуки_модуль;
      сполука_модуль.місцезнаходження = Місцезнаходження {
        позиція_початку
      };
      вихід::вміст = сполука_модуль;
      вихід_позиції_кінця::вміст = п;
      вернути так;
      звільнити_і_вийти:
      звільнити_тіло(система, дані_сполуки_модуль.тіло);
      вернути ні;
    }

    дія спробувати_розібрати_якщо(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна дані_сполуки_якщо = ДаніСполукиЯкщо {
        умова = пусто,
        тіло = Сполуки { 0, пусто },
        тіло_інакше = Сполуки { 0, пусто }
      };
      змінна п = позиція_початку;
      // якщо?
      якщо слова.дані[п].вид != ВидСловаЯкщо {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      // умова якщо
      змінна позиція_помилки_умови: позитивне = 0;
      якщо спробувати_розібрати_операцію(система, слова, п, дані_сполуки_якщо.умова::адреса, п::адреса, ні, позиція_помилки_умови::адреса) {
        п += 1;
      } інакше {
        вихід_позиції_помилки::вміст = позиція_помилки_умови;
        стрибнути звільнити_і_вийти;
      }
      якщо слова.дані[п].вид != ВидСловаСимволМіжряд {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      // тіло якщо
      змінна тіло = зробити_накопичувач<адреса<Сполука>>(система);
      поки п < слова.розмір {
        якщо слова.дані[п].вид == ВидСловаКінець {
          дані_сполуки_якщо.тіло.розмір = тіло.розмір;
          дані_сполуки_якщо.тіло.дані = тіло.дані;
          стрибнути після_тіла;
        }
        якщо слова.дані[п].вид == ВидСловаІнакше {
          дані_сполуки_якщо.тіло.розмір = тіло.розмір;
          дані_сполуки_якщо.тіло.дані = тіло.дані;
          стрибнути розбір_інакше;
        }
        зʼїсти_міжрядки(слова, п, п::адреса);
        змінна сполука_елемента_тіла: адреса<Сполука> = пусто;
        змінна позиція_помилки_елемента_тіла: позитивне = 0;
        якщо спробувати_розібрати_елемент_тіла(система, слова, п, сполука_елемента_тіла::адреса, п::адреса, позиція_помилки_елемента_тіла::адреса) {
          покласти_в_накопичувач<адреса<Сполука>>(система, тіло::адреса, сполука_елемента_тіла);
          п += 1;
          якщо зʼїсти_міжрядки(слова, п, п::адреса) {
          } інакше якщо слова.дані[п].вид == ВидСловаКінець {
            дані_сполуки_якщо.тіло.розмір = тіло.розмір;
            дані_сполуки_якщо.тіло.дані = тіло.дані;
            стрибнути після_тіла;
          } інакше якщо слова.дані[п].вид == ВидСловаІнакше {
            дані_сполуки_якщо.тіло.розмір = тіло.розмір;
            дані_сполуки_якщо.тіло.дані = тіло.дані;
            стрибнути розбір_інакше;
          } інакше {
            дані_сполуки_якщо.тіло.розмір = тіло.розмір;
            дані_сполуки_якщо.тіло.дані = тіло.дані;
            вихід_позиції_помилки::вміст = п;
            стрибнути звільнити_і_вийти;
          }
        } інакше {
          дані_сполуки_якщо.тіло.розмір = тіло.розмір;
          дані_сполуки_якщо.тіло.дані = тіло.дані;
          вихід_позиції_помилки::вміст = позиція_помилки_елемента_тіла;
          стрибнути звільнити_і_вийти;
        }
      }
      вихід_позиції_помилки::вміст = п;
      стрибнути звільнити_і_вийти;
      розбір_інакше:
      п += 1;
      // інакше якщо
      якщо слова.дані[п].вид == ВидСловаЯкщо {
        змінна сполука_інакше_якщо: адреса<Сполука> = пусто;
        змінна позиція_помилки_інакше_якщо: позитивне = 0;
        якщо спробувати_розібрати_якщо(система, слова, п, сполука_інакше_якщо::адреса, п::адреса, позиція_помилки_інакше_якщо::адреса) {
          змінна накопичувач_інакше_якщо = зробити_накопичувач<адреса<Сполука>>(система);
          покласти_в_накопичувач<адреса<Сполука>>(система, накопичувач_інакше_якщо::адреса, сполука_інакше_якщо);
          дані_сполуки_якщо.тіло_інакше = Сполуки {
            накопичувач_інакше_якщо.розмір,
            накопичувач_інакше_якщо.дані
          };
          стрибнути після_тіла;
        }
        вихід_позиції_помилки::вміст = позиція_помилки_інакше_якщо;
        стрибнути звільнити_і_вийти;
      } інакше якщо зʼїсти_міжрядки(слова, п, п::адреса) {
        // тіло інакше
        змінна позиція_помилки_інакше: позитивне = 0;
        якщо спробувати_розібрати_тіло(система, слова, п, дані_сполуки_якщо.тіло_інакше::адреса, п::адреса, ВидСловаКінець, позиція_помилки_інакше::адреса) == ні {
          вихід_позиції_помилки::вміст = позиція_помилки_інакше;
          стрибнути звільнити_і_вийти;
        }
        стрибнути після_тіла;
      } інакше {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      після_тіла:
      змінна сполука_якщо = виділити<Сполука>(система);
      сполука_якщо.вид = ВидСполукиЯкщо;
      сполука_якщо.дані = дані_сполуки_якщо;
      сполука_якщо.місцезнаходження = Місцезнаходження {
        позиція_початку
      };
      вихід::вміст = сполука_якщо;
      вихід_позиції_кінця::вміст = п;
      вернути так;
      звільнити_і_вийти:
      звільнити_сполуку(система, дані_сполуки_якщо.умова);
      звільнити_тіло(система, дані_сполуки_якщо.тіло);
      звільнити_тіло(система, дані_сполуки_якщо.тіло_інакше);
      вернути ні;
    }

    дія спробувати_розібрати_поки(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна дані_сполуки_поки = ДаніСполукиПоки {
        умова = пусто,
        тіло = Сполуки { 0, пусто }
      };
      змінна п = позиція_початку;
      // поки?
      якщо слова.дані[п].вид != ВидСловаПоки {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      // умова поки
      змінна позиція_помилки_умови: позитивне = 0;
      якщо спробувати_розібрати_операцію(система, слова, п, дані_сполуки_поки.умова::адреса, п::адреса, ні, позиція_помилки_умови::адреса) {
        п += 1;
      } інакше {
        вихід_позиції_помилки::вміст = позиція_помилки_умови;
        стрибнути звільнити_і_вийти;
      }
      // тіло поки
      якщо слова.дані[п].вид == ВидСловаСимволМіжряд {
        стрибнути розбір_тіла;
      } інакше якщо слова.дані[п].вид == ВидСловаСимволДвокрапка {
        стрибнути розбір_короткого_тіла;
      } інакше {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      розбір_короткого_тіла:
      п += 1;
      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: позитивне = 0;
      якщо спробувати_розібрати_елемент_тіла(система, слова, п, сполука_значення::адреса, п::адреса, позиція_помилки_сполуки_значення::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
        стрибнути звільнити_і_вийти;
      }
      дані_сполуки_поки.тіло.дані = перевиділити_памʼять<адреса<Сполука>>(система, дані_сполуки_поки.тіло.дані, 1);
      дані_сполуки_поки.тіло.дані[0] = сполука_значення;
      дані_сполуки_поки.тіло.розмір = 1;
      стрибнути після_тіла;
      розбір_тіла:
      п += 1;
      змінна позиція_помилки_тіла: позитивне = 0;
      якщо спробувати_розібрати_тіло(система, слова, п, дані_сполуки_поки.тіло::адреса, п::адреса, ВидСловаКінець, позиція_помилки_тіла::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_тіла;
        стрибнути звільнити_і_вийти;
      }
      після_тіла:
      змінна сполука_поки = виділити<Сполука>(система);
      сполука_поки.вид = ВидСполукиПоки;
      сполука_поки.дані = дані_сполуки_поки;
      сполука_поки.місцезнаходження = Місцезнаходження {
        позиція_початку
      };
      вихід::вміст = сполука_поки;
      вихід_позиції_кінця::вміст = п;
      вернути так;
      звільнити_і_вийти:
      звільнити_сполуку(система, дані_сполуки_поки.умова);
      звільнити_тіло(система, дані_сполуки_поки.тіло);
      вернути ні;
    }

    дія спробувати_розібрати_цикл(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      вихід_позиції_помилки::вміст = позиція_початку;
      вернути ні;
    }

    дія спробувати_розібрати_перебрати(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна дані_сполуки_перебрати = ДаніСполукиПеребрати {
        предмет = пусто,
        ідентифікатор = можливо<Ідентифікатор> { позитивне(ні), ... },
        тіло = Сполуки { 0, пусто }
      };
      змінна п = позиція_початку;
      // перебрати?
      якщо слова.дані[п].вид != ВидСловаПеребрати {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      // значення перебрати
      змінна позиція_помилки_операції: позитивне = 0;
      якщо спробувати_розібрати_операцію(система, слова, п, дані_сполуки_перебрати.предмет::адреса, п::адреса, ні, позиція_помилки_операції::адреса) {
        п += 1;
      } інакше {
        вихід_позиції_помилки::вміст = позиція_помилки_операції;
        стрибнути звільнити_і_вийти;
      }
      якщо слова.дані[п].вид == ВидСловаЯк {
        п += 1;
        якщо слова.дані[п].вид != ВидСловаІдентифікатор {
          вихід_позиції_помилки::вміст = п;
          стрибнути звільнити_і_вийти;
        }
        дані_сполуки_перебрати.ідентифікатор = можливо<Ідентифікатор> {
          позитивне(так),
          Ідентифікатор { п }
        };
        п += 1;
      } інакше {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      // тіло перебрати
      якщо слова.дані[п].вид == ВидСловаСимволМіжряд {
        стрибнути розбір_тіла;
      } інакше якщо слова.дані[п].вид == ВидСловаСимволДвокрапка {
        стрибнути розбір_короткого_тіла;
      } інакше {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      розбір_короткого_тіла:
      п += 1;
      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: позитивне = 0;
      якщо спробувати_розібрати_елемент_тіла(система, слова, п, сполука_значення::адреса, п::адреса, позиція_помилки_сполуки_значення::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
        стрибнути звільнити_і_вийти;
      }
      дані_сполуки_перебрати.тіло.дані = перевиділити_памʼять<адреса<Сполука>>(система, дані_сполуки_перебрати.тіло.дані, 1);
      дані_сполуки_перебрати.тіло.дані[0] = сполука_значення;
      дані_сполуки_перебрати.тіло.розмір = 1;
      стрибнути після_тіла;
      розбір_тіла:
      п += 1;
      змінна позиція_помилки_тіла: позитивне = 0;
      якщо спробувати_розібрати_тіло(система, слова, п, дані_сполуки_перебрати.тіло::адреса, п::адреса, ВидСловаКінець, позиція_помилки_тіла::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_тіла;
        стрибнути звільнити_і_вийти;
      }
      після_тіла:
      змінна сполука_перебрати = виділити<Сполука>(система);
      сполука_перебрати.вид = ВидСполукиПеребрати;
      сполука_перебрати.дані = дані_сполуки_перебрати;
      сполука_перебрати.місцезнаходження = Місцезнаходження {
        позиція_початку
      };
      вихід::вміст = сполука_перебрати;
      вихід_позиції_кінця::вміст = п;
      вернути так;
      звільнити_і_вийти:
      звільнити_сполуку(система, дані_сполуки_перебрати.предмет);
      звільнити_тіло(система, дані_сполуки_перебрати.тіло);
      вернути ні;
    }

    дія спробувати_розібрати_спробувати(система: адреса<Система>, слова: Слова, позиція_початку: позитивне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<позитивне>, вихід_позиції_помилки: адреса<позитивне>): логічне {
      змінна дані_сполуки_спробувати = ДаніСполукиСпробувати {
        тіло = Сполуки { 0, пусто },
        ідентифікатор_зловити = можливо<Ідентифікатор> { позитивне(ні), ... },
        тіло_зловити = Сполуки { 0, пусто }
      };
      змінна п = позиція_початку;
      // спробувати?
      якщо слова.дані[п].вид != ВидСловаСпробувати {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      якщо слова.дані[п].вид != ВидСловаСимволМіжряд {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      // тіло спробувати
      змінна позиція_помилки_тіла: позитивне = 0;
      якщо спробувати_розібрати_тіло(система, слова, п, дані_сполуки_спробувати.тіло::адреса, п::адреса, ВидСловаЗловити, позиція_помилки_тіла::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_тіла;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      якщо слова.дані[п].вид == ВидСловаІдентифікатор {
        дані_сполуки_спробувати.ідентифікатор_зловити = можливо<Ідентифікатор> {
          позитивне(так),
          Ідентифікатор { п }
        };
        п += 1;
      }
      якщо слова.дані[п].вид != ВидСловаСимволМіжряд {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      // тіло зловити
      змінна позиція_помилки_тіла_зловити: позитивне = 0;
      якщо спробувати_розібрати_тіло(система, слова, п, дані_сполуки_спробувати.тіло_зловити::адреса, п::адреса, ВидСловаКінець, позиція_помилки_тіла_зловити::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_тіла_зловити;
        стрибнути звільнити_і_вийти;
      }
      змінна сполука_спробувати = виділити<Сполука>(система);
      сполука_спробувати.вид = ВидСполукиСпробувати;
      сполука_спробувати.дані = дані_сполуки_спробувати;
      сполука_спробувати.місцезнаходження = Місцезнаходження {
        позиція_початку
      };
      вихід::вміст = сполука_спробувати;
      вихід_позиції_кінця::вміст = п;
      вернути так;
      звільнити_і_вийти:
      звільнити_тіло(система, дані_сполуки_спробувати.тіло);
      звільнити_тіло(система, дані_сполуки_спробувати.тіло_зловити);
      вернути ні;
    }

    місцева дія розібрати_слова_на_сполуки(система: адреса<Система>, значення_ю8: ю8, слова: Слова, вихід: адреса<Сполуки>, вихід_помилки: адреса<ПомилкаРозборуНаСполуки>): логічне {
      змінна тіло = Сполуки { 0, пусто };
      змінна позиція_кінця: позитивне = 0;
      змінна позиція_помилки: позитивне = 0;
      якщо спробувати_розібрати_тіло(система, слова, 0, тіло::адреса, позиція_кінця::адреса, ВидСловаКІНЕЦЬСЛІВ, позиція_помилки::адреса) {
        вихід::вміст = Сполуки {
          тіло.розмір,
          тіло.дані
        };
        вернути так;
      }
      вихід_помилки::вміст = ПомилкаРозборуНаСполуки {
        позиція_слова = позиція_помилки,
        рядок = слова.дані[позиція_помилки].позиція_початку.рядок,
        стовпець = слова.дані[позиція_помилки].позиція_початку.стовпець
      };
      вернути ні;
    }

    місцева дія вивести_сполуку(система: адреса<Система>, вихідний_потік: адреса<ВихіднийПотік>, значення_ю8: ю8, слова: Слова, сполука: адреса<Сполука>) {
      якщо сполука.вид == ВидСполукиНіщо {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Ніщо");
      } інакше якщо сполука.вид == ВидСполукиВизначити {
        змінна дані = сполука.дані як ДаніСполукиВизначити;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Визначити(");
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Ідентифікатор(");
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, отримати_ю8_ідентифікатора(значення_ю8, слова, дані.ідентифікатор));
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"), ");
        вивести_сполуку(система, вихідний_потік, значення_ю8, слова, дані.значення);
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8")");
      } інакше якщо сполука.вид == ВидСполукиЗвернутись {
        змінна дані = сполука.дані як ДаніСполукиЗвернутись;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Звернутись(");
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Ідентифікатор(");
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, отримати_ю8_ідентифікатора(значення_ю8, слова, дані.ідентифікатор));
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8")");
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8")");
      } інакше якщо сполука.вид == ВидСполукиОтримати {
        змінна дані = сполука.дані як ДаніСполукиОтримати;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Отримати(");
        вивести_сполуку(система, вихідний_потік, значення_ю8, слова, дані.предмет);
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8", Ідентифікатор(");
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, отримати_ю8_ідентифікатора(значення_ю8, слова, дані.ідентифікатор));
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8")");
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8")");
      } інакше якщо сполука.вид == ВидСполукиОтриматиЕлемент {
        змінна дані = сполука.дані як ДаніСполукиОтриматиЕлемент;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ОтриматиЕлемент");
      } інакше якщо сполука.вид == ВидСполукиЗмінити {
        змінна дані = сполука.дані як ДаніСполукиЗмінити;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Змінити");
      } інакше якщо сполука.вид == ВидСполукиЗмінитиЕлемент {
        змінна дані = сполука.дані як ДаніСполукиЗмінитиЕлемент;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ЗмінитиЕлемент");
      } інакше якщо сполука.вид == ВидСполукиВиконати {
        змінна дані = сполука.дані як ДаніСполукиВиконати;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Виконати(");
        вивести_сполуку(система, вихідний_потік, значення_ю8, слова, дані.предмет);
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8", [");
        змінна п: позитивне = 0;
        поки п < дані.кількість_аргументів {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Аргумент(");
          якщо дані.аргументи[п].ідентифікатор.заповнено == позитивне(так) {
            дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Ідентифікатор(");
            дописати_ю8_у_вихідний_потік(система, вихідний_потік, отримати_ю8_ідентифікатора(значення_ю8, слова, дані.аргументи[п].ідентифікатор.значення));
            дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"), ");
          }
        вивести_сполуку(система, вихідний_потік, значення_ю8, слова, дані.аргументи[п].значення);
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8")");
          якщо п != дані.кількість_аргументів - 1 {
            дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8", ");
          }
          п += 1;
        }
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"])");
      } інакше якщо сполука.вид == ВидСполукиДія {
        змінна дані = сполука.дані як ДаніСполукиДія;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Дія");
      } інакше якщо сполука.вид == ВидСполукиСтруктура {
        змінна дані = сполука.дані як ДаніСполукиСтруктура;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Структура");
      } інакше якщо сполука.вид == ВидСполукиЧисло {
        змінна дані = сполука.дані як ДаніСполукиЧисло;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Число(");
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, отримати_ю8_слова(значення_ю8, слова, слова.дані[дані.позиція_слова]));
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8")");
      } інакше якщо сполука.вид == ВидСполукиТекст {
        змінна дані = сполука.дані як ДаніСполукиТекст;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Текст(\"");
        якщо дані.ідентифікатор.заповнено == позитивне(так) {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Ідентифікатор(");
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, отримати_ю8_ідентифікатора(значення_ю8, слова, дані.ідентифікатор.значення));
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"), ");
        }
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, слова.дані[дані.позиція_слова].значення);
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\")");
      } інакше якщо сполука.вид == ВидСполукиОперація {
        змінна дані = сполука.дані як ДаніСполукиОперація;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Операція(");
        вивести_сполуку(система, вихідний_потік, значення_ю8, слова, дані.ліво);
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8", ");
        якщо дані.операція == ВидОпераціїМноження {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"*");
        } інакше якщо дані.операція == ВидОпераціїДілення {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"/");
        } інакше якщо дані.операція == ВидОпераціїМодуль {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"%");
        } інакше якщо дані.операція == ВидОпераціїДодавання {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"+");
        } інакше якщо дані.операція == ВидОпераціїВіднімання {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"-");
        } інакше якщо дані.операція == ВидОпераціїЗсувВліво {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"<<");
        } інакше якщо дані.операція == ВидОпераціїЗсувВправо {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8">>");
        } інакше якщо дані.операція == ВидОпераціїЗсувВправоЗнаковий {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8">>>");
        } інакше якщо дані.операція == ВидОпераціїМенше {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"<");
        } інакше якщо дані.операція == ВидОпераціїБільше {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8">");
        } інакше якщо дані.операція == ВидОпераціїМеншеРівне {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"<=");
        } інакше якщо дані.операція == ВидОпераціїБільшеРівне {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8">=");
        } інакше якщо дані.операція == ВидОпераціїРівне {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"==");
        } інакше якщо дані.операція == ВидОпераціїНерівне {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"!=");
        } інакше якщо дані.операція == ВидОпераціїДІ {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"&");
        } інакше якщо дані.операція == ВидОпераціїВАБО {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"∧");
        } інакше якщо дані.операція == ВидОпераціїДАБО {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"|");
        } інакше якщо дані.операція == ВидОпераціїІ {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"&&");
        } інакше якщо дані.операція == ВидОпераціїАБО {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"||");
        } інакше якщо дані.операція == ВидОпераціїДіленняНаціло {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"//");
        } інакше якщо дані.операція == ВидОпераціїПіднесенняДоСтепеня {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"**");
        } інакше якщо дані.операція == ВидОпераціїМістить {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"містить");
        } інакше якщо дані.операція == ВидОпераціїНеМістить {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"не містить");
        } інакше якщо дані.операція == ВидОпераціїЄ {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"є");
        } інакше якщо дані.операція == ВидОпераціїНеЄ {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"не є");
        } інакше {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"НЕВІДОМА ОПЕРАЦІЯ");
        }
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8", ");
        вивести_сполуку(система, вихідний_потік, значення_ю8, слова, дані.право);
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8")");
      } інакше якщо сполука.вид == ВидСполукиЯкщо {
        змінна дані = сполука.дані як ДаніСполукиЯкщо;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Якщо");
      } інакше якщо сполука.вид == ВидСполукиПоки {
        змінна дані = сполука.дані як ДаніСполукиПоки;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Поки");
      } інакше якщо сполука.вид == ВидСполукиВернути {
        змінна дані = сполука.дані як ДаніСполукиВернути;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Вернути");
      } інакше якщо сполука.вид == ВидСполукиЗначенняЯкщо {
        змінна дані = сполука.дані як ДаніСполукиЗначенняЯкщо;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ЗначенняЯкщо(");
        вивести_сполуку(система, вихідний_потік, значення_ю8, слова, дані.умова);
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8", ");
        вивести_сполуку(система, вихідний_потік, значення_ю8, слова, дані.значення_так);
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8", ");
        вивести_сполуку(система, вихідний_потік, значення_ю8, слова, дані.значення_ні);
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8")");
      } інакше якщо сполука.вид == ВидСполукиСамоОперація {
        змінна дані = сполука.дані як ДаніСполукиСамоОперація;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"СамоОперація");
      } інакше якщо сполука.вид == ВидСполукиВзяти {
        змінна дані = сполука.дані як ДаніСполукиВзяти;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Взяти");
      } інакше якщо сполука.вид == ВидСполукиСпробувати {
        змінна дані = сполука.дані як ДаніСполукиСпробувати;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Спробувати");
      } інакше якщо сполука.вид == ВидСполукиВпасти {
        змінна дані = сполука.дані як ДаніСполукиВпасти;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Впасти");
      } інакше якщо сполука.вид == ВидСполукиДати {
        змінна дані = сполука.дані як ДаніСполукиДати;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Дати");
      } інакше якщо сполука.вид == ВидСполукиМодуль {
        змінна дані = сполука.дані як ДаніСполукиМодуль;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Модуль");
      } інакше якщо сполука.вид == ВидСполукиСписок {
        змінна дані = сполука.дані як ДаніСполукиСписок;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Список");
      } інакше якщо сполука.вид == ВидСполукиСловник {
        змінна дані = сполука.дані як ДаніСполукиСловник;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Словник");
      } інакше якщо сполука.вид == ВидСполукиСимвол {
        змінна дані = сполука.дані як ДаніСполукиСимвол;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Символ('");
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, слова.дані[дані.позиція_слова].значення);
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"')");
      } інакше якщо сполука.вид == ВидСполукиПеребрати {
        змінна дані = сполука.дані як ДаніСполукиПеребрати;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Перебрати");
      } інакше якщо сполука.вид == ВидСполукиЦикл {
        змінна дані = сполука.дані як ДаніСполукиЦикл;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Цикл");
      } інакше якщо сполука.вид == ВидСполукиВизначитиЗзовні {
        змінна дані = сполука.дані як ДаніСполукиВизначитиЗзовні;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВизначитиЗзовні");
      } інакше якщо сполука.вид == ВидСполукиВічнийЦикл {
        змінна дані = сполука.дані як ДаніСполукиВічнийЦикл;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВічнийЦикл");
      } інакше якщо сполука.вид == ВидСполукиВидалити {
        змінна дані = сполука.дані як ДаніСполукиВидалити;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Видалити");
      } інакше якщо сполука.вид == ВидСполукиВидалитиВластивість {
        змінна дані = сполука.дані як ДаніСполукиВидалитиВластивість;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВидалитиВластивість");
      } інакше якщо сполука.вид == ВидСполукиВидалитиЕлемент {
        змінна дані = сполука.дані як ДаніСполукиВидалитиЕлемент;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ВидалитиЕлемент");
      } інакше якщо сполука.вид == ВидСполукиЧекати {
        змінна дані = сполука.дані як ДаніСполукиЧекати;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Чекати");
      } інакше якщо сполука.вид == ВидСполукиДіапазон {
        змінна дані = сполука.дані як ДаніСполукиДіапазон;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"Діапазон");
      } інакше якщо сполука.вид == ВидСполукиЗбитийТекст {
        змінна дані = сполука.дані як ДаніСполукиЗбитийТекст;
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"ЗбитийТекст([");
        змінна п: позитивне = 0;
        поки п < дані.кількість_гілок {
          вивести_сполуку(система, вихідний_потік, значення_ю8, слова, дані.сполуки[п]);
          якщо п != дані.кількість_гілок - 1 {
            дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8", ");
          }
          п += 1;
        }
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"])");
      } інакше {
        дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"!!! НЕВІДОМА ГІЛКА !!!");
      }
    }

    місцева дія вивести_сполуки(система: адреса<Система>, вихідний_потік: адреса<ВихіднийПотік>, значення_ю8: ю8, слова: Слова, сполуки: Сполуки) {
      змінна п: позитивне = 0;
      поки п < сполуки.розмір {
        вивести_сполуку(система, вихідний_потік, значення_ю8, слова, сполуки.дані[п]);
        якщо п != сполуки.розмір - 1 {
          дописати_ю8_у_вихідний_потік(система, вихідний_потік, ю8"\р");
        }
        п += 1;
      }
    }

    місцева дія звільнити_сполуки(система: адреса<Система>, сполуки: Сполуки) {
      змінна п: позитивне = 0;
      поки п < сполуки.розмір {
        звільнити_сполуку(система, сполуки.дані[п]);
        п += 1;
      }
      звільнити_памʼять(система, сполуки.дані);
    }

    місцева дія звільнити_помилку_розбору_на_сполуки(система: адреса<Система>, помилка: ПомилкаРозборуНаСполуки) {
      // ...
    }

    місцева дія отримати_ю8_помилки_розбору_на_сполуки(система: адреса<Система>, помилка: ПомилкаРозборуНаСполуки, вихід: адреса<ю8>): логічне {
      виділити_копію_ю8(система, ю8"Не вдалось розібрати", вихід);
      вернути так;
    }

    місцева дія отримати_рядок_помилки_розбору_на_сполуки(система: адреса<Система>, помилка: ПомилкаРозборуНаСполуки): позитивне {
      вернути помилка.рядок;
    }

    місцева дія отримати_стовпець_помилки_розбору_на_сполуки(система: адреса<Система>, помилка: ПомилкаРозборуНаСполуки): позитивне {
      вернути помилка.стовпець;
    }
  }
}