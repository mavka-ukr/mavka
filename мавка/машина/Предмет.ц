взяти визначення біб/КД;
взяти визначення мавка;

секція мавка {
  місцева дія предмет_отримати_користувацькі_дані(М: адреса<Машина>, предмет: адреса<Предмет>): невідома_адреса {
    вернути предмет.користувацькі_дані;
  }

  місцева дія предмет_змінити_користувацькі_дані(М: адреса<Машина>, предмет: адреса<Предмет>, користувацькі_дані: невідома_адреса) {
    предмет.користувацькі_дані = користувацькі_дані;
  }

  дія предмет_виконати_метод_чародія_зображення(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    змінна накопичувач_т8 = зробити_накопичувач<п8>(М);
    покласти_в_накопичувач_т8(М, накопичувач_т8::адреса, "<предмет");
    якщо предмет.тип != пусто {
      якщо предмет.тип != М.предмет_структури_предмет {
        якщо предмет.тип.назва != пусто {
          покласти_в_накопичувач_т8(М, накопичувач_т8::адреса, " ");
          покласти_в_накопичувач_т8(М, накопичувач_т8::адреса, предмет.тип.назва.значення);
        }
      }
    }
    покласти_в_накопичувач_т8(М, накопичувач_т8::адреса, ">");
    змінна предмет_тексту = створити_предмет_тексту(М, т8 { накопичувач_т8.розмір, накопичувач_т8.дані });
    звільнити_памʼять(М, накопичувач_т8.дані);
    вернути предмет_тексту як адреса<Предмет>;
  }

  дія предмет_виконати_метод_чародія_текст(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    змінна накопичувач_т8 = зробити_накопичувач<п8>(М);
    покласти_в_накопичувач_т8(М, накопичувач_т8::адреса, "<предмет");
    якщо предмет.тип != пусто {
      якщо предмет.тип != М.предмет_структури_предмет {
        якщо предмет.тип.назва != пусто {
          покласти_в_накопичувач_т8(М, накопичувач_т8::адреса, " ");
          покласти_в_накопичувач_т8(М, накопичувач_т8::адреса, предмет.тип.назва.значення);
        }
      }
    }
    покласти_в_накопичувач_т8(М, накопичувач_т8::адреса, ">");
    змінна предмет_тексту = створити_предмет_тексту(М, т8 { накопичувач_т8.розмір, накопичувач_т8.дані });
    звільнити_памʼять(М, накопичувач_т8.дані);
    вернути предмет_тексту як адреса<Предмет>;
  }

  дія предмет_виконати_метод_чародія_юнікод(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    змінна накопичувач_ю8 = зробити_накопичувач<п8>(М);
    покласти_в_накопичувач_ю8(М, накопичувач_ю8::адреса, ю8"<предмет");
    якщо предмет.тип != пусто {
      якщо предмет.тип != М.предмет_структури_предмет {
        якщо предмет.тип.назва != пусто {
          покласти_в_накопичувач_ю8(М, накопичувач_ю8::адреса, ю8" ");
          покласти_т8_в_накопичувач_ю8(М, накопичувач_ю8::адреса, предмет.тип.назва.значення);
        }
      }
    }
    покласти_в_накопичувач_ю8(М, накопичувач_ю8::адреса, ю8">");
    змінна предмет_юнікоду = створити_предмет_юнікоду_з_ю8(М, ю8 { накопичувач_ю8.розмір, накопичувач_ю8.дані });
    звільнити_памʼять(М, накопичувач_ю8.дані);
    вернути предмет_юнікоду як адреса<Предмет>;
  }
}

секція мавка {
  дія рідна_дія_метода_чародія_зображення(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    змінна предмет = предмет_я як адреса<Предмет>;
    вернути предмет_виконати_метод_чародія_зображення(М, предмет, місцезнаходження);
  }

  дія записати_метод_структури_предмет_чародія_зображення(М: адреса<Машина>) {
    змінна предмет_дії_метода_чародія_зображення = створити_предмет_рідної_дії(М, назва(М, "чародія_зображення"), 0, пусто, пусто, рідна_дія_метода_чародія_зображення, пусто, пусто, пусто);
    предмет_структури_записати_метод(М, М.предмет_структури_предмет, назва(М, "чародія_зображення"), предмет_дії_метода_чародія_зображення);
  }

  дія рідна_дія_метода_чародія_текст(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    змінна предмет = предмет_я як адреса<Предмет>;
    вернути предмет_виконати_метод_чародія_текст(М, предмет, місцезнаходження);
  }

  дія записати_метод_структури_предмет_чародія_текст(М: адреса<Машина>) {
    змінна предмет_дії_метода_чародія_текст = створити_предмет_рідної_дії(М, назва(М, "чародія_текст"), 0, пусто, пусто, рідна_дія_метода_чародія_текст, пусто, пусто, пусто);
    предмет_структури_записати_метод(М, М.предмет_структури_предмет, назва(М, "чародія_текст"), предмет_дії_метода_чародія_текст);
  }

  дія рідна_дія_метода_чародія_юнікод(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    змінна предмет = предмет_я як адреса<Предмет>;
    вернути предмет_виконати_метод_чародія_юнікод(М, предмет, місцезнаходження);
  }

  дія записати_метод_структури_предмет_чародія_юнікод(М: адреса<Машина>) {
    змінна предмет_дії_метода_чародія_юнікод = створити_предмет_рідної_дії(М, назва(М, "чародія_юнікод"), 0, пусто, пусто, рідна_дія_метода_чародія_юнікод, пусто, пусто, пусто);
    предмет_структури_записати_метод(М, М.предмет_структури_предмет, назва(М, "чародія_юнікод"), предмет_дії_метода_чародія_юнікод);
  }

  місцева дія заповнити_предмет_структури_предмет(М: адреса<Машина>) {
    записати_метод_структури_предмет_чародія_зображення(М);
    записати_метод_структури_предмет_чародія_текст(М);
    записати_метод_структури_предмет_чародія_юнікод(М);
  }
}

секція мавка {
  місцева дія назва(М: адреса<Машина>, значення: т8): адреса<ПредметТексту> {
    вернути створити_предмет_тексту(М, значення);
  }

  місцева дія перевірити_чи_предмети_назви_рівні(М: адреса<Машина>, а: адреса<ПредметТексту>, б: адреса<ПредметТексту>): логічне {
    якщо а == б {
      вернути так;
    }
    вернути перевірити_чи_т8_рівні(а.значення, б.значення);
  }

  дія перевірити_чи_предмети_логічного_рівні(М: адреса<Машина>, а: адреса<ПредметЛогічного>, б: адреса<ПредметЛогічного>): логічне {
    вернути а.значення == б.значення;
  }

  дія перевірити_чи_предмети_числа_рівні(М: адреса<Машина>, а: адреса<ПредметЧисла>, б: адреса<ПредметЧисла>): логічне {
    вернути а.значення == б.значення;
  }

  дія перевірити_чи_предмети_тексту_рівні(М: адреса<Машина>, а: адреса<ПредметТексту>, б: адреса<ПредметТексту>): логічне {
    вернути перевірити_чи_т8_рівні(а.значення, б.значення);
  }

  дія перевірити_чи_предмети_юнікоду_рівні(М: адреса<Машина>, а: адреса<ПредметЮнікоду>, б: адреса<ПредметЮнікоду>): логічне {
    вернути перевірити_чи_ю32_рівні(а.значення, б.значення);
  }

  місцева дія перевірити_чи_предмети_рівні(М: адреса<Машина>, а: адреса<Предмет>, б: адреса<Предмет>): логічне {
    якщо а == б {
      вернути так;
    }
    якщо а == пусто {
      вернути ні;
    }
    якщо б == пусто {
      вернути ні;
    }
    якщо а.тип == М.предмет_структури_логічне {
      якщо б.тип == М.предмет_структури_логічне {
        вернути перевірити_чи_предмети_логічного_рівні(М, а як адреса<ПредметЛогічного>, б як адреса<ПредметЛогічного>);
      }
    } інакше якщо а.тип == М.предмет_структури_число {
      якщо б.тип == М.предмет_структури_число {
        вернути перевірити_чи_предмети_числа_рівні(М, а як адреса<ПредметЧисла>, б як адреса<ПредметЧисла>);
      }
    } інакше якщо а.тип == М.предмет_структури_текст {
      якщо б.тип == М.предмет_структури_текст {
        вернути перевірити_чи_предмети_тексту_рівні(М, а як адреса<ПредметТексту>, б як адреса<ПредметТексту>);
      }
    } інакше якщо а.тип == М.предмет_структури_юнікод {
      якщо б.тип == М.предмет_структури_юнікод {
        вернути перевірити_чи_предмети_юнікоду_рівні(М, а як адреса<ПредметЮнікоду>, б як адреса<ПредметЮнікоду>);
      }
    }
    вернути ні;
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_отримати_властивість(М: адреса<Машина>, предмет: адреса<Предмет>, назва: адреса<ПредметТексту>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо отримати властивість пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_отримати_властивість(М, предмет як адреса<ПредметСтруктури>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_отримати_властивість(М, предмет як адреса<ПредметКоду>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_отримати_властивість(М, предмет як адреса<ПредметСередовища>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_отримати_властивість(М, предмет як адреса<ПредметДії>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_отримати_властивість(М, предмет як адреса<ПредметЛогічного>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_отримати_властивість(М, предмет як адреса<ПредметЧисла>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_отримати_властивість(М, предмет як адреса<ПредметТексту>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_отримати_властивість(М, предмет як адреса<ПредметЮнікоду>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_отримати_властивість(М, предмет як адреса<ПредметСписку>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_отримати_властивість(М, предмет як адреса<ПредметСловника>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_отримати_властивість(М, предмет як адреса<ПредметБайтів>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_отримати_властивість(М, предмет як адреса<ПредметБуфера>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_отримати_властивість(М, предмет як адреса<ПредметМодуля>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_отримати_властивість(М, предмет як адреса<ПредметТипу>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_отримати_властивість(М, предмет як адреса<ПредметПараметра>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_отримати_властивість(М, предмет як адреса<ПредметДіапазонуЧисел>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_отримати_властивість(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_отримати_властивість(М, предмет як адреса<ПредметПереборуСписку>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_отримати_властивість(М, предмет як адреса<ПредметПереборуТексту>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_отримати_властивість(М, предмет як адреса<ПредметПереборуЮнікоду>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_отримати_властивість(М, предмет як адреса<ПредметРозширення>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_отримати_властивість(М, предмет як адреса<ПредметПереборуБайтів>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_отримати_властивість(М, предмет як адреса<ПредметПереборуБуфера>, назва, місцезнаходження);
    } інакше {
      вернути складений_предмет_отримати_властивість(М, предмет як адреса<СкладенийПредмет>, назва, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_змінити_властивість(М: адреса<Машина>, предмет: адреса<Предмет>, назва: адреса<ПредметТексту>, значення: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо змінити властивість пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_змінити_властивість(М, предмет як адреса<ПредметСтруктури>, назва, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_змінити_властивість(М, предмет як адреса<ПредметКоду>, назва, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_змінити_властивість(М, предмет як адреса<ПредметСередовища>, назва, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_змінити_властивість(М, предмет як адреса<ПредметДії>, назва, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_змінити_властивість(М, предмет як адреса<ПредметЛогічного>, назва, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_змінити_властивість(М, предмет як адреса<ПредметЧисла>, назва, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_змінити_властивість(М, предмет як адреса<ПредметТексту>, назва, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_змінити_властивість(М, предмет як адреса<ПредметЮнікоду>, назва, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_змінити_властивість(М, предмет як адреса<ПредметСписку>, назва, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_змінити_властивість(М, предмет як адреса<ПредметСловника>, назва, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_змінити_властивість(М, предмет як адреса<ПредметБайтів>, назва, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_змінити_властивість(М, предмет як адреса<ПредметБуфера>, назва, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_змінити_властивість(М, предмет як адреса<ПредметМодуля>, назва, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_змінити_властивість(М, предмет як адреса<ПредметТипу>, назва, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_змінити_властивість(М, предмет як адреса<ПредметПараметра>, назва, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_змінити_властивість(М, предмет як адреса<ПредметДіапазонуЧисел>, назва, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_змінити_властивість(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, назва, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_змінити_властивість(М, предмет як адреса<ПредметПереборуСписку>, назва, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_змінити_властивість(М, предмет як адреса<ПредметПереборуТексту>, назва, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_змінити_властивість(М, предмет як адреса<ПредметПереборуЮнікоду>, назва, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_змінити_властивість(М, предмет як адреса<ПредметРозширення>, назва, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_змінити_властивість(М, предмет як адреса<ПредметПереборуБайтів>, назва, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_змінити_властивість(М, предмет як адреса<ПредметПереборуБуфера>, назва, значення, місцезнаходження);
    } інакше {
      вернути складений_предмет_змінити_властивість(М, предмет як адреса<СкладенийПредмет>, назва, значення, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_видалити_властивість(М: адреса<Машина>, предмет: адреса<Предмет>, назва: адреса<ПредметТексту>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо отримати властивість пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_видалити_властивість(М, предмет як адреса<ПредметСтруктури>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_видалити_властивість(М, предмет як адреса<ПредметКоду>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_видалити_властивість(М, предмет як адреса<ПредметСередовища>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_видалити_властивість(М, предмет як адреса<ПредметДії>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_видалити_властивість(М, предмет як адреса<ПредметЛогічного>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_видалити_властивість(М, предмет як адреса<ПредметЧисла>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_видалити_властивість(М, предмет як адреса<ПредметТексту>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_видалити_властивість(М, предмет як адреса<ПредметЮнікоду>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_видалити_властивість(М, предмет як адреса<ПредметСписку>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_видалити_властивість(М, предмет як адреса<ПредметСловника>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_видалити_властивість(М, предмет як адреса<ПредметБайтів>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_видалити_властивість(М, предмет як адреса<ПредметБуфера>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_видалити_властивість(М, предмет як адреса<ПредметМодуля>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_видалити_властивість(М, предмет як адреса<ПредметТипу>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_видалити_властивість(М, предмет як адреса<ПредметПараметра>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_видалити_властивість(М, предмет як адреса<ПредметДіапазонуЧисел>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_видалити_властивість(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_видалити_властивість(М, предмет як адреса<ПредметПереборуСписку>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_видалити_властивість(М, предмет як адреса<ПредметПереборуТексту>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_видалити_властивість(М, предмет як адреса<ПредметПереборуЮнікоду>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_видалити_властивість(М, предмет як адреса<ПредметРозширення>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_видалити_властивість(М, предмет як адреса<ПредметПереборуБайтів>, назва, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_видалити_властивість(М, предмет як адреса<ПредметПереборуБуфера>, назва, місцезнаходження);
    } інакше {
      вернути складений_предмет_видалити_властивість(М, предмет як адреса<СкладенийПредмет>, назва, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_виконати_властивість(М: адреса<Машина>, предмет: адреса<Предмет>, назва: адреса<ПредметТексту>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо виконати властивість пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_виконати_властивість(М, предмет як адреса<ПредметСтруктури>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_виконати_властивість(М, предмет як адреса<ПредметКоду>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_виконати_властивість(М, предмет як адреса<ПредметСередовища>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_виконати_властивість(М, предмет як адреса<ПредметДії>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_виконати_властивість(М, предмет як адреса<ПредметЛогічного>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_виконати_властивість(М, предмет як адреса<ПредметЧисла>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_виконати_властивість(М, предмет як адреса<ПредметТексту>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_виконати_властивість(М, предмет як адреса<ПредметЮнікоду>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_виконати_властивість(М, предмет як адреса<ПредметСписку>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_виконати_властивість(М, предмет як адреса<ПредметСловника>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_виконати_властивість(М, предмет як адреса<ПредметБайтів>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_виконати_властивість(М, предмет як адреса<ПредметБуфера>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_виконати_властивість(М, предмет як адреса<ПредметМодуля>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_виконати_властивість(М, предмет як адреса<ПредметТипу>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_виконати_властивість(М, предмет як адреса<ПредметПараметра>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_виконати_властивість(М, предмет як адреса<ПредметДіапазонуЧисел>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_виконати_властивість(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_виконати_властивість(М, предмет як адреса<ПредметПереборуСписку>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_виконати_властивість(М, предмет як адреса<ПредметПереборуТексту>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_виконати_властивість(М, предмет як адреса<ПредметПереборуЮнікоду>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_виконати_властивість(М, предмет як адреса<ПредметРозширення>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_виконати_властивість(М, предмет як адреса<ПредметПереборуБайтів>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_виконати_властивість(М, предмет як адреса<ПредметПереборуБуфера>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше {
      вернути складений_предмет_виконати_властивість(М, предмет як адреса<СкладенийПредмет>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_виконати(М: адреса<Машина>, предмет: адреса<Предмет>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо виконати пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_виконати(М, предмет як адреса<ПредметСтруктури>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_виконати(М, предмет як адреса<ПредметКоду>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_виконати(М, предмет як адреса<ПредметСередовища>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_виконати(М, предмет як адреса<ПредметДії>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_виконати(М, предмет як адреса<ПредметЛогічного>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_виконати(М, предмет як адреса<ПредметЧисла>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_виконати(М, предмет як адреса<ПредметТексту>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_виконати(М, предмет як адреса<ПредметЮнікоду>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_виконати(М, предмет як адреса<ПредметСписку>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_виконати(М, предмет як адреса<ПредметСловника>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_виконати(М, предмет як адреса<ПредметБайтів>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_виконати(М, предмет як адреса<ПредметБуфера>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_виконати(М, предмет як адреса<ПредметМодуля>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_виконати(М, предмет як адреса<ПредметТипу>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_виконати(М, предмет як адреса<ПредметПараметра>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_виконати(М, предмет як адреса<ПредметДіапазонуЧисел>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_виконати(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_виконати(М, предмет як адреса<ПредметПереборуСписку>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_виконати(М, предмет як адреса<ПредметПереборуТексту>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_виконати(М, предмет як адреса<ПредметПереборуЮнікоду>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_виконати(М, предмет як адреса<ПредметРозширення>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_виконати(М, предмет як адреса<ПредметПереборуБайтів>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_виконати(М, предмет як адреса<ПредметПереборуБуфера>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше {
      вернути складений_предмет_виконати(М, предмет як адреса<СкладенийПредмет>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_отримати_елемент(М: адреса<Машина>, предмет: адреса<Предмет>, ключ: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо отримати елемент з пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_отримати_елемент(М, предмет як адреса<ПредметСтруктури>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_отримати_елемент(М, предмет як адреса<ПредметКоду>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_отримати_елемент(М, предмет як адреса<ПредметСередовища>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_отримати_елемент(М, предмет як адреса<ПредметДії>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_отримати_елемент(М, предмет як адреса<ПредметЛогічного>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_отримати_елемент(М, предмет як адреса<ПредметЧисла>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_отримати_елемент(М, предмет як адреса<ПредметТексту>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_отримати_елемент(М, предмет як адреса<ПредметЮнікоду>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_отримати_елемент(М, предмет як адреса<ПредметСписку>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_отримати_елемент(М, предмет як адреса<ПредметСловника>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_отримати_елемент(М, предмет як адреса<ПредметБайтів>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_отримати_елемент(М, предмет як адреса<ПредметБуфера>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_отримати_елемент(М, предмет як адреса<ПредметМодуля>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_отримати_елемент(М, предмет як адреса<ПредметТипу>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_отримати_елемент(М, предмет як адреса<ПредметПараметра>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_отримати_елемент(М, предмет як адреса<ПредметДіапазонуЧисел>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_отримати_елемент(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_отримати_елемент(М, предмет як адреса<ПредметПереборуСписку>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_отримати_елемент(М, предмет як адреса<ПредметПереборуТексту>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_отримати_елемент(М, предмет як адреса<ПредметПереборуЮнікоду>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_отримати_елемент(М, предмет як адреса<ПредметРозширення>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_отримати_елемент(М, предмет як адреса<ПредметПереборуБайтів>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_отримати_елемент(М, предмет як адреса<ПредметПереборуБуфера>, ключ, місцезнаходження);
    } інакше {
      вернути складений_предмет_отримати_елемент(М, предмет як адреса<СкладенийПредмет>, ключ, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_змінити_елемент(М: адреса<Машина>, предмет: адреса<Предмет>, ключ: адреса<Предмет>, значення: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо змінити елемент в пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_змінити_елемент(М, предмет як адреса<ПредметСтруктури>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_змінити_елемент(М, предмет як адреса<ПредметКоду>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_змінити_елемент(М, предмет як адреса<ПредметСередовища>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_змінити_елемент(М, предмет як адреса<ПредметДії>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_змінити_елемент(М, предмет як адреса<ПредметЛогічного>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_змінити_елемент(М, предмет як адреса<ПредметЧисла>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_змінити_елемент(М, предмет як адреса<ПредметТексту>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_змінити_елемент(М, предмет як адреса<ПредметЮнікоду>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_змінити_елемент(М, предмет як адреса<ПредметСписку>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_змінити_елемент(М, предмет як адреса<ПредметСловника>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_змінити_елемент(М, предмет як адреса<ПредметБайтів>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_змінити_елемент(М, предмет як адреса<ПредметБуфера>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_змінити_елемент(М, предмет як адреса<ПредметМодуля>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_змінити_елемент(М, предмет як адреса<ПредметТипу>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_змінити_елемент(М, предмет як адреса<ПредметПараметра>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_змінити_елемент(М, предмет як адреса<ПредметДіапазонуЧисел>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_змінити_елемент(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_змінити_елемент(М, предмет як адреса<ПредметПереборуСписку>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_змінити_елемент(М, предмет як адреса<ПредметПереборуТексту>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_змінити_елемент(М, предмет як адреса<ПредметПереборуЮнікоду>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_змінити_елемент(М, предмет як адреса<ПредметРозширення>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_змінити_елемент(М, предмет як адреса<ПредметПереборуБайтів>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_змінити_елемент(М, предмет як адреса<ПредметПереборуБуфера>, ключ, значення, місцезнаходження);
    } інакше {
      вернути складений_предмет_змінити_елемент(М, предмет як адреса<СкладенийПредмет>, ключ, значення, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_видалити_елемент(М: адреса<Машина>, предмет: адреса<Предмет>, ключ: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо отримати елемент з пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_видалити_елемент(М, предмет як адреса<ПредметСтруктури>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_видалити_елемент(М, предмет як адреса<ПредметКоду>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_видалити_елемент(М, предмет як адреса<ПредметСередовища>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_видалити_елемент(М, предмет як адреса<ПредметДії>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_видалити_елемент(М, предмет як адреса<ПредметЛогічного>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_видалити_елемент(М, предмет як адреса<ПредметЧисла>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_видалити_елемент(М, предмет як адреса<ПредметТексту>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_видалити_елемент(М, предмет як адреса<ПредметЮнікоду>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_видалити_елемент(М, предмет як адреса<ПредметСписку>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_видалити_елемент(М, предмет як адреса<ПредметСловника>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_видалити_елемент(М, предмет як адреса<ПредметБайтів>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_видалити_елемент(М, предмет як адреса<ПредметБуфера>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_видалити_елемент(М, предмет як адреса<ПредметМодуля>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_видалити_елемент(М, предмет як адреса<ПредметТипу>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_видалити_елемент(М, предмет як адреса<ПредметПараметра>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_видалити_елемент(М, предмет як адреса<ПредметДіапазонуЧисел>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_видалити_елемент(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_видалити_елемент(М, предмет як адреса<ПредметПереборуСписку>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_видалити_елемент(М, предмет як адреса<ПредметПереборуТексту>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_видалити_елемент(М, предмет як адреса<ПредметПереборуЮнікоду>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_видалити_елемент(М, предмет як адреса<ПредметРозширення>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_видалити_елемент(М, предмет як адреса<ПредметПереборуБайтів>, ключ, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_видалити_елемент(М, предмет як адреса<ПредметПереборуБуфера>, ключ, місцезнаходження);
    } інакше {
      вернути складений_предмет_видалити_елемент(М, предмет як адреса<СкладенийПредмет>, ключ, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_додати(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо додати до пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_додати(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_додати(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_додати(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_додати(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_додати(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_додати(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_додати(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_додати(М, предмет як адреса<ПредметЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_додати(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_додати(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_додати(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_додати(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_додати(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_додати(М, предмет як адреса<ПредметТипу>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_додати(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_додати(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_додати(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_додати(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_додати(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_додати(М, предмет як адреса<ПредметПереборуЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_додати(М, предмет як адреса<ПредметРозширення>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_додати(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_додати(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_додати(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_відняти(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо відняти до пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_відняти(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_відняти(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_відняти(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_відняти(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_відняти(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_відняти(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_відняти(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_відняти(М, предмет як адреса<ПредметЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_відняти(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_відняти(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_відняти(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_відняти(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_відняти(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_відняти(М, предмет як адреса<ПредметТипу>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_відняти(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_відняти(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_відняти(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_відняти(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_відняти(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_відняти(М, предмет як адреса<ПредметПереборуЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_відняти(М, предмет як адреса<ПредметРозширення>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_відняти(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_відняти(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_відняти(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_помножити(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо помножити до пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_помножити(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_помножити(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_помножити(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_помножити(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_помножити(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_помножити(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_помножити(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_помножити(М, предмет як адреса<ПредметЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_помножити(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_помножити(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_помножити(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_помножити(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_помножити(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_помножити(М, предмет як адреса<ПредметТипу>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_помножити(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_помножити(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_помножити(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_помножити(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_помножити(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_помножити(М, предмет як адреса<ПредметПереборуЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_помножити(М, предмет як адреса<ПредметРозширення>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_помножити(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_помножити(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_помножити(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_поділити(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо поділити до пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_поділити(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_поділити(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_поділити(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_поділити(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_поділити(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_поділити(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_поділити(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_поділити(М, предмет як адреса<ПредметЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_поділити(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_поділити(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_поділити(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_поділити(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_поділити(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_поділити(М, предмет як адреса<ПредметТипу>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_поділити(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_поділити(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_поділити(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_поділити(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_поділити(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_поділити(М, предмет як адреса<ПредметПереборуЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_поділити(М, предмет як адреса<ПредметРозширення>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_поділити(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_поділити(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_поділити(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_остача(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо остача до пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_остача(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_остача(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_остача(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_остача(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_остача(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_остача(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_остача(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_остача(М, предмет як адреса<ПредметЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_остача(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_остача(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_остача(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_остача(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_остача(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_остача(М, предмет як адреса<ПредметТипу>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_остача(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_остача(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_остача(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_остача(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_остача(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_остача(М, предмет як адреса<ПредметПереборуЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_остача(М, предмет як адреса<ПредметРозширення>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_остача(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_остача(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_остача(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_неповна_частка(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо частка до пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_неповна_частка(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_неповна_частка(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_неповна_частка(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_неповна_частка(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_неповна_частка(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_неповна_частка(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_неповна_частка(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_неповна_частка(М, предмет як адреса<ПредметЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_неповна_частка(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_неповна_частка(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_неповна_частка(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_неповна_частка(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_неповна_частка(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_неповна_частка(М, предмет як адреса<ПредметТипу>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_неповна_частка(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_неповна_частка(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_неповна_частка(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_неповна_частка(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_неповна_частка(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_неповна_частка(М, предмет як адреса<ПредметПереборуЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_неповна_частка(М, предмет як адреса<ПредметРозширення>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_неповна_частка(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_неповна_частка(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_неповна_частка(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_степінь(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо степінь до пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_степінь(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_степінь(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_степінь(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_степінь(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_степінь(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_степінь(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_степінь(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_степінь(М, предмет як адреса<ПредметЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_степінь(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_степінь(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_степінь(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_степінь(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_степінь(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_степінь(М, предмет як адреса<ПредметТипу>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_степінь(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_степінь(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_степінь(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_степінь(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_степінь(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_степінь(М, предмет як адреса<ПредметПереборуЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_степінь(М, предмет як адреса<ПредметРозширення>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_степінь(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_степінь(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_степінь(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_зсунути_вліво(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо зсунути_вліво до пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_зсунути_вліво(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_зсунути_вліво(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_зсунути_вліво(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_зсунути_вліво(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_зсунути_вліво(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_зсунути_вліво(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_зсунути_вліво(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_зсунути_вліво(М, предмет як адреса<ПредметЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_зсунути_вліво(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_зсунути_вліво(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_зсунути_вліво(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_зсунути_вліво(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_зсунути_вліво(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_зсунути_вліво(М, предмет як адреса<ПредметТипу>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_зсунути_вліво(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_зсунути_вліво(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_зсунути_вліво(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_зсунути_вліво(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_зсунути_вліво(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_зсунути_вліво(М, предмет як адреса<ПредметПереборуЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_зсунути_вліво(М, предмет як адреса<ПредметРозширення>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_зсунути_вліво(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_зсунути_вліво(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_зсунути_вліво(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_зсунути_вправо(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо зсунути_вправо до пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_зсунути_вправо(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_зсунути_вправо(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_зсунути_вправо(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_зсунути_вправо(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_зсунути_вправо(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_зсунути_вправо(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_зсунути_вправо(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_зсунути_вправо(М, предмет як адреса<ПредметЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_зсунути_вправо(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_зсунути_вправо(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_зсунути_вправо(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_зсунути_вправо(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_зсунути_вправо(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_зсунути_вправо(М, предмет як адреса<ПредметТипу>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_зсунути_вправо(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_зсунути_вправо(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_зсунути_вправо(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_зсунути_вправо(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_зсунути_вправо(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_зсунути_вправо(М, предмет як адреса<ПредметПереборуЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_зсунути_вправо(М, предмет як адреса<ПредметРозширення>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_зсунути_вправо(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_зсунути_вправо(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_зсунути_вправо(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_зсунути_вправо_2(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо беззнаковий_зсув_вправо до пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_зсунути_вправо_2(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_зсунути_вправо_2(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_зсунути_вправо_2(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_зсунути_вправо_2(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_зсунути_вправо_2(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_зсунути_вправо_2(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_зсунути_вправо_2(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_зсунути_вправо_2(М, предмет як адреса<ПредметЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_зсунути_вправо_2(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_зсунути_вправо_2(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_зсунути_вправо_2(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_зсунути_вправо_2(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_зсунути_вправо_2(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_зсунути_вправо_2(М, предмет як адреса<ПредметТипу>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_зсунути_вправо_2(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_зсунути_вправо_2(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_зсунути_вправо_2(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_зсунути_вправо_2(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_зсунути_вправо_2(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_зсунути_вправо_2(М, предмет як адреса<ПредметПереборуЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_зсунути_вправо_2(М, предмет як адреса<ПредметРозширення>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_зсунути_вправо_2(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_зсунути_вправо_2(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_зсунути_вправо_2(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_двійкове_і(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо двійкове_і до пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_двійкове_і(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_двійкове_і(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_двійкове_і(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_двійкове_і(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_двійкове_і(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_двійкове_і(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_двійкове_і(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_двійкове_і(М, предмет як адреса<ПредметЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_двійкове_і(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_двійкове_і(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_двійкове_і(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_двійкове_і(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_двійкове_і(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_двійкове_і(М, предмет як адреса<ПредметТипу>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_двійкове_і(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_двійкове_і(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_двійкове_і(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_двійкове_і(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_двійкове_і(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_двійкове_і(М, предмет як адреса<ПредметПереборуЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_двійкове_і(М, предмет як адреса<ПредметРозширення>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_двійкове_і(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_двійкове_і(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_двійкове_і(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_двійкове_або(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо двійкове_або до пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_двійкове_або(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_двійкове_або(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_двійкове_або(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_двійкове_або(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_двійкове_або(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_двійкове_або(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_двійкове_або(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_двійкове_або(М, предмет як адреса<ПредметЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_двійкове_або(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_двійкове_або(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_двійкове_або(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_двійкове_або(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_двійкове_або(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_двійкове_або(М, предмет як адреса<ПредметТипу>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_двійкове_або(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_двійкове_або(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_двійкове_або(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_двійкове_або(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_двійкове_або(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_двійкове_або(М, предмет як адреса<ПредметПереборуЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_двійкове_або(М, предмет як адреса<ПредметРозширення>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_двійкове_або(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_двійкове_або(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_двійкове_або(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_двійкове_виключне_або(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо двійкове_виключне_або до пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_двійкове_виключне_або(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_двійкове_виключне_або(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_двійкове_виключне_або(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_двійкове_виключне_або(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_двійкове_виключне_або(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_двійкове_виключне_або(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_двійкове_виключне_або(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_двійкове_виключне_або(М, предмет як адреса<ПредметЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_двійкове_виключне_або(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_двійкове_виключне_або(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_двійкове_виключне_або(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_двійкове_виключне_або(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_двійкове_виключне_або(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_двійкове_виключне_або(М, предмет як адреса<ПредметТипу>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_двійкове_виключне_або(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_двійкове_виключне_або(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_двійкове_виключне_або(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_двійкове_виключне_або(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_двійкове_виключне_або(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_двійкове_виключне_або(М, предмет як адреса<ПредметПереборуЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_двійкове_виключне_або(М, предмет як адреса<ПредметРозширення>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_двійкове_виключне_або(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_двійкове_виключне_або(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_двійкове_виключне_або(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_двійкове_заперечення(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо двійкове_заперечення до пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_двійкове_заперечення(М, предмет як адреса<ПредметСтруктури>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_двійкове_заперечення(М, предмет як адреса<ПредметКоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_двійкове_заперечення(М, предмет як адреса<ПредметСередовища>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_двійкове_заперечення(М, предмет як адреса<ПредметДії>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_двійкове_заперечення(М, предмет як адреса<ПредметЛогічного>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_двійкове_заперечення(М, предмет як адреса<ПредметЧисла>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_двійкове_заперечення(М, предмет як адреса<ПредметТексту>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_двійкове_заперечення(М, предмет як адреса<ПредметЮнікоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_двійкове_заперечення(М, предмет як адреса<ПредметСписку>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_двійкове_заперечення(М, предмет як адреса<ПредметСловника>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_двійкове_заперечення(М, предмет як адреса<ПредметБайтів>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_двійкове_заперечення(М, предмет як адреса<ПредметБуфера>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_двійкове_заперечення(М, предмет як адреса<ПредметМодуля>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_двійкове_заперечення(М, предмет як адреса<ПредметТипу>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_двійкове_заперечення(М, предмет як адреса<ПредметПараметра>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_двійкове_заперечення(М, предмет як адреса<ПредметДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_двійкове_заперечення(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_двійкове_заперечення(М, предмет як адреса<ПредметПереборуСписку>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_двійкове_заперечення(М, предмет як адреса<ПредметПереборуТексту>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_двійкове_заперечення(М, предмет як адреса<ПредметПереборуЮнікоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_двійкове_заперечення(М, предмет як адреса<ПредметРозширення>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_двійкове_заперечення(М, предмет як адреса<ПредметПереборуБайтів>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_двійкове_заперечення(М, предмет як адреса<ПредметПереборуБуфера>, місцезнаходження);
    } інакше {
      вернути складений_предмет_двійкове_заперечення(М, предмет як адреса<СкладенийПредмет>, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_менше(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо менше до пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_менше(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_менше(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_менше(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_менше(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_менше(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_менше(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_менше(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_менше(М, предмет як адреса<ПредметЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_менше(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_менше(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_менше(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_менше(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_менше(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_менше(М, предмет як адреса<ПредметТипу>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_менше(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_менше(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_менше(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_менше(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_менше(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_менше(М, предмет як адреса<ПредметПереборуЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_менше(М, предмет як адреса<ПредметРозширення>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_менше(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_менше(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_менше(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_більше(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо більше до пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_більше(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_більше(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_більше(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_більше(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_більше(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_більше(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_більше(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_більше(М, предмет як адреса<ПредметЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_більше(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_більше(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_більше(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_більше(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_більше(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_більше(М, предмет як адреса<ПредметТипу>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_більше(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_більше(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_більше(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_більше(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_більше(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_більше(М, предмет як адреса<ПредметПереборуЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_більше(М, предмет як адреса<ПредметРозширення>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_більше(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_більше(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_більше(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_містить(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо містить до пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_містить(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_містить(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_містить(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_містить(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_містить(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_містить(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_містить(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_містить(М, предмет як адреса<ПредметЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_містить(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_містить(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_містить(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_містить(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_містить(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_містить(М, предмет як адреса<ПредметТипу>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_містить(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_містить(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_містить(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_містить(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_містить(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_містить(М, предмет як адреса<ПредметПереборуЮнікоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_містить(М, предмет як адреса<ПредметРозширення>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_містить(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_містить(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_містить(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_числова_негація(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути пусто; // потім: помилка
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_числова_негація(М, предмет як адреса<ПредметСтруктури>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_числова_негація(М, предмет як адреса<ПредметКоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_числова_негація(М, предмет як адреса<ПредметСередовища>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_числова_негація(М, предмет як адреса<ПредметДії>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_числова_негація(М, предмет як адреса<ПредметЛогічного>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_числова_негація(М, предмет як адреса<ПредметЧисла>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_числова_негація(М, предмет як адреса<ПредметТексту>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_числова_негація(М, предмет як адреса<ПредметЮнікоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_числова_негація(М, предмет як адреса<ПредметСписку>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_числова_негація(М, предмет як адреса<ПредметСловника>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_числова_негація(М, предмет як адреса<ПредметБайтів>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_числова_негація(М, предмет як адреса<ПредметБуфера>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_числова_негація(М, предмет як адреса<ПредметМодуля>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_числова_негація(М, предмет як адреса<ПредметТипу>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_числова_негація(М, предмет як адреса<ПредметПараметра>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_числова_негація(М, предмет як адреса<ПредметДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_числова_негація(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_числова_негація(М, предмет як адреса<ПредметПереборуСписку>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_числова_негація(М, предмет як адреса<ПредметПереборуТексту>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_числова_негація(М, предмет як адреса<ПредметПереборуЮнікоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_числова_негація(М, предмет як адреса<ПредметРозширення>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_числова_негація(М, предмет як адреса<ПредметПереборуБайтів>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_числова_негація(М, предмет як адреса<ПредметПереборуБуфера>, місцезнаходження);
    } інакше {
      вернути складений_предмет_числова_негація(М, предмет як адреса<СкладенийПредмет>, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_отримати_число(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути пусто; // потім: помилка
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_отримати_число(М, предмет як адреса<ПредметСтруктури>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_отримати_число(М, предмет як адреса<ПредметКоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_отримати_число(М, предмет як адреса<ПредметСередовища>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_отримати_число(М, предмет як адреса<ПредметДії>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_отримати_число(М, предмет як адреса<ПредметЛогічного>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_отримати_число(М, предмет як адреса<ПредметЧисла>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_отримати_число(М, предмет як адреса<ПредметТексту>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_отримати_число(М, предмет як адреса<ПредметЮнікоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_отримати_число(М, предмет як адреса<ПредметСписку>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_отримати_число(М, предмет як адреса<ПредметСловника>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_отримати_число(М, предмет як адреса<ПредметБайтів>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_отримати_число(М, предмет як адреса<ПредметБуфера>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_отримати_число(М, предмет як адреса<ПредметМодуля>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_отримати_число(М, предмет як адреса<ПредметТипу>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_отримати_число(М, предмет як адреса<ПредметПараметра>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_отримати_число(М, предмет як адреса<ПредметДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_отримати_число(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_отримати_число(М, предмет як адреса<ПредметПереборуСписку>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_отримати_число(М, предмет як адреса<ПредметПереборуТексту>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_отримати_число(М, предмет як адреса<ПредметПереборуЮнікоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_отримати_число(М, предмет як адреса<ПредметРозширення>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_отримати_число(М, предмет як адреса<ПредметПереборуБайтів>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_отримати_число(М, предмет як адреса<ПредметПереборуБуфера>, місцезнаходження);
    } інакше {
      вернути складений_предмет_отримати_число(М, предмет як адреса<СкладенийПредмет>, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_збільшити(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути пусто; // потім: помилка
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_збільшити(М, предмет як адреса<ПредметСтруктури>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_збільшити(М, предмет як адреса<ПредметКоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_збільшити(М, предмет як адреса<ПредметСередовища>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_збільшити(М, предмет як адреса<ПредметДії>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_збільшити(М, предмет як адреса<ПредметЛогічного>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_збільшити(М, предмет як адреса<ПредметЧисла>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_збільшити(М, предмет як адреса<ПредметТексту>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_збільшити(М, предмет як адреса<ПредметЮнікоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_збільшити(М, предмет як адреса<ПредметСписку>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_збільшити(М, предмет як адреса<ПредметСловника>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_збільшити(М, предмет як адреса<ПредметБайтів>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_збільшити(М, предмет як адреса<ПредметБуфера>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_збільшити(М, предмет як адреса<ПредметМодуля>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_збільшити(М, предмет як адреса<ПредметТипу>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_збільшити(М, предмет як адреса<ПредметПараметра>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_збільшити(М, предмет як адреса<ПредметДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_збільшити(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_збільшити(М, предмет як адреса<ПредметПереборуСписку>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_збільшити(М, предмет як адреса<ПредметПереборуТексту>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_збільшити(М, предмет як адреса<ПредметПереборуЮнікоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_збільшити(М, предмет як адреса<ПредметРозширення>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_збільшити(М, предмет як адреса<ПредметПереборуБайтів>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_збільшити(М, предмет як адреса<ПредметПереборуБуфера>, місцезнаходження);
    } інакше {
      вернути складений_предмет_збільшити(М, предмет як адреса<СкладенийПредмет>, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_зменшити(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути пусто; // потім: помилка
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_зменшити(М, предмет як адреса<ПредметСтруктури>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_зменшити(М, предмет як адреса<ПредметКоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_зменшити(М, предмет як адреса<ПредметСередовища>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_зменшити(М, предмет як адреса<ПредметДії>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_зменшити(М, предмет як адреса<ПредметЛогічного>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_зменшити(М, предмет як адреса<ПредметЧисла>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_зменшити(М, предмет як адреса<ПредметТексту>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_зменшити(М, предмет як адреса<ПредметЮнікоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_зменшити(М, предмет як адреса<ПредметСписку>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_зменшити(М, предмет як адреса<ПредметСловника>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_зменшити(М, предмет як адреса<ПредметБайтів>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_зменшити(М, предмет як адреса<ПредметБуфера>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_зменшити(М, предмет як адреса<ПредметМодуля>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_зменшити(М, предмет як адреса<ПредметТипу>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_зменшити(М, предмет як адреса<ПредметПараметра>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_зменшити(М, предмет як адреса<ПредметДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_зменшити(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_зменшити(М, предмет як адреса<ПредметПереборуСписку>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_зменшити(М, предмет як адреса<ПредметПереборуТексту>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_зменшити(М, предмет як адреса<ПредметПереборуЮнікоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_зменшити(М, предмет як адреса<ПредметРозширення>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_зменшити(М, предмет як адреса<ПредметПереборуБайтів>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_зменшити(М, предмет як адреса<ПредметПереборуБуфера>, місцезнаходження);
    } інакше {
      вернути складений_предмет_зменшити(М, предмет як адреса<СкладенийПредмет>, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_отримати_зображення(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути створити_предмет_тексту(М, "пусто") як адреса<Предмет>;
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_зображення(М, предмет як адреса<ПредметСтруктури>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_зображення(М, предмет як адреса<ПредметКоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_зображення(М, предмет як адреса<ПредметСередовища>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_зображення(М, предмет як адреса<ПредметДії>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_зображення(М, предмет як адреса<ПредметЛогічного>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_зображення(М, предмет як адреса<ПредметЧисла>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_зображення(М, предмет як адреса<ПредметТексту>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_зображення(М, предмет як адреса<ПредметЮнікоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_зображення(М, предмет як адреса<ПредметСписку>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_зображення(М, предмет як адреса<ПредметСловника>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_зображення(М, предмет як адреса<ПредметБайтів>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_зображення(М, предмет як адреса<ПредметБуфера>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_зображення(М, предмет як адреса<ПредметМодуля>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_зображення(М, предмет як адреса<ПредметТипу>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_зображення(М, предмет як адреса<ПредметПараметра>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_зображення(М, предмет як адреса<ПредметДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_зображення(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_зображення(М, предмет як адреса<ПредметПереборуСписку>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_зображення(М, предмет як адреса<ПредметПереборуТексту>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_зображення(М, предмет як адреса<ПредметПереборуЮнікоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_зображення(М, предмет як адреса<ПредметРозширення>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_зображення(М, предмет як адреса<ПредметПереборуБайтів>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_зображення(М, предмет як адреса<ПредметПереборуБуфера>, місцезнаходження);
    } інакше {
      вернути складений_предмет_отримати_зображення(М, предмет як адреса<СкладенийПредмет>, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_отримати_текст(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути створити_предмет_тексту(М, "пусто") як адреса<Предмет>;
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_текст(М, предмет як адреса<ПредметСтруктури>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_текст(М, предмет як адреса<ПредметКоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_текст(М, предмет як адреса<ПредметСередовища>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_текст(М, предмет як адреса<ПредметДії>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_текст(М, предмет як адреса<ПредметЛогічного>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_текст(М, предмет як адреса<ПредметЧисла>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_текст(М, предмет як адреса<ПредметТексту>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_текст(М, предмет як адреса<ПредметЮнікоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_текст(М, предмет як адреса<ПредметСписку>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_текст(М, предмет як адреса<ПредметСловника>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_текст(М, предмет як адреса<ПредметБайтів>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_текст(М, предмет як адреса<ПредметБуфера>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_текст(М, предмет як адреса<ПредметМодуля>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_текст(М, предмет як адреса<ПредметТипу>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_текст(М, предмет як адреса<ПредметПараметра>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_текст(М, предмет як адреса<ПредметДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_текст(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_текст(М, предмет як адреса<ПредметПереборуСписку>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_текст(М, предмет як адреса<ПредметПереборуТексту>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_текст(М, предмет як адреса<ПредметПереборуЮнікоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_текст(М, предмет як адреса<ПредметРозширення>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_текст(М, предмет як адреса<ПредметПереборуБайтів>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_текст(М, предмет як адреса<ПредметПереборуБуфера>, місцезнаходження);
    } інакше {
      вернути складений_предмет_отримати_текст(М, предмет як адреса<СкладенийПредмет>, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_отримати_юнікод(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути створити_предмет_юнікоду_з_ю8(М, ю8"пусто") як адреса<Предмет>;
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_юнікод(М, предмет як адреса<ПредметСтруктури>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_юнікод(М, предмет як адреса<ПредметКоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_юнікод(М, предмет як адреса<ПредметСередовища>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_юнікод(М, предмет як адреса<ПредметДії>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_юнікод(М, предмет як адреса<ПредметЛогічного>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_юнікод(М, предмет як адреса<ПредметЧисла>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_юнікод(М, предмет як адреса<ПредметТексту>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_юнікод(М, предмет як адреса<ПредметЮнікоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_юнікод(М, предмет як адреса<ПредметСписку>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_юнікод(М, предмет як адреса<ПредметСловника>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_юнікод(М, предмет як адреса<ПредметБайтів>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_юнікод(М, предмет як адреса<ПредметБуфера>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_юнікод(М, предмет як адреса<ПредметМодуля>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_юнікод(М, предмет як адреса<ПредметТипу>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_юнікод(М, предмет як адреса<ПредметПараметра>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_юнікод(М, предмет як адреса<ПредметДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_юнікод(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_юнікод(М, предмет як адреса<ПредметПереборуСписку>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_юнікод(М, предмет як адреса<ПредметПереборуТексту>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_юнікод(М, предмет як адреса<ПредметПереборуЮнікоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_юнікод(М, предмет як адреса<ПредметРозширення>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_юнікод(М, предмет як адреса<ПредметПереборуБайтів>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_юнікод(М, предмет як адреса<ПредметПереборуБуфера>, місцезнаходження);
    } інакше {
      вернути складений_предмет_отримати_юнікод(М, предмет як адреса<СкладенийПредмет>, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_отримати_байти(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо отримати байти з пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_отримати_байти(М, предмет як адреса<ПредметСтруктури>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_отримати_байти(М, предмет як адреса<ПредметКоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_отримати_байти(М, предмет як адреса<ПредметСередовища>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_отримати_байти(М, предмет як адреса<ПредметДії>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_отримати_байти(М, предмет як адреса<ПредметЛогічного>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_отримати_байти(М, предмет як адреса<ПредметЧисла>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_отримати_байти(М, предмет як адреса<ПредметТексту>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_отримати_байти(М, предмет як адреса<ПредметЮнікоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_отримати_байти(М, предмет як адреса<ПредметСписку>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_отримати_байти(М, предмет як адреса<ПредметСловника>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_отримати_байти(М, предмет як адреса<ПредметБайтів>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_отримати_байти(М, предмет як адреса<ПредметБуфера>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_отримати_байти(М, предмет як адреса<ПредметМодуля>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_отримати_байти(М, предмет як адреса<ПредметТипу>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_отримати_байти(М, предмет як адреса<ПредметПараметра>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_отримати_байти(М, предмет як адреса<ПредметДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_отримати_байти(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_отримати_байти(М, предмет як адреса<ПредметПереборуСписку>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_отримати_байти(М, предмет як адреса<ПредметПереборуТексту>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_отримати_байти(М, предмет як адреса<ПредметПереборуЮнікоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_отримати_байти(М, предмет як адреса<ПредметРозширення>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_отримати_байти(М, предмет як адреса<ПредметПереборуБайтів>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_отримати_байти(М, предмет як адреса<ПредметПереборуБуфера>, місцезнаходження);
    } інакше {
      вернути складений_предмет_отримати_байти(М, предмет як адреса<СкладенийПредмет>, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_отримати_перебір(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо отримати перебір з пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_отримати_перебір(М, предмет як адреса<ПредметСтруктури>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_отримати_перебір(М, предмет як адреса<ПредметКоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_отримати_перебір(М, предмет як адреса<ПредметСередовища>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_отримати_перебір(М, предмет як адреса<ПредметДії>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_отримати_перебір(М, предмет як адреса<ПредметЛогічного>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_отримати_перебір(М, предмет як адреса<ПредметЧисла>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_отримати_перебір(М, предмет як адреса<ПредметТексту>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_отримати_перебір(М, предмет як адреса<ПредметЮнікоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_отримати_перебір(М, предмет як адреса<ПредметСписку>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_отримати_перебір(М, предмет як адреса<ПредметСловника>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_отримати_перебір(М, предмет як адреса<ПредметБайтів>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_отримати_перебір(М, предмет як адреса<ПредметБуфера>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_отримати_перебір(М, предмет як адреса<ПредметМодуля>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_отримати_перебір(М, предмет як адреса<ПредметТипу>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_отримати_перебір(М, предмет як адреса<ПредметПараметра>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_отримати_перебір(М, предмет як адреса<ПредметДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_отримати_перебір(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_отримати_перебір(М, предмет як адреса<ПредметПереборуСписку>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_отримати_перебір(М, предмет як адреса<ПредметПереборуТексту>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_отримати_перебір(М, предмет як адреса<ПредметПереборуЮнікоду>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_отримати_перебір(М, предмет як адреса<ПредметРозширення>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_отримати_перебір(М, предмет як адреса<ПредметПереборуБайтів>, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_отримати_перебір(М, предмет як адреса<ПредметПереборуБуфера>, місцезнаходження);
    } інакше {
      вернути складений_предмет_отримати_перебір(М, предмет як адреса<СкладенийПредмет>, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_отримати_діапазон(М: адреса<Машина>, предмет: адреса<Предмет>, включно: логічне, до: адреса<Предмет>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо отримати діапазон для пусто") як адреса<Предмет>);
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вернути предмет_структури_отримати_діапазон(М, предмет як адреса<ПредметСтруктури>, включно, до, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вернути предмет_коду_отримати_діапазон(М, предмет як адреса<ПредметКоду>, включно, до, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вернути предмет_середовища_отримати_діапазон(М, предмет як адреса<ПредметСередовища>, включно, до, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вернути предмет_дії_отримати_діапазон(М, предмет як адреса<ПредметДії>, включно, до, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      вернути предмет_логічного_отримати_діапазон(М, предмет як адреса<ПредметЛогічного>, включно, до, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_число {
      вернути предмет_числа_отримати_діапазон(М, предмет як адреса<ПредметЧисла>, включно, до, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      вернути предмет_тексту_отримати_діапазон(М, предмет як адреса<ПредметТексту>, включно, до, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_юнікод {
      вернути предмет_юнікоду_отримати_діапазон(М, предмет як адреса<ПредметЮнікоду>, включно, до, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_список {
      вернути предмет_списку_отримати_діапазон(М, предмет як адреса<ПредметСписку>, включно, до, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вернути предмет_словника_отримати_діапазон(М, предмет як адреса<ПредметСловника>, включно, до, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вернути предмет_байтів_отримати_діапазон(М, предмет як адреса<ПредметБайтів>, включно, до, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вернути предмет_буфера_отримати_діапазон(М, предмет як адреса<ПредметБуфера>, включно, до, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вернути предмет_модуля_отримати_діапазон(М, предмет як адреса<ПредметМодуля>, включно, до, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вернути предмет_типу_отримати_діапазон(М, предмет як адреса<ПредметТипу>, включно, до, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вернути предмет_параметра_отримати_діапазон(М, предмет як адреса<ПредметПараметра>, включно, до, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_отримати_діапазон(М, предмет як адреса<ПредметДіапазонуЧисел>, включно, до, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_отримати_діапазон(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, включно, до, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_отримати_діапазон(М, предмет як адреса<ПредметПереборуСписку>, включно, до, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_отримати_діапазон(М, предмет як адреса<ПредметПереборуТексту>, включно, до, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірЮнікоду {
      вернути предмет_перебору_юнікоду_отримати_діапазон(М, предмет як адреса<ПредметПереборуЮнікоду>, включно, до, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вернути предмет_розширення_отримати_діапазон(М, предмет як адреса<ПредметРозширення>, включно, до, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_отримати_діапазон(М, предмет як адреса<ПредметПереборуБайтів>, включно, до, місцезнаходження);
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_отримати_діапазон(М, предмет як адреса<ПредметПереборуБуфера>, включно, до, місцезнаходження);
    } інакше {
      вернути складений_предмет_отримати_діапазон(М, предмет як адреса<СкладенийПредмет>, включно, до, місцезнаходження);
    }
  }
}