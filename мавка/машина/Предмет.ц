взяти визначення мавка;

зовнішня дія мавка_система_перевірити_чи_р64_невизначеність(значення: р64) -> логічне;

секція мавка {
  місцева дія предмет_отримати_користувацькі_дані(М: адреса<Машина>, предмет: адреса<Предмет>) -> адреса<КористувацькіДані> {
    вернути предмет.користувацькі_дані;
  }

  місцева дія предмет_отримати_дані_користувацьких_даних(М: адреса<Машина>, предмет: адреса<Предмет>) -> невідома_адреса {
    якщо предмет.користувацькі_дані == пусто {
      вернути пусто;
    }
    вернути предмет.користувацькі_дані.дані;
  }

  місцева дія предмет_змінити_користувацькі_дані(М: адреса<Машина>, предмет: адреса<Предмет>, користувацькі_дані: адреса<КористувацькіДані>) {
    предмет.користувацькі_дані = користувацькі_дані;
  }

  місцева дія предмет_видалити_користувацькі_дані(М: адреса<Машина>, предмет: адреса<Предмет>) {
    якщо предмет.користувацькі_дані != пусто {
      знищити_користувацькі_дані(М, предмет.користувацькі_дані);
      предмет.користувацькі_дані = пусто;
    }
  }

  місцева дія створити_користувацькі_дані(М: адреса<Машина>, дані: невідома_адреса, дія_перед_знищенням: ДіяПередЗнищеннямКористувацькихДаних, дія_клонування: ДіяКлонуванняКористувацькихДаних) -> адреса<КористувацькіДані> {
    змінна користувацькі_дані = виділити<КористувацькіДані>(М);
    користувацькі_дані.дані = дані;
    користувацькі_дані.дія_перед_знищенням = дія_перед_знищенням;
    користувацькі_дані.дія_клонування = дія_клонування;
    вернути користувацькі_дані;
  }

  місцева дія знищити_користувацькі_дані(М: адреса<Машина>, користувацькі_дані: адреса<КористувацькіДані>) {
    якщо користувацькі_дані.дія_перед_знищенням != пусто {
      користувацькі_дані.дія_перед_знищенням(М, користувацькі_дані);
    }
    звільнити(М, користувацькі_дані);
  }

  дія предмет_виконати_метод_чародія_зображення(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    змінна накопичувач_т8 = зробити_накопичувач<н8>(М);
    покласти_в_накопичувач_т8(М, накопичувач_т8::адреса, "<предмет");
    якщо предмет.с != пусто {
      якщо предмет.с != М.предмет_структури_предмет {
        якщо предмет.с.назва != пусто {
          покласти_в_накопичувач_т8(М, накопичувач_т8::адреса, " ");
          покласти_в_накопичувач_т8(М, накопичувач_т8::адреса, предмет.с.назва.значення);
        }
      }
    }
    покласти_в_накопичувач_т8(М, накопичувач_т8::адреса, ">");
    змінна предмет_тексту = створити_предмет_тексту(М, т8 { накопичувач_т8.розмір, накопичувач_т8.дані });
    звільнити_памʼять(М, накопичувач_т8.дані);
    вернути предмет_тексту як адреса<Предмет>;
  }

  дія предмет_виконати_метод_чародія_текст(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    змінна накопичувач_т8 = зробити_накопичувач<н8>(М);
    покласти_в_накопичувач_т8(М, накопичувач_т8::адреса, "<предмет");
    якщо предмет.с != пусто {
      якщо предмет.с != М.предмет_структури_предмет {
        якщо предмет.с.назва != пусто {
          покласти_в_накопичувач_т8(М, накопичувач_т8::адреса, " ");
          покласти_в_накопичувач_т8(М, накопичувач_т8::адреса, предмет.с.назва.значення);
        }
      }
    }
    покласти_в_накопичувач_т8(М, накопичувач_т8::адреса, ">");
    змінна предмет_тексту = створити_предмет_тексту(М, т8 { накопичувач_т8.розмір, накопичувач_т8.дані });
    звільнити_памʼять(М, накопичувач_т8.дані);
    вернути предмет_тексту як адреса<Предмет>;
  }
}

секція мавка {
  дія рідна_дія_метода_чародія_зображення(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: натуральне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>) -> ПредметАбоСтанПадіння<Предмет> {
    змінна предмет = предмет_я як адреса<Предмет>;
    вернути предмет_виконати_метод_чародія_зображення(М, предмет, Місцезнаходження { пусто як адреса<ПредметБайтів>, 0 });
  }

  дія записати_метод_структури_предмет_чародія_зображення(М: адреса<Машина>) {
    змінна предмет_дії_метода_чародія_зображення = створити_предмет_рідної_дії(М, створити_назву(М, "чародія_зображення"), 0, пусто, рідна_дія_метода_чародія_зображення, пусто, пусто, пусто);
    предмет_структури_записати_метод(М, М.предмет_структури_предмет, створити_назву(М, "чародія_зображення"), предмет_дії_метода_чародія_зображення);
  }

  дія рідна_дія_метода_чародія_текст(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: натуральне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>) -> ПредметАбоСтанПадіння<Предмет> {
    змінна предмет = предмет_я як адреса<Предмет>;
    вернути предмет_виконати_метод_чародія_текст(М, предмет, Місцезнаходження { пусто як адреса<ПредметБайтів>, 0 });
  }

  дія записати_метод_структури_предмет_чародія_текст(М: адреса<Машина>) {
    змінна предмет_дії_метода_чародія_текст = створити_предмет_рідної_дії(М, створити_назву(М, "чародія_текст"), 0, пусто, рідна_дія_метода_чародія_текст, пусто, пусто, пусто);
    предмет_структури_записати_метод(М, М.предмет_структури_предмет, створити_назву(М, "чародія_текст"), предмет_дії_метода_чародія_текст);
  }

  місцева дія заповнити_предмет_структури_предмет(М: адреса<Машина>) {
    записати_метод_структури_предмет_чародія_зображення(М);
    записати_метод_структури_предмет_чародія_текст(М);
  }
}

секція мавка {
  місцева дія перевірити_чи_предмети_назви_рівні(М: адреса<Машина>, а: адреса<ПредметТексту>, б: адреса<ПредметТексту>): логічне {
    якщо а == б {
      вернути так;
    }
    вернути перевірити_чи_т8_рівні(а.значення, б.значення);
  }

  дія перевірити_чи_предмети_логічного_рівні(М: адреса<Машина>, а: адреса<ПредметЛогічного>, б: адреса<ПредметЛогічного>): логічне {
    вернути а.значення == б.значення;
  }

  дія перевірити_чи_предмети_числа_рівні(М: адреса<Машина>, а: адреса<ПредметЧисла>, б: адреса<ПредметЧисла>): логічне {
    якщо мавка_система_перевірити_чи_р64_невизначеність(а.значення) або мавка_система_перевірити_чи_р64_невизначеність(б.значення) {
      вернути ні;
    }
    вернути а.значення == б.значення;
  }

  дія перевірити_чи_предмети_тексту_рівні(М: адреса<Машина>, а: адреса<ПредметТексту>, б: адреса<ПредметТексту>): логічне {
    вернути перевірити_чи_т8_рівні(а.значення, б.значення);
  }

  місцева дія перевірити_чи_предмети_рівні(М: адреса<Машина>, а: адреса<Предмет>, б: адреса<Предмет>): логічне {
    якщо а == б {
      якщо а.с == М.предмет_структури_число {
        якщо б.с == М.предмет_структури_число {
          змінна ач = а як адреса<ПредметЧисла>;
          змінна бч = б як адреса<ПредметЧисла>;
          
          якщо мавка_система_перевірити_чи_р64_невизначеність(ач.значення) або мавка_система_перевірити_чи_р64_невизначеність(бч.значення) {
            вернути ні;
          }
        }
      }
      вернути так;
    }
    якщо а == пусто {
      вернути ні;
    }
    якщо б == пусто {
      вернути ні;
    }
    якщо а.с == М.предмет_структури_логічне {
      якщо б.с == М.предмет_структури_логічне {
        вернути перевірити_чи_предмети_логічного_рівні(М, а як адреса<ПредметЛогічного>, б як адреса<ПредметЛогічного>);
      }
    } інакше якщо а.с == М.предмет_структури_число {
      якщо б.с == М.предмет_структури_число {
        вернути перевірити_чи_предмети_числа_рівні(М, а як адреса<ПредметЧисла>, б як адреса<ПредметЧисла>);
      }
    } інакше якщо а.с == М.предмет_структури_текст {
      якщо б.с == М.предмет_структури_текст {
        вернути перевірити_чи_предмети_тексту_рівні(М, а як адреса<ПредметТексту>, б як адреса<ПредметТексту>);
      }
    }
    вернути ні;
  }

  місцева дія перевірити_чи_значення_предметів_байтів_рівні(М: адреса<Машина>, а: адреса<ПредметБайтів>, б: адреса<ПредметБайтів>) -> логічне {
    змінна п: натуральне = 0;

    якщо а.розмір != б.розмір {
      вернути ні;
    }
    
    поки п < а.розмір {
      якщо а.дані[п] != б.дані[п] {
        вернути ні;
      }

      п += 1;
    }

    вернути так;
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_отримати_властивість(М: адреса<Машина>, предмет: адреса<Предмет>, назва: адреса<ПредметТексту>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо отримати властивість пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_отримати_властивість(М, предмет як адреса<ПредметСтруктури>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_отримати_властивість(М, предмет як адреса<ПредметКоду>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_отримати_властивість(М, предмет як адреса<ПредметСередовища>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_отримати_властивість(М, предмет як адреса<ПредметДії>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_отримати_властивість(М, предмет як адреса<ПредметЛогічного>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_отримати_властивість(М, предмет як адреса<ПредметЧисла>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_отримати_властивість(М, предмет як адреса<ПредметТексту>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_отримати_властивість(М, предмет як адреса<ПредметСписку>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_отримати_властивість(М, предмет як адреса<ПредметПослідовності>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_отримати_властивість(М, предмет як адреса<ПредметСловника>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_отримати_властивість(М, предмет як адреса<ПредметБайтів>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_отримати_властивість(М, предмет як адреса<ПредметБуфера>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_отримати_властивість(М, предмет як адреса<ПредметМодуля>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_отримати_властивість(М, предмет як адреса<ПредметПараметра>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_отримати_властивість(М, предмет як адреса<ПредметДіапазонуЧисел>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_отримати_властивість(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_отримати_властивість(М, предмет як адреса<ПредметПереборуСписку>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_отримати_властивість(М, предмет як адреса<ПредметПереборуПослідовності>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_отримати_властивість(М, предмет як адреса<ПредметПереборуТексту>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_отримати_властивість(М, предмет як адреса<ПредметПереборуБайтів>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_отримати_властивість(М, предмет як адреса<ПредметПереборуБуфера>, назва, місцезнаходження);
    } інакше {
      вернути складений_предмет_отримати_властивість(М, предмет як адреса<СкладенийПредмет>, назва, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_змінити_властивість(М: адреса<Машина>, предмет: адреса<Предмет>, назва: адреса<ПредметТексту>, значення: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо змінити властивість пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_змінити_властивість(М, предмет як адреса<ПредметСтруктури>, назва, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_змінити_властивість(М, предмет як адреса<ПредметКоду>, назва, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_змінити_властивість(М, предмет як адреса<ПредметСередовища>, назва, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_змінити_властивість(М, предмет як адреса<ПредметДії>, назва, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_змінити_властивість(М, предмет як адреса<ПредметЛогічного>, назва, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_змінити_властивість(М, предмет як адреса<ПредметЧисла>, назва, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_змінити_властивість(М, предмет як адреса<ПредметТексту>, назва, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_змінити_властивість(М, предмет як адреса<ПредметСписку>, назва, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_змінити_властивість(М, предмет як адреса<ПредметПослідовності>, назва, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_змінити_властивість(М, предмет як адреса<ПредметСловника>, назва, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_змінити_властивість(М, предмет як адреса<ПредметБайтів>, назва, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_змінити_властивість(М, предмет як адреса<ПредметБуфера>, назва, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_змінити_властивість(М, предмет як адреса<ПредметМодуля>, назва, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_змінити_властивість(М, предмет як адреса<ПредметПараметра>, назва, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_змінити_властивість(М, предмет як адреса<ПредметДіапазонуЧисел>, назва, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_змінити_властивість(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, назва, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_змінити_властивість(М, предмет як адреса<ПредметПереборуСписку>, назва, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_змінити_властивість(М, предмет як адреса<ПредметПереборуПослідовності>, назва, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_змінити_властивість(М, предмет як адреса<ПредметПереборуТексту>, назва, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_змінити_властивість(М, предмет як адреса<ПредметПереборуБайтів>, назва, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_змінити_властивість(М, предмет як адреса<ПредметПереборуБуфера>, назва, значення, місцезнаходження);
    } інакше {
      вернути складений_предмет_змінити_властивість(М, предмет як адреса<СкладенийПредмет>, назва, значення, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_видалити_властивість(М: адреса<Машина>, предмет: адреса<Предмет>, назва: адреса<ПредметТексту>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо отримати властивість пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_видалити_властивість(М, предмет як адреса<ПредметСтруктури>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_видалити_властивість(М, предмет як адреса<ПредметКоду>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_видалити_властивість(М, предмет як адреса<ПредметСередовища>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_видалити_властивість(М, предмет як адреса<ПредметДії>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_видалити_властивість(М, предмет як адреса<ПредметЛогічного>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_видалити_властивість(М, предмет як адреса<ПредметЧисла>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_видалити_властивість(М, предмет як адреса<ПредметТексту>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_видалити_властивість(М, предмет як адреса<ПредметСписку>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_видалити_властивість(М, предмет як адреса<ПредметПослідовності>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_видалити_властивість(М, предмет як адреса<ПредметСловника>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_видалити_властивість(М, предмет як адреса<ПредметБайтів>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_видалити_властивість(М, предмет як адреса<ПредметБуфера>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_видалити_властивість(М, предмет як адреса<ПредметМодуля>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_видалити_властивість(М, предмет як адреса<ПредметПараметра>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_видалити_властивість(М, предмет як адреса<ПредметДіапазонуЧисел>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_видалити_властивість(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_видалити_властивість(М, предмет як адреса<ПредметПереборуСписку>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_видалити_властивість(М, предмет як адреса<ПредметПереборуПослідовності>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_видалити_властивість(М, предмет як адреса<ПредметПереборуТексту>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_видалити_властивість(М, предмет як адреса<ПредметПереборуБайтів>, назва, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_видалити_властивість(М, предмет як адреса<ПредметПереборуБуфера>, назва, місцезнаходження);
    } інакше {
      вернути складений_предмет_видалити_властивість(М, предмет як адреса<СкладенийПредмет>, назва, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_виконати_властивість(М: адреса<Машина>, предмет: адреса<Предмет>, назва: адреса<ПредметТексту>, кількість_аргументів: натуральне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо виконати властивість пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_виконати_властивість(М, предмет як адреса<ПредметСтруктури>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_виконати_властивість(М, предмет як адреса<ПредметКоду>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_виконати_властивість(М, предмет як адреса<ПредметСередовища>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_виконати_властивість(М, предмет як адреса<ПредметДії>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_виконати_властивість(М, предмет як адреса<ПредметЛогічного>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_виконати_властивість(М, предмет як адреса<ПредметЧисла>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_виконати_властивість(М, предмет як адреса<ПредметТексту>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_виконати_властивість(М, предмет як адреса<ПредметСписку>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_виконати_властивість(М, предмет як адреса<ПредметПослідовності>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_виконати_властивість(М, предмет як адреса<ПредметСловника>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_виконати_властивість(М, предмет як адреса<ПредметБайтів>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_виконати_властивість(М, предмет як адреса<ПредметБуфера>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_виконати_властивість(М, предмет як адреса<ПредметМодуля>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_виконати_властивість(М, предмет як адреса<ПредметПараметра>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_виконати_властивість(М, предмет як адреса<ПредметДіапазонуЧисел>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_виконати_властивість(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_виконати_властивість(М, предмет як адреса<ПредметПереборуСписку>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_виконати_властивість(М, предмет як адреса<ПредметПереборуПослідовності>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_виконати_властивість(М, предмет як адреса<ПредметПереборуТексту>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_виконати_властивість(М, предмет як адреса<ПредметПереборуБайтів>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_виконати_властивість(М, предмет як адреса<ПредметПереборуБуфера>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше {
      вернути складений_предмет_виконати_властивість(М, предмет як адреса<СкладенийПредмет>, назва, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_виконати(М: адреса<Машина>, предмет: адреса<Предмет>, предмет_я: адреса<Предмет>, кількість_аргументів: натуральне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо виконати пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_виконати(М, предмет як адреса<ПредметСтруктури>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_виконати(М, предмет як адреса<ПредметКоду>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_виконати(М, предмет як адреса<ПредметСередовища>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_виконати(М, предмет як адреса<ПредметДії>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_виконати(М, предмет як адреса<ПредметЛогічного>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_виконати(М, предмет як адреса<ПредметЧисла>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_виконати(М, предмет як адреса<ПредметТексту>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_виконати(М, предмет як адреса<ПредметСписку>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_виконати(М, предмет як адреса<ПредметПослідовності>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_виконати(М, предмет як адреса<ПредметСловника>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_виконати(М, предмет як адреса<ПредметБайтів>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_виконати(М, предмет як адреса<ПредметБуфера>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_виконати(М, предмет як адреса<ПредметМодуля>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_виконати(М, предмет як адреса<ПредметПараметра>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_виконати(М, предмет як адреса<ПредметДіапазонуЧисел>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_виконати(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_виконати(М, предмет як адреса<ПредметПереборуСписку>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_виконати(М, предмет як адреса<ПредметПереборуПослідовності>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_виконати(М, предмет як адреса<ПредметПереборуТексту>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_виконати(М, предмет як адреса<ПредметПереборуБайтів>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_виконати(М, предмет як адреса<ПредметПереборуБуфера>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    } інакше {
      вернути складений_предмет_виконати(М, предмет як адреса<СкладенийПредмет>, предмет_я, кількість_аргументів, аргументи, іменовані_аргументи, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_отримати_елемент(М: адреса<Машина>, предмет: адреса<Предмет>, ключ: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо отримати елемент з пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_отримати_елемент(М, предмет як адреса<ПредметСтруктури>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_отримати_елемент(М, предмет як адреса<ПредметКоду>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_отримати_елемент(М, предмет як адреса<ПредметСередовища>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_отримати_елемент(М, предмет як адреса<ПредметДії>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_отримати_елемент(М, предмет як адреса<ПредметЛогічного>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_отримати_елемент(М, предмет як адреса<ПредметЧисла>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_отримати_елемент(М, предмет як адреса<ПредметТексту>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_отримати_елемент(М, предмет як адреса<ПредметСписку>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_отримати_елемент(М, предмет як адреса<ПредметПослідовності>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_отримати_елемент(М, предмет як адреса<ПредметСловника>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_отримати_елемент(М, предмет як адреса<ПредметБайтів>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_отримати_елемент(М, предмет як адреса<ПредметБуфера>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_отримати_елемент(М, предмет як адреса<ПредметМодуля>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_отримати_елемент(М, предмет як адреса<ПредметПараметра>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_отримати_елемент(М, предмет як адреса<ПредметДіапазонуЧисел>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_отримати_елемент(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_отримати_елемент(М, предмет як адреса<ПредметПереборуСписку>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_отримати_елемент(М, предмет як адреса<ПредметПереборуПослідовності>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_отримати_елемент(М, предмет як адреса<ПредметПереборуТексту>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_отримати_елемент(М, предмет як адреса<ПредметПереборуБайтів>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_отримати_елемент(М, предмет як адреса<ПредметПереборуБуфера>, ключ, місцезнаходження);
    } інакше {
      вернути складений_предмет_отримати_елемент(М, предмет як адреса<СкладенийПредмет>, ключ, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_змінити_елемент(М: адреса<Машина>, предмет: адреса<Предмет>, ключ: адреса<Предмет>, значення: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо змінити елемент в пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_змінити_елемент(М, предмет як адреса<ПредметСтруктури>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_змінити_елемент(М, предмет як адреса<ПредметКоду>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_змінити_елемент(М, предмет як адреса<ПредметСередовища>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_змінити_елемент(М, предмет як адреса<ПредметДії>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_змінити_елемент(М, предмет як адреса<ПредметЛогічного>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_змінити_елемент(М, предмет як адреса<ПредметЧисла>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_змінити_елемент(М, предмет як адреса<ПредметТексту>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_змінити_елемент(М, предмет як адреса<ПредметСписку>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_змінити_елемент(М, предмет як адреса<ПредметПослідовності>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_змінити_елемент(М, предмет як адреса<ПредметСловника>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_змінити_елемент(М, предмет як адреса<ПредметБайтів>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_змінити_елемент(М, предмет як адреса<ПредметБуфера>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_змінити_елемент(М, предмет як адреса<ПредметМодуля>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_змінити_елемент(М, предмет як адреса<ПредметПараметра>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_змінити_елемент(М, предмет як адреса<ПредметДіапазонуЧисел>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_змінити_елемент(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_змінити_елемент(М, предмет як адреса<ПредметПереборуСписку>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_змінити_елемент(М, предмет як адреса<ПредметПереборуПослідовності>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_змінити_елемент(М, предмет як адреса<ПредметПереборуТексту>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_змінити_елемент(М, предмет як адреса<ПредметПереборуБайтів>, ключ, значення, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_змінити_елемент(М, предмет як адреса<ПредметПереборуБуфера>, ключ, значення, місцезнаходження);
    } інакше {
      вернути складений_предмет_змінити_елемент(М, предмет як адреса<СкладенийПредмет>, ключ, значення, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_видалити_елемент(М: адреса<Машина>, предмет: адреса<Предмет>, ключ: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо отримати елемент з пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_видалити_елемент(М, предмет як адреса<ПредметСтруктури>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_видалити_елемент(М, предмет як адреса<ПредметКоду>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_видалити_елемент(М, предмет як адреса<ПредметСередовища>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_видалити_елемент(М, предмет як адреса<ПредметДії>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_видалити_елемент(М, предмет як адреса<ПредметЛогічного>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_видалити_елемент(М, предмет як адреса<ПредметЧисла>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_видалити_елемент(М, предмет як адреса<ПредметТексту>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_видалити_елемент(М, предмет як адреса<ПредметСписку>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_видалити_елемент(М, предмет як адреса<ПредметПослідовності>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_видалити_елемент(М, предмет як адреса<ПредметСловника>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_видалити_елемент(М, предмет як адреса<ПредметБайтів>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_видалити_елемент(М, предмет як адреса<ПредметБуфера>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_видалити_елемент(М, предмет як адреса<ПредметМодуля>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_видалити_елемент(М, предмет як адреса<ПредметПараметра>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_видалити_елемент(М, предмет як адреса<ПредметДіапазонуЧисел>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_видалити_елемент(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_видалити_елемент(М, предмет як адреса<ПредметПереборуСписку>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_видалити_елемент(М, предмет як адреса<ПредметПереборуПослідовності>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_видалити_елемент(М, предмет як адреса<ПредметПереборуТексту>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_видалити_елемент(М, предмет як адреса<ПредметПереборуБайтів>, ключ, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_видалити_елемент(М, предмет як адреса<ПредметПереборуБуфера>, ключ, місцезнаходження);
    } інакше {
      вернути складений_предмет_видалити_елемент(М, предмет як адреса<СкладенийПредмет>, ключ, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_додати(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо додати до пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_додати(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_додати(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_додати(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_додати(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_додати(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_додати(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_додати(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_додати(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_додати(М, предмет як адреса<ПредметПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_додати(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_додати(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_додати(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_додати(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_додати(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_додати(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_додати(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_додати(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_додати(М, предмет як адреса<ПредметПереборуПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_додати(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_додати(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_додати(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_додати(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_відняти(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо відняти до пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_відняти(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_відняти(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_відняти(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_відняти(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_відняти(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_відняти(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_відняти(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_відняти(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_відняти(М, предмет як адреса<ПредметПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_відняти(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_відняти(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_відняти(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_відняти(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_відняти(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_відняти(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_відняти(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_відняти(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_відняти(М, предмет як адреса<ПредметПереборуПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_відняти(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_відняти(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_відняти(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_відняти(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_помножити(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо помножити до пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_помножити(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_помножити(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_помножити(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_помножити(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_помножити(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_помножити(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_помножити(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_помножити(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_помножити(М, предмет як адреса<ПредметПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_помножити(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_помножити(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_помножити(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_помножити(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_помножити(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_помножити(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_помножити(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_помножити(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_помножити(М, предмет як адреса<ПредметПереборуПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_помножити(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_помножити(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_помножити(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_помножити(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_поділити(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо поділити до пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_поділити(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_поділити(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_поділити(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_поділити(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_поділити(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_поділити(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_поділити(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_поділити(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_поділити(М, предмет як адреса<ПредметПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_поділити(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_поділити(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_поділити(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_поділити(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_поділити(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_поділити(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_поділити(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_поділити(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_поділити(М, предмет як адреса<ПредметПереборуПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_поділити(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_поділити(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_поділити(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_поділити(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_остача(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо остача до пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_остача(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_остача(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_остача(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_остача(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_остача(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_остача(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_остача(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_остача(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_остача(М, предмет як адреса<ПредметПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_остача(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_остача(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_остача(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_остача(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_остача(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_остача(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_остача(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_остача(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_остача(М, предмет як адреса<ПредметПереборуПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_остача(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_остача(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_остача(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_остача(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_неповна_частка(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо частка до пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_неповна_частка(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_неповна_частка(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_неповна_частка(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_неповна_частка(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_неповна_частка(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_неповна_частка(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_неповна_частка(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_неповна_частка(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_неповна_частка(М, предмет як адреса<ПредметПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_неповна_частка(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_неповна_частка(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_неповна_частка(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_неповна_частка(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_неповна_частка(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_неповна_частка(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_неповна_частка(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_неповна_частка(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_неповна_частка(М, предмет як адреса<ПредметПереборуПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_неповна_частка(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_неповна_частка(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_неповна_частка(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_неповна_частка(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_степінь(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо степінь до пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_степінь(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_степінь(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_степінь(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_степінь(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_степінь(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_степінь(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_степінь(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_степінь(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_степінь(М, предмет як адреса<ПредметПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_степінь(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_степінь(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_степінь(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_степінь(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_степінь(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_степінь(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_степінь(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_степінь(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_степінь(М, предмет як адреса<ПредметПереборуПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_степінь(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_степінь(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_степінь(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_степінь(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_зсунути_вліво(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо зсунути_вліво до пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_зсунути_вліво(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_зсунути_вліво(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_зсунути_вліво(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_зсунути_вліво(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_зсунути_вліво(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_зсунути_вліво(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_зсунути_вліво(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_зсунути_вліво(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_зсунути_вліво(М, предмет як адреса<ПредметПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_зсунути_вліво(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_зсунути_вліво(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_зсунути_вліво(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_зсунути_вліво(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_зсунути_вліво(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_зсунути_вліво(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_зсунути_вліво(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_зсунути_вліво(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_зсунути_вліво(М, предмет як адреса<ПредметПереборуПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_зсунути_вліво(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_зсунути_вліво(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_зсунути_вліво(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_зсунути_вліво(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_зсунути_вправо(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо зсунути_вправо до пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_зсунути_вправо(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_зсунути_вправо(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_зсунути_вправо(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_зсунути_вправо(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_зсунути_вправо(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_зсунути_вправо(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_зсунути_вправо(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_зсунути_вправо(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_зсунути_вправо(М, предмет як адреса<ПредметПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_зсунути_вправо(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_зсунути_вправо(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_зсунути_вправо(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_зсунути_вправо(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_зсунути_вправо(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_зсунути_вправо(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_зсунути_вправо(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_зсунути_вправо(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_зсунути_вправо(М, предмет як адреса<ПредметПереборуПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_зсунути_вправо(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_зсунути_вправо(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_зсунути_вправо(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_зсунути_вправо(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_зсунути_вправо_2(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо беззнаковий_зсув_вправо до пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_зсунути_вправо_2(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_зсунути_вправо_2(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_зсунути_вправо_2(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_зсунути_вправо_2(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_зсунути_вправо_2(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_зсунути_вправо_2(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_зсунути_вправо_2(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_зсунути_вправо_2(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_зсунути_вправо_2(М, предмет як адреса<ПредметПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_зсунути_вправо_2(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_зсунути_вправо_2(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_зсунути_вправо_2(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_зсунути_вправо_2(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_зсунути_вправо_2(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_зсунути_вправо_2(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_зсунути_вправо_2(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_зсунути_вправо_2(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_зсунути_вправо_2(М, предмет як адреса<ПредметПереборуПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_зсунути_вправо_2(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_зсунути_вправо_2(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_зсунути_вправо_2(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_зсунути_вправо_2(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_двійкове_і(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо двійкове_і до пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_двійкове_і(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_двійкове_і(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_двійкове_і(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_двійкове_і(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_двійкове_і(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_двійкове_і(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_двійкове_і(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_двійкове_і(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_двійкове_і(М, предмет як адреса<ПредметПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_двійкове_і(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_двійкове_і(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_двійкове_і(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_двійкове_і(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_двійкове_і(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_двійкове_і(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_двійкове_і(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_двійкове_і(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_двійкове_і(М, предмет як адреса<ПредметПереборуПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_двійкове_і(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_двійкове_і(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_двійкове_і(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_двійкове_і(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_двійкове_або(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо двійкове_або до пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_двійкове_або(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_двійкове_або(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_двійкове_або(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_двійкове_або(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_двійкове_або(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_двійкове_або(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_двійкове_або(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_двійкове_або(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_двійкове_або(М, предмет як адреса<ПредметПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_двійкове_або(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_двійкове_або(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_двійкове_або(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_двійкове_або(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_двійкове_або(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_двійкове_або(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_двійкове_або(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_двійкове_або(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_двійкове_або(М, предмет як адреса<ПредметПереборуПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_двійкове_або(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_двійкове_або(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_двійкове_або(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_двійкове_або(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_двійкове_виключне_або(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо двійкове_виключне_або до пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_двійкове_виключне_або(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_двійкове_виключне_або(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_двійкове_виключне_або(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_двійкове_виключне_або(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_двійкове_виключне_або(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_двійкове_виключне_або(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_двійкове_виключне_або(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_двійкове_виключне_або(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_двійкове_виключне_або(М, предмет як адреса<ПредметПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_двійкове_виключне_або(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_двійкове_виключне_або(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_двійкове_виключне_або(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_двійкове_виключне_або(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_двійкове_виключне_або(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_двійкове_виключне_або(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_двійкове_виключне_або(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_двійкове_виключне_або(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_двійкове_виключне_або(М, предмет як адреса<ПредметПереборуПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_двійкове_виключне_або(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_двійкове_виключне_або(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_двійкове_виключне_або(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_двійкове_виключне_або(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_двійкове_заперечення(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо двійкове_заперечення до пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_двійкове_заперечення(М, предмет як адреса<ПредметСтруктури>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_двійкове_заперечення(М, предмет як адреса<ПредметКоду>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_двійкове_заперечення(М, предмет як адреса<ПредметСередовища>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_двійкове_заперечення(М, предмет як адреса<ПредметДії>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_двійкове_заперечення(М, предмет як адреса<ПредметЛогічного>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_двійкове_заперечення(М, предмет як адреса<ПредметЧисла>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_двійкове_заперечення(М, предмет як адреса<ПредметТексту>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_двійкове_заперечення(М, предмет як адреса<ПредметСписку>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_двійкове_заперечення(М, предмет як адреса<ПредметПослідовності>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_двійкове_заперечення(М, предмет як адреса<ПредметСловника>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_двійкове_заперечення(М, предмет як адреса<ПредметБайтів>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_двійкове_заперечення(М, предмет як адреса<ПредметБуфера>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_двійкове_заперечення(М, предмет як адреса<ПредметМодуля>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_двійкове_заперечення(М, предмет як адреса<ПредметПараметра>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_двійкове_заперечення(М, предмет як адреса<ПредметДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_двійкове_заперечення(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_двійкове_заперечення(М, предмет як адреса<ПредметПереборуСписку>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_двійкове_заперечення(М, предмет як адреса<ПредметПереборуПослідовності>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_двійкове_заперечення(М, предмет як адреса<ПредметПереборуТексту>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_двійкове_заперечення(М, предмет як адреса<ПредметПереборуБайтів>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_двійкове_заперечення(М, предмет як адреса<ПредметПереборуБуфера>, місцезнаходження);
    } інакше {
      вернути складений_предмет_двійкове_заперечення(М, предмет як адреса<СкладенийПредмет>, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_менше(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо менше до пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_менше(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_менше(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_менше(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_менше(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_менше(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_менше(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_менше(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_менше(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_менше(М, предмет як адреса<ПредметПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_менше(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_менше(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_менше(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_менше(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_менше(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_менше(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_менше(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_менше(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_менше(М, предмет як адреса<ПредметПереборуПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_менше(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_менше(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_менше(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_менше(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_більше(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо більше до пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_більше(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_більше(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_більше(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_більше(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_більше(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_більше(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_більше(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_більше(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_більше(М, предмет як адреса<ПредметПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_більше(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_більше(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_більше(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_більше(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_більше(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_більше(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_більше(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_більше(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_більше(М, предмет як адреса<ПредметПереборуПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_більше(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_більше(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_більше(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_більше(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_містить(М: адреса<Машина>, предмет: адреса<Предмет>, аргумент: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо містить до пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_містить(М, предмет як адреса<ПредметСтруктури>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_містить(М, предмет як адреса<ПредметКоду>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_містить(М, предмет як адреса<ПредметСередовища>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_містить(М, предмет як адреса<ПредметДії>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_містить(М, предмет як адреса<ПредметЛогічного>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_містить(М, предмет як адреса<ПредметЧисла>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_містить(М, предмет як адреса<ПредметТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_містить(М, предмет як адреса<ПредметСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_містить(М, предмет як адреса<ПредметПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_містить(М, предмет як адреса<ПредметСловника>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_містить(М, предмет як адреса<ПредметБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_містить(М, предмет як адреса<ПредметБуфера>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_містить(М, предмет як адреса<ПредметМодуля>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_містить(М, предмет як адреса<ПредметПараметра>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_містить(М, предмет як адреса<ПредметДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_містить(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_містить(М, предмет як адреса<ПредметПереборуСписку>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_містить(М, предмет як адреса<ПредметПереборуПослідовності>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_містить(М, предмет як адреса<ПредметПереборуТексту>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_містить(М, предмет як адреса<ПредметПереборуБайтів>, аргумент, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_містить(М, предмет як адреса<ПредметПереборуБуфера>, аргумент, місцезнаходження);
    } інакше {
      вернути складений_предмет_містить(М, предмет як адреса<СкладенийПредмет>, аргумент, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_числова_негація(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути пусто; // потім: помилка
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_числова_негація(М, предмет як адреса<ПредметСтруктури>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_числова_негація(М, предмет як адреса<ПредметКоду>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_числова_негація(М, предмет як адреса<ПредметСередовища>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_числова_негація(М, предмет як адреса<ПредметДії>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_числова_негація(М, предмет як адреса<ПредметЛогічного>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_числова_негація(М, предмет як адреса<ПредметЧисла>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_числова_негація(М, предмет як адреса<ПредметТексту>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_числова_негація(М, предмет як адреса<ПредметСписку>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_числова_негація(М, предмет як адреса<ПредметПослідовності>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_числова_негація(М, предмет як адреса<ПредметСловника>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_числова_негація(М, предмет як адреса<ПредметБайтів>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_числова_негація(М, предмет як адреса<ПредметБуфера>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_числова_негація(М, предмет як адреса<ПредметМодуля>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_числова_негація(М, предмет як адреса<ПредметПараметра>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_числова_негація(М, предмет як адреса<ПредметДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_числова_негація(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_числова_негація(М, предмет як адреса<ПредметПереборуСписку>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_числова_негація(М, предмет як адреса<ПредметПереборуПослідовності>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_числова_негація(М, предмет як адреса<ПредметПереборуТексту>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_числова_негація(М, предмет як адреса<ПредметПереборуБайтів>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_числова_негація(М, предмет як адреса<ПредметПереборуБуфера>, місцезнаходження);
    } інакше {
      вернути складений_предмет_числова_негація(М, предмет як адреса<СкладенийПредмет>, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_отримати_число(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути пусто; // потім: помилка
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_отримати_число(М, предмет як адреса<ПредметСтруктури>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_отримати_число(М, предмет як адреса<ПредметКоду>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_отримати_число(М, предмет як адреса<ПредметСередовища>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_отримати_число(М, предмет як адреса<ПредметДії>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_отримати_число(М, предмет як адреса<ПредметЛогічного>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_отримати_число(М, предмет як адреса<ПредметЧисла>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_отримати_число(М, предмет як адреса<ПредметТексту>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_отримати_число(М, предмет як адреса<ПредметСписку>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_отримати_число(М, предмет як адреса<ПредметПослідовності>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_отримати_число(М, предмет як адреса<ПредметСловника>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_отримати_число(М, предмет як адреса<ПредметБайтів>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_отримати_число(М, предмет як адреса<ПредметБуфера>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_отримати_число(М, предмет як адреса<ПредметМодуля>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_отримати_число(М, предмет як адреса<ПредметПараметра>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_отримати_число(М, предмет як адреса<ПредметДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_отримати_число(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_отримати_число(М, предмет як адреса<ПредметПереборуСписку>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_отримати_число(М, предмет як адреса<ПредметПереборуПослідовності>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_отримати_число(М, предмет як адреса<ПредметПереборуТексту>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_отримати_число(М, предмет як адреса<ПредметПереборуБайтів>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_отримати_число(М, предмет як адреса<ПредметПереборуБуфера>, місцезнаходження);
    } інакше {
      вернути складений_предмет_отримати_число(М, предмет як адреса<СкладенийПредмет>, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_збільшити(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути пусто; // потім: помилка
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_збільшити(М, предмет як адреса<ПредметСтруктури>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_збільшити(М, предмет як адреса<ПредметКоду>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_збільшити(М, предмет як адреса<ПредметСередовища>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_збільшити(М, предмет як адреса<ПредметДії>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_збільшити(М, предмет як адреса<ПредметЛогічного>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_збільшити(М, предмет як адреса<ПредметЧисла>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_збільшити(М, предмет як адреса<ПредметТексту>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_збільшити(М, предмет як адреса<ПредметСписку>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_збільшити(М, предмет як адреса<ПредметПослідовності>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_збільшити(М, предмет як адреса<ПредметСловника>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_збільшити(М, предмет як адреса<ПредметБайтів>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_збільшити(М, предмет як адреса<ПредметБуфера>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_збільшити(М, предмет як адреса<ПредметМодуля>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_збільшити(М, предмет як адреса<ПредметПараметра>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_збільшити(М, предмет як адреса<ПредметДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_збільшити(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_збільшити(М, предмет як адреса<ПредметПереборуСписку>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_збільшити(М, предмет як адреса<ПредметПереборуПослідовності>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_збільшити(М, предмет як адреса<ПредметПереборуТексту>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_збільшити(М, предмет як адреса<ПредметПереборуБайтів>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_збільшити(М, предмет як адреса<ПредметПереборуБуфера>, місцезнаходження);
    } інакше {
      вернути складений_предмет_збільшити(М, предмет як адреса<СкладенийПредмет>, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_зменшити(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути пусто; // потім: помилка
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_зменшити(М, предмет як адреса<ПредметСтруктури>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_зменшити(М, предмет як адреса<ПредметКоду>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_зменшити(М, предмет як адреса<ПредметСередовища>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_зменшити(М, предмет як адреса<ПредметДії>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_зменшити(М, предмет як адреса<ПредметЛогічного>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_зменшити(М, предмет як адреса<ПредметЧисла>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_зменшити(М, предмет як адреса<ПредметТексту>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_зменшити(М, предмет як адреса<ПредметСписку>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_зменшити(М, предмет як адреса<ПредметПослідовності>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_зменшити(М, предмет як адреса<ПредметСловника>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_зменшити(М, предмет як адреса<ПредметБайтів>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_зменшити(М, предмет як адреса<ПредметБуфера>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_зменшити(М, предмет як адреса<ПредметМодуля>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_зменшити(М, предмет як адреса<ПредметПараметра>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_зменшити(М, предмет як адреса<ПредметДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_зменшити(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_зменшити(М, предмет як адреса<ПредметПереборуСписку>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_зменшити(М, предмет як адреса<ПредметПереборуПослідовності>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_зменшити(М, предмет як адреса<ПредметПереборуТексту>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_зменшити(М, предмет як адреса<ПредметПереборуБайтів>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_зменшити(М, предмет як адреса<ПредметПереборуБуфера>, місцезнаходження);
    } інакше {
      вернути складений_предмет_зменшити(М, предмет як адреса<СкладенийПредмет>, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_отримати_зображення(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути створити_предмет_тексту(М, "пусто") як адреса<Предмет>;
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_зображення(М, предмет як адреса<ПредметСтруктури>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_зображення(М, предмет як адреса<ПредметКоду>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_зображення(М, предмет як адреса<ПредметСередовища>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_зображення(М, предмет як адреса<ПредметДії>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_зображення(М, предмет як адреса<ПредметЛогічного>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_зображення(М, предмет як адреса<ПредметЧисла>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_зображення(М, предмет як адреса<ПредметТексту>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_зображення(М, предмет як адреса<ПредметСписку>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_зображення(М, предмет як адреса<ПредметПослідовності>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_зображення(М, предмет як адреса<ПредметСловника>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_зображення(М, предмет як адреса<ПредметБайтів>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_зображення(М, предмет як адреса<ПредметБуфера>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_зображення(М, предмет як адреса<ПредметМодуля>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_зображення(М, предмет як адреса<ПредметПараметра>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_зображення(М, предмет як адреса<ПредметДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_зображення(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_зображення(М, предмет як адреса<ПредметПереборуСписку>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_зображення(М, предмет як адреса<ПредметПереборуПослідовності>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_зображення(М, предмет як адреса<ПредметПереборуТексту>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_зображення(М, предмет як адреса<ПредметПереборуБайтів>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_зображення(М, предмет як адреса<ПредметПереборуБуфера>, місцезнаходження);
    } інакше {
      вернути складений_предмет_отримати_зображення(М, предмет як адреса<СкладенийПредмет>, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_отримати_текст(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути створити_предмет_тексту(М, "пусто") як адреса<Предмет>;
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_текст(М, предмет як адреса<ПредметСтруктури>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_текст(М, предмет як адреса<ПредметКоду>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_текст(М, предмет як адреса<ПредметСередовища>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_текст(М, предмет як адреса<ПредметДії>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_текст(М, предмет як адреса<ПредметЛогічного>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_текст(М, предмет як адреса<ПредметЧисла>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_текст(М, предмет як адреса<ПредметТексту>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_текст(М, предмет як адреса<ПредметСписку>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_текст(М, предмет як адреса<ПредметПослідовності>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_текст(М, предмет як адреса<ПредметСловника>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_текст(М, предмет як адреса<ПредметБайтів>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_текст(М, предмет як адреса<ПредметБуфера>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_текст(М, предмет як адреса<ПредметМодуля>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_текст(М, предмет як адреса<ПредметПараметра>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_текст(М, предмет як адреса<ПредметДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_текст(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_текст(М, предмет як адреса<ПредметПереборуСписку>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_текст(М, предмет як адреса<ПредметПереборуПослідовності>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_текст(М, предмет як адреса<ПредметПереборуТексту>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_текст(М, предмет як адреса<ПредметПереборуБайтів>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_текст(М, предмет як адреса<ПредметПереборуБуфера>, місцезнаходження);
    } інакше {
      вернути складений_предмет_отримати_текст(М, предмет як адреса<СкладенийПредмет>, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_отримати_байти(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо отримати байти з пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_отримати_байти(М, предмет як адреса<ПредметСтруктури>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_отримати_байти(М, предмет як адреса<ПредметКоду>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_отримати_байти(М, предмет як адреса<ПредметСередовища>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_отримати_байти(М, предмет як адреса<ПредметДії>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_отримати_байти(М, предмет як адреса<ПредметЛогічного>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_отримати_байти(М, предмет як адреса<ПредметЧисла>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_отримати_байти(М, предмет як адреса<ПредметТексту>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_отримати_байти(М, предмет як адреса<ПредметСписку>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_отримати_байти(М, предмет як адреса<ПредметПослідовності>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_отримати_байти(М, предмет як адреса<ПредметСловника>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_отримати_байти(М, предмет як адреса<ПредметБайтів>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_отримати_байти(М, предмет як адреса<ПредметБуфера>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_отримати_байти(М, предмет як адреса<ПредметМодуля>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_отримати_байти(М, предмет як адреса<ПредметПараметра>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_отримати_байти(М, предмет як адреса<ПредметДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_отримати_байти(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_отримати_байти(М, предмет як адреса<ПредметПереборуСписку>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_отримати_байти(М, предмет як адреса<ПредметПереборуПослідовності>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_отримати_байти(М, предмет як адреса<ПредметПереборуТексту>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_отримати_байти(М, предмет як адреса<ПредметПереборуБайтів>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_отримати_байти(М, предмет як адреса<ПредметПереборуБуфера>, місцезнаходження);
    } інакше {
      вернути складений_предмет_отримати_байти(М, предмет як адреса<СкладенийПредмет>, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_отримати_перебір(М: адреса<Машина>, предмет: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо отримати перебір з пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_отримати_перебір(М, предмет як адреса<ПредметСтруктури>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_отримати_перебір(М, предмет як адреса<ПредметКоду>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_отримати_перебір(М, предмет як адреса<ПредметСередовища>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_отримати_перебір(М, предмет як адреса<ПредметДії>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_отримати_перебір(М, предмет як адреса<ПредметЛогічного>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_отримати_перебір(М, предмет як адреса<ПредметЧисла>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_отримати_перебір(М, предмет як адреса<ПредметТексту>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_отримати_перебір(М, предмет як адреса<ПредметСписку>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_отримати_перебір(М, предмет як адреса<ПредметПослідовності>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_отримати_перебір(М, предмет як адреса<ПредметСловника>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_отримати_перебір(М, предмет як адреса<ПредметБайтів>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_отримати_перебір(М, предмет як адреса<ПредметБуфера>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_отримати_перебір(М, предмет як адреса<ПредметМодуля>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_отримати_перебір(М, предмет як адреса<ПредметПараметра>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_отримати_перебір(М, предмет як адреса<ПредметДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_отримати_перебір(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_отримати_перебір(М, предмет як адреса<ПредметПереборуСписку>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_отримати_перебір(М, предмет як адреса<ПредметПереборуПослідовності>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_отримати_перебір(М, предмет як адреса<ПредметПереборуТексту>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_отримати_перебір(М, предмет як адреса<ПредметПереборуБайтів>, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_отримати_перебір(М, предмет як адреса<ПредметПереборуБуфера>, місцезнаходження);
    } інакше {
      вернути складений_предмет_отримати_перебір(М, предмет як адреса<СкладенийПредмет>, місцезнаходження);
    }
  }

  // позначка: прохід по типах предмета
  місцева дія предмет_отримати_діапазон(М: адреса<Машина>, предмет: адреса<Предмет>, включно: логічне, до: адреса<Предмет>, місцезнаходження: Місцезнаходження) -> ПредметАбоСтанПадіння<Предмет> {
    якщо предмет == пусто {
      вернути результат_стан_падіння(М, місцезнаходження, створити_предмет_тексту(М, "Неможливо отримати діапазон для пусто") як адреса<Предмет>);
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      вернути предмет_структури_отримати_діапазон(М, предмет як адреса<ПредметСтруктури>, включно, до, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вернути предмет_коду_отримати_діапазон(М, предмет як адреса<ПредметКоду>, включно, до, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вернути предмет_середовища_отримати_діапазон(М, предмет як адреса<ПредметСередовища>, включно, до, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      вернути предмет_дії_отримати_діапазон(М, предмет як адреса<ПредметДії>, включно, до, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      вернути предмет_логічного_отримати_діапазон(М, предмет як адреса<ПредметЛогічного>, включно, до, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_число {
      вернути предмет_числа_отримати_діапазон(М, предмет як адреса<ПредметЧисла>, включно, до, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      вернути предмет_тексту_отримати_діапазон(М, предмет як адреса<ПредметТексту>, включно, до, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_список {
      вернути предмет_списку_отримати_діапазон(М, предмет як адреса<ПредметСписку>, включно, до, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      вернути предмет_послідовності_отримати_діапазон(М, предмет як адреса<ПредметПослідовності>, включно, до, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_словник {
      вернути предмет_словника_отримати_діапазон(М, предмет як адреса<ПредметСловника>, включно, до, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_байти {
      вернути предмет_байтів_отримати_діапазон(М, предмет як адреса<ПредметБайтів>, включно, до, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      вернути предмет_буфера_отримати_діапазон(М, предмет як адреса<ПредметБуфера>, включно, до, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      вернути предмет_модуля_отримати_діапазон(М, предмет як адреса<ПредметМодуля>, включно, до, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      вернути предмет_параметра_отримати_діапазон(М, предмет як адреса<ПредметПараметра>, включно, до, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      вернути предмет_діапазону_чисел_отримати_діапазон(М, предмет як адреса<ПредметДіапазонуЧисел>, включно, до, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вернути предмет_перебору_діапазону_чисел_отримати_діапазон(М, предмет як адреса<ПредметПереборуДіапазонуЧисел>, включно, до, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вернути предмет_перебору_списку_отримати_діапазон(М, предмет як адреса<ПредметПереборуСписку>, включно, до, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вернути предмет_перебору_послідовності_отримати_діапазон(М, предмет як адреса<ПредметПереборуПослідовності>, включно, до, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вернути предмет_перебору_тексту_отримати_діапазон(М, предмет як адреса<ПредметПереборуТексту>, включно, до, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вернути предмет_перебору_байтів_отримати_діапазон(М, предмет як адреса<ПредметПереборуБайтів>, включно, до, місцезнаходження);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБуфера {
      вернути предмет_перебору_буфера_отримати_діапазон(М, предмет як адреса<ПредметПереборуБуфера>, включно, до, місцезнаходження);
    } інакше {
      вернути складений_предмет_отримати_діапазон(М, предмет як адреса<СкладенийПредмет>, включно, до, місцезнаходження);
    }
  }
}