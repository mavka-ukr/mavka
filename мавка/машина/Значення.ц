взяти означення мавка;

простір мавка {
  місцева дія створити_предмет(
    М: адреса<Машина>,
    значення_структури: Значення
  ) -> Значення {
    змінна предмет = виділити_предмет(М, значення_структури);
    
    предмет.властивості = Властивості { 0, пусто };
    
    вернути предмет як Значення;
  }

  місцева дія здійснити(
    М: адреса<Машина>,
    здійснювач: Значення,
    значення: Значення,
    кількість_задіяних: природне,
    задіяні: памʼять<Значення>,
    іменовано_задіяні: адреса<ІменованіЗадіяні>,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо значення.тип == М.значення_структура_Дія {
      вернути предмет_дії_здійснити(
        М,
        здійснювач,
        значення,
        кількість_задіяних,
        задіяні,
        іменовано_задіяні,
        місцезнаходження
      );
    }
    
    якщо значення.тип == М.значення_структура_Структура {
      вернути предмет_структури_здійснити(
        М,
        здійснювач,
        значення,
        кількість_задіяних,
        задіяні,
        іменовано_задіяні,
        місцезнаходження
      );
    }          
    
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконати дію можна лише над діями."),
      місцезнаходження
    );
    вернути пусто;               
  }

  // позначка: прохід по типах предметів
  місцева дія отримати_властивість(
    М: адреса<Машина>,
    предмет: Значення,
    назва: Значення,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо предмет == пусто {
      вернути пусто;
    }

    якщо предмет.тип == М.значення_дійсне {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_послідовність {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_дійсність {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_предмет {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Структура {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Модуль {
      змінна властивості_модуля = (предмет як адреса<Предмет>).властивості як ВластивостіМодуля;
      змінна властивості = властивості_модуля.властивості;
      
      змінна п: природне = 0;
      поки п < властивості.розмір {
        змінна властивість = властивості.дані[п];
  
        якщо перевірити_чи_значення_рівні(М, властивість.назва, назва) {
          вернути властивість.значення;
        }
  
        п += 1;
      }

      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Параметр {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Число {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Ціле {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Дробове {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Текст {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Код {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Дія {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Список {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Словник {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Дані {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_ЗмінніДані {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_ДіапазонЦілих {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_ДіапазонДробових {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_ПеребірДіапазонуЦілих {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_ПеребірДіапазонуДробових {
      вернути пусто;
    }

    змінна властивості = (предмет як адреса<Предмет>).властивості як Властивості;
    
    змінна п: природне = 0;
    поки п < властивості.розмір {
      змінна властивість = властивості.дані[п];

      якщо перевірити_чи_значення_рівні(М, властивість.назва, назва) {
        вернути властивість.значення;
      }

      п += 1;
    }

    якщо предмет.тип.тип == М.значення_структура_Структура {
      вернути знайти_метод_в_структурі(М, предмет.тип, назва);
    }

    вернути пусто;
  }

  // позначка: прохід по типах предметів
  місцева дія змінити_властивість(
    М: адреса<Машина>,
    предмет: Значення,
    назва: Значення,
    значення: Значення,
    місцезнаходження: Місцезнаходження
  ) {
    якщо предмет == пусто {
      вернути;
    }

    якщо предмет.тип == М.значення_дійсне {
      вернути;
    }
    
    якщо предмет.тип == М.значення_послідовність {
      вернути;
    }
    
    якщо предмет.тип == М.значення_дійсність {
      вернути;
    }
    
    якщо предмет.тип == М.значення_предмет {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Структура {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Модуль {
      змінна властивості_модуля = ((предмет як адреса<Предмет>).властивості як ВластивостіМодуля)::адреса;
      змінна властивості = властивості_модуля.властивості::адреса;
      
      змінна п: природне = 0;
      поки п < властивості.розмір {
        змінна властивість = властивості.дані[п]::адреса;
  
        якщо перевірити_чи_значення_рівні(М, властивість.назва, назва) {
          властивість.значення = значення;
  
          вернути;
        }
  
        п += 1;
      }
  
      властивості.дані = перевиділити_памʼять<Властивість>(М, властивості.дані, властивості.розмір + 1);
      властивості.дані[властивості.розмір] = Властивість { назва, значення };
      властивості.розмір += 1;
  
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Параметр {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Число {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Ціле {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Дробове {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Текст {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Код {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Дія {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Список {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Словник {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Дані {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_ЗмінніДані {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_ДіапазонЦілих {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_ДіапазонДробових {
      вернути;
    }

    змінна властивості = ((предмет як адреса<Предмет>).властивості як Властивості)::адреса;
    
    змінна п: природне = 0;
    поки п < властивості.розмір {
      змінна властивість = властивості.дані[п]::адреса;

      якщо перевірити_чи_значення_рівні(М, властивість.назва, назва) {
        властивість.значення = значення;

        вернути;
      }

      п += 1;
    }

    властивості.дані = перевиділити_памʼять<Властивість>(М, властивості.дані, властивості.розмір + 1);
    властивості.дані[властивості.розмір] = Властивість { назва, значення };
    властивості.розмір += 1;

    вернути;
  }

  місцева дія здійснити_властивість(
    М: адреса<Машина>,
    предмет: Значення,
    назва: Значення,
    кількість_задіяних: природне,
    задіяні: памʼять<Значення>,
    іменовано_задіяні: адреса<ІменованіЗадіяні>,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    змінна значення_властивості = отримати_властивість(М, предмет, назва, місцезнаходження);
    якщо М.стан_падіння {
      звільнити_памʼять(М, задіяні);
      якщо іменовано_задіяні != пусто {
        знищити_іменовано_задіяні(М, іменовано_задіяні);
      }
      вернути пусто;
    }

    якщо значення_властивості == пусто {
      увімкнути_стан_падіння(
        М, 
        створити_текст(М, "Не влалось здійснити властивість."), 
        місцезнаходження
      );
      звільнити_памʼять(М, задіяні);
      якщо іменовано_задіяні != пусто {
        знищити_іменовано_задіяні(М, іменовано_задіяні);
      }
      вернути пусто;
    }

    вернути здійснити(
      М,
      предмет,
      значення_властивості,
      кількість_задіяних,
      задіяні,
      іменовано_задіяні,
      місцезнаходження
    );
  }

  // позначка: прохід по типах предметів
  місцева дія отримати_елемент(
    М: адреса<Машина>,
    предмет: Значення,
    ключ: Значення,
    місцезнаходження: Місцезнаходження
  ) -> Значення {
    якщо предмет == пусто {
      вернути пусто;
    }

    якщо предмет.тип == М.значення_дійсне {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_послідовність {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_дійсність {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_предмет {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Структура {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Модуль {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Параметр {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Число {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Ціле {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Дробове {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Текст {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Код {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Дія {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Список {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Словник {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Дані {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_ЗмінніДані {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_ДіапазонЦілих {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_ДіапазонДробових {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_ПеребірДіапазонуЦілих {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_ПеребірДіапазонуДробових {
      вернути пусто;
    }

    вернути пусто;
  }

  // позначка: прохід по типах предметів
  місцева дія змінити_елемент(
    М: адреса<Машина>,
    предмет: Значення,
    ключ: Значення,
    значення: Значення,
    місцезнаходження: Місцезнаходження
  ) {
    якщо предмет == пусто {
      вернути;
    }

    якщо предмет.тип == М.значення_дійсне {
      вернути;
    }
    
    якщо предмет.тип == М.значення_послідовність {
      вернути;
    }
    
    якщо предмет.тип == М.значення_дійсність {
      вернути;
    }
    
    якщо предмет.тип == М.значення_предмет {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Структура {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Модуль {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Параметр {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Число {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Ціле {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Дробове {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Текст {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Код {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Дія {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Список {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Словник {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Дані {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_ЗмінніДані {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_ДіапазонЦілих {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_ДіапазонДробових {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_ПеребірДіапазонуЦілих {
      вернути;
    }

    якщо предмет.тип == М.значення_структура_ПеребірДіапазонуДробових {
      вернути;
    }

    вернути;
  }

  // позначка: прохід по типах предметів
  місцева дія отримати_текст(М: адреса<Машина>, значення: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо значення == пусто {
      вернути створити_текст(М, "недійсне");
    }

    якщо значення.тип == М.значення_дійсне {
      вернути створити_текст(М, "дійсне");
    }
    
    якщо значення.тип == М.значення_послідовність {
      вернути створити_текст(М, "послідовність");
    }
    
    якщо значення.тип == М.значення_дійсність {
      вернути створити_текст(М, "дійсність");
    }
    
    якщо значення.тип == М.значення_предмет {
      вернути створити_текст(М, "предмет");
    }
    
    якщо значення.тип == М.значення_структура_Структура {
      вернути створити_текст(М, "<Структура>");
    }
    
    якщо значення.тип == М.значення_структура_Модуль {
      вернути створити_текст(М, "<Модуль>");
    }
    
    якщо значення.тип == М.значення_структура_Параметр {
      вернути створити_текст(М, "<Параметр>");
    }
    
    якщо значення.тип == М.значення_структура_Число {
      вернути створити_текст(М, "<Число>");
    }
    
    якщо значення.тип == М.значення_структура_Ціле {
      вернути створити_текст(М, "<Ціле>");
    }
    
    якщо значення.тип == М.значення_структура_Дробове {
      вернути створити_текст(М, "<Дробове>");
    }
    
    якщо значення.тип == М.значення_структура_Текст {
      вернути значення;
    }
    
    якщо значення.тип == М.значення_структура_Код {
      вернути створити_текст(М, "<Код>");
    }
    
    якщо значення.тип == М.значення_структура_Дія {
      вернути створити_текст(М, "<Дія>");
    }
    
    якщо значення.тип == М.значення_структура_Список {
      вернути створити_текст(М, "<Список>");
    }
    
    якщо значення.тип == М.значення_структура_Словник {
      вернути створити_текст(М, "<Словник>");
    }
    
    якщо значення.тип == М.значення_структура_Дані {
      вернути створити_текст(М, "<Дані>");
    }
    
    якщо значення.тип == М.значення_структура_ЗмінніДані {
      вернути створити_текст(М, "<ЗмінніДані>");
    }
    
    якщо значення.тип == М.значення_структура_ДіапазонЦілих {
      вернути створити_текст(М, "<ДіапазонЦілих>");
    }
    
    якщо значення.тип == М.значення_структура_ДіапазонДробових {
      вернути створити_текст(М, "<ДіапазонДробових>");
    }
    
    якщо значення.тип == М.значення_структура_ПеребірДіапазонуЦілих {
      вернути створити_текст(М, "<ПеребірДіапазонуЦілих>");
    }
    
    якщо значення.тип == М.значення_структура_ПеребірДіапазонуДробових {
      вернути створити_текст(М, "<ПеребірДіапазонуДробових>");
    }
    
    вернути пусто;
  }

  // позначка: прохід по типах предметів
  місцева дія отримати_діапазон(
    М: адреса<Машина>,
    від: Значення,
    до: Значення,
    включно: логічне,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо від == пусто {
      вернути пусто;
    }

    якщо від.тип == М.значення_дійсне {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_послідовність {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_дійсність {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_предмет {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_Структура {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_Модуль {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_Параметр {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_Число {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_Ціле {
      якщо до.тип == М.значення_структура_Ціле {
        вернути створити_діапазон_цілих(М, від, до, включно);
      } інакше {
        увімкнути_стан_падіння(
          М,
          створити_текст(М, "Неможливо створити діапазон цілих чисел з різнорідних типів."),
          місцезнаходження
        );

        вернути пусто;
      }
    }
    
    якщо від.тип == М.значення_структура_Дробове {
      якщо до.тип == М.значення_структура_Дробове {
        вернути створити_діапазон_дробових(М, від, до, включно);
      } інакше {
        увімкнути_стан_падіння(
          М,
          створити_текст(М, "Неможливо створити діапазон дробових чисел з різнорідних типів."),
          місцезнаходження
        );

        вернути пусто;
      }
    }
    
    якщо від.тип == М.значення_структура_Текст {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_Код {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_Дія {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_Список {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_Словник {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_Дані {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_ЗмінніДані {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_ДіапазонЦілих {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_ДіапазонДробових {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_ПеребірДіапазонуЦілих {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_ПеребірДіапазонуДробових {
      вернути пусто;
    }

    змінна кількість_задіяних: природне = 2;
    змінна задіяні = виділити_памʼять<Значення>(М, кількість_задіяних);
    задіяні[0] = до;
    якщо включно {
      задіяні[1] = М.значення_дійсне;
    } інакше {
      задіяні[1] = пусто як Значення;
    }

    вернути здійснити_властивість(
      М,
      від,
      створити_текст(М, "чародія_діапазон"),
      кількість_задіяних,
      задіяні,
      пусто,
      місцезнаходження
    );
  }

  // позначка: прохід по типах предметів
  місцева дія отримати_перебір(
    М: адреса<Машина>,
    предмет: Значення,
    місцезнаходження: Місцезнаходження
  ) -> Значення {
    якщо предмет == пусто {
      вернути пусто;
    }

    якщо предмет.тип == М.значення_дійсне {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_послідовність {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_дійсність {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_предмет {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Структура {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Модуль {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Параметр {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Число {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Ціле {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Дробове {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Текст {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Код {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Дія {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Список {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Словник {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Дані {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_ЗмінніДані {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_ДіапазонЦілих {
      вернути створити_перебір_діапазону_цілих(М, предмет);
    }
    
    якщо предмет.тип == М.значення_структура_ДіапазонДробових {
      вернути створити_перебір_діапазону_дробових(М, предмет);
    }

    якщо предмет.тип == М.значення_структура_ПеребірДіапазонуЦілих {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_ПеребірДіапазонуДробових {
      вернути пусто;
    }

    вернути здійснити_властивість(
      М,
      предмет,
      створити_текст(М, "чародія_перебір"),
      0,
      пусто,
      пусто,
      місцезнаходження
    );
  }

  місцева дія виконати_додати(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто {
      стрибнути крок_помилка;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      вернути предмет_цілого_додати(М, ліво, право, місцезнаходження);
    }

    якщо ліво.тип == М.значення_структура_Дробове {
      вернути предмет_дробового_додати(М, ліво, право, місцезнаходження);
    }
  
  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконати додавання можна лише між числами."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія виконати_відняти(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто {
      стрибнути крок_помилка;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      вернути предмет_цілого_відняти(М, ліво, право, місцезнаходження);
    }

    якщо ліво.тип == М.значення_структура_Дробове {
      вернути предмет_дробового_відняти(М, ліво, право, місцезнаходження);
    }
  
  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконати віднімання можна лише між числами."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія виконати_помножити(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто {
      стрибнути крок_помилка;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      вернути предмет_цілого_помножити(М, ліво, право, місцезнаходження);
    }

    якщо ліво.тип == М.значення_структура_Дробове {
      вернути предмет_дробового_помножити(М, ліво, право, місцезнаходження);
    }
  
  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконати множення можна лише між числами."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія виконати_поділити(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто {
      стрибнути крок_помилка;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      вернути предмет_цілого_поділити(М, ліво, право, місцезнаходження);
    }

    якщо ліво.тип == М.значення_структура_Дробове {
      вернути предмет_дробового_поділити(М, ліво, право, місцезнаходження);
    }
  
  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконати ділення можна лише між числами."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія виконати_остача(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто {
      стрибнути крок_помилка;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      вернути предмет_цілого_остача(М, ліво, право, місцезнаходження);
    }

    якщо ліво.тип == М.значення_структура_Дробове {
      вернути предмет_дробового_остача(М, ліво, право, місцезнаходження);
    }
  
  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконати отримання остачі ділення можна лише між числами."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія виконати_частка(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто {
      стрибнути крок_помилка;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      вернути предмет_цілого_частка(М, ліво, право, місцезнаходження);
    }

    якщо ліво.тип == М.значення_структура_Дробове {
      вернути предмет_дробового_частка(М, ліво, право, місцезнаходження);
    }
  
  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконати отримання неповної частки ділення можна лише між числами."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія виконати_степінь(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто {
      стрибнути крок_помилка;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      вернути предмет_цілого_степінь(М, ліво, право, місцезнаходження);
    }

    якщо ліво.тип == М.значення_структура_Дробове {
      вернути предмет_дробового_степінь(М, ліво, право, місцезнаходження);
    }
  
  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконати піднесення до степеня можна лише між числами."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія виконати_вліво(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто {
      стрибнути крок_помилка;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      вернути предмет_цілого_вліво(М, ліво, право, місцезнаходження);
    }
  
  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконати двійкове зсув вліво можна лише між цілими числами."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія виконати_вправо(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто {
      стрибнути крок_помилка;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      вернути предмет_цілого_вправо(М, ліво, право, місцезнаходження);
    }
  
  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконати двійкове зсув вправо можна лише між цілими числами."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія виконати_двійкове_і(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто {
      стрибнути крок_помилка;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      вернути предмет_цілого_двійкове_і(М, ліво, право, місцезнаходження);
    }
  
  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконати двійкове І можна лише між цілими числами."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія виконати_двійкове_або(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто {
      стрибнути крок_помилка;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      вернути предмет_цілого_двійкове_або(М, ліво, право, місцезнаходження);
    }
  
  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконати двійкове АБО можна лише між цілими числами."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія виконати_двійкове_вабо(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто {
      стрибнути крок_помилка;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      вернути предмет_цілого_двійкове_вабо(М, ліво, право, місцезнаходження);
    }
  
  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконати двійкове ВАБО можна лише між цілими числами."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія виконати_менше(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто {
      стрибнути крок_помилка;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      вернути предмет_цілого_менше(М, ліво, право, місцезнаходження);
    }

    якщо ліво.тип == М.значення_структура_Дробове {
      вернути предмет_дробового_більше(М, ліво, право, місцезнаходження);
    }
  
  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконати перевірку чи менше можна лише між числами."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія виконати_більше(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто {
      стрибнути крок_помилка;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      вернути предмет_цілого_більше(М, ліво, право, місцезнаходження);
    }

    якщо ліво.тип == М.значення_структура_Дробове {
      вернути предмет_дробового_більше(М, ліво, право, місцезнаходження);
    }
  
  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконати перевірку чи більше можна лише між числами."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія виконати_рівно(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо перевірити_чи_значення_рівні(М, ліво, право) {
      вернути М.значення_дійсне;
    } інакше {
      вернути пусто;
    }
  }

  місцева дія виконати_містить(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    вернути пусто;
  }

  місцева дія виконати_є(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо перевірити_чи_значення_є(М, ліво, право) {
      вернути М.значення_дійсне;
    } інакше {
      вернути пусто;
    }
  }

  місцева дія виконати_двійкове_не(М: адреса<Машина>, значення: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо значення == пусто {
      стрибнути крок_помилка;
    }
    
    якщо значення.тип == М.значення_структура_Ціле {
      вернути предмет_цілого_двійкове_не(М, значення, місцезнаходження);
    }
  
  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконати двійкове НЕ можна лише для цілого числа."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія виконати_змінити_знак(М: адреса<Машина>, значення: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо значення == пусто {
      стрибнути крок_помилка;
    }
    
    якщо значення.тип == М.значення_структура_Ціле {
      вернути предмет_цілого_змінити_знак(М, значення, місцезнаходження);
    }
    
    якщо значення.тип == М.значення_структура_Дробове {
      вернути предмет_дробового_змінити_знак(М, значення, місцезнаходження);
    }
  
  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконати зміну знаку можна лише для чисел."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія перевірити_чи_значення_рівні(М: адреса<Машина>, а: Значення, б: Значення) -> логічне {
    якщо а == б {
      вернути так;
    }

    якщо а == пусто або б == пусто {
      вернути ні;
    }
    
    якщо а.тип == б.тип {
      якщо а.тип == М.значення_структура_Ціле {
        змінна предмет_цілого_а = а як адреса<Предмет>;
        змінна властивості_цілого_а = предмет_цілого_а.властивості як ВластивостіЦілого;

        змінна предмет_цілого_б = б як адреса<Предмет>;
        змінна властивості_цілого_б = предмет_цілого_б.властивості як ВластивостіЦілого;

        якщо властивості_цілого_а.значення == властивості_цілого_б.значення {
          вернути так;
        }

        вернути ні;
      }
      
      якщо а.тип == М.значення_структура_Дробове {
        змінна предмет_дробового_а = а як адреса<Предмет>;
        змінна властивості_дробового_а = предмет_дробового_а.властивості як ВластивостіДробового;

        змінна предмет_дробового_б = б як адреса<Предмет>;
        змінна властивості_дробового_б = предмет_дробового_б.властивості як ВластивостіДробового;

        якщо властивості_дробового_а.значення == властивості_дробового_б.значення {
          вернути так;
        }

        вернути ні;
      }

      якщо а.тип == М.значення_структура_Текст {
        змінна предмет_тексту_а = а як адреса<Предмет>;
        змінна властивості_тексту_а = предмет_тексту_а.властивості як ВластивостіТексту;

        змінна предмет_тексту_б = б як адреса<Предмет>;
        змінна властивості_тексту_б = предмет_тексту_б.властивості як ВластивостіТексту;

        якщо властивості_тексту_а.значення.розмір != властивості_тексту_б.значення.розмір {
          вернути ні;
        }

        змінна п: природне = 0;
        поки п < властивості_тексту_а.значення.розмір {
          якщо властивості_тексту_а.значення.дані[п] != властивості_тексту_б.значення.дані[п] {
            вернути ні;
          }

          п += 1;
        }

        вернути так;
      }
    }

    якщо а.тип == М.значення_структура_Ціле і б.тип == М.значення_структура_Дробове {
      змінна предмет_цілого_а = а як адреса<Предмет>;
      змінна властивості_цілого_а = предмет_цілого_а.властивості як ВластивостіЦілого;

      змінна предмет_дробового_б = б як адреса<Предмет>;
      змінна властивості_дробового_б = предмет_дробового_б.властивості як ВластивостіДробового;

      якщо д64(властивості_цілого_а.значення) == властивості_дробового_б.значення {
        вернути так;
      }

      вернути ні;
    }

    якщо а.тип == М.значення_структура_Дробове і б.тип == М.значення_структура_Ціле {
      змінна предмет_дробового_а = а як адреса<Предмет>;
      змінна властивості_дробового_а = предмет_дробового_а.властивості як ВластивостіДробового;

      змінна предмет_цілого_б = б як адреса<Предмет>;
      змінна властивості_цілого_б = предмет_цілого_б.властивості як ВластивостіЦілого;

      якщо властивості_дробового_а.значення == д64(властивості_цілого_б.значення) {
        вернути так;
      }

      вернути ні;
    }
    
    вернути ні;
  }

  місцева дія перевірити_чи_значення_є(М: адреса<Машина>, а: Значення, б: Значення) -> логічне {
    якщо а == пусто {
      якщо б == пусто {
        вернути так;
      }

      вернути ні;
    }

    якщо б == пусто {
      вернути ні;
    }

    якщо б == М.значення_дійсне {
      вернути так;
    }

    змінна тип_а = а.тип;

    поки тип_а != М.значення_дійсне {
      якщо тип_а == б {
        вернути так;
      }

      якщо тип_а == М.значення_предмет {
        вернути ні;
      }

      змінна предмет_типу_а = тип_а як адреса<Предмет>;
      змінна властивості_типу_а = предмет_типу_а.властивості як ВластивостіСтруктури;

      тип_а = властивості_типу_а.предок;
    }
    
    вернути ні;
  }

  дія вивести_пропуски(М: адреса<Машина>, кількість: природне) {
    змінна п: природне = 0;
    
    поки п < кількість {
      вивести(М, " ");
    
      п += 1;
    }
  }

  // позначка: прохід по типах предметів
  місцева дія вивести_значення(М: адреса<Машина>, значення: Значення, розмір_відступу: природне, глибина: природне) {
    якщо значення == пусто {
      вивести_формат(М, ФКолірТекстуЖовтий);
      
      вивести(М, "недійсне");
      
      вивести_формат(М, ФОчистити);

      вернути;
    }
    
    якщо значення == М.значення_дійсне {
      вивести_формат(М, ФКолірТекстуЖовтий);
      
      вивести(М, "дійсне");

      вивести_формат(М, ФОчистити);

      вернути;
    }
    
    якщо значення == М.значення_послідовність {
      вивести(М, "послідовність");
      вернути;
    }
    
    якщо значення == М.значення_дійсність {
      вивести(М, "дійсність");
      вернути;
    }
    
    якщо значення == М.значення_предмет {
      вивести(М, "предмет");
      вернути;
    }

    якщо значення.тип == М.значення_дійсне {
      вивести(М, "дійсне()");
      вернути;
    }
    
    якщо значення.тип == М.значення_послідовність {
      вивести(М, "послідовність()");
      вернути;
    }
    
    якщо значення.тип == М.значення_дійсність {
      вивести(М, "дійсність()");
      вернути;
    }
    
    якщо значення.тип == М.значення_предмет {
      вивести(М, "предмет()");
      вернути;
    }
    
    якщо значення.тип == М.значення_структура_Структура {
      змінна предмет = значення як адреса<Предмет>;
      змінна властивості = предмет.властивості як ВластивостіСтруктури;

      вивести_формат(М, ФКолірТекстуСиній);

      якщо властивості.назва == пусто {
        вивести(М, "<структура>");
      } інакше {
        вивести(М, "<структура ");
        
        вивести_значення(М, властивості.назва, 0, 0);

        вивести(М, ">");
      }

      вивести_формат(М, ФОчистити);

      вернути;
    }
    
    якщо значення.тип == М.значення_структура_Модуль {
      змінна предмет = значення як адреса<Предмет>;
      змінна властивості_модуля = предмет.властивості як ВластивостіМодуля;

      вивести_формат(М, ФКолірТекстуСиній);

      якщо властивості_модуля.назва == пусто {
        вивести(М, "<модуль");
      } інакше {
        вивести(М, "<модуль ");

        вивести_значення(М, властивості_модуля.назва, 0, 0);
      }

      якщо властивості_модуля.властивості.розмір > 0 {
        вивести(М, "[");
        змінна п: природне = 0;

        поки п < властивості_модуля.властивості.розмір {
          вивести_значення(М, властивості_модуля.властивості.дані[п].назва, 0, 0);
  
          якщо п + 1 < властивості_модуля.властивості.розмір {
            вивести(М, ", ");
          }
  
          п += 1;
        }
        вивести(М, "]");
      }
      
      вивести(М, ">");

      вивести_формат(М, ФОчистити);

      вернути;
    }
    
    якщо значення.тип == М.значення_структура_Параметр {
      вивести(М, "Параметр()");
      вернути;
    }
    
    якщо значення.тип == М.значення_структура_Число {
      запанікувати(М, "Неможливо вивести значення типу Число без конкретизації Ціле або Дробове.");
    }
    
    якщо значення.тип == М.значення_структура_Ціле {
      змінна предмет = значення як адреса<Предмет>;
      змінна властивості = предмет.властивості як ВластивостіЦілого;

      вивести_формат(М, ФКолірТекстуЖовтий);

      вивести_ц64(М, властивості.значення);

      вивести_формат(М, ФОчистити);

      вернути;
    }
    
    якщо значення.тип == М.значення_структура_Дробове {
      змінна предмет = значення як адреса<Предмет>;
      змінна властивості = предмет.властивості як ВластивостіДробового;

      вивести_формат(М, ФКолірТекстуЖовтий);

      вивести_д64(М, властивості.значення);

      вивести_формат(М, ФОчистити);

      вернути;
    }
    
    якщо значення.тип == М.значення_структура_Текст {
      змінна предмет = значення як адреса<Предмет>;
      змінна властивості = предмет.властивості як ВластивостіТексту;


      якщо глибина != 0 {
        вивести_формат(М, ФКолірТекстуЗелений);
        вивести(М, "\"");
      }

      якщо глибина == 0 {
        вивести(М, властивості.значення);
      } інакше {
        змінна п: природне = 0;
        поки п < властивості.значення.розмір {
          змінна символ = властивості.значення.дані[п];

          якщо символ == КД::символи::Міжряд {
            вивести(М, "\\р");
          } інакше якщо символ == КД::символи::Дволапка {
            вивести(М, "\\\"");
          } інакше якщо символ == КД::символи::Обернена_похила {
            вивести(М, "\\\\");
          } інакше {
            вивести(М, кд { 1, символ::адреса як памʼять<п8> });
          }

          п += 1;
        }
      }

      якщо глибина != 0 {
        вивести(М, "\"");
        вивести_формат(М, ФОчистити);
      }

      вернути;
    }
    
    якщо значення.тип == М.значення_структура_Код {
      вивести(М, "Код()");
      вернути;
    }
    
    якщо значення.тип == М.значення_структура_Дія {
      змінна предмет = значення як адреса<Предмет>;
      змінна властивості = предмет.властивості як ВластивостіДії;

      вивести_формат(М, ФКолірТекстуСиній);

      якщо властивості.назва == пусто {
        вивести(М, "<дія>");
      } інакше {
        вивести(М, "<дія ");
        
        вивести_значення(М, властивості.назва, 0, 0);

        вивести(М, ">");
      }

      вивести_формат(М, ФОчистити);

      вернути;
    }
    
    якщо значення.тип == М.значення_структура_Список {
      змінна предмет_списку = значення як адреса<Предмет>;
      змінна властивості_списку = предмет_списку.властивості як ВластивостіСписку;
      
      вивести(М, "[");

      якщо властивості_списку.розмір > 0 {
        якщо розмір_відступу > 0 {
          вивести(М, "\р");
        }

        змінна п: природне = 0;
        поки п < властивості_списку.розмір {
          змінна елемент = властивості_списку.елементи[п];
          вивести_пропуски(М, розмір_відступу * (глибина + 1));
          вивести_значення(М, елемент, розмір_відступу, глибина + 1);
          якщо п + 1 < властивості_списку.розмір {
            вивести(М, ",");
            якщо розмір_відступу > 0 {
              вивести(М, "\р");
            } інакше {
              вивести(М, " ");
            }
          }

          п += 1;
        }

        якщо розмір_відступу > 0 {
          вивести(М, "\р");
        }
        вивести_пропуски(М, розмір_відступу * глибина);
      }

      вивести(М, "]");
      
      вернути;
    }
    
    якщо значення.тип == М.значення_структура_Словник {
      змінна предмет_словника = значення як адреса<Предмет>;
      змінна властивості_словника = предмет_словника.властивості як ВластивостіСловника;

      вивести(М, "{");
      якщо властивості_словника.розмір > 0 {
        якщо розмір_відступу > 0 {
          вивести(М, "\р");
        }

        змінна п: природне = 0;
        поки п < властивості_словника.розмір {
          змінна пара = властивості_словника.елементи[п];
          вивести_пропуски(М, розмір_відступу * (глибина + 1));
          вивести_значення(М, пара.ключ, розмір_відступу, глибина + 1);
          вивести(М, " => ");
          вивести_значення(М, пара.значення, розмір_відступу, глибина + 1);
          якщо п + 1 < властивості_словника.розмір {
            вивести(М, ",");
            якщо розмір_відступу > 0 {
              вивести(М, "\р");
            } інакше {
              вивести(М, " ");
            }
          }

          п += 1;
        }

        якщо розмір_відступу > 0 {
          вивести(М, "\р");
        }
        вивести_пропуски(М, розмір_відступу * глибина);
      }
      
      вивести(М, "}");

      вернути;
    }
    
    якщо значення.тип == М.значення_структура_Дані {
      вивести(М, "Дані()");
      вернути;
    }
    
    якщо значення.тип == М.значення_структура_ЗмінніДані {
      вивести(М, "ЗмінніДані()");
      вернути;
    }
    
    якщо значення.тип == М.значення_структура_ДіапазонЦілих {
      вивести(М, "ДіапазонЦілих()");
      вернути;
    }
    
    якщо значення.тип == М.значення_структура_ДіапазонДробових {
      вивести(М, "ДіапазонДробових()");
      вернути;
    }
    
    якщо значення.тип == М.значення_структура_ПеребірДіапазонуЦілих {
      вивести(М, "ПеребірДіапазонуЦілих()");
      вернути;
    }
    
    якщо значення.тип == М.значення_структура_ПеребірДіапазонуДробових {
      вивести(М, "ПеребірДіапазонуДробових()");
      вернути;
    }

    змінна предмет_структури = значення.тип як адреса<Предмет>;
    змінна властивості_структури = предмет_структури.властивості як ВластивостіСтруктури;

    вивести_формат(М, ФКолірТекстуСиній);

    якщо властивості_структури.назва == пусто {
      вивести(М, "<без_назви>");
    } інакше {
      вивести_значення(М, властивості_структури.назва, 0, 0);
    }

    вивести_формат(М, ФОчистити);

    вивести(М, "(");

    якщо властивості_структури.параметри != пусто {
      якщо розмір_відступу > 0 {
        вивести(М, "\р");
      }

      змінна п: природне = 0;
      поки п < властивості_структури.параметри.розмір {
        змінна параметр = властивості_структури.параметри.дані[п];
        змінна предмет_параметра = параметр як адреса<Предмет>;
        змінна властивості_параметра = предмет_параметра.властивості як ВластивостіПараметра;
  
        змінна значення_властивості = отримати_властивість(М, значення, властивості_параметра.назва, Місцезнаходження { пусто, 0});
        вивести_пропуски(М, розмір_відступу * (глибина + 1));
        вивести_значення(М, властивості_параметра.назва, 0, 0);
        вивести(М, "=");
        вивести_значення(М, значення_властивості, розмір_відступу, глибина + 1);
        якщо п + 1 < властивості_структури.параметри.розмір {
          вивести(М, ",");
          якщо розмір_відступу > 0 {
            вивести(М, "\р");
          } інакше {
            вивести(М, " ");
          }
        }
  
        п += 1;
      }

      якщо розмір_відступу > 0 {
        вивести(М, "\р");
      }
      вивести_пропуски(М, розмір_відступу * глибина);
    }

    вивести(М, ")");
  }

  місцева дія надрукувати_значення(М: адреса<Машина>, значення: Значення, розмір_відступу: природне, глибина: природне) {
    вивести_значення(М, значення, розмір_відступу, глибина);
    вивести(М, "\р");
  }
}