взяти означення мавка;

простір мавка {
  місцева дія створити_ціле(М: адреса<Машина>, значення: ц64) -> Значення {
    змінна предмет = виділити_предмет(М, М.значення_структура_Ціле як Значення);
    
    предмет.властивості = ВластивостіЦілого { значення };
    
    вернути предмет як Значення;
  }

  місцева дія предмет_цілого_додати(М: адреса<Машина>, значення: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    змінна ліво_предмет = значення як адреса<Предмет>;
    змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;

    якщо право.тип == М.значення_структура_Ціле {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;
    
      вернути створити_ціле(М, властивості_ліво.значення + властивості_право.значення);
    }

    якщо право.тип == М.значення_структура_Дробове {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
    
      вернути створити_дробове(М, д64(властивості_ліво.значення) + властивості_право.значення);
    }
    
  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Додати до цілого числа можна лише або ціле або дробове число."),
      місцезнаходження
    );
    вернути пусто;
  }
  
  місцева дія предмет_цілого_відняти(М: адреса<Машина>, значення: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    змінна ліво_предмет = значення як адреса<Предмет>;
    змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;

    якщо право.тип == М.значення_структура_Ціле {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;
    
      вернути створити_ціле(М, властивості_ліво.значення - властивості_право.значення);
    }

    якщо право.тип == М.значення_структура_Дробове {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
    
      вернути створити_дробове(М, д64(властивості_ліво.значення) - властивості_право.значення);
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Відняти від цілого числа можна лише або ціле або дробове число."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_помножити(М: адреса<Машина>, значення: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    змінна ліво_предмет = значення як адреса<Предмет>;
    змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;

    якщо право.тип == М.значення_структура_Ціле {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;
    
      вернути створити_ціле(М, властивості_ліво.значення * властивості_право.значення);
    }

    якщо право.тип == М.значення_структура_Дробове {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
    
      вернути створити_дробове(М, д64(властивості_ліво.значення) * властивості_право.значення);
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Помножити ціле число можна лише на або ціле або дробове число."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_поділити(М: адреса<Машина>, значення: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    змінна ліво_предмет = значення як адреса<Предмет>;
    змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;

    якщо право.тип == М.значення_структура_Ціле {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;
    
      вернути створити_дробове(М, д64(властивості_ліво.значення) / д64(властивості_право.значення));
    }

    якщо право.тип == М.значення_структура_Дробове {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
    
      вернути створити_дробове(М, д64(властивості_ліво.значення) / властивості_право.значення);
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Поділити ціле число можна лише на або ціле або дробове число."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_остача(М: адреса<Машина>, значення: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    змінна ліво_предмет = значення як адреса<Предмет>;
    змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;

    якщо право.тип == М.значення_структура_Ціле {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;
    
      вернути створити_ціле(М, властивості_ліво.значення % властивості_право.значення);
    }

    якщо право.тип == М.значення_структура_Дробове {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
    
      вернути створити_дробове(М, д64(властивості_ліво.значення) % властивості_право.значення);
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Отримати остачу ділення цілого числа можна лише з або цілим або дробовим число."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_частка(М: адреса<Машина>, значення: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    змінна ліво_предмет = значення як адреса<Предмет>;
    змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;

    якщо право.тип == М.значення_структура_Ціле {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;
    
      вернути створити_ціле(М, властивості_ліво.значення / властивості_право.значення);
    }

    якщо право.тип == М.значення_структура_Дробове {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
    
      вернути створити_дробове(М, д64(властивості_ліво.значення) / властивості_право.значення);
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Отримати неповну частку ділення цілого числа можна лише з або цілим або дробовим число."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_степінь(М: адреса<Машина>, значення: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    змінна ліво_предмет = значення як адреса<Предмет>;
    змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;

    якщо право.тип == М.значення_структура_Ціле {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;
    
      вернути створити_ціле(М, піднести_до_степеня_ц64(М, властивості_ліво.значення, властивості_право.значення));
    }

    якщо право.тип == М.значення_структура_Дробове {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
    
      вернути створити_дробове(М, піднести_до_степеня_д64(М, д64(властивості_ліво.значення), властивості_право.значення));
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Отримати степінь цілого числа можна лише з або цілим або дробовим число."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_вліво(М: адреса<Машина>, значення: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    змінна ліво_предмет = значення як адреса<Предмет>;
    змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;

    якщо право.тип == М.значення_структура_Ціле {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;
    
      вернути створити_ціле(М, властивості_ліво.значення << властивості_право.значення);
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Зсунути вліво ціле число можна лише з або цілим числом."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_вправо(М: адреса<Машина>, значення: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    змінна ліво_предмет = значення як адреса<Предмет>;
    змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;

    якщо право.тип == М.значення_структура_Ціле {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;
    
      вернути створити_ціле(М, властивості_ліво.значення >> властивості_право.значення);
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Зсунути вправо ціле число можна лише з або цілим числом."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_двійкове_і(М: адреса<Машина>, значення: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    змінна ліво_предмет = значення як адреса<Предмет>;
    змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;

    якщо право.тип == М.значення_структура_Ціле {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;

      вернути створити_ціле(М, властивості_ліво.значення & властивості_право.значення);
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконути двійкове І можна лише між цілими числами."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_двійкове_або(М: адреса<Машина>, значення: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    змінна ліво_предмет = значення як адреса<Предмет>;
    змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;

    якщо право.тип == М.значення_структура_Ціле {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;

      вернути створити_ціле(М, властивості_ліво.значення | властивості_право.значення);
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконути двійкове АБО можна лише між цілими числами."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_двійкове_вабо(М: адреса<Машина>, значення: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    змінна ліво_предмет = значення як адреса<Предмет>;
    змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;

    якщо право.тип == М.значення_структура_Ціле {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;

      вернути створити_ціле(М, властивості_ліво.значення вабо властивості_право.значення);
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконути двійкове ВАБО можна лише між цілими числами."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_менше(М: адреса<Машина>, значення: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    змінна ліво_предмет = значення як адреса<Предмет>;
    змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;

    якщо право.тип == М.значення_структура_Ціле {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;

      якщо властивості_ліво.значення < властивості_право.значення {
        вернути М.значення_дійсне;
      } інакше {
        вернути пусто;
      }
    }

    якщо право.тип == М.значення_структура_Дробове {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіДробового;

      якщо д64(властивості_ліво.значення) < властивості_право.значення {
        вернути М.значення_дійсне;
      } інакше {
        вернути пусто;
      }
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконути перевірку ціле число менше можна з цілим або дробовим числом."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_більше(М: адреса<Машина>, значення: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> ЗначенняАбоСтанПадіння {
    якщо право == пусто {
      стрибнути крок_помилка;
    }

    змінна ліво_предмет = значення як адреса<Предмет>;
    змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;

    якщо право.тип == М.значення_структура_Ціле {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;

      якщо властивості_ліво.значення > властивості_право.значення {
        вернути М.значення_дійсне;
      } інакше {
        вернути пусто;
      }
    }

    якщо право.тип == М.значення_структура_Дробове {
      змінна право_предмет = право як адреса<Предмет>;
      змінна властивості_право = право_предмет.властивості як ВластивостіДробового;

      якщо д64(властивості_ліво.значення) > властивості_право.значення {
        вернути М.значення_дійсне;
      } інакше {
        вернути пусто;
      }
    }

  крок_помилка:
    увімкнути_стан_падіння(
      М,
      створити_текст(М, "Виконути перевірку ціле число менше можна з цілим або дробовим числом."),
      місцезнаходження
    );
    вернути пусто;
  }

  місцева дія предмет_цілого_двійкове_не(М: адреса<Машина>, значення: Значення, місцезнаходження: Місцезнаходження) -> ЗначенняАбоСтанПадіння {
    змінна предмет = значення як адреса<Предмет>;
    змінна властивості_предмета = предмет.властивості як ВластивостіЦілого;
    
    вернути створити_ціле(М, властивості_предмета.значення);
  }

  місцева дія предмет_цілого_змінити_знак(М: адреса<Машина>, значення: Значення, місцезнаходження: Місцезнаходження) -> ЗначенняАбоСтанПадіння {
    змінна предмет = значення як адреса<Предмет>;
    змінна властивості_предмета = предмет.властивості як ВластивостіЦілого;
    
    вернути створити_ціле(М, -властивості_предмета.значення);
  }
}