взяти визначення біб/КД;
взяти визначення мавка;
взяти визначення мавка/розбирач;
взяти визначення мавка/перекладач;
взяти визначення біб/турбо;

зовнішня дія мавка_система_вийти(код: ц32);
зовнішня дія мавка_система_прочитати_файл(шлях: адреса<ю8>, вихід: адреса<ю8>): логічне;
зовнішня дія мавка_система_отримати_абсолютний_шлях(шлях: адреса<ю8>, вихід: адреса<ю8>): логічне;
зовнішня дія мавка_система_отримати_абсолютний_зовнішній_шлях(шлях: адреса<ю8>, вихід: адреса<ю8>): логічне;
зовнішня дія мавка_система_отримати_поточну_папку_процесу(вихід: адреса<ю8>): логічне;
зовнішня дія мавка_система_отримати_назву_файлу_без_розширення(шлях: адреса<ю8>, вихід: адреса<ю8>): логічне;
зовнішня дія мавка_система_прочитати_ю8_зі_стандартного_вводу(префікс: адреса<ю8>, вихід: адреса<ю8>, додати_в_історію: логічне): логічне;
зовнішня дія мавка_система_перевірити_чи_шлях_існує_і_є_файлом(шлях: адреса<ю8>): логічне;
зовнішня дія мавка_отримати_версію_мавки_як_ю8(вихід: адреса<ю8>);

секція мавка {
  місцева дія отримати_версію_мавки_як_т8(М: адреса<Машина>): т8 {

    змінна значення = т8 { 0, пусто };
    змінна значення_ю8 = ю8 { 0, пусто };
    мавка_отримати_версію_мавки_як_ю8(значення_ю8::адреса);
    якщо перекодувати_ю8_в_т8(М, значення_ю8, значення::адреса, ні) == ні {
      // потім: помилка
    }
    вернути значення;
  }

  структура ДаніМашини {
    шлях_до_папки_виконання: ю8;
    обробник_взяття_біб: (М: адреса<Машина>, розмір_шляху: позитивне, шлях: памʼять<адреса<Предмет>>) -> предмет_або_стан_падіння;
  }

  дія машина_виділити_сиру_памʼять(М: адреса<Машина>, розмір: позитивне): памʼять<п8> {
    вернути мавка_система_виділити_сиру_памʼять(розмір);
  }

  дія машина_перевиділити_сиру_памʼять(М: адреса<Машина>, значення: памʼять<п8>, розмір: позитивне): памʼять<п8> {
    вернути мавка_система_перевиділити_сиру_памʼять(значення, розмір);
  }

  дія машина_звільнити_сиру_памʼять(М: адреса<Машина>, значення: памʼять<п8>) {
    мавка_система_звільнити_сиру_памʼять(значення);
  }

  дія машина_померти(М: адреса<Машина>, код: ц32, повідомлення: т8) {

    надрукувати_ю8(М, ю8"СМЕРТЬ!");
    мавка_система_вийти(код);
  }

  дія система_розбирача_виділити_сиру_памʼять(система: адреса<мавка::розбирач::Система>, розмір: позитивне): памʼять<п8> {
    змінна М = система.дані як адреса<Машина>;
    вернути виділити_памʼять<п8>(М, розмір);
  }

  дія система_розбирача_перевиділити_сиру_памʼять(система: адреса<мавка::розбирач::Система>, значення: памʼять<п8>, новий_розмір: позитивне): памʼять<п8> {
    змінна М = система.дані як адреса<Машина>;
    вернути перевиділити_памʼять<п8>(М, значення, новий_розмір);
  }

  дія система_розбирача_звільнити_сиру_памʼять(система: адреса<мавка::розбирач::Система>, значення: невідома_памʼять) {
    змінна М = система.дані як адреса<Машина>;
    звільнити_памʼять(М, значення);
  }

  дія розбирач_дописати_у_стандартний_вивід(система: адреса<мавка::розбирач::Система>, потік: адреса<мавка::розбирач::ВихіднийПотік>, розмір: позитивне, дані: памʼять<п8>): логічне {
    змінна М = система.дані як адреса<Машина>;
    вивести_ю8(М, ю8 { розмір, дані });
    вернути так;
  }

  дія система_перекладача_виділити_сиру_памʼять(система: адреса<мавка::перекладач::Система>, розмір: позитивне): памʼять<п8> {
    змінна М = система.дані як адреса<Машина>;
    вернути виділити_памʼять<п8>(М, розмір);
  }

  дія система_перекладача_перевиділити_сиру_памʼять(система: адреса<мавка::перекладач::Система>, значення: памʼять<п8>, новий_розмір: позитивне): памʼять<п8> {
    змінна М = система.дані як адреса<Машина>;
    вернути перевиділити_памʼять<п8>(М, значення, новий_розмір);
  }

  дія система_перекладача_звільнити_сиру_памʼять(система: адреса<мавка::перекладач::Система>, значення: невідома_памʼять) {
    змінна М = система.дані як адреса<Машина>;
    звільнити_памʼять(М, значення);
  }

  дія перекладач_дописати_у_стандартний_вивід(система: адреса<мавка::перекладач::Система>, потік: адреса<мавка::перекладач::ВихіднийПотік>, розмір: позитивне, дані: памʼять<п8>): логічне {
    змінна М = система.дані як адреса<Машина>;
    вивести_ю8(М, ю8 { розмір, дані });
    вернути так;
  }

  дія код_в_ПредметКоду(М: адреса<Машина>, шлях: адреса<ПредметЮнікоду>, сирі_константи: Послідовність<п8>, сирі_вказівки: Послідовність<п8>): адреса<ПредметКоду> {
    змінна константи = зробити_накопичувач<адреса<Предмет>>(М);
    змінна п: позитивне = 0;
    поки п < сирі_константи.розмір {
      змінна вид_константи = сирі_константи.дані[п];
      якщо вид_константи == мавка::перекладач::ВидКонстантиНазва {
        п += 1;
        змінна адреса_на_розмір_назви = сирі_константи.дані[п]::адреса як адреса<позитивне>;
        змінна розмір_назви = адреса_на_розмір_назви::вміст;
        п += 7;
        якщо розмір_назви > 0 {
          п += 1;
          змінна предмет_назви = створити_предмет_тексту(М, т8 { розмір_назви, сирі_константи.дані[п]::адреса як памʼять<п8> });
          покласти_в_накопичувач<адреса<Предмет>>(М, константи::адреса, предмет_назви як адреса<Предмет>);
          п += (розмір_назви - 1);
        } інакше {
          змінна предмет_назви = створити_предмет_тексту(М, "");
          покласти_в_накопичувач<адреса<Предмет>>(М, константи::адреса, предмет_назви як адреса<Предмет>);
        }
      } інакше якщо вид_константи == мавка::перекладач::ВидКонстантиЧисло {
        п += 1;
        змінна адреса_на_значення = сирі_константи.дані[п]::адреса як адреса<д64>;
        змінна значення = адреса_на_значення::вміст;
        змінна предмет_числа = створити_предмет_числа(М, значення);
        покласти_в_накопичувач<адреса<Предмет>>(М, константи::адреса, предмет_числа як адреса<Предмет>);
        п += 7;
      } інакше якщо вид_константи == мавка::перекладач::ВидКонстантиТекст {
        п += 1;
        змінна адреса_на_розмір_тексту = сирі_константи.дані[п]::адреса як адреса<позитивне>;
        змінна розмір_тексту = адреса_на_розмір_тексту::вміст;
        п += 7;
        якщо розмір_тексту > 0 {
          п += 1;
          змінна предмет_тексту = створити_предмет_тексту(М, т8 { розмір_тексту, сирі_константи.дані[п]::адреса як памʼять<п8> });
          покласти_в_накопичувач<адреса<Предмет>>(М, константи::адреса, предмет_тексту як адреса<Предмет>);
          п += (розмір_тексту - 1);
        } інакше {
          змінна предмет_тексту = створити_предмет_тексту(М, "");
          покласти_в_накопичувач<адреса<Предмет>>(М, константи::адреса, предмет_тексту як адреса<Предмет>);
        }
      } інакше якщо вид_константи == мавка::перекладач::ВидКонстантиЮнікод8 {
        п += 1;
        змінна адреса_на_розмір_юнікоду8 = сирі_константи.дані[п]::адреса як адреса<позитивне>;
        змінна розмір_юнікоду8 = адреса_на_розмір_юнікоду8::вміст;
        п += 7;
        якщо розмір_юнікоду8 > 0 {
          п += 1;
          змінна значення_ю32 = ю32 { 0, пусто };
          якщо перекодувати_ю8_в_ю32(М, ю8 { розмір_юнікоду8, сирі_константи.дані[п]::адреса як памʼять<п8> }, значення_ю32::адреса, ні) == ні {
            ПОМЕРТИ(М, "Ой...");
          }
          змінна предмет_юнікоду = створити_предмет_юнікоду(М, значення_ю32);
          звільнити_памʼять(М, значення_ю32.дані);
          покласти_в_накопичувач<адреса<Предмет>>(М, константи::адреса, предмет_юнікоду як адреса<Предмет>);
          п += (розмір_юнікоду8 - 1);
        } інакше {
          змінна предмет_юнікоду = створити_предмет_юнікоду(М, ю32 { 0, пусто });
          покласти_в_накопичувач<адреса<Предмет>>(М, константи::адреса, предмет_юнікоду як адреса<Предмет>);
        }
      } інакше якщо вид_константи == мавка::перекладач::ВидКонстантиЮнікод32 {
        п += 1;
        змінна адреса_на_розмір_юнікоду32 = сирі_константи.дані[п]::адреса як адреса<позитивне>;
        змінна розмір_юнікоду32 = адреса_на_розмір_юнікоду32::вміст;
        п += 7;
        якщо розмір_юнікоду32 > 0 {
          п += 1;
          змінна предмет_юнікоду = створити_предмет_юнікоду(М, ю32 { розмір_юнікоду32, сирі_константи.дані[п]::адреса як памʼять<п32> });
          покласти_в_накопичувач<адреса<Предмет>>(М, константи::адреса, предмет_юнікоду як адреса<Предмет>);
          п += ((розмір_юнікоду32 * 4) - 1);
        } інакше {
          змінна предмет_юнікоду = створити_предмет_юнікоду(М, ю32 { 0, пусто });
          покласти_в_накопичувач<адреса<Предмет>>(М, константи::адреса, предмет_юнікоду як адреса<Предмет>);
        }
      } інакше якщо вид_константи == мавка::перекладач::ВидКонстантиКод {
        п += 1;
        змінна адреса_на_розмір_констант = сирі_константи.дані[п]::адреса як адреса<позитивне>;
        змінна розмір_констант = адреса_на_розмір_констант::вміст;
        п += 7;
        змінна константи_дії = Послідовність<п8> { 0, пусто };
        якщо розмір_констант > 0 {
          п += 1;
          константи_дії = Послідовність<п8> { розмір_констант, сирі_константи.дані[п]::адреса як памʼять<п8> };
          п += (розмір_констант - 1);
        } інакше {
          // ...
        }
        п += 1;
        змінна адреса_на_розмір_вказівок = сирі_константи.дані[п]::адреса як адреса<позитивне>;
        змінна розмір_вказівок = адреса_на_розмір_вказівок::вміст;
        п += 7;
        змінна вказівки_дії = Послідовність<п8> { 0, пусто };
        якщо розмір_вказівок > 0 {
          п += 1;
          вказівки_дії = Послідовність<п8> { розмір_вказівок, сирі_константи.дані[п]::адреса як памʼять<п8> };
          п += (розмір_вказівок - 1);
        } інакше {
          // ...
        }
        змінна предмет_коду = код_в_ПредметКоду(М, шлях, константи_дії, вказівки_дії);
        покласти_в_накопичувач<адреса<Предмет>>(М, константи::адреса, предмет_коду як адреса<Предмет>);
      } інакше {
        // потім: помилка
      }
      п += 1;
    }
    змінна вказівки: памʼять<п8> = пусто;
    якщо виділити_копію_памʼяті(М, сирі_вказівки.розмір, сирі_вказівки.дані, вказівки::адреса) == ні {
      // потім: помилка
    }
    змінна байти = створити_предмет_байтів_без_копіювання(М, сирі_вказівки.розмір, вказівки);
    вернути створити_предмет_коду_1(М, шлях, Послідовність<адреса<Предмет>> { константи.розмір, константи.дані }, байти);
  }

  дія код_перекладача_в_ПредметКоду(М: адреса<Машина>, шлях: адреса<ПредметЮнікоду>, код_перекладача: адреса<мавка::перекладач::Код>): адреса<ПредметКоду> {
    вернути код_в_ПредметКоду(М, шлях, Послідовність<п8> { код_перекладача.накопичувач_констант.розмір, код_перекладача.накопичувач_констант.дані }, Послідовність<п8> { код_перекладача.накопичувач_вказівок.розмір, код_перекладача.накопичувач_вказівок.дані });
  }

  дія отримати_шлях_взяття_до_модуля(М: адреса<Машина>, назва_паку: адреса<ПредметТексту>, кількість_назв_шляху: позитивне, назви_шляху: памʼять<адреса<ПредметТексту>>): адреса<ПредметЮнікоду> {
    змінна дані_машини = М.дані як адреса<ДаніМашини>;
    змінна накопичувач_шляху = зробити_накопичувач<п8>(М);
    покласти_в_накопичувач_ю8(М, накопичувач_шляху::адреса, дані_машини.шлях_до_папки_виконання);
    якщо назва_паку != пусто {
      покласти_в_накопичувач_ю8(М, накопичувач_шляху::адреса, ю8"/паки/");
      покласти_т8_в_накопичувач_ю8(М, накопичувач_шляху::адреса, назва_паку.значення);
    }
    змінна п: позитивне = 0;
    поки п < кількість_назв_шляху {
      покласти_в_накопичувач_ю8(М, накопичувач_шляху::адреса, ю8"/");
      покласти_т8_в_накопичувач_ю8(М, накопичувач_шляху::адреса, назви_шляху[п].значення);
      п += 1;
    }
    покласти_в_накопичувач_ю8(М, накопичувач_шляху::адреса, ю8".ю8.м");
    змінна предмет_шляху = створити_предмет_юнікоду_з_ю8(М, ю8 { накопичувач_шляху.розмір, накопичувач_шляху.дані });
    звільнити_накопичувач<п8>(М, накопичувач_шляху);
    вернути предмет_шляху;
  }

  дія машина_взяти_файл(М: адреса<Машина>, назва_паку: адреса<ПредметТексту>, назва_модуля: адреса<ПредметТексту>, предмет_шляху: адреса<ПредметЮнікоду>): предмет_або_стан_падіння {
    змінна взятий_предмет: адреса<Предмет> = пусто;
    якщо отримати_взятий_предмет(М, предмет_шляху як адреса<Предмет>, взятий_предмет::адреса) {
      вернути взятий_предмет;
    }
    змінна шлях_ю8 = ю8 { 0, пусто };
    якщо перекодувати_ю32_в_ю8(М, предмет_шляху.значення, шлях_ю8::адреса, ні) == ні {
      вернути результат_стан_падіння(М, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 }, створити_предмет_тексту(М, "Не вдалось перекодувати шлях") як адреса<Предмет>);
    }
    якщо мавка_система_перевірити_чи_шлях_існує_і_є_файлом(шлях_ю8::адреса) == ні {
      звільнити_памʼять(М, шлях_ю8.дані);
      вернути результат_стан_падіння(М, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 }, створити_предмет_тексту(М, "Файл модуля не знайдено") як адреса<Предмет>);
    }
    якщо перевірити_чи_ю8_закінчується_на(шлях_ю8, ю8".ю8.м") == ні {
      звільнити_памʼять(М, шлях_ю8.дані);
      вернути результат_стан_падіння(М, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 }, створити_предмет_тексту(М, "Шлях повинен закінчуватися на .ю8.м") як адреса<Предмет>);
    }
    змінна значення_файлу = ю8 { 0, пусто };
    якщо мавка_система_прочитати_файл(шлях_ю8::адреса, значення_файлу::адреса) == ні {
      звільнити_памʼять(М, шлях_ю8.дані);
      вернути результат_стан_падіння(М, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 }, створити_предмет_тексту(М, "Не вдалось прочитати файл") як адреса<Предмет>);
    }
    звільнити_памʼять(М, шлях_ю8.дані);

    змінна система_розбирача = мавка::розбирач::Система {
      дані = М,
      виділити_сиру_памʼять = система_розбирача_виділити_сиру_памʼять,
      перевиділити_сиру_памʼять = система_розбирача_перевиділити_сиру_памʼять,
      звільнити_сиру_памʼять = система_розбирача_звільнити_сиру_памʼять,
    };
    змінна вихідний_потік_розбирача = мавка::розбирач::ВихіднийПотік {
      дані = М,
      дописати = розбирач_дописати_у_стандартний_вивід
    };

    змінна слова = мавка::розбирач::Слова { 0, пусто };
    змінна помилка_розбору_на_слова = мавка::розбирач::ПомилкаРозборуНаСлова { ... };
    якщо мавка::розбирач::розібрати_ю8_на_слова(система_розбирача::адреса, значення_файлу, слова::адреса, помилка_розбору_на_слова::адреса) == ні {
      звільнити_памʼять(М, значення_файлу.дані);
      вернути результат_стан_падіння(М, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 }, створити_предмет_тексту(М, "Не вдалось розібрати на слова") як адреса<Предмет>);
    }
    змінна гілки = мавка::розбирач::Гілки { 0, пусто };
    змінна помилка_розбору_на_гілки = мавка::розбирач::ПомилкаРозборуНаГілки { ... };
    якщо мавка::розбирач::розібрати_слова_на_гілки(система_розбирача::адреса, значення_файлу, слова, гілки::адреса, помилка_розбору_на_гілки::адреса) == ні {
      мавка::розбирач::звільнити_слова(система_розбирача::адреса, слова);
      звільнити_памʼять(М, значення_файлу.дані);
      вернути результат_стан_падіння(М, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 }, створити_предмет_тексту(М, "Не вдалось розібрати на гілки") як адреса<Предмет>);
    }

    змінна система_перекладача = мавка::перекладач::Система {
      дані = М,
      виділити_сиру_памʼять = система_перекладача_виділити_сиру_памʼять,
      перевиділити_сиру_памʼять = система_перекладача_перевиділити_сиру_памʼять,
      звільнити_сиру_памʼять = система_перекладача_звільнити_сиру_памʼять,
    };
    змінна вихідний_потік_перекладача = мавка::перекладач::ВихіднийПотік {
      дані = М,
      дописати = перекладач_дописати_у_стандартний_вивід
    };
    змінна код_МаМа = мавка::перекладач::створити_код(система_перекладача::адреса);
    змінна контекст = мавка::перекладач::створити_контекст(система_перекладача::адреса, значення_файлу, слова);
    змінна помилка_перекладу = мавка::перекладач::ПомилкаПерекладуВМаМа { ... };
    якщо мавка::перекладач::перекласти_в_МаМа(система_перекладача::адреса, контекст, гілки, ні, код_МаМа, помилка_перекладу::адреса) == ні {
      змінна предмет_помилки = створити_предмет_тексту(М, помилка_перекладу.повідомлення);
      звільнити_памʼять(М, помилка_перекладу.повідомлення.дані);
      мавка::розбирач::звільнити_слова(система_розбирача::адреса, слова);
      мавка::розбирач::звільнити_гілки(система_розбирача::адреса, гілки);
      мавка::перекладач::знищити_код(система_перекладача::адреса, код_МаМа);
      мавка::перекладач::знищити_контекст(система_перекладача::адреса, контекст);
      звільнити_памʼять(М, значення_файлу.дані);
      вернути результат_стан_падіння(М, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 }, предмет_помилки як адреса<Предмет>);
    }
  //  мавка::перекладач::вивести_КодМаМа(система_перекладача::адреса, вихідний_потік_перекладача::адреса, код_МаМа);

    змінна предмет_коду = код_перекладача_в_ПредметКоду(М, предмет_шляху, код_МаМа);
    змінна притримувач = покласти_притримувач(М);
    притримати(М, притримувач, предмет_коду як адреса<Предмет>);

    змінна предмет_модуля = створити_предмет_модуля(М, створити_назву(М, назва_модуля.значення));
    предмет_модуля.назва_паку = назва_паку;
    покласти_взятий_предмет(М, предмет_шляху як адреса<Предмет>, предмет_модуля як адреса<Предмет>);
    змінна предмет_середовища = створити_предмет_середовища(М, М.предмет_глобального_середовища, предмет_модуля, предмет_модуля як адреса<Предмет>);
    притримати(М, притримувач, предмет_середовища як адреса<Предмет>);
    змінна результат = виконати_код(М, предмет_коду, предмет_середовища);

    забрати_притримувач(М);
    мавка::розбирач::звільнити_слова(система_розбирача::адреса, слова);
    мавка::розбирач::звільнити_гілки(система_розбирача::адреса, гілки);
    мавка::перекладач::знищити_код(система_перекладача::адреса, код_МаМа);
    мавка::перекладач::знищити_контекст(система_перекладача::адреса, контекст);
    звільнити_памʼять(М, значення_файлу.дані);



    якщо перевірити_чи_стан_падіння(М) {
      вернути результат;
    }

    вернути предмет_модуля як адреса<Предмет>;
  }

  дія машина_обробник_взяття(М: адреса<Машина>, назва_паку: адреса<ПредметТексту>, назва_репозиторія: адреса<ПредметТексту>, кількість_назв_шляху: позитивне, назви_шляху: памʼять<адреса<ПредметТексту>>): предмет_або_стан_падіння {
    якщо перевірити_чи_предмети_назви_рівні(М, назва_репозиторія, створити_назву(М, "модуль")) {
      змінна предмет_шляху = отримати_шлях_взяття_до_модуля(М, назва_паку, кількість_назв_шляху, назви_шляху);
      вернути машина_взяти_файл(М, назва_паку, назви_шляху[кількість_назв_шляху - 1], предмет_шляху);
    }
    якщо перевірити_чи_предмети_назви_рівні(М, назва_репозиторія, створити_назву(М, "пак")) {
      змінна предмет_шляху = отримати_шлях_взяття_до_модуля(М, назви_шляху[0], кількість_назв_шляху, назви_шляху);
      вернути машина_взяти_файл(М, назви_шляху[0], назви_шляху[кількість_назв_шляху - 1], предмет_шляху);
    }
    якщо перевірити_чи_предмети_назви_рівні(М, назва_репозиторія, створити_назву(М, "біб")) {

      змінна дані_машини = М.дані як адреса<ДаніМашини>;
      змінна результат = дані_машини.обробник_взяття_біб(М, кількість_назв_шляху, назви_шляху як памʼять<адреса<Предмет>>);
      вернути результат як адреса<Предмет>;
    }
    вернути результат_стан_падіння(М, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 }, створити_предмет_тексту(М, "Неможливо взяти") як адреса<Предмет>);
  }

  місцева дія створити_машину(): адреса<Машина> {
    змінна М = мавка_система_виділити_сиру_памʼять(Машина.розмір) як адреса<Машина>;

    налаштувати_машину(М, Система {
      виділити_сиру_памʼять = машина_виділити_сиру_памʼять,
      перевиділити_сиру_памʼять = машина_перевиділити_сиру_памʼять,
      звільнити_сиру_памʼять = машина_звільнити_сиру_памʼять,
      померти = машина_померти
    });
    М.обробник_взяття = машина_обробник_взяття;

    змінна дані_машини = виділити<ДаніМашини>(М);
    дані_машини.шлях_до_папки_виконання = ю8 { 0, пусто };
    дані_машини.обробник_взяття_біб = пусто;
    мавка_система_отримати_поточну_папку_процесу(дані_машини.шлях_до_папки_виконання::адреса);
    М.дані = дані_машини;

    вернути М;
  }

  місцева дія знищити_машину(М: адреса<Машина>) {
    змінна дані_машини = М.дані як адреса<ДаніМашини>;
    звільнити_памʼять(М, дані_машини.шлях_до_папки_виконання.дані);
    звільнити(М, дані_машини);
    очистити(М);
    розлаштувати_машину(М);
    мавка_система_звільнити_сиру_памʼять(М як памʼять<п8>);
  }

  місцева дія взяти_файл_шлях_ю8(М: адреса<Машина>, шлях: ю8): предмет_або_стан_падіння {

    змінна шлях_до_файлу = ю8 { 0, пусто };
    мавка_система_отримати_абсолютний_шлях(шлях::адреса, шлях_до_файлу::адреса);
    змінна назва_файлу_без_розширення = ю8 { 0, пусто };
    мавка_система_отримати_назву_файлу_без_розширення(шлях_до_файлу::адреса, назва_файлу_без_розширення::адреса);
    змінна назва_файлу_без_розширення_т8 = т8 { 0, пусто };
    якщо перекодувати_ю8_в_т8(М, назва_файлу_без_розширення, назва_файлу_без_розширення_т8::адреса, ні) == ні {
      ПОМЕРТИ(М, "Не вдалось отримати назву файлу без розширення");
    }
    звільнити_памʼять(М, назва_файлу_без_розширення.дані);
    змінна назва_модуля = створити_назву(М, назва_файлу_без_розширення_т8);
    звільнити_памʼять(М, назва_файлу_без_розширення_т8.дані);
    змінна результат = машина_взяти_файл(М, пусто, назва_модуля, створити_предмет_юнікоду_з_ю8(М, шлях_до_файлу));
    звільнити_памʼять(М, шлях_до_файлу.дані);
    вернути результат;
  }

  дія виконати_ю8(М: адреса<Машина>, середовище: адреса<ПредметСередовища>, значення_файлу: ю8): предмет_або_стан_падіння {
    змінна система_розбирача = мавка::розбирач::Система {
      дані = М,
      виділити_сиру_памʼять = система_розбирача_виділити_сиру_памʼять,
      перевиділити_сиру_памʼять = система_розбирача_перевиділити_сиру_памʼять,
      звільнити_сиру_памʼять = система_розбирача_звільнити_сиру_памʼять,
    };
    змінна вихідний_потік_розбирача = мавка::розбирач::ВихіднийПотік {
      дані = М,
      дописати = розбирач_дописати_у_стандартний_вивід
    };

    змінна слова = мавка::розбирач::Слова { 0, пусто };
    змінна помилка_розбору_на_слова = мавка::розбирач::ПомилкаРозборуНаСлова { ... };
    якщо мавка::розбирач::розібрати_ю8_на_слова(система_розбирача::адреса, значення_файлу, слова::адреса, помилка_розбору_на_слова::адреса) == ні {
      вернути результат_стан_падіння(М, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 }, створити_предмет_тексту(М, "Не вдалось розібрати на слова") як адреса<Предмет>);
    }
    змінна гілки = мавка::розбирач::Гілки { 0, пусто };
    змінна помилка_розбору_на_гілки = мавка::розбирач::ПомилкаРозборуНаГілки { ... };
    якщо мавка::розбирач::розібрати_слова_на_гілки(система_розбирача::адреса, значення_файлу, слова, гілки::адреса, помилка_розбору_на_гілки::адреса) == ні {
      мавка::розбирач::звільнити_слова(система_розбирача::адреса, слова);
      вернути результат_стан_падіння(М, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 }, створити_предмет_тексту(М, "Не вдалось розібрати на гілки") як адреса<Предмет>);
    }

    змінна система_перекладача = мавка::перекладач::Система {
      дані = М,
      виділити_сиру_памʼять = система_перекладача_виділити_сиру_памʼять,
      перевиділити_сиру_памʼять = система_перекладача_перевиділити_сиру_памʼять,
      звільнити_сиру_памʼять = система_перекладача_звільнити_сиру_памʼять,
    };
    змінна вихідний_потік_перекладача = мавка::перекладач::ВихіднийПотік {
      дані = М,
      дописати = перекладач_дописати_у_стандартний_вивід
    };

    змінна код_МаМа = мавка::перекладач::створити_код(система_перекладача::адреса);
    змінна контекст = мавка::перекладач::створити_контекст(система_перекладача::адреса, значення_файлу, слова);
    змінна помилка_перекладу = мавка::перекладач::ПомилкаПерекладуВМаМа { ... };
    якщо мавка::перекладач::перекласти_в_МаМа(система_перекладача::адреса, контекст, гілки, так, код_МаМа, помилка_перекладу::адреса) == ні {
      змінна предмет_помилки = створити_предмет_тексту(М, помилка_перекладу.повідомлення);
      звільнити_памʼять(М, помилка_перекладу.повідомлення.дані);
      мавка::розбирач::звільнити_слова(система_розбирача::адреса, слова);
      мавка::розбирач::звільнити_гілки(система_розбирача::адреса, гілки);
      мавка::перекладач::знищити_код(система_перекладача::адреса, код_МаМа);
      мавка::перекладач::знищити_контекст(система_перекладача::адреса, контекст);
      вернути результат_стан_падіння(М, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 }, предмет_помилки як адреса<Предмет>);
    }

    змінна предмет_коду = код_перекладача_в_ПредметКоду(М, пусто, код_МаМа);
    змінна притримувач = покласти_притримувач(М);
    притримати(М, притримувач, предмет_коду як адреса<Предмет>);

    притримати(М, притримувач, середовище як адреса<Предмет>);
    змінна результат = виконати_код(М, предмет_коду, середовище);

    забрати_притримувач(М);
    мавка::розбирач::звільнити_слова(система_розбирача::адреса, слова);
    мавка::розбирач::звільнити_гілки(система_розбирача::адреса, гілки);
    мавка::перекладач::знищити_код(система_перекладача::адреса, код_МаМа);
    мавка::перекладач::знищити_контекст(система_перекладача::адреса, контекст);

    вернути результат;
  }

  дія діалог_виконати(М: адреса<Машина>, середовище: адреса<ПредметСередовища>, значення: ю8) {

    змінна стан = зберегти_стан_розмірів_машини(М);
    змінна результат = виконати_ю8(М, середовище, значення);
    якщо перевірити_чи_стан_падіння(М) {
      змінна інформація_падіння = отримати_інформацію_падіння(М);
      надрукувати_падіння(М, інформація_падіння, результат);
      знищити_інформацію_падіння(М, інформація_падіння);
      відновити_стан_розмірів_машини(М, стан);
      М.стан_падіння = позитивне(ні);
    } інакше {
      вивести_предмет(М, результат, 1);
      вивести_ю8(М, ю8"\р");
    }
  }

  структура ДаніДіалогу {
    М: адреса<Машина>;
    глобально_притриманий_предмет_середовища: адреса<ГлобальноПритриманийПредмет>;
  }

  дія обробник_вводу_діалогу(турбіна: адреса<турбо::Турбіна>, аргумент: невідома_адреса, скасовано: логічне, розмір_префікса: позитивне, дані_префікса: памʼять<п8>, розмір: позитивне, дані: памʼять<п8>) {
    змінна дані_діалогу = аргумент як адреса<ДаніДіалогу>;
    змінна М = дані_діалогу.М;

    якщо скасовано {
      відпустити_глобально(М, дані_діалогу.глобально_притриманий_предмет_середовища);
      звільнити(М, дані_діалогу);
      звільнити_памʼять(М, дані_префікса);
    } інакше {
      змінна значення = ю8 { розмір, дані };
      якщо значення.розмір > 0 {
        діалог_виконати(М, отримати_глобально_притриманий_предмет(М, дані_діалогу.глобально_притриманий_предмет_середовища) як адреса<ПредметСередовища>, значення);
      }
      звільнити_памʼять(М, значення.дані);

      турбо::прочитати_ввід_ю8(турбіна, обробник_вводу_діалогу, дані_діалогу, ю8 { розмір_префікса, дані_префікса });
    }
  }

  місцева дія почати_діалог(М: адреса<Машина>) {

    змінна предмет_середовища = створити_предмет_середовища(М, М.предмет_глобального_середовища, пусто, пусто);

    змінна дані_діалогу = виділити<ДаніДіалогу>(М);
    дані_діалогу.М = М;
    дані_діалогу.глобально_притриманий_предмет_середовища = притримати_глобально(М, предмет_середовища як адреса<Предмет>);

    змінна турбіна = турбо::отримати_глобальну_турбіну();

    змінна розмір_префікса: позитивне = 2;
    змінна дані_префікса = виділити_памʼять<п8>(М, розмір_префікса);
    дані_префікса[0] = 45; // "-"
    дані_префікса[1] = 32; // " "

    турбо::прочитати_ввід_ю8(турбіна, обробник_вводу_діалогу, дані_діалогу, ю8 { розмір_префікса, дані_префікса });
  }

  місцева дія запланувати_виконання(М: адреса<Машина>, обробник: ОбробникЗапланованогоВиконання, дані: невідома_адреса, відклик_перед_знищенням: ВідкликПередЗнищеннямЗапланованогоВиконання, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>): логічне {

    вернути покласти_в_чергу_запланованих_виконань(М, обробник як невідома_адреса як ОбробникЗапланованогоВиконання, дані, відклик_перед_знищенням як невідома_адреса як ВідкликПередЗнищеннямЗапланованогоВиконання, кількість_аргументів, аргументи як памʼять<адреса<Предмет>>);
  }

  дія обробник_запланованого_виконання_падіння(М: адреса<Машина>, дані: невідома_адреса, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>): предмет_або_стан_падіння {
    вернути аргументи[0];
  }

  місцева дія запланувати_падіння(М: адреса<Машина>, предмет_помилки: адреса<Предмет>): логічне {

    змінна кількість_аргументів: позитивне = 1;
    змінна аргументи = виділити_памʼять<адреса<Предмет>>(М, кількість_аргументів);
    аргументи[0] = предмет_помилки;
    змінна о = обробник_запланованого_виконання_падіння;
    вернути покласти_першим_в_чергу_запланованих_виконань(
      М,
      о як невідома_адреса як ОбробникЗапланованогоВиконання,
      пусто,
      пусто,
      кількість_аргументів,
      аргументи як памʼять<адреса<Предмет>>
    );
  }

  місцева дія встановити_обробник_взяття_біб(М: адреса<Машина>, обробник_взяття_біб: ОбробникВзяттяБіб) {

    змінна дані_машини = М.дані як адреса<ДаніМашини>;
    дані_машини.обробник_взяття_біб = обробник_взяття_біб;
  }
}

секція мавка {
  місцева дія отримати_інформацію_падіння(М: адреса<Машина>): адреса<ІнформаціяПадіння> {
    якщо перевірити_чи_стан_падіння(М) {
      змінна інформація_падіння = виділити<ІнформаціяПадіння>(М);
      інформація_падіння.місцезнаходження = Місцезнаходження {
        шлях = М.місцезнаходження_падіння.шлях як адреса<ПредметТексту>,
        рядок = М.місцезнаходження_падіння.рядок,
      };
      змінна накопичувач_історії = зробити_накопичувач<ЕлементІсторіїВиконання>(М);
      змінна п: позитивне = 0;
      поки п < М.історія.розмір {
        змінна елемент_історії = М.історія.дані[п];
        змінна елемент_історії_виконання = ЕлементІсторіїВиконання { ... };
        якщо елемент_історії.предмет_дії != пусто {
          якщо елемент_історії.предмет_дії.назва != пусто {
            якщо елемент_історії.місцезнаходження.шлях як адреса<ПредметТексту> != пусто {
              якщо виділити_копію_т8(М, елемент_історії.предмет_дії.назва.значення, елемент_історії_виконання.назва::адреса) == ні {
                // потім_помилка
              }
              елемент_історії_виконання.місцезнаходження = Місцезнаходження {
                шлях = елемент_історії.місцезнаходження.шлях як адреса<ПредметТексту>,
                рядок = елемент_історії.місцезнаходження.рядок
              };
              покласти_в_накопичувач<ЕлементІсторіїВиконання>(М, накопичувач_історії::адреса, елемент_історії_виконання);
            }
          }
        }
        п += 1;
      }
      інформація_падіння.розмір_історії = накопичувач_історії.розмір;
      інформація_падіння.історія = накопичувач_історії.дані;
      вернути інформація_падіння;
    }
    вернути пусто;
  }

  місцева дія знищити_інформацію_падіння(М: адреса<Машина>, інформація_падіння: адреса<ІнформаціяПадіння>) {

    змінна п: позитивне = 0;
    поки п < інформація_падіння.розмір_історії {
      звільнити_памʼять(М, інформація_падіння.історія[п].назва.дані);
      п += 1;
    }
    звільнити_памʼять(М, інформація_падіння.історія);
    звільнити(М, інформація_падіння);
  }
}

секція мавка {
  місцева дія змінити_в_глобальному_середовищі(М: адреса<Машина>, назва: адреса<ПредметТексту>, значення: адреса<Предмет>): предмет_або_стан_падіння {

    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва як адреса<ПредметТексту>, значення як адреса<Предмет>);
    вернути пусто;
  }

  місцева дія надрукувати_падіння(М: адреса<Машина>, інформація_падіння: адреса<ІнформаціяПадіння>, предмет_помилки: адреса<Предмет>) {
    вивести_ю8(М, ю8"Падіння");
    якщо інформація_падіння.місцезнаходження.шлях як адреса<ПредметТексту> == пусто {
      вивести_ю8(М, ю8": ");
    } інакше {
      вивести_ю8(М, ю8" в ");
      вивести_предмет(М, інформація_падіння.місцезнаходження.шлях як адреса<ПредметТексту> як адреса<Предмет>, 0);
      вивести_ю8(М, ю8":");
      вивести_позитивне(М, інформація_падіння.місцезнаходження.рядок);
      вивести_ю8(М, ю8": ");
    }
    вивести_предмет(М, предмет_помилки, 0);
    вивести_ю8(М, ю8"\р");
    змінна виведено_перший_елемент_історії = ні;
    змінна п: позитивне = 0;
    поки п < інформація_падіння.розмір_історії {
      змінна елемент_історії = інформація_падіння.історія[п];
      якщо виведено_перший_елемент_історії == ні {
        вивести_ю8(М, ю8"\рІсторія виконання:\р");
        виведено_перший_елемент_історії = так;
      }
      вивести_ю8(М, ю8"  ");
      вивести_т8(М, елемент_історії.назва);
      вивести_ю8(М, ю8" в ");
      вивести_предмет(М, елемент_історії.місцезнаходження.шлях як адреса<ПредметТексту> як адреса<Предмет>, 0);
      вивести_ю8(М, ю8":");
      вивести_позитивне(М, елемент_історії.місцезнаходження.рядок);
      вивести_ю8(М, ю8"\р");
      п += 1;
    }
  }

  структура ДаніРідноїДіїМавки {
    рідна_дія: РіднаДія;
    дані: невідома_адреса;
    зробити_копію_даних: ЗробитиКопіюДанихПредметаДії;
    відклик_перед_звільненням: ВідкликПередЗвільненнямПредметаДії;
  }

  дія рідна_дія_мавки(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
    змінна дані_рідної_дії_мавки = предмет_дії.дані як адреса<ДаніРідноїДіїМавки>;

    змінна результат = дані_рідної_дії_мавки.рідна_дія(М, предмет_дії, предмет_я як адреса<Предмет>, кількість_аргументів, аргументи як памʼять<адреса<Предмет>>, пусто, Місцезнаходження { місцезнаходження.шлях як адреса<ПредметТексту> як адреса<Предмет>, місцезнаходження.рядок });
    вернути результат;
  }

  дія зробити_копію_даних_рідної_дії_мавки(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>): невідома_адреса {

    змінна дані_рідної_дії_мавки = предмет_дії.дані як адреса<ДаніРідноїДіїМавки>;
    змінна копія_даних_рідної_дії_мавки = виділити<ДаніРідноїДіїМавки>(М);
    копія_даних_рідної_дії_мавки.рідна_дія = дані_рідної_дії_мавки.рідна_дія;
    якщо дані_рідної_дії_мавки.зробити_копію_даних == пусто {
      копія_даних_рідної_дії_мавки.дані = дані_рідної_дії_мавки.дані;
    } інакше {
      копія_даних_рідної_дії_мавки.дані = дані_рідної_дії_мавки.зробити_копію_даних(М, предмет_дії);
    }
    копія_даних_рідної_дії_мавки.зробити_копію_даних = дані_рідної_дії_мавки.зробити_копію_даних;
    копія_даних_рідної_дії_мавки.відклик_перед_звільненням = дані_рідної_дії_мавки.відклик_перед_звільненням;
    вернути копія_даних_рідної_дії_мавки;
  }

  дія відклик_перед_звільненням_рідної_дії_мавки(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>) {

    змінна дані_рідної_дії_мавки = предмет_дії.дані як адреса<ДаніРідноїДіїМавки>;
    якщо дані_рідної_дії_мавки.відклик_перед_звільненням != пусто {
      дані_рідної_дії_мавки.відклик_перед_звільненням(М, предмет_дії);
    }
    звільнити(М, дані_рідної_дії_мавки);
  }
}

секція мавка {
  місцева дія почати_спробу(М: адреса<Машина>): адреса<Спроба> {
    вернути пусто;
  }

  місцева дія знищити_спробу(М: адреса<Машина>, спроба: адреса<Спроба>) {
    // ...
  }
}

секція мавка {
  місцева дія вивести_т8(М: адреса<Машина>, значення: т8) {

    змінна значення_ю8 = ю8 { 0, пусто };
    якщо перекодувати_т8_в_ю8(М, значення, значення_ю8::адреса, ні) == ні {
      // потім: помилка
    }
    вивести_ю8(М, значення_ю8);
    звільнити_памʼять(М, значення_ю8.дані);
  }

  місцева дія вивести_ю8(М: адреса<Машина>, значення: ю8) {
    мавка_система_вивести_ю8(значення.розмір, значення.дані);
  }

  місцева дія вивести_ю32(М: адреса<Машина>, значення: ю32) {

    змінна значення_ю8 = ю8 { 0, пусто };
    якщо перекодувати_ю32_в_ю8(М, значення, значення_ю8::адреса, ні) == ні {
      // потім: помилка
    }
    вивести_ю8(М, значення_ю8);
    звільнити_памʼять(М, значення_ю8.дані);
  }

  місцева дія вивести_позитивне(М: адреса<Машина>, значення: позитивне) {
    мавка_система_вивести_позитивне(значення);
  }

  місцева дія вивести_д64(М: адреса<Машина>, значення: д64) {
    мавка_система_вивести_д64(значення);
  }

  місцева дія надрукувати_т8(М: адреса<Машина>, значення: т8) {
    вивести_т8(М, значення);
    вивести_ю8(М, ю8"\р");
  }

  місцева дія надрукувати_ю8(М: адреса<Машина>, значення: ю8) {
    вивести_ю8(М, значення);
    вивести_ю8(М, ю8"\р");
  }

  місцева дія надрукувати_позитивне(М: адреса<Машина>, значення: позитивне) {
    вивести_позитивне(М, значення);
    вивести_ю8(М, ю8"\р");
  }

  місцева дія надрукувати_д64(М: адреса<Машина>, значення: д64) {
    вивести_д64(М, значення);
    вивести_ю8(М, ю8"\р");
  }

  місцева дія отримати_з_т8_т8_з_закодованими_недрукованими(М: адреса<Машина>, значення: т8, вихід: адреса<т8>): логічне {

    змінна накопичувач_т8 = зробити_накопичувач<п8>(М);
    змінна п: позитивне = 0;
    поки п < значення.розмір {
      якщо значення.дані[п] == 0 {
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, КД::символи::Обернена_похила);
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, КД::символи::Нуль);
      } інакше якщо значення.дані[п] == 1 {
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, КД::символи::Обернена_похила);
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, КД::символи::Один);
      } інакше якщо значення.дані[п] == 2 {
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, КД::символи::Обернена_похила);
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, КД::символи::Два);
      } інакше якщо значення.дані[п] == 3 {
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, КД::символи::Обернена_похила);
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, КД::символи::Мала_буква_р);
      } інакше {
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, значення.дані[п]);
      }
      п += 1;
    }
    вихід::вміст = т8 {
      накопичувач_т8.розмір,
      накопичувач_т8.дані
    };
    вернути так;
  }

  місцева дія отримати_з_ю32_ю32_з_закодованими_недрукованими(М: адреса<Машина>, значення: ю32, вихід: адреса<ю32>): логічне {

    змінна накопичувач_ю32 = зробити_накопичувач<п32>(М);
    змінна п: позитивне = 0;
    поки п < значення.розмір {
      якщо значення.дані[п] == 0 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Нуль);
      } інакше якщо значення.дані[п] == 1 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
      } інакше якщо значення.дані[п] == 2 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
      } інакше якщо значення.дані[п] == 3 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Три);
      } інакше якщо значення.дані[п] == 4 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Чотири);
      } інакше якщо значення.дані[п] == 5 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Пʼять);
      } інакше якщо значення.дані[п] == 6 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Шість);
      } інакше якщо значення.дані[п] == 7 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Сім);
      } інакше якщо значення.дані[п] == 8 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Вісім);
      } інакше якщо значення.дані[п] == 9 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Девʼять);
      } інакше якщо значення.дані[п] == 10 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, 110);
      } інакше якщо значення.дані[п] == 11 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
      } інакше якщо значення.дані[п] == 12 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
      } інакше якщо значення.дані[п] == 13 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Три);
      } інакше якщо значення.дані[п] == 14 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Чотири);
      } інакше якщо значення.дані[п] == 15 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Пʼять);
      } інакше якщо значення.дані[п] == 16 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Шість);
      } інакше якщо значення.дані[п] == 17 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Сім);
      } інакше якщо значення.дані[п] == 18 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Вісім);
      } інакше якщо значення.дані[п] == 19 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Девʼять);
      } інакше якщо значення.дані[п] == 20 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Нуль);
      } інакше якщо значення.дані[п] == 21 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
      } інакше якщо значення.дані[п] == 22 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
      } інакше якщо значення.дані[п] == 23 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Три);
      } інакше якщо значення.дані[п] == 24 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Чотири);
      } інакше якщо значення.дані[п] == 25 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Пʼять);
      } інакше якщо значення.дані[п] == 26 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Шість);
      } інакше якщо значення.дані[п] == 27 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Сім);
      } інакше якщо значення.дані[п] == 28 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Вісім);
      } інакше якщо значення.дані[п] == 29 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Девʼять);
      } інакше якщо значення.дані[п] == 30 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Три);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Нуль);
      } інакше якщо значення.дані[п] == 31 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Три);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
      } інакше якщо значення.дані[п] == 127 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Сім);
      } інакше {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, значення.дані[п]);
      }
      п += 1;
    }
    вихід::вміст = ю32 {
      накопичувач_ю32.розмір,
      накопичувач_ю32.дані
    };
    вернути так;
  }
}