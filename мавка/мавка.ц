взяти визначення біб/КД;
взяти визначення мавка;
взяти визначення мавка/розбирач;
взяти визначення мавка/перекладач;
взяти визначення біб/турбо;

зовнішня дія мавка_система_перевірити_чи_шлях_існує_і_є_файлом(шлях: адреса<мавка::Байти>): логічне;
зовнішня дія мавка_отримати_версію_мавки_як_ю8(вихід: адреса<ю8>);

секція мавка {
  місцева дія отримати_версію_мавки_як_т8(М: адреса<Машина>): т8 {

    змінна значення = т8 { 0, пусто };
    змінна значення_ю8 = ю8 { 0, пусто };
    мавка_отримати_версію_мавки_як_ю8(значення_ю8::адреса);
    якщо перекодувати_ю8_в_т8(М, значення_ю8, значення::адреса, ні) == ні {
      // потім: помилка
    }
    вернути значення;
  }

  дія система_розбирача_виділити_сиру_памʼять(система: адреса<мавка::розбирач::Система>, розмір: позитивне): памʼять<п8> {
    змінна М = система.дані як адреса<Машина>;
    вернути виділити_памʼять<п8>(М, розмір);
  }

  дія система_розбирача_перевиділити_сиру_памʼять(система: адреса<мавка::розбирач::Система>, значення: памʼять<п8>, новий_розмір: позитивне): памʼять<п8> {
    змінна М = система.дані як адреса<Машина>;
    вернути перевиділити_памʼять<п8>(М, значення, новий_розмір);
  }

  дія система_розбирача_звільнити_сиру_памʼять(система: адреса<мавка::розбирач::Система>, значення: невідома_памʼять) {
    змінна М = система.дані як адреса<Машина>;
    звільнити_памʼять(М, значення);
  }

  дія розбирач_дописати_у_стандартний_вивід(система: адреса<мавка::розбирач::Система>, потік: адреса<мавка::розбирач::ВихіднийПотік>, розмір: позитивне, дані: памʼять<п8>): логічне {
    змінна М = система.дані як адреса<Машина>;
    вивести_ю8(М, ю8 { розмір, дані });
    вернути так;
  }

  місцева дія машина_взяти_файл(М: адреса<Машина>, назва_паку: адреса<ПредметТексту>, назва_модуля: адреса<ПредметТексту>, предмет_шляху: адреса<ПредметШляху>): предмет_або_стан_падіння {
    змінна взятий_предмет: адреса<Предмет> = пусто;
    якщо отримати_взятий_предмет(М, предмет_шляху як адреса<Предмет>, взятий_предмет::адреса) {
      вернути взятий_предмет;
    }
    змінна шлях_байти = Байти {
      предмет_шляху.байти.розмір,
      предмет_шляху.байти.дані
    };
    якщо М.система.перевірити_чи_шлях_існує_і_є_файлом(М, шлях_байти) == ні {
      звільнити_памʼять(М, шлях_байти.дані);
      вернути результат_стан_падіння(М, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 }, створити_предмет_тексту(М, "Файл модуля не знайдено") як адреса<Предмет>);
    }
    змінна значення_файлу = Байти { 0, пусто };
    якщо М.система.прочитати_файл(М, шлях_байти, значення_файлу::адреса) == ні {
      звільнити_памʼять(М, шлях_байти.дані);
      вернути результат_стан_падіння(М, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 }, створити_предмет_тексту(М, "Не вдалось прочитати файл") як адреса<Предмет>);
    }

    змінна система_розбирача = мавка::розбирач::Система {
      дані = М,
      виділити_сиру_памʼять = система_розбирача_виділити_сиру_памʼять,
      перевиділити_сиру_памʼять = система_розбирача_перевиділити_сиру_памʼять,
      звільнити_сиру_памʼять = система_розбирача_звільнити_сиру_памʼять,
    };
    змінна вихідний_потік_розбирача = мавка::розбирач::ВихіднийПотік {
      дані = М,
      дописати = розбирач_дописати_у_стандартний_вивід
    };

    змінна слова = мавка::розбирач::Слова { 0, пусто };
    змінна помилка_розбору_на_слова = мавка::розбирач::ПомилкаРозборуНаСлова { ... };
    якщо мавка::розбирач::розібрати_ю8_на_слова(система_розбирача::адреса, ю8 { значення_файлу.розмір, значення_файлу.дані }, слова::адреса, помилка_розбору_на_слова::адреса) == ні {
      звільнити_памʼять(М, значення_файлу.дані);
      вернути результат_стан_падіння(М, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 }, створити_предмет_тексту(М, "Не вдалось розібрати на слова") як адреса<Предмет>);
    }
    змінна сполуки = мавка::розбирач::Сполуки { 0, пусто };
    змінна помилка_розбору_на_сполуки = мавка::розбирач::ПомилкаРозборуНаСполуки { ... };
    якщо мавка::розбирач::розібрати_слова_на_сполуки(система_розбирача::адреса, ю8 { значення_файлу.розмір, значення_файлу.дані }, слова, сполуки::адреса, помилка_розбору_на_сполуки::адреса) == ні {
      мавка::розбирач::звільнити_слова(система_розбирача::адреса, слова);
      звільнити_памʼять(М, значення_файлу.дані);
      вернути результат_стан_падіння(М, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 }, створити_предмет_тексту(М, "Не вдалось розібрати на сполуки") як адреса<Предмет>);
    }

    змінна код_МаМа = мавка::перекладач::створити_код(М);
    змінна контекст = мавка::перекладач::створити_контекст(М);
    змінна помилка_перекладу = мавка::перекладач::ПомилкаПерекладуВМаМа { ... };
    якщо мавка::перекладач::перекласти(М, ю8 { значення_файлу.розмір, значення_файлу.дані }, слова, сполуки, ні, контекст, код_МаМа, помилка_перекладу::адреса) == ні {
      змінна предмет_помилки = створити_предмет_тексту(М, помилка_перекладу.повідомлення);
      звільнити_памʼять(М, помилка_перекладу.повідомлення.дані);
      мавка::розбирач::звільнити_слова(система_розбирача::адреса, слова);
      мавка::розбирач::звільнити_сполуки(система_розбирача::адреса, сполуки);
      мавка::перекладач::знищити_код(М, код_МаМа);
      мавка::перекладач::знищити_контекст(М, контекст);
      звільнити_памʼять(М, значення_файлу.дані);
      вернути результат_стан_падіння(М, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 }, предмет_помилки як адреса<Предмет>);
    }
  //  мавка::перекладач::вивести_КодМаМа(М, вихідний_потік_перекладача::адреса, код_МаМа);

    змінна предмет_коду = перекладач::створити_предмет_коду_з_коду_перекладача(М, предмет_шляху, код_МаМа);
    змінна притримувач = покласти_притримувач(М);
    притримати(М, притримувач, предмет_коду як адреса<Предмет>);

    змінна предмет_модуля = створити_предмет_модуля(М, створити_назву(М, назва_модуля.значення));
    предмет_модуля.назва_паку = назва_паку;
    покласти_взятий_предмет(М, предмет_шляху як адреса<Предмет>, предмет_модуля як адреса<Предмет>);
    змінна предмет_середовища = створити_предмет_середовища(М, М.предмет_глобального_середовища, предмет_модуля, предмет_модуля як адреса<Предмет>);
    притримати(М, притримувач, предмет_середовища як адреса<Предмет>);
    змінна результат = виконати_код(М, предмет_коду, предмет_середовища);

    забрати_притримувач(М);
    мавка::розбирач::звільнити_слова(система_розбирача::адреса, слова);
    мавка::розбирач::звільнити_сполуки(система_розбирача::адреса, сполуки);
    звільнити(М, код_МаМа);
    мавка::перекладач::знищити_контекст(М, контекст);
    звільнити_памʼять(М, значення_файлу.дані);



    якщо перевірити_чи_стан_падіння(М) {
      вернути результат;
    }

    вернути предмет_модуля як адреса<Предмет>;
  }


  місцева дія взяти_файл_ю8(М: адреса<Машина>, шлях: адреса<ПредметШляху>): предмет_або_стан_падіння {
    змінна шлях_до_файлу = Байти { 0, пусто };
    М.система.отримати_абсолютний_шлях(М, Байти { шлях.байти.розмір, шлях.байти.дані }, шлях_до_файлу::адреса);
    змінна назва_файлу_без_розширення = Байти { 0, пусто };
    М.система.отримати_назву_файлу_без_розширення(М, шлях_до_файлу, назва_файлу_без_розширення::адреса);
    змінна назва_файлу_без_розширення_т8 = т8 { 0, пусто };
    якщо перекодувати_ю8_в_т8(М, ю8 { назва_файлу_без_розширення.розмір, назва_файлу_без_розширення.дані }, назва_файлу_без_розширення_т8::адреса, ні) == ні {
      ПОМЕРТИ(М, "Не вдалось отримати назву файлу без розширення");
    }
    звільнити_памʼять(М, назва_файлу_без_розширення.дані);
    змінна назва_модуля = створити_назву(М, назва_файлу_без_розширення_т8);
    звільнити_памʼять(М, назва_файлу_без_розширення_т8.дані);
    змінна результат = машина_взяти_файл(М, пусто, назва_модуля, створити_предмет_шляху(М, створити_предмет_байтів(М, шлях_до_файлу.розмір, шлях_до_файлу.дані)));
    звільнити_памʼять(М, шлях_до_файлу.дані);
    вернути результат;
  }

  дія виконати_ю8(М: адреса<Машина>, середовище: адреса<ПредметСередовища>, значення_файлу: ю8): предмет_або_стан_падіння {
    змінна система_розбирача = мавка::розбирач::Система {
      дані = М,
      виділити_сиру_памʼять = система_розбирача_виділити_сиру_памʼять,
      перевиділити_сиру_памʼять = система_розбирача_перевиділити_сиру_памʼять,
      звільнити_сиру_памʼять = система_розбирача_звільнити_сиру_памʼять,
    };
    змінна вихідний_потік_розбирача = мавка::розбирач::ВихіднийПотік {
      дані = М,
      дописати = розбирач_дописати_у_стандартний_вивід
    };

    змінна слова = мавка::розбирач::Слова { 0, пусто };
    змінна помилка_розбору_на_слова = мавка::розбирач::ПомилкаРозборуНаСлова { ... };
    якщо мавка::розбирач::розібрати_ю8_на_слова(система_розбирача::адреса, значення_файлу, слова::адреса, помилка_розбору_на_слова::адреса) == ні {
      вернути результат_стан_падіння(М, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 }, створити_предмет_тексту(М, "Не вдалось розібрати на слова") як адреса<Предмет>);
    }
    змінна сполуки = мавка::розбирач::Сполуки { 0, пусто };
    змінна помилка_розбору_на_сполуки = мавка::розбирач::ПомилкаРозборуНаСполуки { ... };
    якщо мавка::розбирач::розібрати_слова_на_сполуки(система_розбирача::адреса, значення_файлу, слова, сполуки::адреса, помилка_розбору_на_сполуки::адреса) == ні {
      мавка::розбирач::звільнити_слова(система_розбирача::адреса, слова);
      вернути результат_стан_падіння(М, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 }, створити_предмет_тексту(М, "Не вдалось розібрати на сполуки") як адреса<Предмет>);
    }

    змінна код_МаМа = мавка::перекладач::створити_код(М);
    змінна контекст = мавка::перекладач::створити_контекст(М);
    змінна помилка_перекладу = мавка::перекладач::ПомилкаПерекладуВМаМа { ... };
    якщо мавка::перекладач::перекласти(М, значення_файлу, слова, сполуки, так, контекст, код_МаМа, помилка_перекладу::адреса) == ні {
      змінна предмет_помилки = створити_предмет_тексту(М, помилка_перекладу.повідомлення);
      звільнити_памʼять(М, помилка_перекладу.повідомлення.дані);
      мавка::розбирач::звільнити_слова(система_розбирача::адреса, слова);
      мавка::розбирач::звільнити_сполуки(система_розбирача::адреса, сполуки);
      мавка::перекладач::знищити_код(М, код_МаМа);
      мавка::перекладач::знищити_контекст(М, контекст);
      вернути результат_стан_падіння(М, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 }, предмет_помилки як адреса<Предмет>);
    }

    змінна предмет_коду = перекладач::створити_предмет_коду_з_коду_перекладача(М, пусто, код_МаМа);
    змінна притримувач = покласти_притримувач(М);
    притримати(М, притримувач, предмет_коду як адреса<Предмет>);

    притримати(М, притримувач, середовище як адреса<Предмет>);
    змінна результат = виконати_код(М, предмет_коду, середовище);

    забрати_притримувач(М);
    мавка::розбирач::звільнити_слова(система_розбирача::адреса, слова);
    мавка::розбирач::звільнити_сполуки(система_розбирача::адреса, сполуки);
    звільнити(М, код_МаМа);
    мавка::перекладач::знищити_контекст(М, контекст);

    вернути результат;
  }

  дія діалог_виконати(М: адреса<Машина>, середовище: адреса<ПредметСередовища>, значення: ю8) {
    змінна стан = зберегти_стан_розмірів_машини(М);
    змінна результат = виконати_ю8(М, середовище, значення);
    якщо перевірити_чи_стан_падіння(М) {
      змінна інформація_падіння = отримати_інформацію_падіння(М);
      надрукувати_падіння(М, інформація_падіння, результат);
      знищити_інформацію_падіння(М, інформація_падіння);
      відновити_стан_розмірів_машини(М, стан);
      М.стан_падіння = позитивне(ні);
    } інакше {
      вивести_предмет(М, результат, 1);
      вивести_ю8(М, ю8"\р");
    }
  }

  структура ДаніДіалогу {
    М: адреса<Машина>;
    глобально_притриманий_предмет_середовища: адреса<ГлобальноПритриманийПредмет>;
  }

  дія обробник_вводу_діалогу(турбіна: адреса<турбо::Турбіна>, аргумент: невідома_адреса, скасовано: логічне, розмір_префікса: позитивне, дані_префікса: памʼять<п8>, розмір: позитивне, дані: памʼять<п8>) {
    змінна дані_діалогу = аргумент як адреса<ДаніДіалогу>;
    змінна М = дані_діалогу.М;

    якщо скасовано {
      відпустити_глобально(М, дані_діалогу.глобально_притриманий_предмет_середовища);
      звільнити(М, дані_діалогу);
      звільнити_памʼять(М, дані_префікса);
    } інакше {
      змінна значення = ю8 { розмір, дані };
      якщо значення.розмір > 0 {
        діалог_виконати(М, отримати_глобально_притриманий_предмет(М, дані_діалогу.глобально_притриманий_предмет_середовища) як адреса<ПредметСередовища>, значення);
      }
      звільнити_памʼять(М, значення.дані);

      турбо::прочитати_ввід_ю8(турбіна, обробник_вводу_діалогу, дані_діалогу, ю8 { розмір_префікса, дані_префікса });
    }
  }

  місцева дія почати_діалог(М: адреса<Машина>) {

    змінна предмет_середовища = створити_предмет_середовища(М, М.предмет_глобального_середовища, пусто, пусто);

    змінна дані_діалогу = виділити<ДаніДіалогу>(М);
    дані_діалогу.М = М;
    дані_діалогу.глобально_притриманий_предмет_середовища = притримати_глобально(М, предмет_середовища як адреса<Предмет>);

    змінна турбіна = турбо::отримати_глобальну_турбіну();

    змінна розмір_префікса: позитивне = 2;
    змінна дані_префікса = виділити_памʼять<п8>(М, розмір_префікса);
    дані_префікса[0] = 45; // "-"
    дані_префікса[1] = 32; // " "

    турбо::прочитати_ввід_ю8(турбіна, обробник_вводу_діалогу, дані_діалогу, ю8 { розмір_префікса, дані_префікса });
  }

  місцева дія запланувати_виконання(М: адреса<Машина>, обробник: ОбробникЗапланованогоВиконання, дані: невідома_адреса, відклик_перед_знищенням: ВідкликПередЗнищеннямЗапланованогоВиконання, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>): логічне {

    вернути покласти_в_чергу_запланованих_виконань(М, обробник як невідома_адреса як ОбробникЗапланованогоВиконання, дані, відклик_перед_знищенням як невідома_адреса як ВідкликПередЗнищеннямЗапланованогоВиконання, кількість_аргументів, аргументи як памʼять<адреса<Предмет>>);
  }

  дія обробник_запланованого_виконання_падіння(М: адреса<Машина>, дані: невідома_адреса, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>): предмет_або_стан_падіння {
    вернути аргументи[0];
  }

  місцева дія запланувати_падіння(М: адреса<Машина>, предмет_помилки: адреса<Предмет>): логічне {

    змінна кількість_аргументів: позитивне = 1;
    змінна аргументи = виділити_памʼять<адреса<Предмет>>(М, кількість_аргументів);
    аргументи[0] = предмет_помилки;
    змінна о = обробник_запланованого_виконання_падіння;
    вернути покласти_першим_в_чергу_запланованих_виконань(
      М,
      о як невідома_адреса як ОбробникЗапланованогоВиконання,
      пусто,
      пусто,
      кількість_аргументів,
      аргументи як памʼять<адреса<Предмет>>
    );
  }
}

секція мавка {
  місцева дія отримати_інформацію_падіння(М: адреса<Машина>): адреса<ІнформаціяПадіння> {
    якщо перевірити_чи_стан_падіння(М) {
      змінна інформація_падіння = виділити<ІнформаціяПадіння>(М);
      інформація_падіння.місцезнаходження = Місцезнаходження {
        шлях_або_код = М.місцезнаходження_падіння.шлях_або_код як адреса<ПредметШляху>,
        рядок_або_позиція_вказівки = М.місцезнаходження_падіння.рядок_або_позиція_вказівки,
      };
      змінна накопичувач_історії = зробити_накопичувач<ЕлементІсторіїВиконання>(М);
      змінна п: позитивне = 0;
      поки п < М.історія.розмір {
        змінна елемент_історії = М.історія.дані[п];
        змінна елемент_історії_виконання = ЕлементІсторіїВиконання { ... };
        якщо елемент_історії.предмет_дії != пусто {
          якщо елемент_історії.предмет_дії.назва != пусто {
            якщо елемент_історії.місцезнаходження.шлях_або_код як адреса<ПредметШляху> != пусто {
              якщо виділити_копію_т8(М, елемент_історії.предмет_дії.назва.значення, елемент_історії_виконання.назва::адреса) == ні {
                // потім_помилка
              }
              елемент_історії_виконання.місцезнаходження = Місцезнаходження {
                шлях_або_код = елемент_історії.місцезнаходження.шлях_або_код як адреса<ПредметШляху>,
                рядок_або_позиція_вказівки = елемент_історії.місцезнаходження.рядок_або_позиція_вказівки
              };
              покласти_в_накопичувач<ЕлементІсторіїВиконання>(М, накопичувач_історії::адреса, елемент_історії_виконання);
            }
          }
        }
        п += 1;
      }
      інформація_падіння.розмір_історії = накопичувач_історії.розмір;
      інформація_падіння.історія = накопичувач_історії.дані;
      вернути інформація_падіння;
    }
    вернути пусто;
  }

  місцева дія знищити_інформацію_падіння(М: адреса<Машина>, інформація_падіння: адреса<ІнформаціяПадіння>) {

    змінна п: позитивне = 0;
    поки п < інформація_падіння.розмір_історії {
      звільнити_памʼять(М, інформація_падіння.історія[п].назва.дані);
      п += 1;
    }
    звільнити_памʼять(М, інформація_падіння.історія);
    звільнити(М, інформація_падіння);
  }
}

секція мавка {
  місцева дія змінити_в_глобальному_середовищі(М: адреса<Машина>, назва: адреса<ПредметТексту>, значення: адреса<Предмет>): предмет_або_стан_падіння {
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва, значення);

    вернути пусто;
  }

  місцева дія надрукувати_падіння(М: адреса<Машина>, інформація_падіння: адреса<ІнформаціяПадіння>, предмет_помилки: адреса<Предмет>) {
    вивести_ю8(М, ю8"Падіння");
    якщо інформація_падіння.місцезнаходження.шлях_або_код як адреса<ПредметШляху> == пусто {
      вивести_ю8(М, ю8": ");
    } інакше {
      вивести_ю8(М, ю8" в ");
      вивести_предмет(М, інформація_падіння.місцезнаходження.шлях_або_код як адреса<ПредметШляху> як адреса<Предмет>, 0);
      вивести_ю8(М, ю8":");
      вивести_позитивне(М, інформація_падіння.місцезнаходження.рядок_або_позиція_вказівки);
      вивести_ю8(М, ю8": ");
    }
    вивести_предмет(М, предмет_помилки, 0);
    вивести_ю8(М, ю8"\р");
    змінна виведено_перший_елемент_історії = ні;
    змінна п: позитивне = 0;
    поки п < інформація_падіння.розмір_історії {
      змінна елемент_історії = інформація_падіння.історія[п];
      якщо виведено_перший_елемент_історії == ні {
        вивести_ю8(М, ю8"\рІсторія виконання:\р");
        виведено_перший_елемент_історії = так;
      }
      вивести_ю8(М, ю8"  ");
      вивести_т8(М, елемент_історії.назва);
      вивести_ю8(М, ю8" в ");
      вивести_предмет(М, елемент_історії.місцезнаходження.шлях_або_код як адреса<ПредметШляху> як адреса<Предмет>, 0);
      вивести_ю8(М, ю8":");
      вивести_позитивне(М, елемент_історії.місцезнаходження.рядок_або_позиція_вказівки);
      вивести_ю8(М, ю8"\р");
      п += 1;
    }
  }
}

секція мавка {
  місцева дія почати_спробу(М: адреса<Машина>): адреса<Спроба> {
    вернути пусто;
  }

  місцева дія знищити_спробу(М: адреса<Машина>, спроба: адреса<Спроба>) {
    // ...
  }
}

секція мавка {
  місцева дія вивести_т8(М: адреса<Машина>, значення: т8) {

    змінна значення_ю8 = ю8 { 0, пусто };
    якщо перекодувати_т8_в_ю8(М, значення, значення_ю8::адреса, ні) == ні {
      // потім: помилка
    }
    вивести_ю8(М, значення_ю8);
    звільнити_памʼять(М, значення_ю8.дані);
  }

  місцева дія вивести_ю8(М: адреса<Машина>, значення: ю8) {
    мавка_система_вивести_ю8(значення.розмір, значення.дані);
  }

  місцева дія вивести_ю32(М: адреса<Машина>, значення: ю32) {

    змінна значення_ю8 = ю8 { 0, пусто };
    якщо перекодувати_ю32_в_ю8(М, значення, значення_ю8::адреса, ні) == ні {
      // потім: помилка
    }
    вивести_ю8(М, значення_ю8);
    звільнити_памʼять(М, значення_ю8.дані);
  }

  місцева дія вивести_позитивне(М: адреса<Машина>, значення: позитивне) {
    мавка_система_вивести_позитивне(значення);
  }

  місцева дія вивести_д64(М: адреса<Машина>, значення: д64) {
    мавка_система_вивести_д64(значення);
  }

  місцева дія надрукувати_т8(М: адреса<Машина>, значення: т8) {
    вивести_т8(М, значення);
    вивести_ю8(М, ю8"\р");
  }

  місцева дія надрукувати_ю8(М: адреса<Машина>, значення: ю8) {
    вивести_ю8(М, значення);
    вивести_ю8(М, ю8"\р");
  }

  місцева дія надрукувати_позитивне(М: адреса<Машина>, значення: позитивне) {
    вивести_позитивне(М, значення);
    вивести_ю8(М, ю8"\р");
  }

  місцева дія надрукувати_д64(М: адреса<Машина>, значення: д64) {
    вивести_д64(М, значення);
    вивести_ю8(М, ю8"\р");
  }

  місцева дія отримати_з_т8_т8_з_закодованими_недрукованими(М: адреса<Машина>, значення: т8, вихід: адреса<т8>): логічне {

    змінна накопичувач_т8 = зробити_накопичувач<п8>(М);
    змінна п: позитивне = 0;
    поки п < значення.розмір {
      якщо значення.дані[п] == 0 {
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, КД::символи::Обернена_похила);
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, КД::символи::Нуль);
      } інакше якщо значення.дані[п] == 1 {
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, КД::символи::Обернена_похила);
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, КД::символи::Один);
      } інакше якщо значення.дані[п] == 2 {
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, КД::символи::Обернена_похила);
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, КД::символи::Два);
      } інакше якщо значення.дані[п] == 3 {
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, КД::символи::Обернена_похила);
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, КД::символи::Мала_буква_р);
      } інакше {
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, значення.дані[п]);
      }
      п += 1;
    }
    вихід::вміст = т8 {
      накопичувач_т8.розмір,
      накопичувач_т8.дані
    };
    вернути так;
  }

  місцева дія отримати_з_ю32_ю32_з_закодованими_недрукованими(М: адреса<Машина>, значення: ю32, вихід: адреса<ю32>): логічне {

    змінна накопичувач_ю32 = зробити_накопичувач<п32>(М);
    змінна п: позитивне = 0;
    поки п < значення.розмір {
      якщо значення.дані[п] == 0 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Нуль);
      } інакше якщо значення.дані[п] == 1 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
      } інакше якщо значення.дані[п] == 2 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
      } інакше якщо значення.дані[п] == 3 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Три);
      } інакше якщо значення.дані[п] == 4 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Чотири);
      } інакше якщо значення.дані[п] == 5 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Пʼять);
      } інакше якщо значення.дані[п] == 6 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Шість);
      } інакше якщо значення.дані[п] == 7 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Сім);
      } інакше якщо значення.дані[п] == 8 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Вісім);
      } інакше якщо значення.дані[п] == 9 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Девʼять);
      } інакше якщо значення.дані[п] == 10 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, 110);
      } інакше якщо значення.дані[п] == 11 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
      } інакше якщо значення.дані[п] == 12 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
      } інакше якщо значення.дані[п] == 13 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Три);
      } інакше якщо значення.дані[п] == 14 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Чотири);
      } інакше якщо значення.дані[п] == 15 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Пʼять);
      } інакше якщо значення.дані[п] == 16 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Шість);
      } інакше якщо значення.дані[п] == 17 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Сім);
      } інакше якщо значення.дані[п] == 18 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Вісім);
      } інакше якщо значення.дані[п] == 19 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Девʼять);
      } інакше якщо значення.дані[п] == 20 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Нуль);
      } інакше якщо значення.дані[п] == 21 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
      } інакше якщо значення.дані[п] == 22 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
      } інакше якщо значення.дані[п] == 23 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Три);
      } інакше якщо значення.дані[п] == 24 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Чотири);
      } інакше якщо значення.дані[п] == 25 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Пʼять);
      } інакше якщо значення.дані[п] == 26 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Шість);
      } інакше якщо значення.дані[п] == 27 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Сім);
      } інакше якщо значення.дані[п] == 28 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Вісім);
      } інакше якщо значення.дані[п] == 29 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Девʼять);
      } інакше якщо значення.дані[п] == 30 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Три);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Нуль);
      } інакше якщо значення.дані[п] == 31 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Три);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
      } інакше якщо значення.дані[п] == 127 {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Обернена_похила);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Один);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Два);
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, КД::відповідні_символи_юнікоду::Сім);
      } інакше {
        покласти_в_накопичувач<п32>(М, накопичувач_ю32::адреса, значення.дані[п]);
      }
      п += 1;
    }
    вихід::вміст = ю32 {
      накопичувач_ю32.розмір,
      накопичувач_ю32.дані
    };
    вернути так;
  }
}