взяти визначення мавка;
взяти визначення мавка/розбирач;
взяти визначення мавка/перекладач;

зовнішня дія мавка_отримати_версію_мавки_як_ю8(вихід: адреса<ю8>);

секція мавка {
  місцева дія порахувати_рядок_ю8_за_позицією(значення: ю8, позиція: натуральне) -> натуральне {
    змінна рядок: натуральне = 1;
    змінна п: натуральне = 0;

    поки п <= позиція + 1 {
      якщо значення.дані[п] == 10 {
        рядок += 1;
      }

      п += 1;
    }

    вернути рядок;
  }

  місцева дія отримати_версію_мавки_як_т8(М: адреса<Машина>): т8 {
    змінна значення = т8 { 0, пусто };
    змінна значення_ю8 = ю8 { 0, пусто };
    мавка_отримати_версію_мавки_як_ю8(значення_ю8::адреса);
    якщо не перекодувати_ю8_в_т8(М, ОпціїПерекодуванняЮ8вТ8 { з_кінцем = ні, екранувати_невідомі = так }, значення_ю8, значення::адреса, пусто, пусто) {
      // потім: помилка
    }
    вернути значення;
  }

  місцева дія машина_взяти_файл(М: адреса<Машина>, назва_паку: адреса<ПредметТексту>, назва_модуля: адреса<ПредметТексту>, предмет_шляху: адреса<ПредметШляху>) -> ПредметАбоСтанПадіння<Предмет> {
    змінна взятий_предмет: адреса<Предмет> = пусто;
    якщо отримати_взятий_предмет(М, предмет_шляху як адреса<Предмет>, взятий_предмет::адреса) {
      вернути взятий_предмет;
    }
    якщо не М.система.перевірити_чи_шлях_існує_і_є_файлом(М, предмет_шляху) {
      вернути результат_стан_падіння(М, Місцезнаходження { пусто як адреса<ПредметШляху>, 0 }, створити_предмет_тексту(М, "Файл модуля не знайдено") як адреса<Предмет>);
    }
    змінна значення_файлу = М.система.прочитати_файл(М, предмет_шляху);
    якщо М.стан_падіння {
      вернути значення_файлу як адреса<Предмет>;
    }

    змінна значення_т8 = т8 { 0, пусто };
    змінна треба_звільнити_значення_т8 = ні;

    якщо М.система.кодування_файлів == КодуванняЮ8 {
      змінна позиція_помилки_перекодування: натуральне = 0;
      якщо не перекодувати_ю8_в_т8(М, ОпціїПерекодуванняЮ8вТ8 { з_кінцем = ні, екранувати_невідомі = так }, ю8 { значення_файлу.розмір, значення_файлу.дані }, значення_т8::адреса, пусто, позиція_помилки_перекодування::адреса) {
        змінна рядок_помилки_перекодування = порахувати_рядок_ю8_за_позицією(ю8 { значення_файлу.розмір, значення_файлу.дані }, позиція_помилки_перекодування);
        вернути результат_стан_падіння(М, Місцезнаходження { предмет_шляху, рядок_помилки_перекодування }, створити_предмет_тексту(М, "Не вдалось перекодувати в т8") як адреса<Предмет>);
      }

      треба_звільнити_значення_т8 = так;
    } інакше {
      значення_т8 = т8 { значення_файлу.розмір, значення_файлу.дані };
    }

    змінна слова = мавка::розбирач::Слова { 0, пусто };
    змінна помилка_розбору_на_слова = мавка::розбирач::ПомилкаРозборуНаСлова { ... };
    якщо не мавка::розбирач::розібрати_на_слова(М, значення_т8, слова::адреса, помилка_розбору_на_слова::адреса) {
      змінна рядок = розбирач::отримати_рядок_помилки_розбору_на_слова(М, помилка_розбору_на_слова);
      якщо треба_звільнити_значення_т8 {
        звільнити_памʼять(М, значення_т8.дані);
      }
      вернути результат_стан_падіння(М, Місцезнаходження { предмет_шляху, рядок }, створити_предмет_тексту(М, "Не вдалось розібрати на слова") як адреса<Предмет>);
    }
    змінна сполуки = мавка::розбирач::Сполуки { 0, пусто };
    змінна помилка_розбору_на_сполуки = мавка::розбирач::ПомилкаРозборуНаСполуки { ... };
    якщо не мавка::розбирач::розібрати_слова_на_сполуки(М, значення_т8, слова, сполуки::адреса, помилка_розбору_на_сполуки::адреса) {
      змінна рядок = розбирач::отримати_рядок_помилки_розбору_на_сполуки(М, помилка_розбору_на_сполуки);
      мавка::розбирач::звільнити_слова(М, слова);
      якщо треба_звільнити_значення_т8 {
        звільнити_памʼять(М, значення_т8.дані);
      }
      вернути результат_стан_падіння(М, Місцезнаходження { предмет_шляху, рядок }, створити_предмет_тексту(М, "Не вдалось розібрати на сполуки") як адреса<Предмет>);
    }

    змінна код_МаМа = мавка::перекладач::створити_код(М, предмет_шляху);
    змінна контекст = мавка::перекладач::створити_контекст(М);
    змінна помилка_перекладу = мавка::перекладач::ПомилкаПерекладуВМаМа { ... };
    якщо не мавка::перекладач::перекласти(М, значення_т8, слова, сполуки, ні, контекст, код_МаМа, помилка_перекладу::адреса) {
      змінна слово = слова.дані[помилка_перекладу.позиція_слова];
      змінна рядок = слово.позиція_початку.рядок;
      змінна предмет_помилки = створити_предмет_тексту(М, помилка_перекладу.повідомлення);
      звільнити_памʼять(М, помилка_перекладу.повідомлення.дані);
      мавка::розбирач::звільнити_слова(М, слова);
      мавка::розбирач::звільнити_сполуки(М, сполуки);
      мавка::перекладач::знищити_код(М, код_МаМа);
      мавка::перекладач::знищити_контекст(М, контекст);
      якщо треба_звільнити_значення_т8 {
        звільнити_памʼять(М, значення_т8.дані);
      }
      вернути результат_стан_падіння(М, Місцезнаходження { предмет_шляху, рядок }, предмет_помилки як адреса<Предмет>);
    }

    змінна предмет_коду = перекладач::створити_предмет_коду_з_коду_перекладача(М, код_МаМа);
    змінна притримувач = покласти_притримувач(М);
    притримати(М, притримувач, предмет_коду як адреса<Предмет>);

    змінна предмет_модуля = створити_предмет_модуля(М, створити_назву(М, назва_модуля.значення));
    предмет_модуля.назва_паку = назва_паку;
    покласти_взятий_предмет(М, предмет_шляху як адреса<Предмет>, предмет_модуля як адреса<Предмет>);
    змінна предмет_середовища = створити_предмет_середовища(М, М.предмет_глобального_середовища, предмет_модуля, предмет_модуля як адреса<Предмет>);
    притримати(М, притримувач, предмет_середовища як адреса<Предмет>);
    змінна результат = виконати_код(М, предмет_коду, предмет_середовища);

    забрати_притримувач(М);
    мавка::розбирач::звільнити_слова(М, слова);
    мавка::розбирач::звільнити_сполуки(М, сполуки);
    звільнити(М, код_МаМа);
    мавка::перекладач::знищити_контекст(М, контекст);
    якщо треба_звільнити_значення_т8 {
      звільнити_памʼять(М, значення_т8.дані);
    }

    якщо перевірити_чи_стан_падіння(М) {
      вернути результат;
    }

    вернути предмет_модуля як адреса<Предмет>;
  }

  місцева дія взяти_файл_ю8(М: адреса<Машина>, шлях: адреса<ПредметШляху>) -> ПредметАбоСтанПадіння<Предмет> {
    змінна шлях_до_файлу = М.система.отримати_абсолютний_шлях(М, шлях);
    змінна назва_файлу_без_розширення = М.система.отримати_назву_файлу_без_розширення(М, шлях_до_файлу);
    змінна результат = машина_взяти_файл(М, пусто, назва_файлу_без_розширення, створити_предмет_шляху(М, шлях_до_файлу.байти));
    вернути результат;
  }

  місцева дія виконати_ю8(М: адреса<Машина>, середовище: адреса<ПредметСередовища>, шлях: адреса<ПредметШляху>, значення_файлу: ю8) -> ПредметАбоСтанПадіння<Предмет> {
    змінна значення_т8 = т8 { 0, пусто };
    змінна позиція_помилки_перекодування: натуральне = 0;
    якщо не перекодувати_ю8_в_т8(М, ОпціїПерекодуванняЮ8вТ8 { з_кінцем = ні, екранувати_невідомі = так }, ю8 { значення_файлу.розмір, значення_файлу.дані }, значення_т8::адреса, пусто, позиція_помилки_перекодування::адреса) {
      змінна рядок_помилки_перекодування = порахувати_рядок_ю8_за_позицією(ю8 { значення_файлу.розмір, значення_файлу.дані }, позиція_помилки_перекодування);
      вернути результат_стан_падіння(М, Місцезнаходження { шлях, рядок_помилки_перекодування }, створити_предмет_тексту(М, "Не вдалось перекодувати в т8") як адреса<Предмет>);
    }
    змінна слова = мавка::розбирач::Слова { 0, пусто };
    змінна помилка_розбору_на_слова = мавка::розбирач::ПомилкаРозборуНаСлова { ... };
    якщо мавка::розбирач::розібрати_на_слова(М, значення_т8, слова::адреса, помилка_розбору_на_слова::адреса) == ні {
      змінна рядок = розбирач::отримати_рядок_помилки_розбору_на_слова(М, помилка_розбору_на_слова);
      вернути результат_стан_падіння(М, Місцезнаходження { шлях, рядок }, створити_предмет_тексту(М, "Не вдалось розібрати на слова") як адреса<Предмет>);
    }
    змінна сполуки = мавка::розбирач::Сполуки { 0, пусто };
    змінна помилка_розбору_на_сполуки = мавка::розбирач::ПомилкаРозборуНаСполуки { ... };
    якщо мавка::розбирач::розібрати_слова_на_сполуки(М, значення_т8, слова, сполуки::адреса, помилка_розбору_на_сполуки::адреса) == ні {
      змінна рядок = розбирач::отримати_рядок_помилки_розбору_на_сполуки(М, помилка_розбору_на_сполуки);
      мавка::розбирач::звільнити_слова(М, слова);
      вернути результат_стан_падіння(М, Місцезнаходження { шлях, рядок }, створити_предмет_тексту(М, "Не вдалось розібрати на сполуки") як адреса<Предмет>);
    }

    змінна код_МаМа = мавка::перекладач::створити_код(М, шлях);
    змінна контекст = мавка::перекладач::створити_контекст(М);
    змінна помилка_перекладу = мавка::перекладач::ПомилкаПерекладуВМаМа { ... };
    якщо мавка::перекладач::перекласти(М, значення_т8, слова, сполуки, так, контекст, код_МаМа, помилка_перекладу::адреса) == ні {
      змінна слово = слова.дані[помилка_перекладу.позиція_слова];
      змінна рядок = слово.позиція_початку.рядок;
      змінна предмет_помилки = створити_предмет_тексту(М, помилка_перекладу.повідомлення);
      звільнити_памʼять(М, помилка_перекладу.повідомлення.дані);
      мавка::розбирач::звільнити_слова(М, слова);
      мавка::розбирач::звільнити_сполуки(М, сполуки);
      мавка::перекладач::знищити_код(М, код_МаМа);
      мавка::перекладач::знищити_контекст(М, контекст);
      вернути результат_стан_падіння(М, Місцезнаходження { шлях, рядок }, предмет_помилки як адреса<Предмет>);
    }

    змінна предмет_коду = перекладач::створити_предмет_коду_з_коду_перекладача(М, код_МаМа);
    змінна притримувач = покласти_притримувач(М);
    притримати(М, притримувач, предмет_коду як адреса<Предмет>);

    притримати(М, притримувач, середовище як адреса<Предмет>);
    змінна результат = виконати_код(М, предмет_коду, середовище);

    забрати_притримувач(М);
    мавка::розбирач::звільнити_слова(М, слова);
    мавка::розбирач::звільнити_сполуки(М, сполуки);
    звільнити(М, код_МаМа);
    мавка::перекладач::знищити_контекст(М, контекст);

    вернути результат;
  }

  місцева дія запланувати_виконання(М: адреса<Машина>, обробник: ОбробникЗапланованогоВиконання, дані: невідома_адреса, відклик_перед_знищенням: ВідкликПередЗнищеннямЗапланованогоВиконання, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>): логічне {
    вернути покласти_в_чергу_запланованих_виконань(М, обробник як невідома_адреса як ОбробникЗапланованогоВиконання, дані, відклик_перед_знищенням як невідома_адреса як ВідкликПередЗнищеннямЗапланованогоВиконання, кількість_аргументів, аргументи як памʼять<адреса<Предмет>>);
  }

  дія обробник_запланованого_виконання_падіння(М: адреса<Машина>, дані: невідома_адреса, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>) -> ПредметАбоСтанПадіння<Предмет> {
    вернути аргументи[0];
  }

  місцева дія запланувати_падіння(М: адреса<Машина>, предмет_помилки: адреса<Предмет>): логічне {
    змінна кількість_аргументів: позитивне = 1;
    змінна аргументи = виділити_памʼять<адреса<Предмет>>(М, кількість_аргументів);
    аргументи[0] = предмет_помилки;
    змінна о = обробник_запланованого_виконання_падіння;
    вернути покласти_першим_в_чергу_запланованих_виконань(
      М,
      о як невідома_адреса як ОбробникЗапланованогоВиконання,
      пусто,
      пусто,
      кількість_аргументів,
      аргументи як памʼять<адреса<Предмет>>
    );
  }
}

секція мавка {
  місцева дія отримати_інформацію_падіння(М: адреса<Машина>): адреса<ІнформаціяПадіння> {
    якщо перевірити_чи_стан_падіння(М) {
      змінна інформація_падіння = виділити<ІнформаціяПадіння>(М);
      інформація_падіння.місцезнаходження = Місцезнаходження {
        шлях_або_код = М.місцезнаходження_падіння.шлях_або_код як адреса<ПредметШляху>,
        рядок_або_позиція_вказівки = М.місцезнаходження_падіння.рядок_або_позиція_вказівки,
      };
      змінна накопичувач_історії = зробити_накопичувач<ЕлементІсторіїВиконання>(М);
      змінна п: позитивне = 0;
      поки п < М.історія.розмір {
        змінна елемент_історії = М.історія.дані[п];
        змінна елемент_історії_виконання = ЕлементІсторіїВиконання { ... };
        якщо елемент_історії.предмет_дії != пусто {
          якщо елемент_історії.предмет_дії.назва != пусто {
            якщо елемент_історії.місцезнаходження.шлях_або_код як адреса<ПредметШляху> != пусто {
              якщо виділити_копію_т8(М, елемент_історії.предмет_дії.назва.значення, елемент_історії_виконання.назва::адреса) == ні {
                // потім_помилка
              }
              елемент_історії_виконання.місцезнаходження = Місцезнаходження {
                шлях_або_код = елемент_історії.місцезнаходження.шлях_або_код як адреса<ПредметШляху>,
                рядок_або_позиція_вказівки = елемент_історії.місцезнаходження.рядок_або_позиція_вказівки
              };
              покласти_в_накопичувач<ЕлементІсторіїВиконання>(М, накопичувач_історії::адреса, елемент_історії_виконання);
            }
          }
        }
        п += 1;
      }
      інформація_падіння.розмір_історії = накопичувач_історії.розмір;
      інформація_падіння.історія = накопичувач_історії.дані;
      вернути інформація_падіння;
    }
    вернути пусто;
  }

  місцева дія знищити_інформацію_падіння(М: адреса<Машина>, інформація_падіння: адреса<ІнформаціяПадіння>) {

    змінна п: позитивне = 0;
    поки п < інформація_падіння.розмір_історії {
      звільнити_памʼять(М, інформація_падіння.історія[п].назва.дані);
      п += 1;
    }
    звільнити_памʼять(М, інформація_падіння.історія);
    звільнити(М, інформація_падіння);
  }
}

секція мавка {
  місцева дія змінити_в_глобальному_середовищі(М: адреса<Машина>, назва: адреса<ПредметТексту>, значення: адреса<Предмет>) -> ПредметАбоСтанПадіння<Предмет> {
    змінити_в_середовищі(М, М.предмет_глобального_середовища, назва, значення);

    вернути пусто;
  }
}

секція мавка {
  місцева дія почати_спробу(М: адреса<Машина>): адреса<Спроба> {
    вернути пусто;
  }

  місцева дія знищити_спробу(М: адреса<Машина>, спроба: адреса<Спроба>) {
    // ...
  }
}

секція мавка {
  місцева дія отримати_з_т8_т8_з_закодованими_недрукованими(М: адреса<Машина>, значення: т8, вихід: адреса<т8>): логічне {
    змінна накопичувач_т8 = зробити_накопичувач<п8>(М);
    змінна п: позитивне = 0;
    поки п < значення.розмір {
      якщо значення.дані[п] == 0 {
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, 48 /* КД::символи::Обернена_похила */);
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, 16 /* КД::символи::Нуль */);
      } інакше якщо значення.дані[п] == 1 {
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, 48 /* КД::символи::Обернена_похила */);
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, 17 /* КД::символи::Один */);
      } інакше якщо значення.дані[п] == 2 {
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, 48 /* КД::символи::Обернена_похила */);
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, 18 /* КД::символи::Два */);
      } інакше якщо значення.дані[п] == 3 {
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, 48 /* КД::символи::Обернена_похила */);
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, 115 /* КД::символи::Мала_буква_р */);
      } інакше {
        покласти_в_накопичувач<п8>(М, накопичувач_т8::адреса, значення.дані[п]);
      }
      п += 1;
    }
    вихід::вміст = т8 {
      накопичувач_т8.розмір,
      накопичувач_т8.дані
    };
    вернути так;
  }
}