взяти визначення МаМа;
взяти визначення мавка/компілятор;
взяти визначення мавка/мавка_втілення;
взяти визначення мавка/бібліотека;

зовнішня дія mavka_double_to_string(value: double, buffer: адреса<адреса<char>>): size_t;
зовнішня дія mavka_bitnot(value: double): double;
зовнішня дія mavka_negate(value: double): double;

секція мавка {
  зовнішня дія виділити_сиру_памʼять(обчислювач: адреса<Обчислювач>, розмір: позитивне): памʼять<п8> {
    вернути МаМа::виділити<п8>(обчислювач.М, розмір) як памʼять<п8>;
  }

  зовнішня дія перевиділити_сиру_памʼять(обчислювач: адреса<Обчислювач>, значення: памʼять<п8>, розмір: позитивне): памʼять<п8> {
    вернути МаМа::перевиділити<п8>(обчислювач.М, значення, розмір) як памʼять<п8>;
  }

  зовнішня дія звільнити_сиру_памʼять(обчислювач: адреса<Обчислювач>, значення: памʼять<п8>) {
    МаМа::звільнити(обчислювач.М, значення як адреса);
  }

  дія машина_обробник_отримання_шляху_до_модуля(М: адреса<МаМа::Машина>, назва_паку: адреса<МаМа::Назва>, шлях: МаМа::Накопичувач<адреса<МаМа::Назва>>, вихід: адреса<ю8>): логічне {
    ціль обчислювач = М.оболонка як адреса<Обчислювач>;
    ціль накопичувач_шляху_ю8 = МаМа::зробити_накопичувач_ю8(М);
    якщо назва_паку != пусто {
      МаМа::покласти_ю8_в_накопичувач_ю8(М, накопичувач_шляху_ю8::адреса, ю8"./паки/");
      ціль ю8_назви_паку = ю8 { пусто, 0 };
      якщо МаМа::виділити_ю8_з_назви(М, назва_паку, ю8_назви_паку::адреса) == ні {
        вернути ні;
      }
      МаМа::покласти_ю8_в_накопичувач_ю8(М, накопичувач_шляху_ю8::адреса, ю8_назви_паку);
      звільнити_памʼять(М.оболонка як адреса<Обчислювач>, ю8_назви_паку.дані);
      МаМа::покласти_ю8_в_накопичувач_ю8(М, накопичувач_шляху_ю8::адреса, ю8"/");
    }
    змінна ціль пш: позитивне = 0;
    поки пш < шлях.розмір {
      ціль ю8_елемента_шляху = ю8 { пусто, 0 };
      якщо МаМа::виділити_ю8_з_назви(М, шлях.дані[пш], ю8_елемента_шляху::адреса) == ні {
        вернути ні;
      }
      МаМа::покласти_ю8_в_накопичувач_ю8(М, накопичувач_шляху_ю8::адреса, ю8_елемента_шляху);
      звільнити_памʼять(М.оболонка як адреса<Обчислювач>, ю8_елемента_шляху.дані);
      якщо пш < шлях.розмір - 1 {
        МаМа::покласти_ю8_в_накопичувач_ю8(М, накопичувач_шляху_ю8::адреса, ю8"/");
      }
      пш += 1;
    }
    МаМа::покласти_ю8_в_накопичувач_ю8(М, накопичувач_шляху_ю8::адреса, ю8".м");
    ціль ю8_шлях_сирий = МаМа::виділити_ю8_з_накопичувача_ю8(М, накопичувач_шляху_ю8::адреса);
    ціль виправлений_шлях_1 = ю8 { пусто, 0 };
    якщо обчислювач.система.виправити_шлях(обчислювач, ю8_шлях_сирий, виправлений_шлях_1::адреса) != 0 {
      // помилка...
    }
    вихід::вміст = виправлений_шлях_1;
    звільнити_памʼять(М.оболонка як адреса<Обчислювач>, ю8_шлях_сирий.дані);
    МаМа::звільнити_значення_накопичувача_ю8(М, накопичувач_шляху_ю8);
    вернути так;
  }

  дія система_розбирача_виділити_сиру_памʼять(система: адреса<розбирач::Система>, розмір: позитивне): памʼять<п8> {
    ціль обчислювач = система.дані як адреса<Обчислювач>;
    вернути виділити_памʼять<п8>(обчислювач, розмір);
  }

  дія система_розбирача_перевиділити_сиру_памʼять(система: адреса<розбирач::Система>, значення: памʼять<п8>, новий_розмір: позитивне): памʼять<п8> {
    ціль обчислювач = система.дані як адреса<Обчислювач>;
    вернути перевиділити_памʼять<п8>(обчислювач, значення, новий_розмір);
  }

  дія система_розбирача_звільнити_сиру_памʼять(система: адреса<розбирач::Система>, значення: невідома_памʼять) {
    ціль обчислювач = система.дані як адреса<Обчислювач>;
    звільнити_памʼять(обчислювач, значення);
  }

  дія машина_обробник_взяття_модуля(М: адреса<МаМа::Машина>, предмет_модуля_запису: адреса<МаМа::ПредметМодуля>, ю8_шлях: ю8): МаМа::предмет_або_стан_падіння {
    ціль обчислювач = М.оболонка як адреса<Обчислювач>;
    змінна ціль значення_файлу = ю8 { пусто, 0 };
    змінна ціль розмір_значення_файлу: позитивне = 0;
    якщо обчислювач.система.прочитати_файл(обчислювач, ю8_шлях, значення_файлу::адреса) != 0 {
      ціль накопичувач_тексту_помилки = МаМа::зробити_накопичувач_ю8(М);
      МаМа::покласти_ю8_в_накопичувач_ю8(М, накопичувач_тексту_помилки::адреса, ю8"Не вдалося прочитати файл \"");
      МаМа::покласти_ю8_в_накопичувач_ю8(М, накопичувач_тексту_помилки::адреса, ю8_шлях);
      МаМа::покласти_ю8_в_накопичувач_ю8(М, накопичувач_тексту_помилки::адреса, ю8"\"");
      ціль ю8_помилки = МаМа::виділити_ю8_з_накопичувача_ю8(М, накопичувач_тексту_помилки::адреса);
      МаМа::звільнити_значення_накопичувача_ю8(М, накопичувач_тексту_помилки);
      ціль предмет_юнікоду = МаМа::виділити_предмет_юнікоду_з_ю8(М, ю8_помилки);
      звільнити_памʼять(М.оболонка як адреса<Обчислювач>, ю8_помилки.дані);
      МаМа::увімкнути_стан_падіння(М, пусто);
      вернути предмет_юнікоду як адреса<МаМа::Предмет>;
    }
    ціль система_розбирача = розбирач::Система {
      дані = обчислювач,
      виділити_сиру_памʼять = система_розбирача_виділити_сиру_памʼять,
      перевиділити_сиру_памʼять = система_розбирача_перевиділити_сиру_памʼять,
      звільнити_сиру_памʼять = система_розбирача_звільнити_сиру_памʼять,
    };
    змінна ціль слова = розбирач::Слова { 0, пусто };
    змінна ціль помилка_розбору_на_слова = розбирач::ПомилкаРозборуНаСлова { ... };
    якщо розбирач::розібрати_ю8_на_слова(система_розбирача::адреса, значення_файлу, слова::адреса, помилка_розбору_на_слова::адреса) == ні {
      ціль рядок = мавка::розбирач::отримати_рядок_помилки_розбору_на_слова(система_розбирача::адреса, помилка_розбору_на_слова);
      ціль ю8_помилки = ю8 { пусто, 0 };
      розбирач::отримати_ю8_помилки_розбору_на_слова(система_розбирача::адреса, помилка_розбору_на_слова, ю8_помилки::адреса);
      розбирач::звільнити_помилку_розбору_на_слова(система_розбирача::адреса, помилка_розбору_на_слова);
      ціль предмет_юнікоду = МаМа::виділити_предмет_юнікоду_з_ю8(М, ю8_помилки);
      розбирач::звільнити_памʼять(система_розбирача::адреса, ю8_помилки.дані);
      змінна ціль місцезнаходження_падіння: адреса<МаМа::МісцезнаходженняПадіння> = пусто;
      якщо так {
        місцезнаходження_падіння = МаМа::виділити_місцезнаходження_падіння(
          М,
          ю8_шлях,
          рядок
        );
      }
      МаМа::увімкнути_стан_падіння(М, місцезнаходження_падіння);
      вернути предмет_юнікоду як адреса<МаМа::Предмет>;
    }
    змінна ціль гілки = розбирач::Гілки { 0, пусто };
    змінна ціль помилка_розбору_на_гілки = розбирач::ПомилкаРозборуНаГілки { ... };
    якщо розбирач::розібрати_слова_на_гілки(система_розбирача::адреса, слова, гілки::адреса, помилка_розбору_на_гілки::адреса) == ні {
      ціль рядок = мавка::розбирач::отримати_рядок_помилки_розбору_на_гілки(система_розбирача::адреса, помилка_розбору_на_гілки);
      ціль ю8_помилки = ю8 { пусто, 0 };
      розбирач::отримати_ю8_помилки_розбору_на_гілки(система_розбирача::адреса, помилка_розбору_на_гілки, ю8_помилки::адреса);
      розбирач::звільнити_слова(система_розбирача::адреса, слова);
      розбирач::звільнити_помилку_розбору_на_гілки(система_розбирача::адреса, помилка_розбору_на_гілки);
      ціль предмет_юнікоду = МаМа::виділити_предмет_юнікоду_з_ю8(М, ю8_помилки);
      розбирач::звільнити_памʼять(система_розбирача::адреса, ю8_помилки.дані);
      змінна ціль місцезнаходження_падіння: адреса<МаМа::МісцезнаходженняПадіння> = пусто;
      якщо так {
        місцезнаходження_падіння = МаМа::виділити_місцезнаходження_падіння(
          М,
          ю8_шлях,
          рядок
        );
      }
      МаМа::увімкнути_стан_падіння(М, місцезнаходження_падіння);
      вернути предмет_юнікоду як адреса<МаМа::Предмет>;
    }
    ціль код = МаМа::виділити_код(М, ю8_шлях);
    ціль контекст_компіляції = виділити_контекст_компіляції(обчислювач, значення_файлу, слова);
    ціль помилка_компіляції = скомпілювати_тіло(обчислювач, контекст_компіляції, код, гілки, так);
    якщо помилка_компіляції != пусто {
      ціль предмет_тексту = МаМа::виділити_предмет_юнікоду_з_ю8(М, ю8 { помилка_компіляції.повідомлення, МаМа::порахувати_розмір_Ю8(помилка_компіляції.повідомлення) });
      змінна ціль місцезнаходження_падіння: адреса<МаМа::МісцезнаходженняПадіння> = пусто;
      якщо помилка_компіляції.місцезнаходження != пусто {
        місцезнаходження_падіння = МаМа::виділити_місцезнаходження_падіння(
          М,
          ю8_шлях,
          помилка_компіляції.місцезнаходження.рядок
        );
      }
      МаМа::увімкнути_стан_падіння(М, місцезнаходження_падіння);
      вернути предмет_тексту як адреса<МаМа::Предмет>;
    }
    звільнити_контекст_компіляції(обчислювач, контекст_компіляції);
    розбирач::звільнити_слова(система_розбирача::адреса, слова);
    розбирач::звільнити_гілки(система_розбирача::адреса, гілки);
    звільнити_памʼять(обчислювач, значення_файлу.дані);
//    МаМа::надрукувати_код(код);
    ціль результат_виконання_коду = МаМа::виконати_код(М, М.глобальне_середовище, код, пусто, предмет_модуля_запису, предмет_модуля_запису як адреса<МаМа::Предмет>);
    вернути результат_виконання_коду;
  }

  дія машина_обробник_взяття_біб(М: адреса<МаМа::Машина>, предмет_модуля_запису: адреса<МаМа::ПредметМодуля>, шлях: МаМа::Накопичувач<адреса<МаМа::Назва>>): МаМа::предмет_або_стан_падіння {
    якщо шлях.дані[0] == М.БН.С.М {
      бібліотека::заповнити_модуль_М(М.оболонка як адреса<Обчислювач>, предмет_модуля_запису як адреса<Предмет>);
      вернути предмет_модуля_запису як адреса<МаМа::Предмет>;
    }
    якщо шлях.дані[0] == М.БН.С.мавка {
      бібліотека::заповнити_модуль_мавка(М.оболонка як адреса<Обчислювач>, предмет_модуля_запису як адреса<Предмет>);
      вернути предмет_модуля_запису як адреса<МаМа::Предмет>;
    }
    якщо шлях.дані[0] == М.БН.С.МаМа {
      бібліотека::заповнити_модуль_МаМа(М.оболонка як адреса<Обчислювач>, предмет_модуля_запису як адреса<Предмет>);
      вернути предмет_модуля_запису як адреса<МаМа::Предмет>;
    }
    якщо шлях.дані[0] == М.БН.С.читати_юнікод {
      бібліотека::заповнити_модуль_читати_юнікод(М.оболонка як адреса<Обчислювач>, предмет_модуля_запису як адреса<Предмет>);
      вернути предмет_модуля_запису як адреса<МаМа::Предмет>;
    }
    МаМа::увімкнути_стан_падіння(М, пусто);
    вернути МаМа::виділити_предмет_тексту_з_ю8(М, ю8"Не вдалося знайти модуль біб") як адреса<МаМа::Предмет>;
  }

  дія машина_виділити_памʼять(М: адреса<МаМа::Машина>, розмір: позитивне): памʼять<п8> {
    ціль обчислювач = М.оболонка як адреса<Обчислювач>;
    вернути обчислювач.система.виділити_сиру_памʼять(обчислювач, розмір);
  }

  дія машина_перевиділити_памʼять(М: адреса<МаМа::Машина>, значення: памʼять<п8>, новий_розмір: позитивне): памʼять<п8> {
    ціль обчислювач = М.оболонка як адреса<Обчислювач>;
    вернути обчислювач.система.перевиділити_сиру_памʼять(обчислювач, значення, новий_розмір);
  }

  дія машина_звільнити_памʼять(М: адреса<МаМа::Машина>, значення: памʼять<п8>) {
    ціль обчислювач = М.оболонка як адреса<Обчислювач>;
    обчислювач.система.звільнити_сиру_памʼять(обчислювач, значення);
  }

  дія машина_вивести(М: адреса<МаМа::Машина>, значення: текст) {
    ціль обчислювач = М.оболонка як адреса<Обчислювач>;
    обчислювач.система.вивести(обчислювач, значення);
  }

  дія машина_вивести_Ю8(М: адреса<МаМа::Машина>, значення: ю8) {
    ціль обчислювач = М.оболонка як адреса<Обчислювач>;
    обчислювач.система.вивести_Ю8(обчислювач, значення);
  }

  дія машина_померти(М: адреса<МаМа::Машина>, код: ц32) {
    ціль обчислювач = М.оболонка як адреса<Обчислювач>;
    обчислювач.система.померти(обчислювач, код);
  }

  зовнішня дія виділити_обчислювач(виділити_сиру_памʼять: (розмір: позитивне) -> памʼять<п8>): адреса<Обчислювач> {
    вернути виділити_сиру_памʼять(Обчислювач.розмір) як адреса<Обчислювач>;
  }

  дія машина_підлога_д64(М: адреса<МаМа::Машина>, значення: д64): д64 {
    вернути д64(математика::підлога_д64(значення));
  }

  дія машина_піднести_до_степеня_д64(М: адреса<МаМа::Машина>, база: д64, експонента: д64): д64 {
    вернути д64(математика::степінь_д64(база, експонента));
  }

  дія машина_негація_д64(М: адреса<МаМа::Машина>, значення: д64): д64 {
    вернути д64(mavka_negate(double(значення)));
  }

  дія машина_двійкова_негація_д64(М: адреса<МаМа::Машина>, значення: д64): д64 {
    вернути д64(mavka_bitnot(double(значення)));
  }

  дія машина_д64_в_Ю8(М: адреса<МаМа::Машина>, значення: д64, вихід: адреса<ю8>, розмір_виходу: адреса<позитивне>) {
    ціль значення_ю8сі: памʼять<п8> = пусто;
    розмір_виходу::вміст = mavka_double_to_string(значення, значення_ю8сі::адреса як адреса<адреса<char>>);
    вихід::вміст = ю8 { значення_ю8сі, розмір_виходу::вміст };
  }

  зовнішня дія налаштувати_обчислювач(обчислювач: адреса<Обчислювач>, версія_мавки: ВерсіяМавки, система: Система) {
    обчислювач.система = система;
    обчислювач.версія_мавки = версія_мавки;
    обчислювач.М = обчислювач.система.виділити_сиру_памʼять(обчислювач, МаМа::Машина.розмір) як адреса<МаМа::Машина>;
    МаМа::налаштувати_машину(обчислювач.М, обчислювач, МаМа::Система {
      виділити_памʼять = машина_виділити_памʼять,
      перевиділити_памʼять = машина_перевиділити_памʼять,
      звільнити_памʼять = машина_звільнити_памʼять,
      вивести = машина_вивести,
      вивести_Ю8 = машина_вивести_Ю8,
      померти = машина_померти,
      підлога_д64 = машина_підлога_д64,
      піднести_до_степеня_д64 = машина_піднести_до_степеня_д64,
      негація_д64 = машина_негація_д64,
      двійкова_негація_д64 = машина_двійкова_негація_д64,
      д64_в_Ю8 = машина_д64_в_Ю8,
    });
    обчислювач.М.обробник_отримання_шляху_до_модуля = машина_обробник_отримання_шляху_до_модуля;
    обчислювач.М.обробник_взяття_модуля = машина_обробник_взяття_модуля;
    обчислювач.М.обробник_взяття_біб = машина_обробник_взяття_біб;
  }

  зовнішня дія розлаштувати_обчислювач(обчислювач: адреса<Обчислювач>) {
    МаМа::розлаштувати_машину(обчислювач.М);
  }

  структура ДаніДіалогу {
    обчислювач: адреса<Обчислювач>;
    середовище: адреса<МаМа::Середовище>;
  }

  дія діалог_виконати(дані: адреса, значення: памʼять<п8>, розмір_значення: позитивне) {
    ціль значення_файлу = ю8 { значення, розмір_значення };
    якщо МаМа::перевірити_чи_ю8_рівні(значення_файлу, ю8"") == так {
    } інакше {
      ціль дані_діалогу = дані як адреса<ДаніДіалогу>;
      ціль обчислювач = дані_діалогу.обчислювач;
      ціль середовище = дані_діалогу.середовище;
      ціль система_розбирача = розбирач::Система {
        дані = обчислювач,
        виділити_сиру_памʼять = система_розбирача_виділити_сиру_памʼять,
        перевиділити_сиру_памʼять = система_розбирача_перевиділити_сиру_памʼять,
        звільнити_сиру_памʼять = система_розбирача_звільнити_сиру_памʼять,
      };
      змінна ціль слова = розбирач::Слова { 0, пусто };
      змінна ціль помилка_розбору_на_слова = розбирач::ПомилкаРозборуНаСлова { ... };
      якщо розбирач::розібрати_ю8_на_слова(система_розбирача::адреса, значення_файлу, слова::адреса, помилка_розбору_на_слова::адреса) == ні {
        ціль рядок = мавка::розбирач::отримати_рядок_помилки_розбору_на_слова(система_розбирача::адреса, помилка_розбору_на_слова);
        ціль ю8_помилки = ю8 { пусто, 0 };
        розбирач::отримати_ю8_помилки_розбору_на_слова(система_розбирача::адреса, помилка_розбору_на_слова, ю8_помилки::адреса);
        розбирач::звільнити_помилку_розбору_на_слова(система_розбирача::адреса, помилка_розбору_на_слова);
        // потім: надрукувати помилку
        розбирач::звільнити_памʼять(система_розбирача::адреса, ю8_помилки.дані);
        вернути;
      }
      змінна ціль гілки = розбирач::Гілки { 0, пусто };
      змінна ціль помилка_розбору_на_гілки = розбирач::ПомилкаРозборуНаГілки { ... };
      якщо розбирач::розібрати_слова_на_гілки(система_розбирача::адреса, слова, гілки::адреса, помилка_розбору_на_гілки::адреса) == ні {
        ціль рядок = мавка::розбирач::отримати_рядок_помилки_розбору_на_гілки(система_розбирача::адреса, помилка_розбору_на_гілки);
        ціль ю8_помилки = ю8 { пусто, 0 };
        розбирач::отримати_ю8_помилки_розбору_на_гілки(система_розбирача::адреса, помилка_розбору_на_гілки, ю8_помилки::адреса);
        розбирач::звільнити_слова(система_розбирача::адреса, слова);
        розбирач::звільнити_помилку_розбору_на_гілки(система_розбирача::адреса, помилка_розбору_на_гілки);
        // потім: надрукувати помилку
        розбирач::звільнити_памʼять(система_розбирача::адреса, ю8_помилки.дані);
        вернути;
      }
      ціль код = МаМа::виділити_код(обчислювач.М, ю8"ДМ://");
      ціль контекст_компіляції = виділити_контекст_компіляції(обчислювач, значення_файлу, слова);
      ціль помилка_компіляції = скомпілювати_тіло(обчислювач, контекст_компіляції, код, гілки, так);
      якщо помилка_компіляції != пусто {
        ціль предмет_тексту = МаМа::виділити_предмет_юнікоду_з_ю8(обчислювач.М, ю8 { помилка_компіляції.повідомлення, МаМа::порахувати_розмір_Ю8(помилка_компіляції.повідомлення) });
        змінна ціль місцезнаходження_падіння: адреса<МаМа::МісцезнаходженняПадіння> = пусто;
        якщо помилка_компіляції.місцезнаходження != пусто {
          місцезнаходження_падіння = МаМа::виділити_місцезнаходження_падіння(
            обчислювач.М,
            ю8"ДМ://",
            помилка_компіляції.місцезнаходження.рядок
          );
        }
        // потім: надрукувати помилку
        вернути;
      }
      звільнити_контекст_компіляції(обчислювач, контекст_компіляції);
      розбирач::звільнити_слова(система_розбирача::адреса, слова);
      розбирач::звільнити_гілки(система_розбирача::адреса, гілки);
      ціль результат_виконання_коду = МаМа::виконати_код_в_середовищі(обчислювач.М, середовище, код);
      якщо обчислювач.М.стан_падіння == позитивне(так) {
        // потім: надрукувати падіння
        МаМа::вимкнути_стан_падіння(обчислювач.М);
      } інакше {
        надрукувати_предмет(обчислювач, результат_виконання_коду як адреса<Предмет>);
      }
    }
  }

  зовнішня дія почати_діалог(обчислювач: адреса<Обчислювач>): Результат {
    ціль дані_діалогу = виділити<ДаніДіалогу>(обчислювач);
    дані_діалогу.обчислювач = обчислювач;
    дані_діалогу.середовище = МаМа::покласти_тимчасове_середовище(обчислювач.М);
    вивести_Ю8(обчислювач, ю8"Діалог Мавки ");
    вивести_п64(обчислювач, обчислювач.версія_мавки.г);
    вивести_Ю8(обчислювач, ю8".");
    вивести_п64(обчислювач, обчислювач.версія_мавки.м);
    вивести_Ю8(обчислювач, ю8".");
    вивести_п64(обчислювач, обчислювач.версія_мавки.в);
    вивести_Ю8(обчислювач, ю8"\n");
    обчислювач.система.розпочати_діалог(обчислювач, дані_діалогу, діалог_виконати);
    МаМа::забрати_тимчасове_середовище(обчислювач.М);
    вернути результат_успіх(обчислювач, пусто);
  }

  зовнішня дія взяти_файл_Ю8(обчислювач: адреса<Обчислювач>, назва_модуля: адреса<Назва>, шлях_до_файлу: ю8): Результат {
    ціль виправлений_шлях_до_файлу = ю8 { пусто, 0 };
    якщо обчислювач.система.виправити_шлях(обчислювач, шлях_до_файлу, виправлений_шлях_до_файлу::адреса) != 0 {
      // помилка
    }
    ціль предмет_модуля = МаМа::взяти_модуль_за_шляхом(обчислювач.М, обчислювач.М.глобальне_середовище, назва_модуля як адреса<МаМа::Назва>, виправлений_шлях_до_файлу);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      змінна ціль місцезнаходження_падіння: адреса<МісцезнаходженняПадіння> = пусто;
      якщо обчислювач.М.місцезнаходження_падіння != пусто {
        місцезнаходження_падіння = виділити_місцезнаходження_падіння(
          обчислювач,
          обчислювач.М.місцезнаходження_падіння.шлях_до_файлу,
          обчислювач.М.місцезнаходження_падіння.рядок
        );
      }
      ціль результат = результат_падіння(обчислювач, предмет_модуля як адреса<Предмет>, місцезнаходження_падіння);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, предмет_модуля як адреса<Предмет>);
  }

  зовнішня дія виконати_ю8(обчислювач: адреса<Обчислювач>, значення: ю8): Результат {
    // ...
  }

  зовнішня дія зберегти_предмет(обчислювач: адреса<Обчислювач>, предмет: адреса<Предмет>) {
    МаМа::зберегти_предмет(обчислювач.М, предмет як адреса<МаМа::Предмет>);
  }

  зовнішня дія видалити_збережений_предмет(обчислювач: адреса<Обчислювач>) {
    МаМа::видалити_збережений_предмет(обчислювач.М);
  }

  зовнішня дія назва_з_Ю8(обчислювач: адреса<Обчислювач>, значення: ю8): адреса<Назва> {
    вернути МаМа::назва_з_Ю8(обчислювач.М, значення) як адреса<Назва>;
  }

  зовнішня дія отримати_так(обчислювач: адреса<Обчислювач>): адреса<Предмет> {
    вернути обчислювач.М.предмет_логічного_так як адреса<Предмет>;
  }

  зовнішня дія отримати_ні(обчислювач: адреса<Обчислювач>): адреса<Предмет> {
    вернути обчислювач.М.предмет_логічного_ні як адреса<Предмет>;
  }

  зовнішня дія визначити_глобальний_підмет(обчислювач: адреса<Обчислювач>, назва: адреса<Назва>, предмет: адреса<Предмет>) {
    МаМа::змінити_в_середовищі(обчислювач.М, обчислювач.М.глобальне_середовище, назва як адреса<МаМа::Назва>, предмет як адреса<МаМа::Предмет>);
  }

  зовнішня дія утилізувати(обчислювач: адреса<Обчислювач>) {
    МаМа::утилізувати(обчислювач.М);
  }

  структура ДаніНативноїДії {
    обчислювач: адреса<Обчислювач>;
    нативна_дія: НативнаДія;
    дані: адреса;
    відклик_перед_звільненням: ВідкликПередЗвільненнямПредметаНативноїДії;
  }

  дія нативна_дія_нативної_дії(предмет_нативної_дії: адреса<МаМа::ПредметНативноїДії>, М: адреса<МаМа::Машина>, предмет_я: адреса<МаМа::Предмет>, аргументи: адреса<МаМа::Накопичувач<адреса<МаМа::Предмет>>>, іменовані_аргументи: адреса<МаМа::Реєстр<адреса<МаМа::Назва>, адреса<МаМа::Предмет>>>): адреса<МаМа::Предмет> {
    ціль дані_нативної_дії = предмет_нативної_дії.дані як адреса<ДаніНативноїДії>;
    ціль результат_нативної_дії = дані_нативної_дії.нативна_дія(
      предмет_нативної_дії як адреса<Предмет>,
      дані_нативної_дії.обчислювач,
      предмет_я як адреса<Предмет>,
      аргументи.розмір,
      аргументи.дані як памʼять<адреса<Предмет>>,
      іменовані_аргументи як адреса<ІменованіАргументи>,
      дані_нативної_дії.дані
    );
    якщо результат_нативної_дії.падіння != пусто {
      якщо результат_нативної_дії.падіння.місцезнаходження == пусто {
        МаМа::увімкнути_стан_падіння(М, пусто);
      } інакше {
        МаМа::увімкнути_стан_падіння(М, МаМа::виділити_місцезнаходження_падіння(
          М,
          результат_нативної_дії.падіння.місцезнаходження.шлях_до_файлу,
          результат_нативної_дії.падіння.місцезнаходження.рядок
        ));
      }
      звільнити_падіння(дані_нативної_дії.обчислювач, результат_нативної_дії.падіння);
      вернути результат_нативної_дії.значення як адреса<МаМа::Предмет>;
    }
    вернути результат_нативної_дії.значення як адреса<МаМа::Предмет>;
  }

  дія відклик_перед_звільненням_нативної_дії(предмет_нативної_дії: адреса<МаМа::ПредметНативноїДії>, М: адреса<МаМа::Машина>) {
    ціль дані_нативної_дії = предмет_нативної_дії.дані як адреса<ДаніНативноїДії>;
    якщо дані_нативної_дії.відклик_перед_звільненням != пусто {
      дані_нативної_дії.відклик_перед_звільненням(предмет_нативної_дії як адреса<Предмет>, дані_нативної_дії.обчислювач, дані_нативної_дії.дані);
    }
    звільнити(дані_нативної_дії.обчислювач, предмет_нативної_дії.дані);
  }

  зовнішня дія створити_нативну_дію(обчислювач: адреса<Обчислювач>, назва: адреса<Назва>, значення: НативнаДія, дані: адреса, відклик_перед_звільненням: ВідкликПередЗвільненнямПредметаНативноїДії): адреса<Предмет> {
    ціль дані_нативної_дії = виділити<ДаніНативноїДії>(обчислювач);
    дані_нативної_дії.обчислювач = обчислювач;
    дані_нативної_дії.нативна_дія = значення;
    дані_нативної_дії.дані = дані;
    дані_нативної_дії.відклик_перед_звільненням = відклик_перед_звільненням;
    ціль предмет_нативної_дії = МаМа::виділити_предмет_нативної_дії(обчислювач.М, назва як адреса<МаМа::Назва>, нативна_дія_нативної_дії, дані_нативної_дії, відклик_перед_звільненням_нативної_дії);
    вернути предмет_нативної_дії як адреса<Предмет>;
  }

  зовнішня дія створити_число(обчислювач: адреса<Обчислювач>, значення: д64): адреса<Предмет> {
    ціль предмет_числа = МаМа::виділити_предмет_числа(обчислювач.М, значення);
    вернути предмет_числа як адреса<Предмет>;
  }

  зовнішня дія створити_текст_з_Ю8(обчислювач: адреса<Обчислювач>, значення: ю8): адреса<Предмет> {
    ціль предмет_тексту = МаМа::виділити_предмет_тексту_з_ю8(обчислювач.М, значення);
    вернути предмет_тексту як адреса<Предмет>;
  }

  зовнішня дія створити_юнікод_з_Ю8(обчислювач: адреса<Обчислювач>, значення: ю8): адреса<Предмет> {
    ціль предмет_юнікоду = МаМа::виділити_предмет_юнікоду_з_ю8(обчислювач.М, значення);
    вернути предмет_юнікоду як адреса<Предмет>;
  }

  зовнішня дія створити_модуль(обчислювач: адреса<Обчислювач>, назва: адреса<Назва>): адреса<Предмет> {
    ціль предмет_модуля = МаМа::виділити_предмет_модуля(обчислювач.М, назва як адреса<МаМа::Назва>);
    вернути предмет_модуля як адреса<Предмет>;
  }

  зовнішня дія створити_список(обчислювач: адреса<Обчислювач>): адреса<Предмет> {
    ціль предмет_списку = МаМа::виділити_предмет_списку(обчислювач.М);
    вернути предмет_списку як адреса<Предмет>;
  }

  зовнішня дія створити_словник(обчислювач: адреса<Обчислювач>): адреса<Предмет> {
    ціль предмет_словника = МаМа::виділити_предмет_словника(обчислювач.М);
    вернути предмет_словника як адреса<Предмет>;
  }

  зовнішня дія створити_байти(обчислювач: адреса<Обчислювач>, розмір: позитивне): адреса<Предмет> {
    ціль предмет_байтів = МаМа::виділити_предмет_байтів(обчислювач.М, розмір);
    вернути предмет_байтів як адреса<Предмет>;
  }

  зовнішня дія створити_адресу(обчислювач: адреса<Обчислювач>, значення: адреса): адреса<Предмет> {
    ціль предмет_адреси = МаМа::виділити_предмет_адреси(обчислювач.М, значення);
    вернути предмет_адреси як адреса<Предмет>;
  }

  зовнішня дія створити_предмет(обчислювач: адреса<Обчислювач>): адреса<Предмет> {
    ціль предмет = МаМа::предмет_виконати(обчислювач.М.предмет_структури_предмет як адреса<МаМа::Предмет>, обчислювач.М, пусто, пусто, пусто);
    вернути предмет як адреса<Предмет>;
  }

  зовнішня дія предмет_виконати(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>): Результат {
    ціль накопичувач_аргументів = МаМа::виділити_накопичувач<адреса<МаМа::Предмет>>(обчислювач.М);
    змінна ціль п: позитивне = 0;
    поки п < кількість_аргументів {
      МаМа::покласти_в_накопичувач<адреса<МаМа::Предмет>>(обчислювач.М, накопичувач_аргументів, аргументи[п] як адреса<МаМа::Предмет>);
      п += 1;
    }
    ціль результат_виконання_предмету = МаМа::предмет_виконати(
      предмет як адреса<МаМа::Предмет>,
      обчислювач.М,
      предмет_я як адреса<МаМа::Предмет>,
      накопичувач_аргументів,
      пусто
    );
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_виконання_предмету як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_виконання_предмету як адреса<Предмет>);
  }

  зовнішня дія предмет_отримати_властивість(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, назва: адреса<Назва>): Результат {
    ціль предмет_властивості = МаМа::предмет_отримати_властивість(предмет як адреса<МаМа::Предмет>, обчислювач.М, назва як адреса<МаМа::Назва>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, предмет_властивості як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, предмет_властивості як адреса<Предмет>);
  }

  зовнішня дія предмет_змінити_властивість(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, назва: адреса<Назва>, значення: адреса<Предмет>): Результат {
    ціль результат_зміни_властивості = МаМа::предмет_змінити_властивість(предмет як адреса<МаМа::Предмет>, обчислювач.М, назва як адреса<МаМа::Назва>, значення як адреса<МаМа::Предмет>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_зміни_властивості як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, пусто);
  }

  зовнішня дія предмет_видалити_властивість(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, назва: адреса<Назва>): Результат {
    ціль результат_видалення_властивості = МаМа::предмет_видалити_властивість(предмет як адреса<МаМа::Предмет>, обчислювач.М, назва як адреса<МаМа::Назва>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_видалення_властивості як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, пусто);
  }

  зовнішня дія предмет_виконати_властивість(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, назва: адреса<Назва>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>): Результат {
    ціль накопичувач_аргументів = МаМа::виділити_накопичувач<адреса<МаМа::Предмет>>(обчислювач.М);
    змінна ціль п: позитивне = 0;
    поки п < кількість_аргументів {
      МаМа::покласти_в_накопичувач<адреса<МаМа::Предмет>>(обчислювач.М, накопичувач_аргументів, аргументи[п] як адреса<МаМа::Предмет>);
      п += 1;
    }
    ціль результат_виконання_властивості = МаМа::предмет_виконати_властивість(
      предмет як адреса<МаМа::Предмет>,
      обчислювач.М,
      назва як адреса<МаМа::Назва>,
      накопичувач_аргументів,
      пусто
    );
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_виконання_властивості як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_виконання_властивості як адреса<Предмет>);
  }

  зовнішня дія предмет_отримати_елемент(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, ключ: адреса<Предмет>): Результат {
    ціль результат_елементу = МаМа::предмет_отримати_елемент(предмет як адреса<МаМа::Предмет>, обчислювач.М, ключ як адреса<МаМа::Предмет>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_елементу як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_елементу як адреса<Предмет>);
  }

  зовнішня дія предмет_змінити_елемент(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, ключ: адреса<Предмет>, значення: адреса<Предмет>): Результат {
    ціль результат_зміни_елементу = МаМа::предмет_змінити_елемент(предмет як адреса<МаМа::Предмет>, обчислювач.М, ключ як адреса<МаМа::Предмет>, значення як адреса<МаМа::Предмет>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_зміни_елементу як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, пусто);
  }

  зовнішня дія предмет_видалити_елемент(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, ключ: адреса<Предмет>): Результат {
    ціль результат_видалення_елементу = МаМа::предмет_видалити_елемент(предмет як адреса<МаМа::Предмет>, обчислювач.М, ключ як адреса<МаМа::Предмет>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_видалення_елементу як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, пусто);
  }

  зовнішня дія предмет_отримати_перебір(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>): Результат {
    ціль результат_перебору = МаМа::предмет_отримати_перебір(предмет як адреса<МаМа::Предмет>, обчислювач.М);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_перебору як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_перебору як адреса<Предмет>);
  }

  зовнішня дія предмет_додати(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, аргумент: адреса<Предмет>): Результат {
    ціль результат_додавання = МаМа::предмет_додати(предмет як адреса<МаМа::Предмет>, обчислювач.М, аргумент як адреса<МаМа::Предмет>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_додавання як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_додавання як адреса<Предмет>);
  }

  зовнішня дія предмет_відняти(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, аргумент: адреса<Предмет>): Результат {
    ціль результат_віднімання = МаМа::предмет_відняти(предмет як адреса<МаМа::Предмет>, обчислювач.М, аргумент як адреса<МаМа::Предмет>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_віднімання як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_віднімання як адреса<Предмет>);
  }

  зовнішня дія предмет_помножити(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, аргумент: адреса<Предмет>): Результат {
    ціль результат_множення = МаМа::предмет_помножити(предмет як адреса<МаМа::Предмет>, обчислювач.М, аргумент як адреса<МаМа::Предмет>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_множення як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_множення як адреса<Предмет>);
  }

  зовнішня дія предмет_поділити(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, аргумент: адреса<Предмет>): Результат {
    ціль результат_ділення = МаМа::предмет_поділити(предмет як адреса<МаМа::Предмет>, обчислювач.М, аргумент як адреса<МаМа::Предмет>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_ділення як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_ділення як адреса<Предмет>);
  }

  зовнішня дія предмет_остача(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, аргумент: адреса<Предмет>): Результат {
    ціль результат_остачі = МаМа::предмет_отримати_остачу_ділення(предмет як адреса<МаМа::Предмет>, обчислювач.М, аргумент як адреса<МаМа::Предмет>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_остачі як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
  }

  зовнішня дія предмет_неповна_частка(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, аргумент: адреса<Предмет>): Результат {
    ціль результат_частки = МаМа::предмет_отримати_неповну_частку_ділення(предмет як адреса<МаМа::Предмет>, обчислювач.М, аргумент як адреса<МаМа::Предмет>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_частки як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_частки як адреса<Предмет>);
  }

  зовнішня дія предмет_степінь(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, аргумент: адреса<Предмет>): Результат {
    ціль результат_степені = МаМа::предмет_піднести_до_степеня(предмет як адреса<МаМа::Предмет>, обчислювач.М, аргумент як адреса<МаМа::Предмет>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_степені як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_степені як адреса<Предмет>);
  }

  зовнішня дія предмет_вліво(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, аргумент: адреса<Предмет>): Результат {
    ціль результат_вліво = МаМа::предмет_зсунути_вліво(предмет як адреса<МаМа::Предмет>, обчислювач.М, аргумент як адреса<МаМа::Предмет>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_вліво як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_вліво як адреса<Предмет>);
  }

  зовнішня дія предмет_вправо_зі_заповненням(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, аргумент: адреса<Предмет>): Результат {
    ціль результат_вправо = МаМа::предмет_зсунути_вправо_зі_заповненням(предмет як адреса<МаМа::Предмет>, обчислювач.М, аргумент як адреса<МаМа::Предмет>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_вправо як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_вправо як адреса<Предмет>);
  }

  зовнішня дія предмет_двійкове_і(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, аргумент: адреса<Предмет>): Результат {
    ціль результат_двійкового_і = МаМа::предмет_двійкове_і(предмет як адреса<МаМа::Предмет>, обчислювач.М, аргумент як адреса<МаМа::Предмет>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_двійкового_і як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_двійкового_і як адреса<Предмет>);
  }

  зовнішня дія предмет_двійкове_або(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, аргумент: адреса<Предмет>): Результат {
    ціль результат_двійкового_або = МаМа::предмет_двійкове_або(предмет як адреса<МаМа::Предмет>, обчислювач.М, аргумент як адреса<МаМа::Предмет>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_двійкового_або як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_двійкового_або як адреса<Предмет>);
  }

  зовнішня дія предмет_двійкове_виключне_або(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, аргумент: адреса<Предмет>): Результат {
    ціль результат_двійкового_виключного_або = МаМа::предмет_двійкове_виключне_або(предмет як адреса<МаМа::Предмет>, обчислювач.М, аргумент як адреса<МаМа::Предмет>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_двійкового_виключного_або як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_двійкового_виключного_або як адреса<Предмет>);
  }

  зовнішня дія предмет_двійкове_не(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>): Результат {
    ціль результат_двійкового_не = МаМа::предмет_двійкове_не(предмет як адреса<МаМа::Предмет>, обчислювач.М);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_двійкового_не як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_двійкового_не як адреса<Предмет>);
  }

  зовнішня дія предмет_більше(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, аргумент: адреса<Предмет>): Результат {
    ціль результат_більше = МаМа::предмет_більше(предмет як адреса<МаМа::Предмет>, обчислювач.М, аргумент як адреса<МаМа::Предмет>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_більше як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_більше як адреса<Предмет>);
  }

  зовнішня дія предмет_менше(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, аргумент: адреса<Предмет>): Результат {
    ціль результат_менше = МаМа::предмет_менше(предмет як адреса<МаМа::Предмет>, обчислювач.М, аргумент як адреса<МаМа::Предмет>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_менше як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_менше як адреса<Предмет>);
  }

  зовнішня дія предмет_рівно(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, аргумент: адреса<Предмет>): Результат {
    ціль результат_рівно = МаМа::предмет_рівно(предмет як адреса<МаМа::Предмет>, обчислювач.М, аргумент як адреса<МаМа::Предмет>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_рівно як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_рівно як адреса<Предмет>);
  }

  зовнішня дія предмет_містить(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, аргумент: адреса<Предмет>): Результат {
    ціль результат_містить = МаМа::предмет_містить(предмет як адреса<МаМа::Предмет>, обчислювач.М, аргумент як адреса<МаМа::Предмет>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_містить як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_містить як адреса<Предмет>);
  }

  зовнішня дія предмет_є(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, аргумент: адреса<Предмет>): Результат {
    ціль результат_є = МаМа::предмет_є(предмет як адреса<МаМа::Предмет>, обчислювач.М, аргумент як адреса<МаМа::Предмет>);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_є як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_є як адреса<Предмет>);
  }

  зовнішня дія предмет_відʼємне(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>): Результат {
    ціль результат_відʼємне = МаМа::предмет_відʼємне(предмет як адреса<МаМа::Предмет>, обчислювач.М);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_відʼємне як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_відʼємне як адреса<Предмет>);
  }

  зовнішня дія предмет_числове(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>): Результат {
    ціль результат_числове = МаМа::предмет_числове(предмет як адреса<МаМа::Предмет>, обчислювач.М);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_числове як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_числове як адреса<Предмет>);
  }

  зовнішня дія предмет_заперечити(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>): Результат {
    ціль результат_заперечення = МаМа::предмет_заперечити(предмет як адреса<МаМа::Предмет>, обчислювач.М);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_заперечення як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_заперечення як адреса<Предмет>);
  }

  зовнішня дія предмет_збільшити(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>): Результат {
    ціль результат_збільшення = МаМа::предмет_збільшити(предмет як адреса<МаМа::Предмет>, обчислювач.М);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_збільшення як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_збільшення як адреса<Предмет>);
  }

  зовнішня дія предмет_зменшити(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>): Результат {
    ціль результат_зменшення = МаМа::предмет_зменшити(предмет як адреса<МаМа::Предмет>, обчислювач.М);
    якщо обчислювач.М.стан_падіння == позитивне(так) {
      ціль результат = результат_падіння(обчислювач, результат_зменшення як адреса<Предмет>, пусто);
      МаМа::вимкнути_стан_падіння(обчислювач.М);
      вернути результат;
    }
    вернути результат_успіх(обчислювач, результат_зменшення як адреса<Предмет>);
  }

  зовнішня дія скопіювати_значення_предмета_юнікоду_як_Ю8(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, вихід: адреса<ю8>): логічне {
    ціль предмет_юнікоду_МаМа = предмет як адреса<МаМа::ПредметЮнікоду>;
    змінна ціль значення_ю8сі: памʼять<п8> = пусто;
    ціль розмір_значення_ю8сі = МаМа::перекодувати_Ю32_в_Ю8(обчислювач.М, предмет_юнікоду_МаМа.значення, предмет_юнікоду_МаМа.довжина, значення_ю8сі::адреса);
    якщо розмір_значення_ю8сі == 0 {
      померти_ю8(обчислювач, ю8"Неможливо перекодувати Ю32 в Ю8");
    }
    вихід::вміст = ю8 { значення_ю8сі, розмір_значення_ю8сі };
    вернути так;
  }

  зовнішня дія результат_успіх(обчислювач: адреса<Обчислювач>, предмет: адреса<Предмет>): Результат {
    вернути Результат { падіння = пусто, значення = предмет };
  }

  зовнішня дія результат_падіння(обчислювач: адреса<Обчислювач>, предмет: адреса<Предмет>, місцезнаходження_падіння: адреса<МісцезнаходженняПадіння>): Результат {
    // потім: зробити копію місцезнаходження падіння
    // потім: зробити копію історії виконання падіння
    ціль падіння = виділити_падіння(обчислювач, місцезнаходження_падіння, 0, пусто);
    вернути Результат { падіння = падіння, значення = предмет };
  }

  зовнішня дія виділити_падіння(обчислювач: адреса<Обчислювач>, місцезнаходження_падіння: адреса<МісцезнаходженняПадіння>, розмір_історії: позитивне, історія: памʼять<ЕлементІсторіїПадіння>): адреса<Падіння> {
    ціль падіння = виділити<Падіння>(обчислювач);
    падіння.місцезнаходження = місцезнаходження_падіння;
    падіння.розмір_історії = розмір_історії;
    падіння.історія = історія;
    вернути падіння;
  }

  зовнішня дія звільнити_падіння(обчислювач: адреса<Обчислювач>, падіння: адреса<Падіння>) {
    якщо падіння.місцезнаходження != пусто {
      звільнити_місцезнаходження_падіння(обчислювач, падіння.місцезнаходження);
    }
    змінна ціль п: позитивне = 0;
    поки п < падіння.розмір_історії {
      звільнити_памʼять(обчислювач, падіння.історія[п].шлях_до_файлу.дані);
      п += 1;
    }
    якщо падіння.історія != пусто {
      звільнити_памʼять(обчислювач, падіння.історія);
    }
    звільнити(обчислювач, падіння);
  }

  зовнішня дія виділити_місцезнаходження_падіння(обчислювач: адреса<Обчислювач>, шлях_до_файлу: ю8, рядок: позитивне): адреса<МісцезнаходженняПадіння> {
    ціль місцезнаходження_падіння = виділити<МісцезнаходженняПадіння>(обчислювач);
    якщо МаМа::виділити_копію_ю8_цілі(обчислювач.М, шлях_до_файлу, місцезнаходження_падіння.шлях_до_файлу::адреса) == ні {
      померти_ю8(обчислювач, ю8"Неможливо виділити копію шляху до файлу");
    }
    місцезнаходження_падіння.рядок = позитивне(рядок);
    вернути місцезнаходження_падіння;
  }

  зовнішня дія звільнити_місцезнаходження_падіння(обчислювач: адреса<Обчислювач>, місцезнаходження_падіння: адреса<МісцезнаходженняПадіння>) {
    звільнити_памʼять(обчислювач, місцезнаходження_падіння.шлях_до_файлу.дані);
    звільнити(обчислювач, місцезнаходження_падіння);
  }

  зовнішня дія отримати_шлях_до_файлу_з_місцезнаходження_падіння(обчислювач: адреса<Обчислювач>, місцезнаходження_падіння: адреса<МісцезнаходженняПадіння>): ю8 {
    ціль мп = місцезнаходження_падіння як адреса<МаМа::МісцезнаходженняПадіння>;
    вернути мп.шлях_до_файлу;
  }

  зовнішня дія отримати_рядок_з_місцезнаходження_падіння(обчислювач: адреса<Обчислювач>, місцезнаходження_падіння: адреса<МісцезнаходженняПадіння>): позитивне {
    ціль мп = місцезнаходження_падіння як адреса<МаМа::МісцезнаходженняПадіння>;
    вернути мп.рядок;
  }

  зовнішня дія отримати_текстове_зображення_предмета_як_Ю8(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, вихід: адреса<ю8>): позитивне {
    ціль накопичувач_ю8 = МаМа::зробити_накопичувач_ю8(обчислювач.М);
    МаМа::надрукувати_предмет_в_накопичувач_ю8(предмет як адреса<МаМа::Предмет>, обчислювач.М, накопичувач_ю8::адреса, 0);
    вихід::вміст = МаМа::виділити_ю8_з_накопичувача_ю8(обчислювач.М, накопичувач_ю8::адреса);
    МаМа::звільнити_значення_накопичувача_ю8(обчислювач.М, накопичувач_ю8);
    вернути вихід::вміст.розмір;
  }

  зовнішня дія отримати_значення_числа(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>): д64 {
    якщо перевірити_чи_предмет_є_числом(предмет, обчислювач) == ні {
      вернути 0;
    }
    ціль предмет_числа = предмет як адреса<МаМа::ПредметЧисла>;
    вернути предмет_числа.значення;
  }

  зовнішня дія перевірити_чи_предмет_виражається_логічним_так(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>): логічне {
    вернути МаМа::перевірити_чи_предмет_виражається_логічним_так(предмет як адреса<МаМа::Предмет>, обчислювач.М);
  }

  зовнішня дія перевірити_чи_предмет_є_дією(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>): логічне {
    вернути МаМа::перевірити_чи_предмет_є_дією(предмет як адреса<МаМа::Предмет>, обчислювач.М);
  }

  зовнішня дія перевірити_чи_предмет_є_нативною_дією(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>): логічне {
    вернути МаМа::перевірити_чи_предмет_є_нативною_дією(предмет як адреса<МаМа::Предмет>, обчислювач.М);
  }

  зовнішня дія перевірити_чи_предмет_є_числом(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>): логічне {
    вернути МаМа::перевірити_чи_предмет_є_числом(предмет як адреса<МаМа::Предмет>, обчислювач.М);
  }

  зовнішня дія перевірити_чи_предмет_є_текстом(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>): логічне {
    вернути МаМа::перевірити_чи_предмет_є_текстом(предмет як адреса<МаМа::Предмет>, обчислювач.М);
  }

  зовнішня дія перевірити_чи_предмет_є_юнікодом(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>): логічне {
    вернути МаМа::перевірити_чи_предмет_є_юнікодом(предмет як адреса<МаМа::Предмет>, обчислювач.М);
  }

  зовнішня дія перевірити_чи_предмет_є_модулем(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>): логічне {
    вернути МаМа::перевірити_чи_предмет_є_модулем(предмет як адреса<МаМа::Предмет>, обчислювач.М);
  }

  зовнішня дія перевірити_чи_предмет_є_списком(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>): логічне {
    вернути МаМа::перевірити_чи_предмет_є_списком(предмет як адреса<МаМа::Предмет>, обчислювач.М);
  }

  зовнішня дія перевірити_чи_предмет_є_словником(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>): логічне {
    вернути МаМа::перевірити_чи_предмет_є_словником(предмет як адреса<МаМа::Предмет>, обчислювач.М);
  }

  зовнішня дія перевірити_чи_предмет_є_логічним(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>): логічне {
    вернути МаМа::перевірити_чи_предмет_є_логічним(предмет як адреса<МаМа::Предмет>, обчислювач.М);
  }

  зовнішня дія перевірити_чи_предмет_є_байтами(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>): логічне {
    вернути МаМа::перевірити_чи_предмет_є_байтами(предмет як адреса<МаМа::Предмет>, обчислювач.М);
  }

  зовнішня дія перевірити_чи_предмет_є_адресою(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>): логічне {
    вернути МаМа::перевірити_чи_предмет_є_адресою(предмет як адреса<МаМа::Предмет>, обчислювач.М);
  }

  зовнішня дія записати_в_байти(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, дані: памʼять<п8>, розмір: позитивне, зсув: позитивне) {
    МаМа::записати_в_байти(предмет як адреса<МаМа::ПредметБайтів>, обчислювач.М, дані, розмір, зсув);
  }

  зовнішня дія отримати_копію_даних_тексту(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, вихід: адреса<текст>): логічне {
    вернути МаМа::отримати_копію_даних_тексту(предмет як адреса<МаМа::ПредметТексту>, обчислювач.М, вихід);
  }

  зовнішня дія отримати_дані_тексту(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, вихід: адреса<текст>): логічне {
    вернути МаМа::отримати_дані_тексту(предмет як адреса<МаМа::ПредметТексту>, обчислювач.М, вихід);
  }

  зовнішня дія отримати_копію_даних_юнікоду(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, вихід: адреса<памʼять<п32>>): позитивне {
    вернути МаМа::отримати_копію_даних_юнікоду(предмет як адреса<МаМа::ПредметЮнікоду>, обчислювач.М, вихід);
  }

  зовнішня дія отримати_дані_юнікоду(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, вихід: адреса<памʼять<п32>>): позитивне {
    вернути МаМа::отримати_дані_юнікоду(предмет як адреса<МаМа::ПредметЮнікоду>, обчислювач.М, вихід);
  }

  зовнішня дія отримати_копію_даних_юнікоду_як_Ю8(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, вихід: адреса<ю8>): логічне {
    вернути МаМа::отримати_копію_даних_юнікоду_як_Ю8(предмет як адреса<МаМа::ПредметЮнікоду>, обчислювач.М, вихід);
  }

  зовнішня дія отримати_копію_даних_байтів(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, вихід: адреса<памʼять<п8>>): позитивне {
    вернути МаМа::отримати_копію_даних_байтів(предмет як адреса<МаМа::ПредметБайтів>, обчислювач.М, вихід);
  }

  зовнішня дія отримати_дані_байтів(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>, вихід: адреса<памʼять<п8>>): позитивне {
    вернути МаМа::отримати_дані_байтів(предмет як адреса<МаМа::ПредметБайтів>, обчислювач.М, вихід);
  }

  зовнішня дія отримати_значення_адреси(предмет: адреса<Предмет>, обчислювач: адреса<Обчислювач>): адреса {
    вернути МаМа::отримати_значення_адреси(предмет як адреса<МаМа::ПредметАдреси>, обчислювач.М);
  }

  зовнішня дія знайти_іменований_аргумент(обчислювач: адреса<Обчислювач>, іменовані_аргументи: адреса<ІменованіАргументи>, назва: адреса<Назва>, вихід: адреса<адреса<Предмет>>): логічне {
    ціль реєстр_іменованих_аргументів = іменовані_аргументи як адреса<МаМа::Реєстр<адреса<МаМа::Назва>, адреса<МаМа::Предмет>>>;
    ціль елемент_реєстру = МаМа::отримати_з_реєстру<адреса<МаМа::Назва>, адреса<МаМа::Предмет>>(обчислювач.М, реєстр_іменованих_аргументів, назва як адреса<МаМа::Назва>);
    якщо елемент_реєстру == пусто {
      вернути ні;
    }
    вихід::вміст = елемент_реєстру.значення як адреса<Предмет>;
    вернути так;
  }

  зовнішня дія записати_іменований_аргумент(обчислювач: адреса<Обчислювач>, іменовані_аргументи: адреса<ІменованіАргументи>, назва: адреса<Назва>, значення: адреса<Предмет>) {
    ціль реєстр_іменованих_аргументів = іменовані_аргументи як адреса<МаМа::Реєстр<адреса<МаМа::Назва>, адреса<МаМа::Предмет>>>;
    МаМа::змінити_в_реєстрі<адреса<МаМа::Назва>, адреса<МаМа::Предмет>>(обчислювач.М, реєстр_іменованих_аргументів, назва як адреса<МаМа::Назва>, значення як адреса<МаМа::Предмет>);
  }

  зовнішня дія виділити_іменовані_аргументи(обчислювач: адреса<Обчислювач>): адреса<ІменованіАргументи> {
    вернути пусто;
  }

  зовнішня дія звільнити_іменовані_аргументи(обчислювач: адреса<Обчислювач>, іменовані_аргументи: адреса<ІменованіАргументи>) {
    // ...
  }

  зовнішня дія вивести_Ю8(обчислювач: адреса<Обчислювач>, значення: ю8) {
    МаМа::вивести_Ю8(обчислювач.М, значення);
  }

  зовнішня дія надрукувати_Ю8(обчислювач: адреса<Обчислювач>, значення: ю8) {
    МаМа::надрукувати_Ю8(обчислювач.М, значення);
  }

  зовнішня дія надрукувати_предмет(обчислювач: адреса<Обчислювач>, значення: адреса<Предмет>) {
    МаМа::надрукувати_предмет(значення як адреса<МаМа::Предмет>, обчислювач.М, 1);
  }

  зовнішня дія вивести_п64(обчислювач: адреса<Обчислювач>, значення: п64) {
    МаМа::вивести_п64(обчислювач.М, значення);
  }

  зовнішня дія вивести_ю8(обчислювач: адреса<Обчислювач>, значення: ю8) {
    МаМа::вивести_Ю8(обчислювач.М, значення);
  }

  зовнішня дія надрукувати_ю8(обчислювач: адреса<Обчислювач>, значення: ю8) {
    МаМа::надрукувати_Ю8(обчислювач.М, значення);
  }

  зовнішня дія виділити_копію_тексту_цілі(обчислювач: адреса<Обчислювач>, значення: текст, вихід: адреса<текст>): логічне {
    ціль М = обчислювач.М;
    вернути МаМа::виділити_копію_тексту_цілі(М, значення, вихід);
  }

  зовнішня дія виділити_копію_ю8_цілі(обчислювач: адреса<Обчислювач>, значення: ю8, вихід: адреса<ю8>): логічне {
    ціль М = обчислювач.М;
    вернути МаМа::виділити_копію_ю8_цілі(М, значення, вихід);
  }

  зовнішня дія виділити_копію_ю8_цілі_з_ю8сі(обчислювач: адреса<Обчислювач>, значення: памʼять<п8>, вихід: адреса<ю8>): логічне {
    ціль М = обчислювач.М;
    вернути МаМа::виділити_копію_ю8_цілі_з_ю8сі(М, значення, вихід);
  }

  зовнішня дія виділити_копію_ю8сі_цілі_з_ю8(обчислювач: адреса<Обчислювач>, значення: ю8, вихід: адреса<памʼять<п8>>): логічне {
    ціль М = обчислювач.М;
    вернути МаМа::виділити_копію_ю8сі_цілі_з_ю8(М, значення, вихід);

  }

  зовнішня дія виділити_копію_ю8сі_цілі_з_тексту(обчислювач: адреса<Обчислювач>, значення: текст, вихід: адреса<памʼять<п8>>): логічне {
    ціль М = обчислювач.М;
    вернути МаМа::виділити_копію_ю8сі_цілі_з_тексту(М, значення, вихід);
  }

  зовнішня дія виділити_копію_ю8_цілі_з_тексту(обчислювач: адреса<Обчислювач>, значення: текст, вихід: адреса<ю8>): логічне {
    ціль М = обчислювач.М;
    вернути МаМа::виділити_копію_ю8_цілі_з_тексту(М, значення, вихід);
  }

  зовнішня дія померти_ю8(обчислювач: адреса<Обчислювач>, повідомлення: ю8) {
    МаМа::ПОМЕРТИ(обчислювач.М, ю8"");
  }
}