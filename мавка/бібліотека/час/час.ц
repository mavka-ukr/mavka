взяти визначення МаМа;
взяти визначення мавка/бібліотека;
взяти визначення турбо;

секція мавка {
  секція бібліотека {
    структура ДаніВідкликуВідкладеного {
      обчислювач: адреса<Обчислювач>;
      предмет_відклику: адреса<Предмет>;
      глобально_притриманий_предмет_відклику: адреса<ГлобальноПритриманийПредмет>;
    }

    дія обробник_запланованого_виконання_відклику_відкладеного(обчислювач: адреса<Обчислювач>, дані: невідома_адреса, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>): предмет_або_стан_падіння {
      ціль предмет_відклику = аргументи[0];
      вернути предмет_виконати(обчислювач, предмет_відклику, пусто, 0, пусто, пусто, Місцезнаходження { пусто, 0 });
    }

    дія відклик_на_доступність_читання_відкладеного(рушій: адреса<ТурбоРушій>, ідентифікатор: ц32, аргумент_відклику: невідома_адреса) {
      ціль дані_відкладеного = аргумент_відклику як адреса<ДаніВідкликуВідкладеного>;
      ціль обчислювач = дані_відкладеного.обчислювач;

      змінна результат = ні;
      змінна турбо_помилка = ТурбоПомилка { ... };

      ціль розмір_даних: позитивне = 8;
      змінна дані = виділити_памʼять<п8>(обчислювач, розмір_даних);
      змінна розмір_прочитаних_даних: позитивне = 0;
      змінна спробувати_пізніше: логічне = ні;

      результат = турбо_прочитати(рушій, ідентифікатор, розмір_даних, дані, розмір_прочитаних_даних::адреса, спробувати_пізніше::адреса, турбо_помилка::адреса);

      звільнити_памʼять(обчислювач, дані);

      якщо результат {
        турбо_закрити_слухач(рушій, ідентифікатор, турбо_помилка::адреса);

        змінна аргументи = виділити_памʼять<адреса<Предмет>>(обчислювач, 1);
        аргументи[0] = дані_відкладеного.предмет_відклику;
        запланувати_виконання(обчислювач, обробник_запланованого_виконання_відклику_відкладеного, пусто, пусто, 1, аргументи);
      } інакше {
        турбо_закрити_слухач(рушій, ідентифікатор, турбо_помилка::адреса);
      }
    }

    дія відклик_після_видалення_відкладеного(рушій: адреса<ТурбоРушій>, ідентифікатор: ц32, аргумент_відклику: невідома_адреса) {
      ціль дані_відкладеного = аргумент_відклику як адреса<ДаніВідкликуВідкладеного>;
      ціль обчислювач = дані_відкладеного.обчислювач;

      відпустити_глобально(обчислювач, дані_відкладеного.глобально_притриманий_предмет_відклику);
      звільнити(обчислювач, дані_відкладеного);

      змінна турбо_помилка: ТурбоПомилка;

      турбо_закрити_відкладене(ідентифікатор, турбо_помилка::адреса);
    }

    дія рідна_дія_модуля_час_відкласти(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<Предмет>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
      змінна знайдено_аргумент_відклик = ні;
      змінна аргумент_відклик: адреса<Предмет> = пусто;
      змінна знайдено_аргумент_тривалість = ні;
      змінна аргумент_тривалість: адреса<Предмет> = пусто;
      якщо іменовані_аргументи != пусто {
        знайдено_аргумент_відклик = знайти_іменований_аргумент(обчислювач, іменовані_аргументи, назва(обчислювач, "відклик"), аргумент_відклик::адреса);
        знайдено_аргумент_тривалість = знайти_іменований_аргумент(обчислювач, іменовані_аргументи, назва(обчислювач, "тривалість"), аргумент_тривалість::адреса);
      }
      якщо аргументи != пусто {
        якщо знайдено_аргумент_відклик == ні {
          якщо кількість_аргументів > 0 {
            знайдено_аргумент_відклик = так;
            аргумент_відклик = аргументи[0];
          }
        }
        якщо знайдено_аргумент_тривалість == ні {
          якщо кількість_аргументів > 1 {
            знайдено_аргумент_тривалість = так;
            аргумент_тривалість = аргументи[1];
          }
        }
      }

      змінна тривалість: позитивне = 1;
      якщо знайдено_аргумент_тривалість {
        якщо перевірити_чи_предмет_є_числом(обчислювач, аргумент_тривалість) == ні {
          вернути падіння(обчислювач, "Тривалість має бути числом");
        }
        тривалість = позитивне(отримати_значення_числа(обчислювач, аргумент_тривалість));
        якщо тривалість == 0 {
          тривалість = 1;
        }
      }

      ціль рушій = турбо_глобальний_рушій();

      змінна дані_відкладеного = виділити<ДаніВідкликуВідкладеного>(обчислювач);
      дані_відкладеного.обчислювач = обчислювач;
      дані_відкладеного.предмет_відклику = аргумент_відклик;
      дані_відкладеного.глобально_притриманий_предмет_відклику = притримати_глобально(обчислювач, аргумент_відклик);

      змінна результат = ні;
      змінна турбо_помилка = ТурбоПомилка { ... };
      змінна вихід_відкладеного = ТурбоВихідВідкладеного { ... };

      результат = турбо_створити_відкладене(тривалість, вихід_відкладеного::адреса, турбо_помилка::адреса);

      якщо результат == ні {
        відпустити_глобально(обчислювач, дані_відкладеного.глобально_притриманий_предмет_відклику);
        звільнити(обчислювач, дані_відкладеного);
        вернути падіння(обчислювач, "Не вдалось створити відкладене");
      } інакше {
        результат = турбо_створити_слухач(рушій, ц32(вихід_відкладеного.ідентифікатор), ТурбоПодіяДоступноДляЧитання, відклик_на_доступність_читання_відкладеного, пусто, відклик_після_видалення_відкладеного, дані_відкладеного, турбо_помилка::адреса);
        якщо результат == ні {
          турбо_закрити_відкладене(ц32(вихід_відкладеного.ідентифікатор), турбо_помилка::адреса);
          відпустити_глобально(обчислювач, дані_відкладеного.глобально_притриманий_предмет_відклику);
          звільнити(обчислювач, дані_відкладеного);
          вернути падіння(обчислювач, "Не вдалось створити слухач відкладеного");
        }
      }

      вернути створити_число(обчислювач, д64(вихід_відкладеного.ідентифікатор));
    }

    дія створити_дію_модуля_час_відкласти(обчислювач: адреса<Обчислювач>): предмет_або_стан_падіння {
      вернути створити_рідну_дію(обчислювач, назва(обчислювач, т8"відкласти"), 0, пусто, пусто, рідна_дія_модуля_час_відкласти);
    }

    дія рідна_дія_модуля_час_скасувати_відкладене(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<Предмет>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
      змінна знайдено_аргумент_ідентифікатор = ні;
      змінна аргумент_ідентифікатор: адреса<Предмет> = пусто;
      якщо іменовані_аргументи != пусто {
        знайдено_аргумент_ідентифікатор = знайти_іменований_аргумент(обчислювач, іменовані_аргументи, назва(обчислювач, "ідентифікатор"), аргумент_ідентифікатор::адреса);
      }
      якщо аргументи != пусто {
        якщо знайдено_аргумент_ідентифікатор == ні {
          якщо кількість_аргументів > 0 {
            знайдено_аргумент_ідентифікатор = так;
            аргумент_ідентифікатор = аргументи[0];
          }
        }
      }

      змінна ідентифікатор: ц32 = 0;
      якщо перевірити_чи_предмет_є_числом(обчислювач, аргумент_ідентифікатор) == ні {
        вернути падіння(обчислювач, "Ідентифікатор має бути числом");
      }
      ідентифікатор = ц32(отримати_значення_числа(обчислювач, аргумент_ідентифікатор));

      ціль рушій = турбо_глобальний_рушій();

      змінна результат = ні;
      змінна турбо_помилка: ТурбоПомилка;

      результат = турбо_закрити_слухач(рушій, ідентифікатор, турбо_помилка::адреса);

      якщо результат {
        вернути отримати_предмет_логічного_так(обчислювач);
      }

      вернути отримати_предмет_логічного_ні(обчислювач);
    }

    дія створити_дію_модуля_час_скасувати_відкладене(обчислювач: адреса<Обчислювач>): предмет_або_стан_падіння {
      вернути створити_рідну_дію(обчислювач, назва(обчислювач, т8"скасувати_відкладене"), 0, пусто, пусто, рідна_дія_модуля_час_скасувати_відкладене);
    }

    дія створити_модуль_час(обчислювач: адреса<Обчислювач>): предмет_або_стан_падіння {
      ціль притримувач = покласти_притримувач(обчислювач);

      ціль предмет_модуля = створити_модуль(обчислювач, назва(обчислювач, "час"), 0, пусто);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_модуля;
      }
      притримати(обчислювач, притримувач, предмет_модуля);

      ціль предмет_дії_відкласти = створити_дію_модуля_час_відкласти(обчислювач);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_дії_відкласти;
      }
      притримати(обчислювач, притримувач, предмет_дії_відкласти);
      змінна результат_зміни_властивості = предмет_змінити_властивість(обчислювач, предмет_модуля, назва(обчислювач, "відкласти"), предмет_дії_відкласти, Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути результат_зміни_властивості;
      }

      ціль предмет_дії_скасувати_відкладене = створити_дію_модуля_час_скасувати_відкладене(обчислювач);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_дії_скасувати_відкладене;
      }
      притримати(обчислювач, притримувач, предмет_дії_скасувати_відкладене);
      результат_зміни_властивості = предмет_змінити_властивість(обчислювач, предмет_модуля, назва(обчислювач, "скасувати_відкладене"), предмет_дії_скасувати_відкладене, Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути результат_зміни_властивості;
      }

      забрати_притримувач(обчислювач);
      вернути предмет_модуля;
    }

    зовнішня дія взяти_модуль_біб_час(обчислювач: адреса<Обчислювач>): предмет_або_стан_падіння {
      ціль М = обчислювач;
      змінна результат = створити_текст(обчислювач, "мавка:бібліотека/час/час.ц");
      якщо перевірити_чи_стан_падіння(обчислювач) {
        вернути результат;
      }
      ціль предмет_шляху = результат;
      змінна взятий_предмет: адреса<МаМа::Предмет> = пусто;
      якщо МаМа::отримати_взятий_предмет(М, предмет_шляху як адреса<МаМа::Предмет>, взятий_предмет::адреса) {
        вернути взятий_предмет як адреса<Предмет>;
      }
      результат = створити_модуль_час(обчислювач);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        вернути результат;
      }
      МаМа::покласти_взятий_предмет(М, предмет_шляху як адреса<МаМа::Предмет>, результат як адреса<МаМа::Предмет>);
      вернути результат;
    }
  }
}