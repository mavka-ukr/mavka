взяти визначення мавка;
взяти визначення мавка/бібліотека;
взяти визначення біб/Друк;
взяти визначення біб/турбо;

секція мавка {
  секція бібліотека {
    структура ДаніВідкликуВідкладеного {
      М: адреса<Машина>;
      глобально_притриманий_предмет_відкладеного: адреса<ГлобальноПритриманийПредмет>;
      глобально_притриманий_предмет_відклику: адреса<ГлобальноПритриманийПредмет>;
    }

    структура ДаніВідкликуПеріодичного {
      М: адреса<Машина>;
      глобально_притриманий_предмет_періодичного: адреса<ГлобальноПритриманийПредмет>;
      глобально_притриманий_предмет_відклику: адреса<ГлобальноПритриманийПредмет>;
    }

    дія обробник_запланованого_виконання_відклику_відкладеного(М: адреса<Машина>, дані: невідома_адреса, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>)-> ПредметАбоСтанПадіння<Предмет> {
      змінна предмет_відклику = аргументи[0];

      вернути предмет_виконати(М, предмет_відклику, пусто, 0, пусто, пусто, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 });
    }

    дія обробник_запланованого_виконання_відклику_періодичного(М: адреса<Машина>, дані: невідома_адреса, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>)-> ПредметАбоСтанПадіння<Предмет> {
      змінна предмет_відклику = аргументи[0];

      вернути предмет_виконати(М, предмет_відклику, пусто, 0, пусто, пусто, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 });
    }

    дія обробник_відклику_відкладеного(турбіна: адреса<турбо::Турбіна>, відкладене: адреса<турбо::Відкладене>, аргумент: невідома_адреса, скасовано: логічне, успішно: логічне, код_помилки: ц32) {
      змінна дані_відкладеного = аргумент як адреса<ДаніВідкликуВідкладеного>;
      змінна М = дані_відкладеного.М;
      змінна предмет_відкладеного = отримати_глобально_притриманий_предмет(М, дані_відкладеного.глобально_притриманий_предмет_відкладеного);
      змінна предмет_відклику = отримати_глобально_притриманий_предмет(М, дані_відкладеного.глобально_притриманий_предмет_відклику);

      якщо успішно {
        змінна кількість_аргументів: позитивне = 1;
        змінна аргументи = виділити_памʼять<адреса<Предмет>>(М, кількість_аргументів);
        аргументи[0] = предмет_відклику;
        запланувати_виконання(М, обробник_запланованого_виконання_відклику_відкладеного, пусто, пусто, кількість_аргументів, аргументи);
      } інакше якщо скасовано {
        // ок
      } інакше {
        ПОМЕРТИ(М, "НОП: помилка відкладеного");
      }

      предмет_змінити_користувацькі_дані(М, предмет_відкладеного, пусто);
      відпустити_глобально(М, дані_відкладеного.глобально_притриманий_предмет_відкладеного);
      відпустити_глобально(М, дані_відкладеного.глобально_притриманий_предмет_відклику);
      звільнити(М, дані_відкладеного);
    }

    дія обробник_відклику_періодичного(турбіна: адреса<турбо::Турбіна>, періодичне: адреса<турбо::Періодичне>, аргумент: невідома_адреса, скасовано: логічне, успішно: логічне, код_помилки: ц32) {
      змінна дані_періодичного = аргумент як адреса<ДаніВідкликуПеріодичного>;
      змінна М = дані_періодичного.М;
      змінна предмет_періодичного = отримати_глобально_притриманий_предмет(М, дані_періодичного.глобально_притриманий_предмет_періодичного);
      змінна предмет_відклику = отримати_глобально_притриманий_предмет(М, дані_періодичного.глобально_притриманий_предмет_відклику);

      якщо успішно {
        змінна кількість_аргументів: позитивне = 1;
        змінна аргументи = виділити_памʼять<адреса<Предмет>>(М, кількість_аргументів);
        аргументи[0] = предмет_відклику;
        запланувати_виконання(М, обробник_запланованого_виконання_відклику_періодичного, пусто, пусто, кількість_аргументів, аргументи);
      } інакше {
        якщо скасовано {
        } інакше {
          ПОМЕРТИ(М, "НОП: помилка періодичного");
        }

        предмет_змінити_користувацькі_дані(М, предмет_періодичного, пусто);
        відпустити_глобально(М, дані_періодичного.глобально_притриманий_предмет_періодичного);
        відпустити_глобально(М, дані_періодичного.глобально_притриманий_предмет_відклику);
        звільнити(М, дані_періодичного);
      }
    }

    дія рідна_дія_модуля_планувальник_відкласти(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>)-> ПредметАбоСтанПадіння<Предмет> {
      змінна знайдено_аргумент_відклик = ні;
      змінна аргумент_відклик: адреса<Предмет> = пусто;
      змінна знайдено_аргумент_тривалість = ні;
      змінна аргумент_тривалість: адреса<Предмет> = пусто;

      якщо іменовані_аргументи != пусто {
        знайдено_аргумент_відклик = знайти_іменований_аргумент(М, іменовані_аргументи, створити_назву(М, "відклик"), аргумент_відклик::адреса);
        знайдено_аргумент_тривалість = знайти_іменований_аргумент(М, іменовані_аргументи, створити_назву(М, "тривалість"), аргумент_тривалість::адреса);
      }
      якщо аргументи != пусто {
        якщо знайдено_аргумент_відклик == ні {
          якщо кількість_аргументів > 0 {
            знайдено_аргумент_відклик = так;
            аргумент_відклик = аргументи[0];
          }
        }
        якщо знайдено_аргумент_тривалість == ні {
          якщо кількість_аргументів > 1 {
            знайдено_аргумент_тривалість = так;
            аргумент_тривалість = аргументи[1];
          }
        }
      }

      змінна тривалість: позитивне = 1;
      якщо знайдено_аргумент_тривалість {
        якщо перевірити_чи_предмет_є_числом(М, аргумент_тривалість) == ні {
          вернути падіння(М, "Тривалість має бути числом");
        }
        тривалість = позитивне(отримати_значення_числа(М, аргумент_тривалість як адреса<ПредметЧисла>));
        якщо тривалість == 0 {
          тривалість = 1;
        }
      }

      змінна предмет_структури_Відкладене = отримати_глобально_притриманий_предмет(М, предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>);

      змінна предмет_відкладеного = предмет_виконати(М, предмет_структури_Відкладене, пусто, 0, пусто, пусто, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 });
      якщо перевірити_чи_стан_падіння(М) {
        вернути предмет_відкладеного;
      }

      змінна дані_відкладеного = виділити<ДаніВідкликуВідкладеного>(М);
      дані_відкладеного.М = М;
      дані_відкладеного.глобально_притриманий_предмет_відкладеного = притримати_глобально(М, предмет_відкладеного);
      дані_відкладеного.глобально_притриманий_предмет_відклику = притримати_глобально(М, аргумент_відклик);

      змінна турбіна = турбо::отримати_глобальну_турбіну();

      змінна відкладене = турбо::відкласти_виконання(турбіна, тривалість, обробник_відклику_відкладеного, дані_відкладеного);
      якщо відкладене == пусто {
        // потім: обробити
      }

      предмет_змінити_користувацькі_дані(М, предмет_відкладеного, відкладене);

      вернути предмет_відкладеного;
    }

    дія зробити_копію_даних_дії_модуля_планувальник_відкласти(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>): невідома_адреса {
      змінна дані_дії = предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>;
      вернути притримати_глобально(М, отримати_глобально_притриманий_предмет(М, дані_дії));
    }

    дія відклик_перед_звільненням_дії_модуля_планувальник_відкласти(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>) {
      змінна дані_дії = предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>;
      відпустити_глобально(М, дані_дії);
    }

    дія створити_дію_модуля_планувальник_відкласти(М: адреса<Машина>, предмет_структури_Відкладене: адреса<Предмет>)-> ПредметАбоСтанПадіння<Предмет> {

      вернути створити_предмет_рідної_дії(
        М,
        створити_назву(М, "відкласти"),
        0,
        пусто,
        пусто,
        рідна_дія_модуля_планувальник_відкласти,
        притримати_глобально(М, предмет_структури_Відкладене),
        зробити_копію_даних_дії_модуля_планувальник_відкласти,
        відклик_перед_звільненням_дії_модуля_планувальник_відкласти
      ) як адреса<Предмет>;
    }

    дія рідна_дія_модуля_планувальник_періодично(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>)-> ПредметАбоСтанПадіння<Предмет> {
      змінна знайдено_аргумент_відклик = ні;
      змінна аргумент_відклик: адреса<Предмет> = пусто;
      змінна знайдено_аргумент_тривалість = ні;
      змінна аргумент_тривалість: адреса<Предмет> = пусто;

      якщо іменовані_аргументи != пусто {
        знайдено_аргумент_відклик = знайти_іменований_аргумент(М, іменовані_аргументи, створити_назву(М, "відклик"), аргумент_відклик::адреса);
        знайдено_аргумент_тривалість = знайти_іменований_аргумент(М, іменовані_аргументи, створити_назву(М, "тривалість"), аргумент_тривалість::адреса);
      }
      якщо аргументи != пусто {
        якщо знайдено_аргумент_відклик == ні {
          якщо кількість_аргументів > 0 {
            знайдено_аргумент_відклик = так;
            аргумент_відклик = аргументи[0];
          }
        }
        якщо знайдено_аргумент_тривалість == ні {
          якщо кількість_аргументів > 1 {
            знайдено_аргумент_тривалість = так;
            аргумент_тривалість = аргументи[1];
          }
        }
      }

      змінна тривалість: позитивне = 1;
      якщо знайдено_аргумент_тривалість {
        якщо перевірити_чи_предмет_є_числом(М, аргумент_тривалість) == ні {
          вернути падіння(М, "Тривалість має бути числом");
        }
        тривалість = позитивне(отримати_значення_числа(М, аргумент_тривалість як адреса<ПредметЧисла>));
        якщо тривалість == 0 {
          тривалість = 1;
        }
      }

      змінна предмет_структури_Періодичне = отримати_глобально_притриманий_предмет(М, предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>);

      змінна предмет_періодичного = предмет_виконати(М, предмет_структури_Періодичне, пусто, 0, пусто, пусто, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 });
      якщо перевірити_чи_стан_падіння(М) {
        вернути предмет_періодичного;
      }

      змінна дані_періодичного = виділити<ДаніВідкликуПеріодичного>(М);
      дані_періодичного.М = М;
      дані_періодичного.глобально_притриманий_предмет_періодичного = притримати_глобально(М, предмет_періодичного);
      дані_періодичного.глобально_притриманий_предмет_відклику = притримати_глобально(М, аргумент_відклик);

      змінна турбіна = турбо::отримати_глобальну_турбіну();

      змінна періодичне = турбо::виконувати_періодично(турбіна, тривалість, обробник_відклику_періодичного, дані_періодичного);
      якщо періодичне == пусто {
        // потім: обробити
      }

      предмет_змінити_користувацькі_дані(М, предмет_періодичного, періодичне);

      вернути предмет_періодичного;
    }

    дія зробити_копію_даних_дії_модуля_планувальник_періодично(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>): невідома_адреса {
      змінна дані_дії = предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>;
      вернути притримати_глобально(М, отримати_глобально_притриманий_предмет(М, дані_дії));
    }

    дія відклик_перед_звільненням_дії_модуля_планувальник_періодично(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>) {
      змінна дані_дії = предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>;
      відпустити_глобально(М, дані_дії);
    }

    дія створити_дію_модуля_планувальник_періодично(М: адреса<Машина>, предмет_структури_Періодичне: адреса<Предмет>)-> ПредметАбоСтанПадіння<Предмет> {

      вернути створити_предмет_рідної_дії(
        М,
        створити_назву(М, "періодично"),
        0,
        пусто,
        пусто,
        рідна_дія_модуля_планувальник_періодично,
        притримати_глобально(М, предмет_структури_Періодичне),
        зробити_копію_даних_дії_модуля_планувальник_періодично,
        відклик_перед_звільненням_дії_модуля_планувальник_періодично
      ) як адреса<Предмет>;
    }

    дія рідна_дія_модуля_планувальник_скасувати_відкладене(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>)-> ПредметАбоСтанПадіння<Предмет> {
      змінна знайдено_аргумент_відкладене = ні;
      змінна аргумент_відкладене: адреса<Предмет> = пусто;

      якщо іменовані_аргументи != пусто {
        знайдено_аргумент_відкладене = знайти_іменований_аргумент(М, іменовані_аргументи, створити_назву(М, "відкладене"), аргумент_відкладене::адреса);
      }
      якщо аргументи != пусто {
        якщо знайдено_аргумент_відкладене == ні {
          якщо кількість_аргументів > 0 {
            знайдено_аргумент_відкладене = так;
            аргумент_відкладене = аргументи[0];
          }
        }
      }

      якщо аргумент_відкладене == пусто {
        вернути падіння(М, "Аргумент має бути періодичним");
      }

      змінна предмет_структури_Відкладене = отримати_глобально_притриманий_предмет(М, предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>);
      якщо перевірити_чи_предмет_є(М, аргумент_відкладене, предмет_структури_Відкладене як адреса<ПредметСтруктури>) == ні {
        вернути падіння(М, "Аргумент має бути відкладеним");
      }

      змінна відкладене = предмет_отримати_користувацькі_дані(М, аргумент_відкладене) як адреса<турбо::Відкладене>;
      якщо відкладене == пусто {
        вернути пусто;
      }

      змінна турбіна = турбо::отримати_глобальну_турбіну();

      турбо::скасувати_відкладене(турбіна, відкладене);

      вернути пусто;
    }

    дія зробити_копію_даних_дії_модуля_планувальник_скасувати_відкладене(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>): невідома_адреса {
      змінна дані_дії = предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>;
      вернути притримати_глобально(М, отримати_глобально_притриманий_предмет(М, дані_дії));
    }

    дія відклик_перед_звільненням_дії_модуля_планувальник_скасувати_відкладене(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>) {
      змінна дані_дії = предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>;
      відпустити_глобально(М, дані_дії);
    }

    дія створити_дію_модуля_планувальник_скасувати_відкладене(М: адреса<Машина>, предмет_структури_Відкладене: адреса<Предмет>)-> ПредметАбоСтанПадіння<Предмет> {

      вернути створити_предмет_рідної_дії(
        М,
        створити_назву(М, "скасувати_відкладене"),
        0,
        пусто,
        пусто,
        рідна_дія_модуля_планувальник_скасувати_відкладене,
        притримати_глобально(М, предмет_структури_Відкладене),
        зробити_копію_даних_дії_модуля_планувальник_скасувати_відкладене,
        відклик_перед_звільненням_дії_модуля_планувальник_скасувати_відкладене
      ) як адреса<Предмет>;
    }

    дія рідна_дія_модуля_планувальник_скасувати_періодичне(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>)-> ПредметАбоСтанПадіння<Предмет> {
      змінна знайдено_аргумент_періодичне = ні;
      змінна аргумент_періодичне: адреса<Предмет> = пусто;

      якщо іменовані_аргументи != пусто {
        знайдено_аргумент_періодичне = знайти_іменований_аргумент(М, іменовані_аргументи, створити_назву(М, "періодичне"), аргумент_періодичне::адреса);
      }
      якщо аргументи != пусто {
        якщо знайдено_аргумент_періодичне == ні {
          якщо кількість_аргументів > 0 {
            знайдено_аргумент_періодичне = так;
            аргумент_періодичне = аргументи[0];
          }
        }
      }

      якщо аргумент_періодичне == пусто {
        вернути падіння(М, "Аргумент має бути періодичним");
      }

      змінна предмет_структури_Періодичне = отримати_глобально_притриманий_предмет(М, предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>);
      якщо перевірити_чи_предмет_є(М, аргумент_періодичне,
      предмет_структури_Періодичне як адреса<ПредметСтруктури>) == ні {
        вернути падіння(М, "Аргумент має бути періодичним");
      }

      змінна періодичне = предмет_отримати_користувацькі_дані(М, аргумент_періодичне) як адреса<турбо::Періодичне>;
      якщо періодичне == пусто {
        вернути пусто;
      }

      змінна турбіна = турбо::отримати_глобальну_турбіну();

      турбо::скасувати_періодичне(турбіна, періодичне);

      вернути пусто;
    }

    дія зробити_копію_даних_дії_модуля_планувальник_скасувати_періодичне(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>): невідома_адреса {
      змінна дані_дії = предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>;
      вернути притримати_глобально(М, отримати_глобально_притриманий_предмет(М, дані_дії));
    }

    дія відклик_перед_звільненням_дії_модуля_планувальник_скасувати_періодичне(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>) {
      змінна дані_дії = предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>;
      відпустити_глобально(М, дані_дії);
    }

    дія створити_дію_модуля_планувальник_скасувати_періодичне(М: адреса<Машина>, предмет_структури_Періодичне: адреса<Предмет>)-> ПредметАбоСтанПадіння<Предмет> {

      вернути створити_предмет_рідної_дії(
        М,
        створити_назву(М, "скасувати_періодичне"),
        0,
        пусто,
        пусто,
        рідна_дія_модуля_планувальник_скасувати_періодичне,
        притримати_глобально(М, предмет_структури_Періодичне),
        зробити_копію_даних_дії_модуля_планувальник_скасувати_періодичне,
        відклик_перед_звільненням_дії_модуля_планувальник_скасувати_періодичне
      ) як адреса<Предмет>;
    }

    дія створити_предмет_структури_Відкладене(М: адреса<Машина>)-> ПредметАбоСтанПадіння<Предмет> {
      змінна притримувач = покласти_притримувач(М);

      змінна кількість_параметрів: позитивне = 0;
      змінна параметри = пусто як памʼять<адреса<Предмет>>;



      змінна предмет_структури_Відкладене = створити_предмет_структури(
        М,
        створити_назву(М, "Відкладене"),
        М.предмет_структури_предмет,
        кількість_параметрів,
        параметри як памʼять<адреса<ПредметПараметра>>
      ) як адреса<Предмет>;
      якщо перевірити_чи_стан_падіння(М) {
        забрати_притримувач(М);
        вернути предмет_структури_Відкладене;
      }

      забрати_притримувач(М);
      вернути предмет_структури_Відкладене;
    }

    дія створити_предмет_структури_Періодичне(М: адреса<Машина>)-> ПредметАбоСтанПадіння<Предмет> {
      змінна притримувач = покласти_притримувач(М);

      змінна кількість_параметрів: позитивне = 0;
      змінна параметри = пусто як памʼять<адреса<Предмет>>;



      змінна предмет_структури_Періодичне = створити_предмет_структури(М, створити_назву(М, "Періодичне"), М.предмет_структури_предмет, кількість_параметрів, параметри як памʼять<адреса<ПредметПараметра>>) як адреса<Предмет>;
      якщо перевірити_чи_стан_падіння(М) {
        забрати_притримувач(М);
        вернути предмет_структури_Періодичне;
      }

      забрати_притримувач(М);
      вернути предмет_структури_Періодичне;
    }

    дія створити_модуль_планувальник(М: адреса<Машина>)-> ПредметАбоСтанПадіння<Предмет> {
      змінна притримувач = покласти_притримувач(М);



      змінна предмет_модуля = створити_предмет_модуля(М, створити_назву(М, "планувальник")) як адреса<Предмет>;
      якщо перевірити_чи_стан_падіння(М) {
        забрати_притримувач(М);
        вернути предмет_модуля;
      }
      притримати(М, притримувач, предмет_модуля);

      змінна предмет_структури_Відкладене = створити_предмет_структури_Відкладене(М);
      якщо перевірити_чи_стан_падіння(М) {
        забрати_притримувач(М);
        вернути предмет_структури_Відкладене;
      }
      притримати(М, притримувач, предмет_структури_Відкладене);
      змінна результат_зміни_властивості = предмет_змінити_властивість(М, предмет_модуля, створити_назву(М, "Відкладене"), предмет_структури_Відкладене, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 });
      якщо перевірити_чи_стан_падіння(М) {
        забрати_притримувач(М);
        вернути результат_зміни_властивості;
      }

      змінна предмет_структури_Періодичне = створити_предмет_структури_Періодичне(М);
      якщо перевірити_чи_стан_падіння(М) {
        забрати_притримувач(М);
        вернути предмет_структури_Періодичне;
      }
      притримати(М, притримувач, предмет_структури_Періодичне);
      результат_зміни_властивості = предмет_змінити_властивість(М, предмет_модуля, створити_назву(М, "Періодичне"), предмет_структури_Періодичне, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 });
      якщо перевірити_чи_стан_падіння(М) {
        забрати_притримувач(М);
        вернути результат_зміни_властивості;
      }

      змінна предмет_дії_відкласти = створити_дію_модуля_планувальник_відкласти(М, предмет_структури_Відкладене);
      якщо перевірити_чи_стан_падіння(М) {
        забрати_притримувач(М);
        вернути предмет_дії_відкласти;
      }
      притримати(М, притримувач, предмет_дії_відкласти);
      результат_зміни_властивості = предмет_змінити_властивість(М, предмет_модуля, створити_назву(М, "відкласти"), предмет_дії_відкласти, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 });
      якщо перевірити_чи_стан_падіння(М) {
        забрати_притримувач(М);
        вернути результат_зміни_властивості;
      }

      змінна предмет_дії_періодично = створити_дію_модуля_планувальник_періодично(М, предмет_структури_Періодичне);
      якщо перевірити_чи_стан_падіння(М) {
        забрати_притримувач(М);
        вернути предмет_дії_періодично;
      }
      притримати(М, притримувач, предмет_дії_періодично);
      результат_зміни_властивості = предмет_змінити_властивість(М, предмет_модуля, створити_назву(М, "періодично"), предмет_дії_періодично, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 });
      якщо перевірити_чи_стан_падіння(М) {
        забрати_притримувач(М);
        вернути результат_зміни_властивості;
      }

      змінна предмет_дії_скасувати_відкладене = створити_дію_модуля_планувальник_скасувати_відкладене(М, предмет_структури_Відкладене);
      якщо перевірити_чи_стан_падіння(М) {
        забрати_притримувач(М);
        вернути предмет_дії_скасувати_відкладене;
      }
      притримати(М, притримувач, предмет_дії_скасувати_відкладене);
      результат_зміни_властивості = предмет_змінити_властивість(М, предмет_модуля, створити_назву(М, "скасувати_відкладене"), предмет_дії_скасувати_відкладене, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 });
      якщо перевірити_чи_стан_падіння(М) {
        забрати_притримувач(М);
        вернути результат_зміни_властивості;
      }

      змінна предмет_дії_скасувати_періодичне = створити_дію_модуля_планувальник_скасувати_періодичне(М, предмет_структури_Періодичне);
      якщо перевірити_чи_стан_падіння(М) {
        забрати_притримувач(М);
        вернути предмет_дії_скасувати_періодичне;
      }
      притримати(М, притримувач, предмет_дії_скасувати_періодичне);
      результат_зміни_властивості = предмет_змінити_властивість(М, предмет_модуля, створити_назву(М, "скасувати_періодичне"), предмет_дії_скасувати_періодичне, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 });
      якщо перевірити_чи_стан_падіння(М) {
        забрати_притримувач(М);
        вернути результат_зміни_властивості;
      }

      забрати_притримувач(М);
      вернути предмет_модуля;
    }

    місцева дія взяти_модуль_біб_планувальник(М: адреса<Машина>)-> ПредметАбоСтанПадіння<Предмет> {

      змінна результат = створити_предмет_тексту(М, "мавка:бібліотека/планувальник/планувальник.ц") як адреса<Предмет>;
      якщо перевірити_чи_стан_падіння(М) {
        вернути результат як адреса<Предмет>;
      }
      змінна предмет_шляху = результат;
      змінна взятий_предмет: адреса<Предмет> = пусто;
      якщо отримати_взятий_предмет(М, предмет_шляху як адреса<Предмет>, взятий_предмет::адреса) {
        вернути взятий_предмет як адреса<Предмет>;
      }
      результат = створити_модуль_планувальник(М);
      якщо перевірити_чи_стан_падіння(М) {
        вернути результат;
      }
      покласти_взятий_предмет(М, предмет_шляху як адреса<Предмет>, результат як адреса<Предмет>);
      вернути результат;
    }
  }
}