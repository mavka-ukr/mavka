взяти визначення МаМа;
взяти визначення мавка/бібліотека;
взяти визначення біб/Друк;
взяти визначення біб/турбо;

секція мавка {
  секція бібліотека {
    структура ДаніВідкликуВідкладеного {
      обчислювач: адреса<Обчислювач>;
      глобально_притриманий_предмет_відкладеного: адреса<ГлобальноПритриманийПредмет>;
      глобально_притриманий_предмет_відклику: адреса<ГлобальноПритриманийПредмет>;
    }

    структура ДаніВідкликуПеріодичного {
      обчислювач: адреса<Обчислювач>;
      глобально_притриманий_предмет_періодичного: адреса<ГлобальноПритриманийПредмет>;
      глобально_притриманий_предмет_відклику: адреса<ГлобальноПритриманийПредмет>;
    }

    дія обробник_запланованого_виконання_відклику_відкладеного(обчислювач: адреса<Обчислювач>, дані: невідома_адреса, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>): предмет_або_стан_падіння {
      ціль предмет_відклику = аргументи[0];
      вернути предмет_виконати(обчислювач, предмет_відклику, пусто, 0, пусто, пусто, Місцезнаходження { пусто, 0 });
    }

    дія обробник_запланованого_виконання_відклику_періодичного(обчислювач: адреса<Обчислювач>, дані: невідома_адреса, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>): предмет_або_стан_падіння {
      ціль предмет_відклику = аргументи[0];
      вернути предмет_виконати(обчислювач, предмет_відклику, пусто, 0, пусто, пусто, Місцезнаходження { пусто, 0 });
    }

    дія обробник_відклику_відкладеного(турбіна: адреса<турбо::Турбіна>, відкладене: адреса<турбо::Відкладене>, аргумент: невідома_адреса, скасовано: логічне, успішно: логічне, код_помилки: ц32) {
      ціль дані_відкладеного = аргумент як адреса<ДаніВідкликуВідкладеного>;
      ціль обчислювач = дані_відкладеного.обчислювач;
      ціль предмет_відкладеного = отримати_глобально_притриманий_предмет(обчислювач, дані_відкладеного.глобально_притриманий_предмет_відкладеного);
      ціль предмет_відклику = отримати_глобально_притриманий_предмет(обчислювач, дані_відкладеного.глобально_притриманий_предмет_відклику);

      якщо успішно {
        ціль кількість_аргументів: позитивне = 1;
        ціль аргументи = виділити_памʼять<адреса<Предмет>>(обчислювач, кількість_аргументів);
        аргументи[0] = предмет_відклику;
        запланувати_виконання(обчислювач, обробник_запланованого_виконання_відклику_відкладеного, пусто, пусто, кількість_аргументів, аргументи);
      } інакше якщо скасовано {
        // ок
      } інакше {
        // потім: впасти
      }

      предмет_змінити_користувацькі_дані(обчислювач, предмет_відкладеного, пусто);
      відпустити_глобально(обчислювач, дані_відкладеного.глобально_притриманий_предмет_відкладеного);
      відпустити_глобально(обчислювач, дані_відкладеного.глобально_притриманий_предмет_відклику);
      звільнити(обчислювач, дані_відкладеного);
    }

    дія обробник_відклику_періодичного(турбіна: адреса<турбо::Турбіна>, періодичне: адреса<турбо::Періодичне>, аргумент: невідома_адреса, скасовано: логічне, успішно: логічне, код_помилки: ц32) {
      ціль дані_періодичного = аргумент як адреса<ДаніВідкликуПеріодичного>;
      ціль обчислювач = дані_періодичного.обчислювач;
      ціль предмет_періодичного = отримати_глобально_притриманий_предмет(обчислювач, дані_періодичного.глобально_притриманий_предмет_періодичного);
      ціль предмет_відклику = отримати_глобально_притриманий_предмет(обчислювач, дані_періодичного.глобально_притриманий_предмет_відклику);

      якщо успішно {
        ціль кількість_аргументів: позитивне = 1;
        ціль аргументи = виділити_памʼять<адреса<Предмет>>(обчислювач, кількість_аргументів);
        аргументи[0] = предмет_відклику;
        запланувати_виконання(обчислювач, обробник_запланованого_виконання_відклику_періодичного, пусто, пусто, кількість_аргументів, аргументи);
      } інакше {
        якщо скасовано {
        } інакше {
          // потім: впасти
        }

        предмет_змінити_користувацькі_дані(обчислювач, предмет_періодичного, пусто);
        відпустити_глобально(обчислювач, дані_періодичного.глобально_притриманий_предмет_періодичного);
        відпустити_глобально(обчислювач, дані_періодичного.глобально_притриманий_предмет_відклику);
        звільнити(обчислювач, дані_періодичного);
      }
    }

    дія рідна_дія_модуля_планувальник_відкласти(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<Предмет>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
      змінна знайдено_аргумент_відклик = ні;
      змінна аргумент_відклик: адреса<Предмет> = пусто;
      змінна знайдено_аргумент_тривалість = ні;
      змінна аргумент_тривалість: адреса<Предмет> = пусто;
      якщо іменовані_аргументи != пусто {
        знайдено_аргумент_відклик = знайти_іменований_аргумент(обчислювач, іменовані_аргументи, назва(обчислювач, "відклик"), аргумент_відклик::адреса);
        знайдено_аргумент_тривалість = знайти_іменований_аргумент(обчислювач, іменовані_аргументи, назва(обчислювач, "тривалість"), аргумент_тривалість::адреса);
      }
      якщо аргументи != пусто {
        якщо знайдено_аргумент_відклик == ні {
          якщо кількість_аргументів > 0 {
            знайдено_аргумент_відклик = так;
            аргумент_відклик = аргументи[0];
          }
        }
        якщо знайдено_аргумент_тривалість == ні {
          якщо кількість_аргументів > 1 {
            знайдено_аргумент_тривалість = так;
            аргумент_тривалість = аргументи[1];
          }
        }
      }

      змінна тривалість: позитивне = 1;
      якщо знайдено_аргумент_тривалість {
        якщо перевірити_чи_предмет_є_числом(обчислювач, аргумент_тривалість) == ні {
          вернути падіння(обчислювач, "Тривалість має бути числом");
        }
        тривалість = позитивне(отримати_значення_числа(обчислювач, аргумент_тривалість));
        якщо тривалість == 0 {
          тривалість = 1;
        }
      }

      ціль предмет_структури_Відкладене = отримати_глобально_притриманий_предмет(обчислювач, отримати_дані_дії(обчислювач, предмет_дії) як адреса<ГлобальноПритриманийПредмет>);

      ціль предмет_відкладеного = предмет_виконати(обчислювач, предмет_структури_Відкладене, пусто, 0, пусто, пусто, Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        вернути предмет_відкладеного;
      }

      ціль дані_відкладеного = виділити<ДаніВідкликуВідкладеного>(обчислювач);
      дані_відкладеного.обчислювач = обчислювач;
      дані_відкладеного.глобально_притриманий_предмет_відкладеного = притримати_глобально(обчислювач, предмет_відкладеного);
      дані_відкладеного.глобально_притриманий_предмет_відклику = притримати_глобально(обчислювач, аргумент_відклик);

      ціль турбіна = турбо::отримати_глобальну_турбіну();

      турбо::відкласти_виконання(турбіна, тривалість, обробник_відклику_відкладеного, дані_відкладеного);

      предмет_змінити_користувацькі_дані(обчислювач, предмет_відкладеного, пусто);

      вернути предмет_відкладеного;
    }

    дія зробити_копію_даних_дії_модуля_планувальник_відкласти(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<Предмет>): невідома_адреса {
      ціль дані_дії = отримати_дані_дії(обчислювач, предмет_дії) як адреса<ГлобальноПритриманийПредмет>;
      вернути притримати_глобально(обчислювач, отримати_глобально_притриманий_предмет(обчислювач, дані_дії));
    }

    дія відклик_перед_звільненням_дії_модуля_планувальник_відкласти(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<Предмет>) {
      ціль дані_дії = отримати_дані_дії(обчислювач, предмет_дії) як адреса<ГлобальноПритриманийПредмет>;
      відпустити_глобально(обчислювач, дані_дії);
    }

    дія створити_дію_модуля_планувальник_відкласти(обчислювач: адреса<Обчислювач>, предмет_структури_Відкладене: адреса<Предмет>): предмет_або_стан_падіння {
      вернути створити_рідну_дію_з_даними(
        обчислювач,
        назва(обчислювач, т8"відкласти"),
        0,
        пусто,
        пусто,
        рідна_дія_модуля_планувальник_відкласти,
        притримати_глобально(обчислювач, предмет_структури_Відкладене),
        зробити_копію_даних_дії_модуля_планувальник_відкласти,
        відклик_перед_звільненням_дії_модуля_планувальник_відкласти
      );
    }

    дія рідна_дія_модуля_планувальник_періодично(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<Предмет>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
      змінна знайдено_аргумент_відклик = ні;
      змінна аргумент_відклик: адреса<Предмет> = пусто;
      змінна знайдено_аргумент_тривалість = ні;
      змінна аргумент_тривалість: адреса<Предмет> = пусто;
      якщо іменовані_аргументи != пусто {
        знайдено_аргумент_відклик = знайти_іменований_аргумент(обчислювач, іменовані_аргументи, назва(обчислювач, "відклик"), аргумент_відклик::адреса);
        знайдено_аргумент_тривалість = знайти_іменований_аргумент(обчислювач, іменовані_аргументи, назва(обчислювач, "тривалість"), аргумент_тривалість::адреса);
      }
      якщо аргументи != пусто {
        якщо знайдено_аргумент_відклик == ні {
          якщо кількість_аргументів > 0 {
            знайдено_аргумент_відклик = так;
            аргумент_відклик = аргументи[0];
          }
        }
        якщо знайдено_аргумент_тривалість == ні {
          якщо кількість_аргументів > 1 {
            знайдено_аргумент_тривалість = так;
            аргумент_тривалість = аргументи[1];
          }
        }
      }

      змінна тривалість: позитивне = 1;
      якщо знайдено_аргумент_тривалість {
        якщо перевірити_чи_предмет_є_числом(обчислювач, аргумент_тривалість) == ні {
          вернути падіння(обчислювач, "Тривалість має бути числом");
        }
        тривалість = позитивне(отримати_значення_числа(обчислювач, аргумент_тривалість));
        якщо тривалість == 0 {
          тривалість = 1;
        }
      }

      ціль предмет_структури_Періодичне = отримати_глобально_притриманий_предмет(обчислювач, отримати_дані_дії(обчислювач, предмет_дії) як адреса<ГлобальноПритриманийПредмет>);

      ціль предмет_періодичного = предмет_виконати(обчислювач, предмет_структури_Періодичне, пусто, 0, пусто, пусто, Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        вернути предмет_періодичного;
      }

      ціль дані_періодичного = виділити<ДаніВідкликуПеріодичного>(обчислювач);
      дані_періодичного.обчислювач = обчислювач;
      дані_періодичного.глобально_притриманий_предмет_періодичного = притримати_глобально(обчислювач, предмет_періодичного);
      дані_періодичного.глобально_притриманий_предмет_відклику = притримати_глобально(обчислювач, аргумент_відклик);

      ціль турбіна = турбо::отримати_глобальну_турбіну();

      турбо::виконувати_періодично(турбіна, тривалість, обробник_відклику_періодичного, дані_періодичного);

      предмет_змінити_користувацькі_дані(обчислювач, предмет_періодичного, пусто);

      вернути предмет_періодичного;
    }

    дія зробити_копію_даних_дії_модуля_планувальник_періодично(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<Предмет>): невідома_адреса {
      ціль дані_дії = отримати_дані_дії(обчислювач, предмет_дії) як адреса<ГлобальноПритриманийПредмет>;
      вернути притримати_глобально(обчислювач, отримати_глобально_притриманий_предмет(обчислювач, дані_дії));
    }

    дія відклик_перед_звільненням_дії_модуля_планувальник_періодично(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<Предмет>) {
      ціль дані_дії = отримати_дані_дії(обчислювач, предмет_дії) як адреса<ГлобальноПритриманийПредмет>;
      відпустити_глобально(обчислювач, дані_дії);
    }

    дія створити_дію_модуля_планувальник_періодично(обчислювач: адреса<Обчислювач>, предмет_структури_Періодичне: адреса<Предмет>): предмет_або_стан_падіння {
      вернути створити_рідну_дію_з_даними(
        обчислювач,
        назва(обчислювач, т8"періодично"),
        0,
        пусто,
        пусто,
        рідна_дія_модуля_планувальник_періодично,
        притримати_глобально(обчислювач, предмет_структури_Періодичне),
        зробити_копію_даних_дії_модуля_планувальник_періодично,
        відклик_перед_звільненням_дії_модуля_планувальник_періодично
      );
    }

    дія рідна_дія_модуля_планувальник_скасувати_відкладене(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<Предмет>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
      змінна знайдено_аргумент_відкладене = ні;
      змінна аргумент_відкладене: адреса<Предмет> = пусто;
      якщо іменовані_аргументи != пусто {
        знайдено_аргумент_відкладене = знайти_іменований_аргумент(обчислювач, іменовані_аргументи, назва(обчислювач, "відкладене"), аргумент_відкладене::адреса);
      }
      якщо аргументи != пусто {
        якщо знайдено_аргумент_відкладене == ні {
          якщо кількість_аргументів > 0 {
            знайдено_аргумент_відкладене = так;
            аргумент_відкладене = аргументи[0];
          }
        }
      }

      // потім: втілити

      вернути пусто;
    }

    дія створити_дію_модуля_планувальник_скасувати_відкладене(обчислювач: адреса<Обчислювач>): предмет_або_стан_падіння {
      вернути створити_рідну_дію(
        обчислювач,
        назва(обчислювач, т8"скасувати_відкладене"),
        0,
        пусто,
        пусто,
        рідна_дія_модуля_планувальник_скасувати_відкладене
      );
    }

    дія створити_предмет_структури_Відкладене(обчислювач: адреса<Обчислювач>): предмет_або_стан_падіння {
      ціль притримувач = покласти_притримувач(обчислювач);

      ціль кількість_параметрів: позитивне = 0;
      змінна параметри = пусто як памʼять<адреса<Предмет>>;

      ціль предмет_структури_Відкладене = створити_структуру(обчислювач, назва(обчислювач, "Відкладене"), отримати_предмет_структури_предмет(обчислювач), кількість_параметрів, параметри);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_структури_Відкладене;
      }

      забрати_притримувач(обчислювач);
      вернути предмет_структури_Відкладене;
    }

    дія створити_предмет_структури_Періодичне(обчислювач: адреса<Обчислювач>): предмет_або_стан_падіння {
      ціль притримувач = покласти_притримувач(обчислювач);

      ціль кількість_параметрів: позитивне = 0;
      змінна параметри = пусто як памʼять<адреса<Предмет>>;

      ціль предмет_структури_Періодичне = створити_структуру(обчислювач, назва(обчислювач, "Періодичне"), отримати_предмет_структури_предмет(обчислювач), кількість_параметрів, параметри);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_структури_Періодичне;
      }

      забрати_притримувач(обчислювач);
      вернути предмет_структури_Періодичне;
    }

    дія створити_модуль_планувальник(обчислювач: адреса<Обчислювач>): предмет_або_стан_падіння {
      ціль притримувач = покласти_притримувач(обчислювач);

      ціль предмет_модуля = створити_модуль(обчислювач, назва(обчислювач, "планувальник"), 0, пусто);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_модуля;
      }
      притримати(обчислювач, притримувач, предмет_модуля);

      ціль предмет_структури_Відкладене = створити_предмет_структури_Відкладене(обчислювач);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_структури_Відкладене;
      }
      притримати(обчислювач, притримувач, предмет_структури_Відкладене);
      змінна результат_зміни_властивості = предмет_змінити_властивість(обчислювач, предмет_модуля, назва(обчислювач, "Відкладене"), предмет_структури_Відкладене, Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути результат_зміни_властивості;
      }

      ціль предмет_структури_Періодичне = створити_предмет_структури_Періодичне(обчислювач);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_структури_Періодичне;
      }
      притримати(обчислювач, притримувач, предмет_структури_Періодичне);
      результат_зміни_властивості = предмет_змінити_властивість(обчислювач, предмет_модуля, назва(обчислювач, "Періодичне"), предмет_структури_Періодичне, Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути результат_зміни_властивості;
      }

      ціль предмет_дії_відкласти = створити_дію_модуля_планувальник_відкласти(обчислювач, предмет_структури_Відкладене);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_дії_відкласти;
      }
      притримати(обчислювач, притримувач, предмет_дії_відкласти);
      результат_зміни_властивості = предмет_змінити_властивість(обчислювач, предмет_модуля, назва(обчислювач, "відкласти"), предмет_дії_відкласти, Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути результат_зміни_властивості;
      }

      ціль предмет_дії_періодично = створити_дію_модуля_планувальник_періодично(обчислювач, предмет_структури_Періодичне);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_дії_періодично;
      }
      притримати(обчислювач, притримувач, предмет_дії_періодично);
      результат_зміни_властивості = предмет_змінити_властивість(обчислювач, предмет_модуля, назва(обчислювач, "періодично"), предмет_дії_періодично, Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути результат_зміни_властивості;
      }

      ціль предмет_дії_скасувати_відкладене = створити_дію_модуля_планувальник_скасувати_відкладене(обчислювач);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_дії_скасувати_відкладене;
      }
      притримати(обчислювач, притримувач, предмет_дії_скасувати_відкладене);
      результат_зміни_властивості = предмет_змінити_властивість(обчислювач, предмет_модуля, назва(обчислювач, "скасувати_відкладене"), предмет_дії_скасувати_відкладене, Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути результат_зміни_властивості;
      }

      забрати_притримувач(обчислювач);
      вернути предмет_модуля;
    }

    зовнішня дія взяти_модуль_біб_планувальник(обчислювач: адреса<Обчислювач>): предмет_або_стан_падіння {
      ціль М = обчислювач;
      змінна результат = створити_текст(обчислювач, "мавка:бібліотека/планувальник/планувальник.ц");
      якщо перевірити_чи_стан_падіння(обчислювач) {
        вернути результат;
      }
      ціль предмет_шляху = результат;
      змінна взятий_предмет: адреса<МаМа::Предмет> = пусто;
      якщо МаМа::отримати_взятий_предмет(М, предмет_шляху як адреса<МаМа::Предмет>, взятий_предмет::адреса) {
        вернути взятий_предмет як адреса<Предмет>;
      }
      результат = створити_модуль_планувальник(обчислювач);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        вернути результат;
      }
      МаМа::покласти_взятий_предмет(М, предмет_шляху як адреса<МаМа::Предмет>, результат як адреса<МаМа::Предмет>);
      вернути результат;
    }
  }
}