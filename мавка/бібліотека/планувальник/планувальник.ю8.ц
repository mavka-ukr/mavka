взяти визначення мавка;
взяти визначення мавка/бібліотека;
взяти визначення біб/Друк;
взяти визначення біб/турбо;

секція мавка {
  секція бібліотека {
    структура ДаніВідкликуВідкладеного {
      обчислювач: адреса<Обчислювач>;
      глобально_притриманий_предмет_відкладеного: адреса<ГлобальноПритриманийПредмет>;
      глобально_притриманий_предмет_відклику: адреса<ГлобальноПритриманийПредмет>;
    }

    структура ДаніВідкликуПеріодичного {
      обчислювач: адреса<Обчислювач>;
      глобально_притриманий_предмет_періодичного: адреса<ГлобальноПритриманийПредмет>;
      глобально_притриманий_предмет_відклику: адреса<ГлобальноПритриманийПредмет>;
    }

    дія обробник_запланованого_виконання_відклику_відкладеного(обчислювач: адреса<Обчислювач>, дані: невідома_адреса, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>): предмет_або_стан_падіння {
      змінна предмет_відклику = аргументи[0];
      змінна М = обчислювач;
      вернути МаМа::предмет_виконати(М, предмет_відклику, пусто, 0, пусто, пусто, МаМа::Місцезнаходження { пусто як адреса<МаМа::ПредметТексту>, 0 });
    }

    дія обробник_запланованого_виконання_відклику_періодичного(обчислювач: адреса<Обчислювач>, дані: невідома_адреса, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>): предмет_або_стан_падіння {
      змінна предмет_відклику = аргументи[0];
      змінна М = обчислювач;
      вернути МаМа::предмет_виконати(М, предмет_відклику, пусто, 0, пусто, пусто, МаМа::Місцезнаходження { пусто як адреса<МаМа::ПредметТексту>, 0 });
    }

    дія обробник_відклику_відкладеного(турбіна: адреса<турбо::Турбіна>, відкладене: адреса<турбо::Відкладене>, аргумент: невідома_адреса, скасовано: логічне, успішно: логічне, код_помилки: ц32) {
      змінна дані_відкладеного = аргумент як адреса<ДаніВідкликуВідкладеного>;
      змінна обчислювач = дані_відкладеного.обчислювач;
      змінна предмет_відкладеного = мавка__отримати_глобально_притриманий_предмет(обчислювач, дані_відкладеного.глобально_притриманий_предмет_відкладеного);
      змінна предмет_відклику = мавка__отримати_глобально_притриманий_предмет(обчислювач, дані_відкладеного.глобально_притриманий_предмет_відклику);

      якщо успішно {
        змінна кількість_аргументів: позитивне = 1;
        змінна аргументи = виділити_памʼять<адреса<Предмет>>(обчислювач, кількість_аргументів);
        аргументи[0] = предмет_відклику;
        мавка__запланувати_виконання(обчислювач, обробник_запланованого_виконання_відклику_відкладеного, пусто, пусто, кількість_аргументів, аргументи);
      } інакше якщо скасовано {
        // ок
      } інакше {
        мавка__ПОМЕРТИ(обчислювач, "НОП: помилка відкладеного");
      }

      мавка__предмет_змінити_користувацькі_дані(обчислювач, предмет_відкладеного, пусто);
      мавка__відпустити_глобально(обчислювач, дані_відкладеного.глобально_притриманий_предмет_відкладеного);
      мавка__відпустити_глобально(обчислювач, дані_відкладеного.глобально_притриманий_предмет_відклику);
      звільнити(обчислювач, дані_відкладеного);
    }

    дія обробник_відклику_періодичного(турбіна: адреса<турбо::Турбіна>, періодичне: адреса<турбо::Періодичне>, аргумент: невідома_адреса, скасовано: логічне, успішно: логічне, код_помилки: ц32) {
      змінна дані_періодичного = аргумент як адреса<ДаніВідкликуПеріодичного>;
      змінна обчислювач = дані_періодичного.обчислювач;
      змінна предмет_періодичного = мавка__отримати_глобально_притриманий_предмет(обчислювач, дані_періодичного.глобально_притриманий_предмет_періодичного);
      змінна предмет_відклику = мавка__отримати_глобально_притриманий_предмет(обчислювач, дані_періодичного.глобально_притриманий_предмет_відклику);

      якщо успішно {
        змінна кількість_аргументів: позитивне = 1;
        змінна аргументи = виділити_памʼять<адреса<Предмет>>(обчислювач, кількість_аргументів);
        аргументи[0] = предмет_відклику;
        мавка__запланувати_виконання(обчислювач, обробник_запланованого_виконання_відклику_періодичного, пусто, пусто, кількість_аргументів, аргументи);
      } інакше {
        якщо скасовано {
        } інакше {
          мавка__ПОМЕРТИ(обчислювач, "НОП: помилка періодичного");
        }

        мавка__предмет_змінити_користувацькі_дані(обчислювач, предмет_періодичного, пусто);
        мавка__відпустити_глобально(обчислювач, дані_періодичного.глобально_притриманий_предмет_періодичного);
        мавка__відпустити_глобально(обчислювач, дані_періодичного.глобально_притриманий_предмет_відклику);
        звільнити(обчислювач, дані_періодичного);
      }
    }

    дія рідна_дія_модуля_планувальник_відкласти(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<МаМа::ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: МаМа::Місцезнаходження): предмет_або_стан_падіння {
      змінна знайдено_аргумент_відклик = ні;
      змінна аргумент_відклик: адреса<Предмет> = пусто;
      змінна знайдено_аргумент_тривалість = ні;
      змінна аргумент_тривалість: адреса<Предмет> = пусто;
      змінна М = обчислювач;
      якщо іменовані_аргументи != пусто {
        знайдено_аргумент_відклик = МаМа::знайти_іменований_аргумент(обчислювач, іменовані_аргументи, МаМа::назва(М, "відклик"), аргумент_відклик::адреса);
        знайдено_аргумент_тривалість = МаМа::знайти_іменований_аргумент(обчислювач, іменовані_аргументи, МаМа::назва(М, "тривалість"), аргумент_тривалість::адреса);
      }
      якщо аргументи != пусто {
        якщо знайдено_аргумент_відклик == ні {
          якщо кількість_аргументів > 0 {
            знайдено_аргумент_відклик = так;
            аргумент_відклик = аргументи[0];
          }
        }
        якщо знайдено_аргумент_тривалість == ні {
          якщо кількість_аргументів > 1 {
            знайдено_аргумент_тривалість = так;
            аргумент_тривалість = аргументи[1];
          }
        }
      }

      змінна тривалість: позитивне = 1;
      якщо знайдено_аргумент_тривалість {
        якщо МаМа::перевірити_чи_предмет_є_числом(обчислювач, аргумент_тривалість) == ні {
          вернути падіння(обчислювач, "Тривалість має бути числом");
        }
        тривалість = позитивне(отримати_значення_числа(обчислювач, аргумент_тривалість як адреса<МаМа::ПредметЧисла>));
        якщо тривалість == 0 {
          тривалість = 1;
        }
      }

      змінна предмет_структури_Відкладене = мавка__отримати_глобально_притриманий_предмет(обчислювач, предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>);

      змінна предмет_відкладеного = МаМа::предмет_виконати(М, предмет_структури_Відкладене, пусто, 0, пусто, пусто, МаМа::Місцезнаходження { пусто як адреса<МаМа::ПредметТексту>, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        вернути предмет_відкладеного;
      }

      змінна дані_відкладеного = виділити<ДаніВідкликуВідкладеного>(обчислювач);
      дані_відкладеного.обчислювач = обчислювач;
      дані_відкладеного.глобально_притриманий_предмет_відкладеного = мавка__притримати_глобально(обчислювач, предмет_відкладеного);
      дані_відкладеного.глобально_притриманий_предмет_відклику = мавка__притримати_глобально(обчислювач, аргумент_відклик);

      змінна турбіна = турбо::отримати_глобальну_турбіну();

      змінна відкладене = турбо::відкласти_виконання(турбіна, тривалість, обробник_відклику_відкладеного, дані_відкладеного);
      якщо відкладене == пусто {
        // потім: обробити
      }

      мавка__предмет_змінити_користувацькі_дані(обчислювач, предмет_відкладеного, відкладене);

      вернути предмет_відкладеного;
    }

    дія зробити_копію_даних_дії_модуля_планувальник_відкласти(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<МаМа::ПредметДії>): невідома_адреса {
      змінна дані_дії = предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>;
      вернути мавка__притримати_глобально(обчислювач, мавка__отримати_глобально_притриманий_предмет(обчислювач, дані_дії));
    }

    дія відклик_перед_звільненням_дії_модуля_планувальник_відкласти(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<МаМа::ПредметДії>) {
      змінна дані_дії = предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>;
      мавка__відпустити_глобально(обчислювач, дані_дії);
    }

    дія створити_дію_модуля_планувальник_відкласти(обчислювач: адреса<Обчислювач>, предмет_структури_Відкладене: адреса<Предмет>): предмет_або_стан_падіння {
      змінна М = обчислювач;
      вернути МаМа::створити_предмет_рідної_дії(
        обчислювач,
        МаМа::назва(М, т8"відкласти"),
        0,
        пусто,
        пусто,
        рідна_дія_модуля_планувальник_відкласти,
        мавка__притримати_глобально(обчислювач, предмет_структури_Відкладене),
        зробити_копію_даних_дії_модуля_планувальник_відкласти,
        відклик_перед_звільненням_дії_модуля_планувальник_відкласти
      ) як адреса<Предмет>;
    }

    дія рідна_дія_модуля_планувальник_періодично(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<МаМа::ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: МаМа::Місцезнаходження): предмет_або_стан_падіння {
      змінна знайдено_аргумент_відклик = ні;
      змінна аргумент_відклик: адреса<Предмет> = пусто;
      змінна знайдено_аргумент_тривалість = ні;
      змінна аргумент_тривалість: адреса<Предмет> = пусто;
      змінна М = обчислювач;
      якщо іменовані_аргументи != пусто {
        знайдено_аргумент_відклик = МаМа::знайти_іменований_аргумент(обчислювач, іменовані_аргументи, МаМа::назва(М, "відклик"), аргумент_відклик::адреса);
        знайдено_аргумент_тривалість = МаМа::знайти_іменований_аргумент(обчислювач, іменовані_аргументи, МаМа::назва(М, "тривалість"), аргумент_тривалість::адреса);
      }
      якщо аргументи != пусто {
        якщо знайдено_аргумент_відклик == ні {
          якщо кількість_аргументів > 0 {
            знайдено_аргумент_відклик = так;
            аргумент_відклик = аргументи[0];
          }
        }
        якщо знайдено_аргумент_тривалість == ні {
          якщо кількість_аргументів > 1 {
            знайдено_аргумент_тривалість = так;
            аргумент_тривалість = аргументи[1];
          }
        }
      }

      змінна тривалість: позитивне = 1;
      якщо знайдено_аргумент_тривалість {
        якщо МаМа::перевірити_чи_предмет_є_числом(обчислювач, аргумент_тривалість) == ні {
          вернути падіння(обчислювач, "Тривалість має бути числом");
        }
        тривалість = позитивне(отримати_значення_числа(обчислювач, аргумент_тривалість як адреса<МаМа::ПредметЧисла>));
        якщо тривалість == 0 {
          тривалість = 1;
        }
      }

      змінна предмет_структури_Періодичне = мавка__отримати_глобально_притриманий_предмет(обчислювач, предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>);

      змінна предмет_періодичного = МаМа::предмет_виконати(М, предмет_структури_Періодичне, пусто, 0, пусто, пусто, МаМа::Місцезнаходження { пусто як адреса<МаМа::ПредметТексту>, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        вернути предмет_періодичного;
      }

      змінна дані_періодичного = виділити<ДаніВідкликуПеріодичного>(обчислювач);
      дані_періодичного.обчислювач = обчислювач;
      дані_періодичного.глобально_притриманий_предмет_періодичного = мавка__притримати_глобально(обчислювач, предмет_періодичного);
      дані_періодичного.глобально_притриманий_предмет_відклику = мавка__притримати_глобально(обчислювач, аргумент_відклик);

      змінна турбіна = турбо::отримати_глобальну_турбіну();

      змінна періодичне = турбо::виконувати_періодично(турбіна, тривалість, обробник_відклику_періодичного, дані_періодичного);
      якщо періодичне == пусто {
        // потім: обробити
      }

      мавка__предмет_змінити_користувацькі_дані(обчислювач, предмет_періодичного, періодичне);

      вернути предмет_періодичного;
    }

    дія зробити_копію_даних_дії_модуля_планувальник_періодично(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<МаМа::ПредметДії>): невідома_адреса {
      змінна дані_дії = предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>;
      вернути мавка__притримати_глобально(обчислювач, мавка__отримати_глобально_притриманий_предмет(обчислювач, дані_дії));
    }

    дія відклик_перед_звільненням_дії_модуля_планувальник_періодично(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<МаМа::ПредметДії>) {
      змінна дані_дії = предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>;
      мавка__відпустити_глобально(обчислювач, дані_дії);
    }

    дія створити_дію_модуля_планувальник_періодично(обчислювач: адреса<Обчислювач>, предмет_структури_Періодичне: адреса<Предмет>): предмет_або_стан_падіння {
      змінна М = обчислювач;
      вернути МаМа::створити_предмет_рідної_дії(
        обчислювач,
        МаМа::назва(М, т8"періодично"),
        0,
        пусто,
        пусто,
        рідна_дія_модуля_планувальник_періодично,
        мавка__притримати_глобально(обчислювач, предмет_структури_Періодичне),
        зробити_копію_даних_дії_модуля_планувальник_періодично,
        відклик_перед_звільненням_дії_модуля_планувальник_періодично
      ) як адреса<Предмет>;
    }

    дія рідна_дія_модуля_планувальник_скасувати_відкладене(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<МаМа::ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: МаМа::Місцезнаходження): предмет_або_стан_падіння {
      змінна знайдено_аргумент_відкладене = ні;
      змінна аргумент_відкладене: адреса<Предмет> = пусто;
      змінна М = обчислювач;
      якщо іменовані_аргументи != пусто {
        знайдено_аргумент_відкладене = МаМа::знайти_іменований_аргумент(обчислювач, іменовані_аргументи, МаМа::назва(М, "відкладене"), аргумент_відкладене::адреса);
      }
      якщо аргументи != пусто {
        якщо знайдено_аргумент_відкладене == ні {
          якщо кількість_аргументів > 0 {
            знайдено_аргумент_відкладене = так;
            аргумент_відкладене = аргументи[0];
          }
        }
      }

      якщо аргумент_відкладене == пусто {
        вернути падіння(обчислювач, "Аргумент має бути періодичним");
      }

      змінна предмет_структури_Відкладене = мавка__отримати_глобально_притриманий_предмет(обчислювач, предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>);
      якщо МаМа::перевірити_чи_предмет_є(М, аргумент_відкладене, предмет_структури_Відкладене як адреса<МаМа::ПредметСтруктури>) == ні {
        вернути падіння(обчислювач, "Аргумент має бути відкладеним");
      }

      змінна відкладене = мавка__предмет_отримати_користувацькі_дані(обчислювач, аргумент_відкладене) як адреса<турбо::Відкладене>;
      якщо відкладене == пусто {
        вернути пусто;
      }

      змінна турбіна = турбо::отримати_глобальну_турбіну();

      турбо::скасувати_відкладене(турбіна, відкладене);

      вернути пусто;
    }

    дія зробити_копію_даних_дії_модуля_планувальник_скасувати_відкладене(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<МаМа::ПредметДії>): невідома_адреса {
      змінна дані_дії = предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>;
      вернути мавка__притримати_глобально(обчислювач, мавка__отримати_глобально_притриманий_предмет(обчислювач, дані_дії));
    }

    дія відклик_перед_звільненням_дії_модуля_планувальник_скасувати_відкладене(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<МаМа::ПредметДії>) {
      змінна дані_дії = предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>;
      мавка__відпустити_глобально(обчислювач, дані_дії);
    }

    дія створити_дію_модуля_планувальник_скасувати_відкладене(обчислювач: адреса<Обчислювач>, предмет_структури_Відкладене: адреса<Предмет>): предмет_або_стан_падіння {
      змінна М = обчислювач;
      вернути МаМа::створити_предмет_рідної_дії(
        обчислювач,
        МаМа::назва(М, т8"скасувати_відкладене"),
        0,
        пусто,
        пусто,
        рідна_дія_модуля_планувальник_скасувати_відкладене,
        мавка__притримати_глобально(обчислювач, предмет_структури_Відкладене),
        зробити_копію_даних_дії_модуля_планувальник_скасувати_відкладене,
        відклик_перед_звільненням_дії_модуля_планувальник_скасувати_відкладене
      ) як адреса<Предмет>;
    }

    дія рідна_дія_модуля_планувальник_скасувати_періодичне(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<МаМа::ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: МаМа::Місцезнаходження): предмет_або_стан_падіння {
      змінна знайдено_аргумент_періодичне = ні;
      змінна аргумент_періодичне: адреса<Предмет> = пусто;
      змінна М = обчислювач;
      якщо іменовані_аргументи != пусто {
        знайдено_аргумент_періодичне = МаМа::знайти_іменований_аргумент(обчислювач, іменовані_аргументи, МаМа::назва(М, "періодичне"), аргумент_періодичне::адреса);
      }
      якщо аргументи != пусто {
        якщо знайдено_аргумент_періодичне == ні {
          якщо кількість_аргументів > 0 {
            знайдено_аргумент_періодичне = так;
            аргумент_періодичне = аргументи[0];
          }
        }
      }

      якщо аргумент_періодичне == пусто {
        вернути падіння(обчислювач, "Аргумент має бути періодичним");
      }

      змінна предмет_структури_Періодичне = мавка__отримати_глобально_притриманий_предмет(обчислювач, предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>);
      якщо МаМа::перевірити_чи_предмет_є(М, аргумент_періодичне,
      предмет_структури_Періодичне як адреса<МаМа::ПредметСтруктури>) == ні {
        вернути падіння(обчислювач, "Аргумент має бути періодичним");
      }

      змінна періодичне = мавка__предмет_отримати_користувацькі_дані(обчислювач, аргумент_періодичне) як адреса<турбо::Періодичне>;
      якщо періодичне == пусто {
        вернути пусто;
      }

      змінна турбіна = турбо::отримати_глобальну_турбіну();

      турбо::скасувати_періодичне(турбіна, періодичне);

      вернути пусто;
    }

    дія зробити_копію_даних_дії_модуля_планувальник_скасувати_періодичне(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<МаМа::ПредметДії>): невідома_адреса {
      змінна дані_дії = предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>;
      вернути мавка__притримати_глобально(обчислювач, мавка__отримати_глобально_притриманий_предмет(обчислювач, дані_дії));
    }

    дія відклик_перед_звільненням_дії_модуля_планувальник_скасувати_періодичне(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<МаМа::ПредметДії>) {
      змінна дані_дії = предмет_дії.дані як адреса<ГлобальноПритриманийПредмет>;
      мавка__відпустити_глобально(обчислювач, дані_дії);
    }

    дія створити_дію_модуля_планувальник_скасувати_періодичне(обчислювач: адреса<Обчислювач>, предмет_структури_Періодичне: адреса<Предмет>): предмет_або_стан_падіння {
      змінна М = обчислювач;
      вернути МаМа::створити_предмет_рідної_дії(
        обчислювач,
        МаМа::назва(М, т8"скасувати_періодичне"),
        0,
        пусто,
        пусто,
        рідна_дія_модуля_планувальник_скасувати_періодичне,
        мавка__притримати_глобально(обчислювач, предмет_структури_Періодичне),
        зробити_копію_даних_дії_модуля_планувальник_скасувати_періодичне,
        відклик_перед_звільненням_дії_модуля_планувальник_скасувати_періодичне
      ) як адреса<Предмет>;
    }

    дія створити_предмет_структури_Відкладене(обчислювач: адреса<Обчислювач>): предмет_або_стан_падіння {
      змінна притримувач = мавка__покласти_притримувач(обчислювач);

      змінна кількість_параметрів: позитивне = 0;
      змінна параметри = пусто як памʼять<адреса<Предмет>>;

      змінна М = обчислювач;

      змінна предмет_структури_Відкладене = МаМа::створити_предмет_структури(
        обчислювач,
        МаМа::назва(М, "Відкладене"),
        обчислювач.предмет_структури_предмет,
        кількість_параметрів,
        параметри як памʼять<адреса<МаМа::ПредметПараметра>>
      ) як адреса<Предмет>;
      якщо перевірити_чи_стан_падіння(обчислювач) {
        мавка__забрати_притримувач(обчислювач);
        вернути предмет_структури_Відкладене;
      }

      мавка__забрати_притримувач(обчислювач);
      вернути предмет_структури_Відкладене;
    }

    дія створити_предмет_структури_Періодичне(обчислювач: адреса<Обчислювач>): предмет_або_стан_падіння {
      змінна притримувач = мавка__покласти_притримувач(обчислювач);

      змінна кількість_параметрів: позитивне = 0;
      змінна параметри = пусто як памʼять<адреса<Предмет>>;

      змінна М = обчислювач;

      змінна предмет_структури_Періодичне = МаМа::створити_предмет_структури(обчислювач, МаМа::назва(М, "Періодичне"), обчислювач.предмет_структури_предмет, кількість_параметрів, параметри як памʼять<адреса<МаМа::ПредметПараметра>>) як адреса<Предмет>;
      якщо перевірити_чи_стан_падіння(обчислювач) {
        мавка__забрати_притримувач(обчислювач);
        вернути предмет_структури_Періодичне;
      }

      мавка__забрати_притримувач(обчислювач);
      вернути предмет_структури_Періодичне;
    }

    дія створити_модуль_планувальник(обчислювач: адреса<Обчислювач>): предмет_або_стан_падіння {
      змінна притримувач = мавка__покласти_притримувач(обчислювач);

      змінна М = обчислювач;

      змінна предмет_модуля = МаМа::створити_предмет_модуля(обчислювач, МаМа::назва(М, "планувальник")) як адреса<Предмет>;
      якщо перевірити_чи_стан_падіння(обчислювач) {
        мавка__забрати_притримувач(обчислювач);
        вернути предмет_модуля;
      }
      мавка__притримати(обчислювач, притримувач, предмет_модуля);

      змінна предмет_структури_Відкладене = створити_предмет_структури_Відкладене(обчислювач);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        мавка__забрати_притримувач(обчислювач);
        вернути предмет_структури_Відкладене;
      }
      мавка__притримати(обчислювач, притримувач, предмет_структури_Відкладене);
      змінна результат_зміни_властивості = МаМа::предмет_змінити_властивість(М, предмет_модуля, МаМа::назва(М, "Відкладене"), предмет_структури_Відкладене, МаМа::Місцезнаходження { пусто як адреса<МаМа::ПредметТексту>, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        мавка__забрати_притримувач(обчислювач);
        вернути результат_зміни_властивості;
      }

      змінна предмет_структури_Періодичне = створити_предмет_структури_Періодичне(обчислювач);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        мавка__забрати_притримувач(обчислювач);
        вернути предмет_структури_Періодичне;
      }
      мавка__притримати(обчислювач, притримувач, предмет_структури_Періодичне);
      результат_зміни_властивості = МаМа::предмет_змінити_властивість(М, предмет_модуля, МаМа::назва(М, "Періодичне"), предмет_структури_Періодичне, МаМа::Місцезнаходження { пусто як адреса<МаМа::ПредметТексту>, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        мавка__забрати_притримувач(обчислювач);
        вернути результат_зміни_властивості;
      }

      змінна предмет_дії_відкласти = створити_дію_модуля_планувальник_відкласти(обчислювач, предмет_структури_Відкладене);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        мавка__забрати_притримувач(обчислювач);
        вернути предмет_дії_відкласти;
      }
      мавка__притримати(обчислювач, притримувач, предмет_дії_відкласти);
      результат_зміни_властивості = МаМа::предмет_змінити_властивість(М, предмет_модуля, МаМа::назва(М, "відкласти"), предмет_дії_відкласти, МаМа::Місцезнаходження { пусто як адреса<МаМа::ПредметТексту>, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        мавка__забрати_притримувач(обчислювач);
        вернути результат_зміни_властивості;
      }

      змінна предмет_дії_періодично = створити_дію_модуля_планувальник_періодично(обчислювач, предмет_структури_Періодичне);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        мавка__забрати_притримувач(обчислювач);
        вернути предмет_дії_періодично;
      }
      мавка__притримати(обчислювач, притримувач, предмет_дії_періодично);
      результат_зміни_властивості = МаМа::предмет_змінити_властивість(М, предмет_модуля, МаМа::назва(М, "періодично"), предмет_дії_періодично, МаМа::Місцезнаходження { пусто як адреса<МаМа::ПредметТексту>, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        мавка__забрати_притримувач(обчислювач);
        вернути результат_зміни_властивості;
      }

      змінна предмет_дії_скасувати_відкладене = створити_дію_модуля_планувальник_скасувати_відкладене(обчислювач, предмет_структури_Відкладене);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        мавка__забрати_притримувач(обчислювач);
        вернути предмет_дії_скасувати_відкладене;
      }
      мавка__притримати(обчислювач, притримувач, предмет_дії_скасувати_відкладене);
      результат_зміни_властивості = МаМа::предмет_змінити_властивість(М, предмет_модуля, МаМа::назва(М, "скасувати_відкладене"), предмет_дії_скасувати_відкладене, МаМа::Місцезнаходження { пусто як адреса<МаМа::ПредметТексту>, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        мавка__забрати_притримувач(обчислювач);
        вернути результат_зміни_властивості;
      }

      змінна предмет_дії_скасувати_періодичне = створити_дію_модуля_планувальник_скасувати_періодичне(обчислювач, предмет_структури_Періодичне);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        мавка__забрати_притримувач(обчислювач);
        вернути предмет_дії_скасувати_періодичне;
      }
      мавка__притримати(обчислювач, притримувач, предмет_дії_скасувати_періодичне);
      результат_зміни_властивості = МаМа::предмет_змінити_властивість(М, предмет_модуля, МаМа::назва(М, "скасувати_періодичне"), предмет_дії_скасувати_періодичне, МаМа::Місцезнаходження { пусто як адреса<МаМа::ПредметТексту>, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        мавка__забрати_притримувач(обчислювач);
        вернути результат_зміни_властивості;
      }

      мавка__забрати_притримувач(обчислювач);
      вернути предмет_модуля;
    }

    зовнішня дія взяти_модуль_біб_планувальник(обчислювач: адреса<Обчислювач>): предмет_або_стан_падіння {
      змінна М = обчислювач;
      змінна результат = МаМа::створити_предмет_тексту(обчислювач, "мавка:бібліотека/планувальник/планувальник.ц") як адреса<Предмет>;
      якщо перевірити_чи_стан_падіння(обчислювач) {
        вернути результат як адреса<Предмет>;
      }
      змінна предмет_шляху = результат;
      змінна взятий_предмет: адреса<МаМа::Предмет> = пусто;
      якщо МаМа::отримати_взятий_предмет(М, предмет_шляху як адреса<МаМа::Предмет>, взятий_предмет::адреса) {
        вернути взятий_предмет як адреса<Предмет>;
      }
      результат = створити_модуль_планувальник(обчислювач);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        вернути результат;
      }
      МаМа::покласти_взятий_предмет(М, предмет_шляху як адреса<МаМа::Предмет>, результат як адреса<МаМа::Предмет>);
      вернути результат;
    }
  }
}