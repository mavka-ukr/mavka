взяти визначення МаМа;
взяти визначення мавка/бібліотека;
взяти визначення турбо;

// Обслуговувач
секція мавка {
  секція бібліотека {
    структура ДаніВідкликуІнтернетКлієнта {
      обчислювач: адреса<Обчислювач>;
      предмет_обслуговувача: адреса<Предмет>;
      глобально_притриманий_предмет_обслуговувача: адреса<ГлобальноПритриманийПредмет>;
    }

    структура ДаніВідкликуІнтернетОбслуговувача {
      обчислювач: адреса<Обчислювач>;
      предмет_обслуговувача: адреса<Предмет>;
      глобально_притриманий_предмет_обслуговувача: адреса<ГлобальноПритриманийПредмет>;
    }

    структура ДаніВідкликуНаРезультатЗаписуВІнтернетКлієнт {
      обчислювач: адреса<Обчислювач>;
      глобально_притриманий_предмет_обслуговувача: адреса<ГлобальноПритриманийПредмет>;
      глобально_притриманий_предмет_даних: адреса<ГлобальноПритриманийПредмет>;
      глобально_притриманий_предмет_відклику: адреса<ГлобальноПритриманийПредмет>;
    }

    дія обробник_запланованого_виконання_відклику_на_підключення_обслуговувача(обчислювач: адреса<Обчислювач>, дані: невідома_адреса, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>): предмет_або_стан_падіння {
      ціль предмет_обслуговувача = аргументи[0];
      вернути предмет_виконати_властивість(обчислювач, предмет_обслуговувача, назва(обчислювач, "обробник_підключення"), кількість_аргументів, аргументи, пусто, Місцезнаходження { пусто, 0 });
    }

    дія обробник_запланованого_виконання_відклику_на_дані_обслуговувача(обчислювач: адреса<Обчислювач>, дані: невідома_адреса, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>): предмет_або_стан_падіння {
      ціль предмет_обслуговувача = аргументи[0];
      вернути предмет_виконати_властивість(обчислювач, предмет_обслуговувача, назва(обчислювач, "обробник_повідомлення"), кількість_аргументів, аргументи, пусто, Місцезнаходження { пусто, 0 });
    }

    дія обробник_запланованого_виконання_відклику_на_відключення_обслуговувача(обчислювач: адреса<Обчислювач>, дані: невідома_адреса, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>): предмет_або_стан_падіння {
      ціль предмет_обслуговувача = аргументи[0];
      вернути предмет_виконати_властивість(обчислювач, предмет_обслуговувача, назва(обчислювач, "обробник_відключення"), кількість_аргументів, аргументи, пусто, Місцезнаходження { пусто, 0 });
    }

    дія обробник_запланованого_виконання_відклику_на_зупинку_обслуговувача(обчислювач: адреса<Обчислювач>, дані: невідома_адреса, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>): предмет_або_стан_падіння {
      ціль предмет_обслуговувача = аргументи[0];
      вернути предмет_виконати_властивість(обчислювач, предмет_обслуговувача, назва(обчислювач, "обробник_зупинки"), кількість_аргументів, аргументи, пусто, Місцезнаходження { пусто, 0 });
    }

    дія обробник_запланованого_виконання_відклику_на_результат_запису_інтернет_клієнта(обчислювач: адреса<Обчислювач>, дані: невідома_адреса, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>): предмет_або_стан_падіння {
      ціль предмет_відклику = аргументи[0];
      ціль нова_кількість_аргументів = кількість_аргументів - 1;
      змінна нові_аргументи = виділити_памʼять<адреса<Предмет>>(обчислювач, нова_кількість_аргументів);
      змінна п: позитивне = 0;
      поки п < нова_кількість_аргументів {
        нові_аргументи[п] = аргументи[п + 1];
        п += 1;
      }
      ціль результат = предмет_виконати(обчислювач, предмет_відклику, пусто, нова_кількість_аргументів, нові_аргументи, пусто, Місцезнаходження { пусто, 0 });
      звільнити_памʼять(обчислювач, нові_аргументи);
      вернути результат;
    }

    дія відклик_на_доступність_читання_інтернет_клієнта(рушій: адреса<ТурбоРушій>, ідентифікатор: ц32, аргумент_відклику: невідома_адреса) {
      ціль дані_клієнта = аргумент_відклику як адреса<ДаніВідкликуІнтернетКлієнта>;
      ціль обчислювач = дані_клієнта.обчислювач;

      поки (так) {
        змінна результат = ні;
        змінна турбо_помилка = ТурбоПомилка { ... };

        ціль розмір_даних: позитивне = 4096;
        змінна дані = виділити_памʼять<п8>(обчислювач, розмір_даних);
        змінна розмір_прочитаних_даних: позитивне = 0;
        змінна спробувати_пізніше: логічне = ні;

        результат = турбо_прочитати(рушій, ідентифікатор, розмір_даних, дані, розмір_прочитаних_даних::адреса, спробувати_пізніше::адреса, турбо_помилка::адреса);

        якщо результат {
          змінна аргументи = виділити_памʼять<адреса<Предмет>>(обчислювач, 3);
          аргументи[0] = дані_клієнта.предмет_обслуговувача;
          аргументи[1] = створити_число(обчислювач, д64(ідентифікатор));
          аргументи[2] = створити_буфер_без_копіювання(обчислювач, розмір_прочитаних_даних, дані);
          запланувати_виконання(обчислювач, обробник_запланованого_виконання_відклику_на_дані_обслуговувача, пусто, пусто, 3, аргументи);
        } інакше {
          якщо спробувати_пізніше {
            звільнити_памʼять(обчислювач, дані);

            вернути;
          } інакше якщо розмір_прочитаних_даних == 0 {
            звільнити_памʼять(обчислювач, дані);

            результат = турбо_закрити_слухач(рушій, ідентифікатор, турбо_помилка::адреса);
            якщо результат == ні {
              вернути;
            }

            вернути;
          } інакше {
            надрукувати_ю8(обчислювач, ю8"не вдалось прочитати(");
            звільнити_памʼять(обчислювач, дані);

            вернути;
          }
        }
      }
    }

    дія відклик_після_видалення_інтернет_клієнта(рушій: адреса<ТурбоРушій>, ідентифікатор: ц32, аргумент_відклику: невідома_адреса) {
      ціль дані_клієнта = аргумент_відклику як адреса<ДаніВідкликуІнтернетКлієнта>;

      ціль предмет_обслуговувача = дані_клієнта.предмет_обслуговувача;
      ціль обчислювач = дані_клієнта.обчислювач;

      звільнити(обчислювач, дані_клієнта);

      змінна результат = ні;
      змінна турбо_помилка = ТурбоПомилка { ... };

      результат = турбо_закрити_інтернет_клієнт(ідентифікатор, турбо_помилка::адреса);
      якщо результат == ні {
        вернути;
      }

      змінна аргументи = виділити_памʼять<адреса<Предмет>>(обчислювач, 2);
      аргументи[0] = предмет_обслуговувача;
      аргументи[1] = створити_число(обчислювач, д64(ідентифікатор));
      запланувати_виконання(обчислювач, обробник_запланованого_виконання_відклику_на_відключення_обслуговувача, пусто, пусто, 2, аргументи);
    }

    дія відклик_на_результат_запису_в_інтернет_клієнта(рушій: адреса<ТурбоРушій>, ідентифікатор: ц32, аргумент_відклику: невідома_адреса, розмір: позитивне, дані: памʼять<п8>, розмір_записаного: позитивне, успіх: логічне, помилка: ТурбоПомилка) {
      ціль дані_відклику = аргумент_відклику як адреса<ДаніВідкликуНаРезультатЗаписуВІнтернетКлієнт>;
      ціль обчислювач = дані_відклику.обчислювач;
      якщо дані_відклику.глобально_притриманий_предмет_відклику != пусто {
        якщо успіх {
          змінна аргументи = виділити_памʼять<адреса<Предмет>>(обчислювач, 5);
          аргументи[0] = отримати_глобально_притриманий_предмет(обчислювач, дані_відклику.глобально_притриманий_предмет_відклику);
          аргументи[1] = отримати_глобально_притриманий_предмет(обчислювач, дані_відклику.глобально_притриманий_предмет_обслуговувача);
          аргументи[2] = створити_число(обчислювач, д64(ідентифікатор));
          аргументи[3] = отримати_глобально_притриманий_предмет(обчислювач, дані_відклику.глобально_притриманий_предмет_даних);
          аргументи[4] = пусто як адреса<Предмет>;
          запланувати_виконання(обчислювач, обробник_запланованого_виконання_відклику_на_результат_запису_інтернет_клієнта, пусто, пусто, 5, аргументи);
        } інакше {
          змінна аргументи = виділити_памʼять<адреса<Предмет>>(обчислювач, 5);
          аргументи[0] = отримати_глобально_притриманий_предмет(обчислювач, дані_відклику.глобально_притриманий_предмет_відклику);
          аргументи[1] = отримати_глобально_притриманий_предмет(обчислювач, дані_відклику.глобально_притриманий_предмет_обслуговувача);
          аргументи[2] = створити_число(обчислювач, д64(ідентифікатор));
          аргументи[3] = отримати_глобально_притриманий_предмет(обчислювач, дані_відклику.глобально_притриманий_предмет_даних);
          аргументи[4] = створити_число(обчислювач, д64(помилка.код));
          запланувати_виконання(обчислювач, обробник_запланованого_виконання_відклику_на_результат_запису_інтернет_клієнта, пусто, пусто, 5, аргументи);
        }
      }
      відпустити_глобально(обчислювач, дані_відклику.глобально_притриманий_предмет_обслуговувача);
      відпустити_глобально(обчислювач, дані_відклику.глобально_притриманий_предмет_даних);
      якщо дані_відклику.глобально_притриманий_предмет_відклику != пусто {
        відпустити_глобально(обчислювач, дані_відклику.глобально_притриманий_предмет_відклику);
      }
      звільнити(обчислювач, дані_відклику);
    }

    дія відклик_на_доступність_читання_інтернет_обслуговувача(рушій: адреса<ТурбоРушій>, ідентифікатор: ц32, аргумент_відклику: невідома_адреса) {
      ціль дані_обслуговувача = аргумент_відклику як адреса<ДаніВідкликуІнтернетОбслуговувача>;
      ціль обчислювач = дані_обслуговувача.обчислювач;

      поки так {
        змінна результат = ні;
        змінна турбо_помилка = ТурбоПомилка { ... };
        змінна вихід_інтернет_клієнта = ТурбоВихідІнтернетКлієнта { ... };
        змінна спробувати_пізніше = ні;

        результат = турбо_прийняти_інтернет_клієнта(ідентифікатор, спробувати_пізніше::адреса, вихід_інтернет_клієнта::адреса, турбо_помилка::адреса);
        якщо результат == ні {
          якщо спробувати_пізніше {
            вернути;
          }
          надрукувати_ю8(обчислювач, ю8"не вдалось прийняти клієнта");
          вернути;
        }

        ціль дані_клієнта = виділити<ДаніВідкликуІнтернетКлієнта>(обчислювач);
        дані_клієнта.обчислювач = обчислювач;
        дані_клієнта.предмет_обслуговувача = дані_обслуговувача.предмет_обслуговувача;
        дані_клієнта.глобально_притриманий_предмет_обслуговувача = притримати_глобально(обчислювач, дані_обслуговувача.предмет_обслуговувача);

        результат = турбо_створити_слухач(рушій, ц32(вихід_інтернет_клієнта.ідентифікатор), ТурбоПодіяДоступноДляЧитання, відклик_на_доступність_читання_інтернет_клієнта, пусто, відклик_після_видалення_інтернет_клієнта, дані_клієнта, турбо_помилка::адреса);
        якщо результат == ні {
          надрукувати_ю8(обчислювач, ю8"не вдалось створити слухач клієнта");
          вернути;
        }

        змінна аргументи = виділити_памʼять<адреса<Предмет>>(обчислювач, 4);
        аргументи[0] = дані_обслуговувача.предмет_обслуговувача;
        аргументи[1] = створити_число(обчислювач, д64(вихід_інтернет_клієнта.ідентифікатор));
        аргументи[2] = створити_юнікод_з_ю8(обчислювач, ю8"");
        аргументи[3] = створити_юнікод_з_ю8(обчислювач, ю8"");
        запланувати_виконання(обчислювач, обробник_запланованого_виконання_відклику_на_підключення_обслуговувача, пусто, пусто, 4, аргументи);
      }
    }

    дія відклик_після_видалення_інтернет_обслуговувача(рушій: адреса<ТурбоРушій>, ідентифікатор: ц32, аргумент_відклику: невідома_адреса) {
      ціль дані_обслуговувача = аргумент_відклику як адреса<ДаніВідкликуІнтернетОбслуговувача>;
      ціль обчислювач = дані_обслуговувача.обчислювач;
      ціль предмет_обслуговувача = дані_обслуговувача.предмет_обслуговувача;

      звільнити(обчислювач, дані_обслуговувача);

      змінна результат = ні;
      змінна турбо_помилка = ТурбоПомилка { ... };

      результат = турбо_закрити_інтернет_обслуговувач(ідентифікатор, турбо_помилка::адреса);
      якщо результат == ні {
        надрукувати_ю8(обчислювач, ю8"не вдалось закрити інтернет обслуговувач");
        вернути;
      }

      змінна аргументи = виділити_памʼять<адреса<Предмет>>(обчислювач, 2);
      аргументи[0] = предмет_обслуговувача;
      аргументи[1] = створити_число(обчислювач, д64(ідентифікатор));
      запланувати_виконання(обчислювач, обробник_запланованого_виконання_відклику_на_відключення_обслуговувача, пусто, пусто, 2, аргументи);
    }

    дія рідна_дія_метода_складеного_предмета_Обслуговувач_запустити(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<Предмет>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
      змінна знайдено_аргумент_відклик = ні;
      змінна аргумент_відклик: адреса<Предмет> = пусто;
      якщо іменовані_аргументи != пусто {
        знайдено_аргумент_відклик = знайти_іменований_аргумент(обчислювач, іменовані_аргументи, назва(обчислювач, "відклик"), аргумент_відклик::адреса);
      }
      якщо аргументи != пусто {
        якщо знайдено_аргумент_відклик == ні {
          якщо кількість_аргументів > 0 {
            знайдено_аргумент_відклик = так;
            аргумент_відклик = аргументи[0];
          }
        }
      }

      ціль рушій = турбо_глобальний_рушій();

      змінна дані_обслуговувача = виділити<ДаніВідкликуІнтернетОбслуговувача>(обчислювач);
      дані_обслуговувача.обчислювач = обчислювач;
      дані_обслуговувача.предмет_обслуговувача = предмет_я;
      дані_обслуговувача.глобально_притриманий_предмет_обслуговувача = притримати_глобально(обчислювач, предмет_я);

      ціль притримувач = покласти_притримувач(обчислювач);

      ціль предмет_адреси = предмет_отримати_властивість(обчислювач, предмет_я, назва(обчислювач, "адреса"), Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        звільнити(обчислювач, дані_обслуговувача);
        забрати_притримувач(обчислювач);
        вернути предмет_адреси;
      }
      притримати(обчислювач, притримувач, предмет_адреси);

      ціль предмет_порта = предмет_отримати_властивість(обчислювач, предмет_я, назва(обчислювач, "порт"), Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        звільнити(обчислювач, дані_обслуговувача);
        забрати_притримувач(обчислювач);
        вернути предмет_порта;
      }
      забрати_притримувач(обчислювач);

      якщо перевірити_чи_предмет_є_текстом(обчислювач, предмет_адреси) == ні {
        звільнити(обчислювач, дані_обслуговувача);
        вернути падіння(обчислювач, "Адреса має бути текстом");
      }
      якщо перевірити_чи_предмет_є_числом(обчислювач, предмет_порта) == ні {
        звільнити(обчислювач, дані_обслуговувача);
        вернути падіння(обчислювач, "Порт має бути числом");
      }

      змінна адреса_т8 = отримати_значення_тексту(обчислювач, предмет_адреси);
      змінна адреса_ю8 = ю8 { 0, пусто };
      якщо перекодувати_т8_в_ю8(обчислювач, адреса_т8, адреса_ю8::адреса) == ні {
        звільнити(обчислювач, дані_обслуговувача);
        вернути падіння(обчислювач, "Не вдалось отримати ю8 з тексту адреси");
      }

      ціль порт = ц32(отримати_значення_числа(обчислювач, предмет_порта));

      змінна результат = ні;
      змінна турбо_помилка = ТурбоПомилка { ... };
      змінна вихід_інтернет_обслуговувача = ТурбоВихідІнтернетОбслуговувача { ... };

      результат = турбо_створити_інтернет_обслуговувач(адреса_ю8, п16(порт), вихід_інтернет_обслуговувача::адреса, турбо_помилка::адреса);
      звільнити_памʼять(обчислювач, адреса_ю8.дані);
      якщо результат == ні {
        звільнити(обчислювач, дані_обслуговувача);
      } інакше {
        результат = турбо_створити_слухач(рушій, ц32(вихід_інтернет_обслуговувача.ідентифікатор), ТурбоПодіяДоступноДляЧитання, відклик_на_доступність_читання_інтернет_обслуговувача, пусто, відклик_після_видалення_інтернет_обслуговувача, дані_обслуговувача, турбо_помилка::адреса);
        якщо результат == ні {
          // потім: закрити обслуговувач
          звільнити(обчислювач, дані_обслуговувача);
        }
      }

      якщо результат {
        ціль результат_зміни_властивості = предмет_змінити_властивість(обчислювач, предмет_я, назва(обчислювач, "оф"), створити_число(обчислювач, д64(вихід_інтернет_обслуговувача.ідентифікатор)), Місцезнаходження { пусто, 0 });
        якщо перевірити_чи_стан_падіння(обчислювач) {
          вернути результат_зміни_властивості;
        }
      }

      якщо аргумент_відклик != пусто {
        ціль кількість_аргументів: позитивне = 2;
        змінна аргументи = виділити_памʼять<адреса<Предмет>>(обчислювач, кількість_аргументів);
        аргументи[0] = предмет_я;
        якщо результат {
          аргументи[1] = пусто як адреса<Предмет>;
        } інакше {
          аргументи[1] = створити_число(обчислювач, д64(турбо_помилка.код));
        }
        ціль результат_виконання = предмет_виконати(обчислювач, аргумент_відклик, пусто, кількість_аргументів, аргументи, пусто, Місцезнаходження { пусто, 0 });
        звільнити_памʼять(обчислювач, аргументи);
        якщо перевірити_чи_стан_падіння(обчислювач) {
          вернути результат_виконання;
        }
      }

      вернути пусто;
    }

    дія рідна_дія_метода_складеного_предмета_Обслуговувач_зупинити(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<Предмет>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
      ціль рушій = турбо_глобальний_рушій();
      ціль предмет_оф = предмет_отримати_властивість(обчислювач, предмет_я, назва(обчислювач, "оф"), Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        вернути предмет_оф;
      }
      якщо перевірити_чи_предмет_є_числом(обчислювач, предмет_оф) == ні {
        вернути пусто;
      }
      ціль оф = ц32(отримати_значення_числа(обчислювач, предмет_оф));
      змінна турбо_помилка: ТурбоПомилка;
      турбо_видалити_слухач(рушій, оф, турбо_помилка::адреса);
      вернути пусто;
    }

    дія рідна_дія_метода_складеного_предмета_Обслуговувач_надіслати(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<Предмет>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
      змінна знайдено_аргумент_клієнт = ні;
      змінна аргумент_клієнт: адреса<Предмет> = пусто;
      змінна знайдено_аргумент_повідомлення = ні;
      змінна аргумент_повідомлення: адреса<Предмет> = пусто;
      змінна знайдено_аргумент_відклик = ні;
      змінна аргумент_відклик: адреса<Предмет> = пусто;
      якщо іменовані_аргументи != пусто {
        знайдено_аргумент_клієнт = знайти_іменований_аргумент(обчислювач, іменовані_аргументи, назва(обчислювач, "клієнт"), аргумент_клієнт::адреса);
        знайдено_аргумент_повідомлення = знайти_іменований_аргумент(обчислювач, іменовані_аргументи, назва(обчислювач, "повідомлення"), аргумент_повідомлення::адреса);
        знайдено_аргумент_відклик = знайти_іменований_аргумент(обчислювач, іменовані_аргументи, назва(обчислювач, "відклик"), аргумент_відклик::адреса);
      }
      якщо аргументи != пусто {
        якщо знайдено_аргумент_клієнт == ні {
          якщо кількість_аргументів > 0 {
            знайдено_аргумент_клієнт = так;
            аргумент_клієнт = аргументи[0];
          }
        }
        якщо знайдено_аргумент_повідомлення == ні {
          якщо кількість_аргументів > 1 {
            знайдено_аргумент_повідомлення = так;
            аргумент_повідомлення = аргументи[1];
          }
        }
        якщо знайдено_аргумент_відклик == ні {
          якщо кількість_аргументів > 2 {
            знайдено_аргумент_відклик = так;
            аргумент_відклик = аргументи[2];
          }
        }
      }
      якщо перевірити_чи_предмет_є_числом(обчислювач, аргумент_клієнт) == ні {
        вернути падіння(обчислювач, "Клієнт має бути числом");
      }
      змінна байти = Байти { 0, пусто };
      якщо перевірити_чи_предмет_є_байтами(обчислювач, аргумент_повідомлення) {
        байти = отримати_значення_байтів(обчислювач, аргумент_повідомлення);
      } інакше якщо перевірити_чи_предмет_є_буфером(обчислювач, аргумент_повідомлення) {
        байти = отримати_значення_буфера(обчислювач, аргумент_повідомлення);
      } інакше {
        вернути падіння(обчислювач, "Повідомлення має бути байтами або буфером");
      }
      ціль клієнт_д64 = отримати_значення_числа(обчислювач, аргумент_клієнт);
      ціль клієнт = ц32(клієнт_д64);

      ціль дані_відклику = виділити<ДаніВідкликуНаРезультатЗаписуВІнтернетКлієнт>(обчислювач);
      дані_відклику.обчислювач = обчислювач;
      дані_відклику.глобально_притриманий_предмет_обслуговувача = притримати_глобально(обчислювач, предмет_я);
      дані_відклику.глобально_притриманий_предмет_даних = притримати_глобально(обчислювач, аргумент_повідомлення);
      якщо аргумент_відклик == пусто {
        дані_відклику.глобально_притриманий_предмет_відклику = пусто;
      } інакше {
        дані_відклику.глобально_притриманий_предмет_відклику = притримати_глобально(обчислювач, аргумент_відклик);
      }
      турбо_записати(турбо_глобальний_рушій(), клієнт, байти.розмір, байти.дані, відклик_на_результат_запису_в_інтернет_клієнта, дані_відклику);

      вернути пусто;
    }

    дія створити_предмет_структури_Обслуговувач(обчислювач: адреса<Обчислювач>): предмет_або_стан_падіння {
      ціль притримувач = покласти_притримувач(обчислювач);

      ціль кількість_параметрів: позитивне = 6;
      змінна параметри = виділити_памʼять<адреса<Предмет>>(обчислювач, кількість_параметрів);

      ціль параметр_оф = створити_параметр(обчислювач, назва(обчислювач, "оф"), пусто, пусто);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути параметр_оф;
      }
      параметри[0] = параметр_оф;
      притримати(обчислювач, притримувач, параметр_оф);

      ціль параметр_адреса = створити_параметр(обчислювач, назва(обчислювач, "адреса"), пусто, пусто);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути параметр_адреса;
      }
      параметри[1] = параметр_адреса;
      притримати(обчислювач, притримувач, параметр_адреса);

      ціль параметр_порт = створити_параметр(обчислювач, назва(обчислювач, "порт"), пусто, пусто);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути параметр_порт;
      }
      параметри[2] = параметр_порт;
      притримати(обчислювач, притримувач, параметр_порт);

      ціль параметр_обробник_підключення = створити_параметр(обчислювач, назва(обчислювач, "обробник_підключення"), пусто, пусто);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути параметр_обробник_підключення;
      }
      параметри[3] = параметр_обробник_підключення;
      притримати(обчислювач, притримувач, параметр_обробник_підключення);

      ціль параметр_обробник_відключення = створити_параметр(обчислювач, назва(обчислювач, "обробник_відключення"), пусто, пусто);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути параметр_обробник_відключення;
      }
      параметри[4] = параметр_обробник_відключення;
      притримати(обчислювач, притримувач, параметр_обробник_відключення);

      ціль параметр_обробник_повідомлення = створити_параметр(обчислювач, назва(обчислювач, "обробник_повідомлення"), пусто, пусто);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути параметр_обробник_повідомлення;
      }
      параметри[5] = параметр_обробник_повідомлення;
      притримати(обчислювач, притримувач, параметр_обробник_повідомлення);

      ціль предмет_структури_Обслуговувач = створити_структуру(обчислювач, назва(обчислювач, "Обслуговувач"), отримати_предмет_структури_предмет(обчислювач), кількість_параметрів, параметри);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_структури_Обслуговувач;
      }

      ціль предмет_дії_метода_запустити = створити_рідну_дію(обчислювач, назва(обчислювач, т8"запустити"), 0, пусто, пусто, рідна_дія_метода_складеного_предмета_Обслуговувач_запустити);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_дії_метода_запустити;
      }
      притримати(обчислювач, притримувач, предмет_дії_метода_запустити);
      змінна результат_запису_метода = предмет_записати_метод(обчислювач, предмет_структури_Обслуговувач, назва(обчислювач, "запустити"), предмет_дії_метода_запустити, Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути результат_запису_метода;
      }

      ціль предмет_дії_метода_зупинити = створити_рідну_дію(обчислювач, назва(обчислювач, т8"зупинити"), 0, пусто, пусто, рідна_дія_метода_складеного_предмета_Обслуговувач_зупинити);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_дії_метода_зупинити;
      }
      притримати(обчислювач, притримувач, предмет_дії_метода_зупинити);
      результат_запису_метода = предмет_записати_метод(обчислювач, предмет_структури_Обслуговувач, назва(обчислювач, "зупинити"), предмет_дії_метода_зупинити, Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути результат_запису_метода;
      }

      ціль предмет_дії_метода_надіслати = створити_рідну_дію(обчислювач, назва(обчислювач, т8"надіслати"), 0, пусто, пусто, рідна_дія_метода_складеного_предмета_Обслуговувач_надіслати);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_дії_метода_надіслати;
      }
      притримати(обчислювач, притримувач, предмет_дії_метода_надіслати);
      результат_запису_метода = предмет_записати_метод(обчислювач, предмет_структури_Обслуговувач, назва(обчислювач, "надіслати"), предмет_дії_метода_надіслати, Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути результат_запису_метода;
      }

      забрати_притримувач(обчислювач);
      вернути предмет_структури_Обслуговувач;
    }
  }
}

// Звʼязок
секція мавка {
  секція бібліотека {
    структура ДаніВідкликуІнтернетЗвʼязку {
      обчислювач: адреса<Обчислювач>;
      предмет_звʼязку: адреса<Предмет>;
      глобально_притриманий_предмет_звʼязку: адреса<ГлобальноПритриманийПредмет>;
    }

    структура ДаніВідкликуНаРезультатЗаписуВІнтернетЗвʼязку {
      обчислювач: адреса<Обчислювач>;
      глобально_притриманий_предмет_звʼязку: адреса<ГлобальноПритриманийПредмет>;
      глобально_притриманий_предмет_даних: адреса<ГлобальноПритриманийПредмет>;
      глобально_притриманий_предмет_відклику: адреса<ГлобальноПритриманийПредмет>;
    }

    дія обробник_запланованого_виконання_відклику_на_підключення_звʼязку(обчислювач: адреса<Обчислювач>, дані: невідома_адреса, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>): предмет_або_стан_падіння {
      ціль предмет_звʼязку = аргументи[0];
      вернути предмет_виконати_властивість(обчислювач, предмет_звʼязку, назва(обчислювач, "обробник_підключення"), кількість_аргументів, аргументи, пусто, Місцезнаходження { пусто, 0 });
    }

    дія обробник_запланованого_виконання_відклику_на_дані_звʼязку(обчислювач: адреса<Обчислювач>, дані: невідома_адреса, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>): предмет_або_стан_падіння {
      ціль предмет_звʼязку = аргументи[0];
      вернути предмет_виконати_властивість(обчислювач, предмет_звʼязку, назва(обчислювач, "обробник_повідомлення"), кількість_аргументів, аргументи, пусто, Місцезнаходження { пусто, 0 });
    }

    дія обробник_запланованого_виконання_відклику_на_закінчення_звʼязку(обчислювач: адреса<Обчислювач>, дані: невідома_адреса, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>): предмет_або_стан_падіння {
      ціль предмет_звʼязку = аргументи[0];
      вернути предмет_виконати_властивість(обчислювач, предмет_звʼязку, назва(обчислювач, "обробник_відключення"), кількість_аргументів, аргументи, пусто, Місцезнаходження { пусто, 0 });
    }

    дія обробник_запланованого_виконання_відклику_на_результат_запису_інтернет_звʼязку(обчислювач: адреса<Обчислювач>, дані: невідома_адреса, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>): предмет_або_стан_падіння {
      ціль предмет_відклику = аргументи[0];
      ціль нова_кількість_аргументів = кількість_аргументів - 1;
      змінна нові_аргументи = виділити_памʼять<адреса<Предмет>>(обчислювач, нова_кількість_аргументів);
      змінна п: позитивне = 0;
      поки п < нова_кількість_аргументів {
        нові_аргументи[п] = аргументи[п + 1];
        п += 1;
      }
      ціль результат = предмет_виконати(обчислювач, предмет_відклику, пусто, нова_кількість_аргументів, нові_аргументи, пусто, Місцезнаходження { пусто, 0 });
      звільнити_памʼять(обчислювач, нові_аргументи);
      вернути результат;
    }

    дія відклик_на_доступність_запису_інтернет_звʼязку(рушій: адреса<ТурбоРушій>, ідентифікатор: ц32, аргумент_відклику: невідома_адреса) {
      ціль дані_звʼязку = аргумент_відклику як адреса<ДаніВідкликуІнтернетЗвʼязку>;
      ціль обчислювач = дані_звʼязку.обчислювач;

      змінна результат = ні;
      змінна турбо_помилка: ТурбоПомилка;

      результат = турбо_перевірити_інтернет_звʼязок(ідентифікатор, турбо_помилка::адреса);

      змінна аргументи = виділити_памʼять<адреса<Предмет>>(обчислювач, 2);
      аргументи[0] = дані_звʼязку.предмет_звʼязку;
      аргументи[1] = пусто як адреса<Предмет>;

      якщо результат == ні {
        аргументи[1] = створити_число(обчислювач, д64(турбо_помилка.код));
      }

      запланувати_виконання(обчислювач, обробник_запланованого_виконання_відклику_на_підключення_звʼязку, пусто, пусто, 2, аргументи);
    }

    дія відклик_на_доступність_читання_інтернет_звʼязку(рушій: адреса<ТурбоРушій>, ідентифікатор: ц32, аргумент_відклику: невідома_адреса) {
      ціль дані_звʼязку = аргумент_відклику як адреса<ДаніВідкликуІнтернетЗвʼязку>;
      ціль обчислювач = дані_звʼязку.обчислювач;

      поки (так) {
        змінна результат = ні;
        змінна турбо_помилка = ТурбоПомилка { ... };

        ціль розмір_даних: позитивне = 4096;
        змінна дані = виділити_памʼять<п8>(обчислювач, розмір_даних);
        змінна розмір_прочитаних_даних: позитивне = 0;
        змінна спробувати_пізніше: логічне = ні;

        результат = турбо_прочитати(рушій, ідентифікатор, розмір_даних, дані, розмір_прочитаних_даних::адреса, спробувати_пізніше::адреса, турбо_помилка::адреса);

        якщо результат {
          змінна аргументи = виділити_памʼять<адреса<Предмет>>(обчислювач, 2);
          аргументи[0] = дані_звʼязку.предмет_звʼязку;
          аргументи[1] = створити_буфер_без_копіювання(обчислювач, розмір_прочитаних_даних, дані);
          запланувати_виконання(обчислювач, обробник_запланованого_виконання_відклику_на_дані_звʼязку, пусто, пусто, 2, аргументи);
        } інакше {
          якщо спробувати_пізніше {
            звільнити_памʼять(обчислювач, дані);

            вернути;
          } інакше якщо розмір_прочитаних_даних == 0 {
            звільнити_памʼять(обчислювач, дані);

            результат = турбо_закрити_слухач(рушій, ідентифікатор, турбо_помилка::адреса);
            якщо результат == ні {
              вернути;
            }

            вернути;
          } інакше {
            надрукувати_ю8(обчислювач, ю8"не вдалось прочитати(");
            звільнити_памʼять(обчислювач, дані);

            вернути;
          }
        }
      }
    }

    дія відклик_після_видалення_інтернет_звʼязку(рушій: адреса<ТурбоРушій>, ідентифікатор: ц32, аргумент_відклику: невідома_адреса) {
      ціль дані_звʼязку = аргумент_відклику як адреса<ДаніВідкликуІнтернетЗвʼязку>;
      ціль обчислювач = дані_звʼязку.обчислювач;
      ціль предмет_звʼязку = дані_звʼязку.предмет_звʼязку;

      звільнити(обчислювач, дані_звʼязку);

      змінна результат = ні;
      змінна турбо_помилка = ТурбоПомилка { ... };

      результат = турбо_закрити_інтернет_звʼязок(ідентифікатор, турбо_помилка::адреса);
      якщо результат == ні {
        надрукувати_ю8(обчислювач, ю8"не вдалось закрити інтернет звʼязок");
        вернути;
      }

      змінна аргументи = виділити_памʼять<адреса<Предмет>>(обчислювач, 2);
      аргументи[0] = предмет_звʼязку;
      аргументи[1] = створити_число(обчислювач, д64(ідентифікатор));
      запланувати_виконання(обчислювач, обробник_запланованого_виконання_відклику_на_закінчення_звʼязку, пусто, пусто, 2, аргументи);
    }

    дія відклик_на_результат_запису_в_інтернет_звʼязок(рушій: адреса<ТурбоРушій>, ідентифікатор: ц32, аргумент_відклику: невідома_адреса, розмір: позитивне, дані: памʼять<п8>, розмір_записаного: позитивне, успіх: логічне, помилка: ТурбоПомилка) {
      ціль дані_відклику = аргумент_відклику як адреса<ДаніВідкликуНаРезультатЗаписуВІнтернетЗвʼязку>;
      ціль обчислювач = дані_відклику.обчислювач;
      якщо дані_відклику.глобально_притриманий_предмет_відклику != пусто {
        якщо успіх {
          змінна аргументи = виділити_памʼять<адреса<Предмет>>(обчислювач, 4);
          аргументи[0] = отримати_глобально_притриманий_предмет(обчислювач, дані_відклику.глобально_притриманий_предмет_відклику);
          аргументи[1] = отримати_глобально_притриманий_предмет(обчислювач, дані_відклику.глобально_притриманий_предмет_звʼязку);
          аргументи[2] = отримати_глобально_притриманий_предмет(обчислювач, дані_відклику.глобально_притриманий_предмет_даних);
          аргументи[3] = пусто як адреса<Предмет>;
          запланувати_виконання(обчислювач, обробник_запланованого_виконання_відклику_на_результат_запису_інтернет_звʼязку, пусто, пусто, 4, аргументи);
        } інакше {
          змінна аргументи = виділити_памʼять<адреса<Предмет>>(обчислювач, 4);
          аргументи[0] = отримати_глобально_притриманий_предмет(обчислювач, дані_відклику.глобально_притриманий_предмет_відклику);
          аргументи[1] = отримати_глобально_притриманий_предмет(обчислювач, дані_відклику.глобально_притриманий_предмет_звʼязку);
          аргументи[2] = отримати_глобально_притриманий_предмет(обчислювач, дані_відклику.глобально_притриманий_предмет_даних);
          аргументи[3] = створити_число(обчислювач, д64(помилка.код));
          запланувати_виконання(обчислювач, обробник_запланованого_виконання_відклику_на_результат_запису_інтернет_звʼязку, пусто, пусто, 5, аргументи);
        }
      }
      відпустити_глобально(обчислювач, дані_відклику.глобально_притриманий_предмет_звʼязку);
      відпустити_глобально(обчислювач, дані_відклику.глобально_притриманий_предмет_даних);
      якщо дані_відклику.глобально_притриманий_предмет_відклику != пусто {
        відпустити_глобально(обчислювач, дані_відклику.глобально_притриманий_предмет_відклику);
      }
      звільнити(обчислювач, дані_відклику);
    }

    дія рідна_дія_метода_складеного_предмета_Звʼязок_підключити(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<Предмет>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
      ціль рушій = турбо_глобальний_рушій();

      змінна дані_інтернет_звʼязку = виділити<ДаніВідкликуІнтернетЗвʼязку>(обчислювач);
      дані_інтернет_звʼязку.обчислювач = обчислювач;
      дані_інтернет_звʼязку.предмет_звʼязку = предмет_я;
      дані_інтернет_звʼязку.глобально_притриманий_предмет_звʼязку = притримати_глобально(обчислювач, предмет_я);

      ціль притримувач = покласти_притримувач(обчислювач);

      ціль предмет_адреси = предмет_отримати_властивість(обчислювач, предмет_я, назва(обчислювач, "адреса"), Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        звільнити(обчислювач, дані_інтернет_звʼязку);
        забрати_притримувач(обчислювач);
        вернути предмет_адреси;
      }
      притримати(обчислювач, притримувач, предмет_адреси);

      ціль предмет_порта = предмет_отримати_властивість(обчислювач, предмет_я, назва(обчислювач, "порт"), Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        звільнити(обчислювач, дані_інтернет_звʼязку);
        забрати_притримувач(обчислювач);
        вернути предмет_порта;
      }
      забрати_притримувач(обчислювач);

      якщо перевірити_чи_предмет_є_текстом(обчислювач, предмет_адреси) == ні {
        звільнити(обчислювач, дані_інтернет_звʼязку);
        вернути падіння(обчислювач, "Адреса має бути текстом");
      }
      якщо перевірити_чи_предмет_є_числом(обчислювач, предмет_порта) == ні {
        звільнити(обчислювач, дані_інтернет_звʼязку);
        вернути падіння(обчислювач, "Порт має бути числом");
      }

      змінна адреса_т8 = отримати_значення_тексту(обчислювач, предмет_адреси);
      змінна адреса_ю8 = ю8 { 0, пусто };
      якщо перекодувати_т8_в_ю8(обчислювач, адреса_т8, адреса_ю8::адреса) == ні {
        звільнити(обчислювач, дані_інтернет_звʼязку);
        вернути падіння(обчислювач, "Не вдалось отримати ю8 з тексту адреси");
      }

      ціль порт = ц32(отримати_значення_числа(обчислювач, предмет_порта));

      змінна результат = ні;
      змінна турбо_помилка = ТурбоПомилка { ... };
      змінна вихід_інтернет_звʼязку = ТурбоВихідІнтернетЗвʼязку { ... };

      результат = турбо_створити_інтернет_звʼязок(адреса_ю8, п16(порт), вихід_інтернет_звʼязку::адреса, турбо_помилка::адреса);
      звільнити_памʼять(обчислювач, адреса_ю8.дані);
      якщо результат == ні {
        звільнити(обчислювач, дані_інтернет_звʼязку);
      } інакше {
        результат = турбо_створити_слухач(рушій, ц32(вихід_інтернет_звʼязку.ідентифікатор), ТурбоПодіяДоступноДляЧитання | ТурбоПодіяДоступноДляЗапису, відклик_на_доступність_читання_інтернет_звʼязку, відклик_на_доступність_запису_інтернет_звʼязку, відклик_після_видалення_інтернет_звʼязку, дані_інтернет_звʼязку, турбо_помилка::адреса);
        якщо результат == ні {
          // потім: закрити звʼязок
          звільнити(обчислювач, дані_інтернет_звʼязку);
        }
      }

      якщо результат {
        ціль результат_зміни_властивості = предмет_змінити_властивість(обчислювач, предмет_я, назва(обчислювач, "оф"), створити_число(обчислювач, д64(вихід_інтернет_звʼязку.ідентифікатор)), Місцезнаходження { пусто, 0 });
        якщо перевірити_чи_стан_падіння(обчислювач) {
          вернути результат_зміни_властивості;
        }
      }

      вернути пусто;
    }

    дія рідна_дія_метода_складеного_предмета_Звʼязок_відключитись(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<Предмет>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
      ціль рушій = турбо_глобальний_рушій();

//      ціль предмет_оф = предмет_отримати_властивість(обчислювач, предмет_я, назва(обчислювач, "оф"), Місцезнаходження { пусто, 0 });
//      якщо перевірити_чи_стан_падіння(обчислювач) {
//        вернути предмет_оф;
//      }
//      якщо перевірити_чи_предмет_є_числом(обчислювач, предмет_оф) == ні {
//        вернути падіння(обчислювач, "Звʼязок має бути числом");
//      }
//      ціль підключення_д64 = отримати_значення_числа(обчислювач, предмет_оф);
//      ціль підключення = ц32(підключення_д64);
//
//      ціль результат_зупинки = турбо_відключити_підключення(рушій, підключення);
//      якщо результат_зупинки == 0ц32-1 {
//        // потім: помилка
//      }

      вернути пусто;
    }

    дія рідна_дія_метода_складеного_предмета_Звʼязок_надіслати(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<Предмет>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
      змінна знайдено_аргумент_повідомлення = ні;
      змінна аргумент_повідомлення: адреса<Предмет> = пусто;
      змінна знайдено_аргумент_відклик = ні;
      змінна аргумент_відклик: адреса<Предмет> = пусто;
      якщо іменовані_аргументи != пусто {
        знайдено_аргумент_повідомлення = знайти_іменований_аргумент(обчислювач, іменовані_аргументи, назва(обчислювач, "повідомлення"), аргумент_повідомлення::адреса);
        знайдено_аргумент_відклик = знайти_іменований_аргумент(обчислювач, іменовані_аргументи, назва(обчислювач, "відклик"), аргумент_відклик::адреса);
      }
      якщо аргументи != пусто {
        якщо знайдено_аргумент_повідомлення == ні {
          якщо кількість_аргументів > 0 {
            знайдено_аргумент_повідомлення = так;
            аргумент_повідомлення = аргументи[0];
          }
        }
        якщо знайдено_аргумент_відклик == ні {
          якщо кількість_аргументів > 1 {
            знайдено_аргумент_відклик = так;
            аргумент_відклик = аргументи[1];
          }
        }
      }
      ціль предмет_оф = предмет_отримати_властивість(обчислювач, предмет_я, назва(обчислювач, "оф"), Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        вернути предмет_оф;
      }
      якщо перевірити_чи_предмет_є_числом(обчислювач, предмет_оф) == ні {
        вернути падіння(обчислювач, "Оф має бути числом");
      }
      якщо перевірити_чи_предмет_є_байтами(обчислювач, аргумент_повідомлення) == ні {
        вернути падіння(обчислювач, "Повідомлення має бути байтами");
      }
      ціль оф_д64 = отримати_значення_числа(обчислювач, предмет_оф);
      ціль оф = ц32(оф_д64);
      змінна байти = Байти { 0, пусто };
      якщо перевірити_чи_предмет_є_байтами(обчислювач, аргумент_повідомлення) {
        байти = отримати_значення_байтів(обчислювач, аргумент_повідомлення);
      } інакше якщо перевірити_чи_предмет_є_буфером(обчислювач, аргумент_повідомлення) {
        байти = отримати_значення_буфера(обчислювач, аргумент_повідомлення);
      } інакше {
        вернути падіння(обчислювач, "Повідомлення має бути байтами або буфером");
      }

      ціль дані_відклику = виділити<ДаніВідкликуНаРезультатЗаписуВІнтернетЗвʼязку>(обчислювач);
      дані_відклику.обчислювач = обчислювач;
      дані_відклику.глобально_притриманий_предмет_звʼязку = притримати_глобально(обчислювач, предмет_я);
      дані_відклику.глобально_притриманий_предмет_даних = притримати_глобально(обчислювач, аргумент_повідомлення);
      якщо аргумент_відклик == пусто {
        дані_відклику.глобально_притриманий_предмет_відклику = пусто;
      } інакше {
        дані_відклику.глобально_притриманий_предмет_відклику = притримати_глобально(обчислювач, аргумент_відклик);
      }
      турбо_записати(турбо_глобальний_рушій(), оф, байти.розмір, байти.дані, відклик_на_результат_запису_в_інтернет_звʼязок, дані_відклику);

      вернути пусто;
    }

    дія створити_предмет_структури_Звʼязок(обчислювач: адреса<Обчислювач>): предмет_або_стан_падіння {
      ціль притримувач = покласти_притримувач(обчислювач);

      ціль кількість_параметрів: позитивне = 6;
      змінна параметри = виділити_памʼять<адреса<Предмет>>(обчислювач, кількість_параметрів);

      ціль параметр_оф = створити_параметр(обчислювач, назва(обчислювач, "оф"), пусто, пусто);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути параметр_оф;
      }
      параметри[0] = параметр_оф;
      притримати(обчислювач, притримувач, параметр_оф);

      ціль параметр_адреса = створити_параметр(обчислювач, назва(обчислювач, "адреса"), пусто, пусто);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути параметр_адреса;
      }
      параметри[1] = параметр_адреса;
      притримати(обчислювач, притримувач, параметр_адреса);

      ціль параметр_порт = створити_параметр(обчислювач, назва(обчислювач, "порт"), пусто, пусто);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути параметр_порт;
      }
      параметри[2] = параметр_порт;
      притримати(обчислювач, притримувач, параметр_порт);

      ціль параметр_обробник_підключення = створити_параметр(обчислювач, назва(обчислювач, "обробник_підключення"), пусто, пусто);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути параметр_обробник_підключення;
      }
      параметри[3] = параметр_обробник_підключення;
      притримати(обчислювач, притримувач, параметр_обробник_підключення);

      ціль параметр_обробник_відключення = створити_параметр(обчислювач, назва(обчислювач, "обробник_відключення"), пусто, пусто);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути параметр_обробник_відключення;
      }
      параметри[4] = параметр_обробник_відключення;
      притримати(обчислювач, притримувач, параметр_обробник_відключення);

      ціль параметр_обробник_повідомлення = створити_параметр(обчислювач, назва(обчислювач, "обробник_повідомлення"), пусто, пусто);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути параметр_обробник_повідомлення;
      }
      параметри[5] = параметр_обробник_повідомлення;
      притримати(обчислювач, притримувач, параметр_обробник_повідомлення);

      ціль предмет_структури_Звʼязок = створити_структуру(обчислювач, назва(обчислювач, "Звʼязок"), отримати_предмет_структури_предмет(обчислювач), кількість_параметрів, параметри);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_структури_Звʼязок;
      }

      ціль предмет_дії_метода_підключити = створити_рідну_дію(обчислювач, назва(обчислювач, т8"підключити"), 0, пусто, пусто, рідна_дія_метода_складеного_предмета_Звʼязок_підключити);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_дії_метода_підключити;
      }
      притримати(обчислювач, притримувач, предмет_дії_метода_підключити);
      змінна результат_запису_метода = предмет_записати_метод(обчислювач, предмет_структури_Звʼязок, назва(обчислювач, "підключити"), предмет_дії_метода_підключити, Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути результат_запису_метода;
      }

      ціль предмет_дії_метода_відключитись = створити_рідну_дію(обчислювач, назва(обчислювач, т8"відключитись"), 0, пусто, пусто, рідна_дія_метода_складеного_предмета_Звʼязок_відключитись);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_дії_метода_відключитись;
      }
      притримати(обчислювач, притримувач, предмет_дії_метода_відключитись);
      результат_запису_метода = предмет_записати_метод(обчислювач, предмет_структури_Звʼязок, назва(обчислювач, "відключитись"), предмет_дії_метода_відключитись, Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути результат_запису_метода;
      }

      ціль предмет_дії_метода_надіслати = створити_рідну_дію(обчислювач, назва(обчислювач, т8"надіслати"), 0, пусто, пусто, рідна_дія_метода_складеного_предмета_Звʼязок_надіслати);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_дії_метода_надіслати;
      }
      притримати(обчислювач, притримувач, предмет_дії_метода_надіслати);
      результат_запису_метода = предмет_записати_метод(обчислювач, предмет_структури_Звʼязок, назва(обчислювач, "надіслати"), предмет_дії_метода_надіслати, Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути результат_запису_метода;
      }

      забрати_притримувач(обчислювач);
      вернути предмет_структури_Звʼязок;
    }
  }
}

секція мавка {
  секція бібліотека {
    дія рідна_дія_модуля_інтернет_створити_обслуговувач(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<Предмет>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
      змінна знайдено_аргумент_адреса = ні;
      змінна аргумент_адреса: адреса<Предмет> = пусто;
      змінна знайдено_аргумент_порт = ні;
      змінна аргумент_порт: адреса<Предмет> = пусто;
      якщо іменовані_аргументи != пусто {
        знайдено_аргумент_адреса = знайти_іменований_аргумент(обчислювач, іменовані_аргументи, назва(обчислювач, "адреса"), аргумент_адреса::адреса);
        знайдено_аргумент_порт = знайти_іменований_аргумент(обчислювач, іменовані_аргументи, назва(обчислювач, "порт"), аргумент_порт::адреса);
      }
      якщо аргументи != пусто {
        якщо знайдено_аргумент_адреса == ні {
          якщо кількість_аргументів > 0 {
            знайдено_аргумент_адреса = так;
            аргумент_адреса = аргументи[0];
          }
        }
        якщо знайдено_аргумент_порт == ні {
          якщо кількість_аргументів > 1 {
            знайдено_аргумент_порт = так;
            аргумент_порт = аргументи[1];
          }
        }
      }
      ціль предмет_структури_Обслуговувач = предмет_отримати_властивість(обчислювач, предмет_я, назва(обчислювач, "Обслуговувач"), Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        вернути предмет_структури_Обслуговувач;
      }
      ціль кількість_аргументів_виконання: позитивне = 3;
      ціль аргументи_виконання = виділити_памʼять<адреса<Предмет>>(обчислювач, кількість_аргументів_виконання);
      аргументи_виконання[0] = пусто як адреса<Предмет>;
      аргументи_виконання[1] = аргумент_адреса;
      аргументи_виконання[2] = аргумент_порт;
      ціль результат = предмет_виконати(обчислювач, предмет_структури_Обслуговувач, пусто, кількість_аргументів_виконання, аргументи_виконання, пусто, Місцезнаходження { пусто, 0 });
      звільнити_памʼять(обчислювач, аргументи_виконання);
      вернути результат;
    }

    дія рідна_дія_модуля_інтернет_створити_звʼязок(обчислювач: адреса<Обчислювач>, предмет_дії: адреса<Предмет>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>, місцезнаходження: Місцезнаходження): предмет_або_стан_падіння {
      змінна знайдено_аргумент_адреса = ні;
      змінна аргумент_адреса: адреса<Предмет> = пусто;
      змінна знайдено_аргумент_порт = ні;
      змінна аргумент_порт: адреса<Предмет> = пусто;
      якщо іменовані_аргументи != пусто {
        знайдено_аргумент_адреса = знайти_іменований_аргумент(обчислювач, іменовані_аргументи, назва(обчислювач, "адреса"), аргумент_адреса::адреса);
        знайдено_аргумент_порт = знайти_іменований_аргумент(обчислювач, іменовані_аргументи, назва(обчислювач, "порт"), аргумент_порт::адреса);
      }
      якщо аргументи != пусто {
        якщо знайдено_аргумент_адреса == ні {
          якщо кількість_аргументів > 0 {
            знайдено_аргумент_адреса = так;
            аргумент_адреса = аргументи[0];
          }
        }
        якщо знайдено_аргумент_порт == ні {
          якщо кількість_аргументів > 1 {
            знайдено_аргумент_порт = так;
            аргумент_порт = аргументи[1];
          }
        }
      }
      ціль предмет_структури_Звʼязок = предмет_отримати_властивість(обчислювач, предмет_я, назва(обчислювач, "Звʼязок"), Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        вернути предмет_структури_Звʼязок;
      }
      ціль кількість_аргументів_виконання: позитивне = 3;
      ціль аргументи_виконання = виділити_памʼять<адреса<Предмет>>(обчислювач, кількість_аргументів_виконання);
      аргументи_виконання[0] = пусто як адреса<Предмет>;
      аргументи_виконання[1] = аргумент_адреса;
      аргументи_виконання[2] = аргумент_порт;
      ціль результат = предмет_виконати(обчислювач, предмет_структури_Звʼязок, пусто, кількість_аргументів_виконання, аргументи_виконання, пусто, Місцезнаходження { пусто, 0 });
      звільнити_памʼять(обчислювач, аргументи_виконання);
      вернути результат;
    }

    дія створити_дію_модуля_інтернет_створити_обслуговувач(обчислювач: адреса<Обчислювач>): предмет_або_стан_падіння {
      вернути створити_рідну_дію(обчислювач, назва(обчислювач, т8"створити_обслуговувач"), 0, пусто, пусто, рідна_дія_модуля_інтернет_створити_обслуговувач);
    }

    дія створити_дію_модуля_інтернет_створити_звʼязок(обчислювач: адреса<Обчислювач>): предмет_або_стан_падіння {
      вернути створити_рідну_дію(обчислювач, назва(обчислювач, т8"створити_звʼязок"), 0, пусто, пусто, рідна_дія_модуля_інтернет_створити_звʼязок);
    }

    дія створити_модуль_інтернет(обчислювач: адреса<Обчислювач>): предмет_або_стан_падіння {
      ціль притримувач = покласти_притримувач(обчислювач);

      ціль предмет_модуля = створити_модуль(обчислювач, назва(обчислювач, "інтернет"), 0, пусто);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_модуля;
      }
      притримати(обчислювач, притримувач, предмет_модуля);

      ціль предмет_дії_створити_обслуговувач = створити_дію_модуля_інтернет_створити_обслуговувач(обчислювач);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_дії_створити_обслуговувач;
      }
      притримати(обчислювач, притримувач, предмет_дії_створити_обслуговувач);
      змінна результат_зміни_властивості = предмет_змінити_властивість(обчислювач, предмет_модуля, назва(обчислювач, "створити_обслуговувач"), предмет_дії_створити_обслуговувач, Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути результат_зміни_властивості;
      }

      ціль предмет_дії_створити_звʼязок = створити_дію_модуля_інтернет_створити_звʼязок(обчислювач);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_дії_створити_звʼязок;
      }
      притримати(обчислювач, притримувач, предмет_дії_створити_звʼязок);
      результат_зміни_властивості = предмет_змінити_властивість(обчислювач, предмет_модуля, назва(обчислювач, "створити_звʼязок"), предмет_дії_створити_звʼязок, Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути результат_зміни_властивості;
      }

      ціль предмет_структури_Обслуговувач = створити_предмет_структури_Обслуговувач(обчислювач);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_структури_Обслуговувач;
      }
      притримати(обчислювач, притримувач, предмет_структури_Обслуговувач);
      результат_зміни_властивості = предмет_змінити_властивість(обчислювач, предмет_модуля, назва(обчислювач, "Обслуговувач"), предмет_структури_Обслуговувач, Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути результат_зміни_властивості;
      }

      ціль предмет_структури_Звʼязок = створити_предмет_структури_Звʼязок(обчислювач);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути предмет_структури_Звʼязок;
      }
      притримати(обчислювач, притримувач, предмет_структури_Звʼязок);
      результат_зміни_властивості = предмет_змінити_властивість(обчислювач, предмет_модуля, назва(обчислювач, "Звʼязок"), предмет_структури_Звʼязок, Місцезнаходження { пусто, 0 });
      якщо перевірити_чи_стан_падіння(обчислювач) {
        забрати_притримувач(обчислювач);
        вернути результат_зміни_властивості;
      }

      забрати_притримувач(обчислювач);
      вернути предмет_модуля;
    }

    зовнішня дія взяти_модуль_біб_інтернет(обчислювач: адреса<Обчислювач>): предмет_або_стан_падіння {
      ціль М = обчислювач;
      змінна результат = створити_текст(обчислювач, "мавка:бібліотека/інтернет/інтернет.ц");
      якщо перевірити_чи_стан_падіння(обчислювач) {
        вернути результат;
      }
      ціль предмет_шляху = результат;
      змінна взятий_предмет: адреса<МаМа::Предмет> = пусто;
      якщо МаМа::отримати_взятий_предмет(М, предмет_шляху як адреса<МаМа::Предмет>, взятий_предмет::адреса) {
        вернути взятий_предмет як адреса<Предмет>;
      }
      результат = створити_модуль_інтернет(обчислювач);
      якщо перевірити_чи_стан_падіння(обчислювач) {
        вернути результат;
      }
      МаМа::покласти_взятий_предмет(М, предмет_шляху як адреса<МаМа::Предмет>, результат як адреса<МаМа::Предмет>);
      вернути результат;
    }
  }
}