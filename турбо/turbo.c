#include <arpa/inet.h>
#include <dlfcn.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <math.h>
#include <memory.h>
#include <netdb.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/epoll.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

#define п8 uint8_t
#define п16 uint16_t
#define п32 uint32_t
#define п64 uint64_t
#define ц8 int8_t
#define ц16 int16_t
#define ц32 int32_t
#define ц64 int64_t
#define д32 float
#define д64 double
#define логічне uint8_t
#define позитивне п64
#define ціле ц64
#define дійсне д64
#define ніщо void
#define невідома_адреса void*
#define невідома_памʼять void*
#define памʼять_п8 п8*
#define адреса_памʼять_п8 п8**
#define памʼять_памʼять_п8 п8**
#define адреса_позитивне позитивне*
typedef struct т8 {
  позитивне розмір;
  памʼять_п8 дані;
} т8;
typedef struct ю8 {
  позитивне розмір;
  памʼять_п8 дані;
} ю8;
#define памʼять_т8 т8*
#define памʼять_ю8 ю8*

static char* перетворити_ю8_в_chars(ю8 value) {
  char* copy = (char*)malloc(value.розмір + 1);
  memcpy(copy, value.дані, value.розмір);
  copy[value.розмір] = 0;
  return copy;
}

void надрукувати_ю8(ю8 значення) {
  позитивне п = 0;
  while (п < значення.розмір) {
    putchar(значення.дані[п]);
    п += 1;
  }
  putchar(10);
}

static int set_non_blocking(int fd) {
  int flags = fcntl(fd, F_GETFL, 0);
  if (flags == -1) {
    return -1;
  }
  return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
}

static int epoll_ctl_add(int epfd, int fd, uint32_t events) {
  struct epoll_event ev = {0};
  ev.events = events;
  ev.data.fd = fd;
  return epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &ev);
}

static int epoll_ctl_del(int epfd, int fd) {
  return epoll_ctl(epfd, EPOLL_CTL_DEL, fd, NULL);
}

static int epoll_ctl_mod(int epfd, int fd, uint32_t events) {
  struct epoll_event ev = {0};
  ev.events = events;
  ev.data.fd = fd;
  return epoll_ctl(epfd, EPOLL_CTL_MOD, fd, &ev);
}

typedef struct ТурбоРушій ТурбоРушій;
typedef struct ТурбоДаніЗапису ТурбоДаніЗапису;
typedef struct ТурбоСлухач ТурбоСлухач;
typedef struct ТурбоПомилка ТурбоПомилка;
typedef struct ТурбоВихідІнтернетОбслуговувача ТурбоВихідІнтернетОбслуговувача;
typedef struct ТурбоВихідІнтернетКлієнта ТурбоВихідІнтернетКлієнта;

typedef void (*ТурбоВідкликНаДоступністьЧитання)(
    ТурбоРушій* рушій,
    ц32 ідентифікатор,
    невідома_адреса аргумент_відклику);
typedef void (*ТурбоВідкликНаДоступністьЗапису)(
    ТурбоРушій* рушій,
    ц32 ідентифікатор,
    невідома_адреса аргумент_відклику);
typedef void (*ТурбоВідкликПісляВидалення)(ТурбоРушій* рушій,
                                           ц32 ідентифікатор,
                                           невідома_адреса аргумент_відклику);
typedef void (*ТурбоВідкликНаРезультатЗапису)(ТурбоРушій* рушій,
                                              ц32 ідентифікатор,
                                              невідома_адреса аргумент_відклику,
                                              позитивне розмір,
                                              памʼять_п8 дані,
                                              позитивне розмір_записаного,
                                              логічне успіх,
                                              ТурбоПомилка помилка);

typedef struct ТурбоРушій {
  ц64 ідентифікатор;
  позитивне кількість_слухачів;
  ТурбоСлухач* перший_слухач;
  ТурбоСлухач* останній_слухач;
} ТурбоРушій;

typedef struct ТурбоДаніЗапису {
  ТурбоДаніЗапису* наступні;
  памʼять_п8 дані;
  позитивне розмір;
  позитивне розмір_записаного;
  ТурбоВідкликНаРезультатЗапису відклик_на_результат;
  невідома_адреса аргумент_відклику;
} ТурбоДаніЗапису;

typedef struct ТурбоСлухач {
  ТурбоСлухач* попередній;
  ТурбоСлухач* наступний;
  ц64 ідентифікатор;
  ТурбоВідкликНаДоступністьЧитання відклик_на_доступність_читання;
  ТурбоВідкликНаДоступністьЗапису відклик_на_доступність_запису;
  ТурбоВідкликПісляВидалення відклик_після_видалення;
  void* аргумент_відклику;
  ТурбоДаніЗапису* перші_дані_запису;
  ТурбоДаніЗапису* останні_дані_запису;
  логічне закрито;
} ТурбоСлухач;

typedef struct ТурбоПомилка {
  ц64 код;
  невідома_адреса дані;
} ТурбоПомилка;

typedef struct ТурбоВихідІнтернетОбслуговувача {
  ц64 ідентифікатор;
  ю8 іа;
  п64 порт;
} ТурбоВихідІнтернетОбслуговувача;

typedef struct ТурбоВихідІнтернетКлієнта {
  ц64 ідентифікатор;
  ю8 іа;
  п64 порт;
} ТурбоВихідІнтернетКлієнта;

ТурбоРушій* глобальний_рушій = NULL;

ТурбоРушій* турбо_рушій() {
  if (глобальний_рушій == NULL) {
    глобальний_рушій = (ТурбоРушій*)malloc(sizeof(ТурбоРушій));
    глобальний_рушій->ідентифікатор = epoll_create1(0);
    глобальний_рушій->кількість_слухачів = 0;
    глобальний_рушій->перший_слухач = NULL;
    глобальний_рушій->останній_слухач = NULL;
  }
  return глобальний_рушій;
}

ТурбоСлухач* турбо_знайти_слухач(ТурбоРушій* рушій, ц32 ідентифікатор) {
  ТурбоСлухач* слухач = рушій->перший_слухач;

  while (слухач != NULL) {
    if (слухач->ідентифікатор == ідентифікатор) {
      return слухач;
    }

    слухач = слухач->наступний;
  }

  return NULL;
}

логічне турбо_створити_слухач(
    ТурбоРушій* рушій,
    ц32 ідентифікатор,
    п32 події,
    ТурбоВідкликНаДоступністьЧитання відклик_на_доступність_читання,
    ТурбоВідкликНаДоступністьЗапису відклик_на_доступність_запису,
    ТурбоВідкликПісляВидалення відклик_після_видалення,
    void* аргумент_відклику,
    ТурбоПомилка* вихід_помилки) {
  int epoll_add_result =
      epoll_ctl_add(рушій->ідентифікатор, ідентифікатор, події | EPOLLET);
  if (epoll_add_result < 0) {
    вихід_помилки->код = epoll_add_result;
    вихід_помилки->дані = NULL;
    return false;
  }

  ТурбоСлухач* слухач = (ТурбоСлухач*)malloc(sizeof(ТурбоСлухач));
  слухач->попередній = NULL;
  слухач->наступний = NULL;
  слухач->ідентифікатор = ідентифікатор;
  слухач->відклик_на_доступність_читання = відклик_на_доступність_читання;
  слухач->відклик_на_доступність_запису = відклик_на_доступність_запису;
  слухач->відклик_після_видалення = відклик_після_видалення;
  слухач->аргумент_відклику = аргумент_відклику;
  слухач->перші_дані_запису = NULL;
  слухач->останні_дані_запису = NULL;
  слухач->закрито = false;

  if (рушій->перший_слухач == NULL) {
    рушій->перший_слухач = слухач;
  }
  if (рушій->останній_слухач == NULL) {
    рушій->останній_слухач = слухач;
  } else {
    слухач->попередній = рушій->останній_слухач;
    рушій->останній_слухач->наступний = слухач;
    рушій->останній_слухач = слухач;
  }

  рушій->кількість_слухачів++;

  return true;
}

логічне турбо_оновити_події_слухача(ТурбоРушій* рушій,
                                    ц32 ідентифікатор,
                                    п32 події,
                                    ТурбоПомилка* вихід_помилки) {
  int epoll_mod_result =
      epoll_ctl_mod(рушій->ідентифікатор, ідентифікатор, події | EPOLLET);
  if (epoll_mod_result < 0) {
    вихід_помилки->код = epoll_mod_result;
    вихід_помилки->дані = NULL;
    return false;
  }
  return true;
}

логічне турбо_видалити_слухач(ТурбоРушій* рушій,
                              ц32 ідентифікатор,
                              ТурбоПомилка* вихід_помилки) {
  ТурбоСлухач* слухач = турбо_знайти_слухач(рушій, ідентифікатор);
  if (слухач == NULL) {
    вихід_помилки->код = 0;
    вихід_помилки->дані = NULL;
    return false;
  }

  int epoll_del_result =
      epoll_ctl_del(рушій->ідентифікатор, слухач->ідентифікатор);
  if (epoll_del_result == -1) {
    вихід_помилки->код = errno;
    вихід_помилки->дані = NULL;
    return false;
  }

  ТурбоСлухач* попередній = слухач->попередній;
  ТурбоСлухач* наступний = слухач->наступний;

  if (попередній != NULL) {
    попередній->наступний = наступний;
  }
  if (наступний != NULL) {
    наступний->попередній = попередній;
  }

  if (рушій->перший_слухач == слухач) {
    рушій->перший_слухач = наступний;
  }
  if (рушій->останній_слухач == слухач) {
    рушій->останній_слухач = попередній;
  }

  while (слухач->перші_дані_запису) {
    ТурбоДаніЗапису* дані_запису = слухач->перші_дані_запису;

    слухач->перші_дані_запису = дані_запису->наступні;

    if (слухач->останні_дані_запису == дані_запису) {
      слухач->останні_дані_запису = NULL;
    }

    ТурбоПомилка турбо_помилка = {0};
    турбо_помилка.код = 0;
    турбо_помилка.дані = NULL;

    дані_запису->відклик_на_результат(
        рушій, ідентифікатор, дані_запису->аргумент_відклику,
        дані_запису->розмір, дані_запису->дані, дані_запису->розмір_записаного,
        false, турбо_помилка);

    free(дані_запису);
  }

  невідома_адреса аргумент_відклику = слухач->аргумент_відклику;

  free(слухач);

  рушій->кількість_слухачів--;

  слухач->відклик_після_видалення(рушій, ідентифікатор, аргумент_відклику);

  return true;
}

логічне турбо_закрити_слухач(ТурбоРушій* рушій,
                             ц32 ідентифікатор,
                             ТурбоПомилка* вихід_помилки) {
  ТурбоСлухач* слухач = турбо_знайти_слухач(рушій, ідентифікатор);
  if (слухач == NULL) {
    вихід_помилки->код = 0;
    вихід_помилки->дані = NULL;
    return false;
  }

  слухач->закрито = true;

  if (слухач->перші_дані_запису == NULL) {
    return турбо_видалити_слухач(рушій, ідентифікатор, вихід_помилки);
  }

  return true;
}

логічне турбо_прочитати(ТурбоРушій* рушій,
                        ц32 ідентифікатор,
                        позитивне розмір,
                        памʼять_п8 дані,
                        позитивне* вихід_розміру_прочитаного,
                        логічне* вихід_спробувати_пізніше,
                        ТурбоПомилка* вихід_помилки) {
  ssize_t read_result = read(ідентифікатор, дані, розмір);

  if (read_result == -1) {
    if (errno == EAGAIN || errno == EWOULDBLOCK) {
      *вихід_розміру_прочитаного = 0;
      *вихід_спробувати_пізніше = true;
      return false;
    }

    вихід_помилки->код = errno;
    вихід_помилки->дані = NULL;
    return false;
  } else if (read_result == 0) {
    *вихід_розміру_прочитаного = 0;
    *вихід_спробувати_пізніше = false;
    return false;
  }

  *вихід_розміру_прочитаного = read_result;
  *вихід_спробувати_пізніше = false;
  return true;
}

логічне турбо_додати_запис_в_чергу(
    ТурбоРушій* рушій,
    ц32 ідентифікатор,
    памʼять_п8 дані,
    позитивне розмір,
    позитивне розмір_записаного,
    ТурбоВідкликНаРезультатЗапису відклик_на_результат,
    невідома_адреса аргумент_відклику,
    ТурбоПомилка* вихід_помилки) {
  ТурбоСлухач* слухач = турбо_знайти_слухач(рушій, ідентифікатор);
  if (слухач == NULL) {
    вихід_помилки->код = 0;
    вихід_помилки->дані = NULL;
    return false;
  }

  int epoll_mod_result = epoll_ctl_mod(рушій->ідентифікатор, ідентифікатор,
                                       EPOLLIN | EPOLLOUT | EPOLLET);
  if (epoll_mod_result < 0) {
    вихід_помилки->код = errno;
    вихід_помилки->дані = NULL;
    return false;
  }

  ТурбоДаніЗапису* дані_запису =
      (ТурбоДаніЗапису*)malloc(sizeof(ТурбоДаніЗапису));
  дані_запису->наступні = NULL;
  дані_запису->дані = дані;
  дані_запису->розмір = розмір;
  дані_запису->розмір_записаного = розмір_записаного;
  дані_запису->відклик_на_результат = відклик_на_результат;
  дані_запису->аргумент_відклику = аргумент_відклику;

  if (слухач->перші_дані_запису == NULL) {
    слухач->перші_дані_запису = дані_запису;
  }
  if (слухач->останні_дані_запису == NULL) {
    слухач->останні_дані_запису = дані_запису;
  } else {
    слухач->останні_дані_запису->наступні = дані_запису;
    слухач->останні_дані_запису = дані_запису;
  }

  return true;
}

void турбо_обробити_чергу_запису(ТурбоРушій* рушій, ТурбоСлухач* слухач) {
  while (слухач->перші_дані_запису != NULL) {
    ТурбоДаніЗапису* дані_запису = слухач->перші_дані_запису;

    while (дані_запису->розмір_записаного < дані_запису->розмір) {
      ssize_t written =
          write(слухач->ідентифікатор,
                дані_запису->дані + дані_запису->розмір_записаного,
                дані_запису->розмір - дані_запису->розмір_записаного);

      if (written < 0) {
        if (errno == EINTR) {
          continue;
        }

        if (errno == EAGAIN || errno == EWOULDBLOCK) {
          return;
        }

        return;
      }

      дані_запису->розмір_записаного += written;
    }

    слухач->перші_дані_запису = дані_запису->наступні;

    if (слухач->останні_дані_запису == дані_запису) {
      слухач->останні_дані_запису = NULL;
    }

    ТурбоПомилка турбо_помилка = {0};
    дані_запису->відклик_на_результат(
        рушій, слухач->ідентифікатор, дані_запису->аргумент_відклику,
        дані_запису->розмір, дані_запису->дані, дані_запису->розмір_записаного,
        true, турбо_помилка);

    free(дані_запису);
  }

  if (слухач->закрито) {
    ТурбоПомилка турбо_помилка = {0};

    логічне результат_видалення_слухача =
        турбо_видалити_слухач(рушій, слухач->ідентифікатор, &турбо_помилка);
    if (!результат_видалення_слухача) {
      printf("failed to турбо_видалити_слухач\n");
    }
  }
}

void турбо_записати(ТурбоРушій* рушій,
                    ц32 ідентифікатор,
                    позитивне розмір,
                    памʼять_п8 дані,
                    ТурбоВідкликНаРезультатЗапису відклик_на_результат,
                    невідома_адреса аргумент_відклику) {
  ТурбоПомилка турбо_помилка = {0};

  позитивне розмір_записаного = 0;

  while (розмір_записаного < розмір) {
    ssize_t written = write(ідентифікатор, дані + розмір_записаного,
                            розмір - розмір_записаного);

    if (written < 0) {
      if (errno == EINTR) {
        continue;
      }

      if (errno == EAGAIN || errno == EWOULDBLOCK) {
        логічне результат_додавання_в_чергу = турбо_додати_запис_в_чергу(
            рушій, ідентифікатор, (памʼять_п8)дані, розмір, розмір_записаного,
            відклик_на_результат, аргумент_відклику, &турбо_помилка);
        if (!результат_додавання_в_чергу) {
          відклик_на_результат(рушій, ідентифікатор, аргумент_відклику, розмір,
                               дані, розмір_записаного, false, турбо_помилка);
        }

        return;
      }

      турбо_помилка.код = errno;
      турбо_помилка.дані = NULL;
      відклик_на_результат(рушій, ідентифікатор, аргумент_відклику, розмір,
                           дані, розмір_записаного, false, турбо_помилка);
      return;
    }

    розмір_записаного += written;
  }

  відклик_на_результат(рушій, ідентифікатор, аргумент_відклику, розмір, дані,
                       розмір_записаного, true, турбо_помилка);
}

логічне турбо_створити_інтернет_обслуговувач(
    ю8 іа,
    п16 порт,
    ТурбоВихідІнтернетОбслуговувача* вихід_інтернет_обслуговувача,
    ТурбоПомилка* вихід_помилки) {
  const char* addr_str = перетворити_ю8_в_chars(іа);

  struct sockaddr_in addr = {0};
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = inet_addr(addr_str);
  addr.sin_port = htons(порт);

  free((void*)addr_str);

  int sockfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sockfd < 0) {
    вихід_помилки->код = errno;
    вихід_помилки->дані = NULL;
    return false;
  }

  int optval = 1;
  int setsockopt_result =
      setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));
  if (setsockopt_result < 0) {
    вихід_помилки->код = errno;
    вихід_помилки->дані = NULL;
    return false;
  }

  int bind_result =
      bind(sockfd, (struct sockaddr*)&addr, sizeof(struct sockaddr_in));
  if (bind_result < 0) {
    вихід_помилки->код = errno;
    вихід_помилки->дані = NULL;
    return false;
  }

  if (set_non_blocking(sockfd) < 0) {
    вихід_помилки->код = errno;
    вихід_помилки->дані = NULL;
    return false;
  }

  if (listen(sockfd, 128) < 0) {
    вихід_помилки->код = errno;
    вихід_помилки->дані = NULL;
    return false;
  }

  вихід_інтернет_обслуговувача->ідентифікатор = sockfd;
  вихід_інтернет_обслуговувача->іа = іа;
  вихід_інтернет_обслуговувача->порт = порт;

  return true;
}

логічне турбо_закрити_інтернет_обслуговувач(
    ц32 ідентифікатор_інтернет_обслуговувача,
    ТурбоПомилка* вихід_помилки) {
  int close_result = close(ідентифікатор_інтернет_обслуговувача);
  if (close_result == -1) {
    вихід_помилки->код = errno;
    вихід_помилки->дані = NULL;
    return false;
  }

  return true;
}

логічне турбо_прийняти_інтернет_клієнта(
    ц32 ідентифікатор_інтернет_обслуговувача,
    ТурбоВихідІнтернетКлієнта* вихід_інтернет_клієнта,
    ТурбоПомилка* вихід_помилки) {
  struct sockaddr_in cli_addr = {0};
  socklen_t addr_len = {0};

  int conn_sock = accept((int)ідентифікатор_інтернет_обслуговувача,
                         (struct sockaddr*)&cli_addr, &addr_len);
  if (conn_sock == -1) {
    вихід_помилки->код = errno;
    вихід_помилки->дані = NULL;
    return false;
  }

  if (set_non_blocking(conn_sock) == -1) {
    вихід_помилки->код = errno;
    вихід_помилки->дані = NULL;
    return false;
  }

  ю8 іа = {0};
  п16 порт = 0;

  вихід_інтернет_клієнта->ідентифікатор = conn_sock;
  вихід_інтернет_клієнта->іа = іа;
  вихід_інтернет_клієнта->порт = порт;

  return true;
}

логічне турбо_закрити_інтернет_клієнт(ц32 ідентифікатор_інтернет_клієнта,
                                      ТурбоПомилка* вихід_помилки) {
  int close_result = close(ідентифікатор_інтернет_клієнта);
  if (close_result == -1) {
    вихід_помилки->код = errno;
    вихід_помилки->дані = NULL;
    return false;
  }

  return true;
}

#define MAX_EVENTS 64

логічне турбо_запустити_рушій(ТурбоРушій* рушій, ТурбоПомилка* вихід_помилки) {
  struct epoll_event events[MAX_EVENTS];

  while (true) {
    if (рушій->кількість_слухачів == 0) {
      return true;
    }

    int epoll_wait_result =
        epoll_wait(рушій->ідентифікатор, events, MAX_EVENTS, -1);
    if (epoll_wait_result < 0) {
      вихід_помилки->код = errno;
      вихід_помилки->дані = NULL;
      return false;
    }

    for (int i = 0; i < epoll_wait_result; i++) {
      ТурбоСлухач* слухач = турбо_знайти_слухач(рушій, events[i].data.fd);

      if (слухач != NULL) {
        uint32_t event = events[i].events;

        if (event & EPOLLOUT) {
          if (слухач->відклик_на_доступність_запису != NULL) {
            слухач->відклик_на_доступність_запису(рушій, слухач->ідентифікатор,
                                                  слухач->аргумент_відклику);
          }

          турбо_обробити_чергу_запису(рушій, слухач);

          if (epoll_ctl_mod(рушій->ідентифікатор, слухач->ідентифікатор,
                            EPOLLIN | EPOLLET) == -1) {
            вихід_помилки->код = errno;
            вихід_помилки->дані = NULL;
            return false;
          }
        }

        if (event & EPOLLIN) {
          слухач->відклик_на_доступність_читання(рушій, слухач->ідентифікатор,
                                                 слухач->аргумент_відклику);
        }
      }
    }
  }

  return true;
}

невідома_памʼять турбо_виділити_сиру_памʼять(позитивне розмір) {
  return malloc(розмір);
}

невідома_памʼять турбо_перевиділити_сиру_памʼять(невідома_памʼять значення,
                                                 позитивне новий_розмір) {
  return realloc(значення, новий_розмір);
}

void турбо_звільнити_сиру_памʼять(невідома_памʼять значення) {
  free(значення);
}