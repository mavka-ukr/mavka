взяти визначення ./Виділяч;
взяти визначення ./Друк;

секція біб {
  структура ЕлементРеєстру<К, З>;
  структура Реєстр<К, З>;

  структура ЕлементРеєстру<К, З> {
    ключ: К;
    значення: З;
    наступний: адреса<ЕлементРеєстру<К, З>>;
  }

  синонім ДіяЗмішуванняКлючаРеєстру<К, З> = (ключ: К, аргумент: невідома_адреса) -> позитивне;
  синонім ДіяПеревіркиКлючаРеєстру<К, З> = (а: К, б: К, аргумент: невідома_адреса) -> логічне;
  синонім ДіяПередЗаміноюЕлементаРеєстру<К, З> = (ак: К, аз: З, бк: адреса<К>, бз: адреса<З>, аргумент: невідома_адреса) -> ніщо;
  синонім ДіяПередВидаленнямЕлементаРеєстру<К, З> = (ключ: К, значення: З, аргумент: невідома_адреса) -> ніщо;

  структура Реєстр<К, З> {
    розмір: позитивне;
    дані: памʼять<адреса<ЕлементРеєстру<К, З>>>;
    вмісткість: позитивне;
    виділяч: адреса<Виділяч>;
    аргумент: невідома_адреса;
    дія_змішування: ДіяЗмішуванняКлючаРеєстру<К, З>;
    дія_перевірки: ДіяПеревіркиКлючаРеєстру<К, З>;
    дія_перед_заміною: ДіяПередЗаміноюЕлементаРеєстру<К, З>;
    дія_перед_видаленням: ДіяПередВидаленнямЕлементаРеєстру<К, З>;
  }

  дія виділити_реєстр<К, З>(виділяч: адреса<Виділяч>,
                            початкова_вмісткість: позитивне,
                            аргумент: невідома_адреса,
                            дія_змішування: ДіяЗмішуванняКлючаРеєстру<К, З>,
                            дія_перевірки: ДіяПеревіркиКлючаРеєстру<К, З>,
                            дія_перед_заміною: ДіяПередЗаміноюЕлементаРеєстру<К, З>,
                            дія_перед_видаленням: ДіяПередВидаленнямЕлементаРеєстру<К, З>): адреса<Реєстр<К, З>> {
    змінна реєстр = виділити<Реєстр<К, З>>(виділяч);

    реєстр.розмір = 0;

    якщо початкова_вмісткість > 0 {
      реєстр.дані = виділити_памʼять<адреса<ЕлементРеєстру<К, З>>>(виділяч, початкова_вмісткість);
    } інакше {
      реєстр.дані = пусто;
    }

    реєстр.вмісткість = початкова_вмісткість;
    реєстр.виділяч = виділяч;
    реєстр.аргумент = аргумент;
    реєстр.дія_змішування = дія_змішування;
    реєстр.дія_перевірки = дія_перевірки;
    реєстр.дія_перед_заміною = дія_перед_заміною;
    реєстр.дія_перед_видаленням = дія_перед_видаленням;

    змінна п: позитивне = 0;

    поки п < реєстр.вмісткість {
      реєстр.дані[п] = пусто як адреса<ЕлементРеєстру<К, З>>;
      п += 1;
    }

    вернути реєстр;
  }

  дія розширити_реєстр<К, З>(реєстр: адреса<Реєстр<К, З>>, нова_вмісткість: позитивне) {
    якщо нова_вмісткість == 0 {
      нова_вмісткість = реєстр.вмісткість * 2;
    } інакше якщо нова_вмісткість <= реєстр.вмісткість {
      вернути;
    }

    змінна нові_дані = виділити_памʼять<адреса<ЕлементРеєстру<К, З>>>(реєстр.виділяч, нова_вмісткість);

    змінна п: позитивне = 0;

    поки п < нова_вмісткість {
      нові_дані[п] = пусто як адреса<ЕлементРеєстру<К, З>>;

      п += 1;
    }

    п = 0;

    поки п < реєстр.вмісткість {
      змінна поточний_елемент = реєстр.дані[п];

      поки поточний_елемент != пусто {
        змінна нова_позиція = реєстр.дія_змішування(поточний_елемент.ключ, реєстр.аргумент) % нова_вмісткість;

        змінна наступний = поточний_елемент.наступний;

        поточний_елемент.наступний = нові_дані[нова_позиція];

        нові_дані[нова_позиція] = поточний_елемент;

        поточний_елемент = наступний;
      }

      п += 1;
    }

    звільнити_памʼять(реєстр.виділяч, реєстр.дані);

    реєстр.дані = нові_дані;
    реєстр.вмісткість = нова_вмісткість;
  }

  дія змінити_в_реєстрі<К, З>(реєстр: адреса<Реєстр<К, З>>, ключ: К, значення: З) {
    якщо реєстр.вмісткість == 0 {
      реєстр.дані = виділити_памʼять<адреса<ЕлементРеєстру<К, З>>>(реєстр.виділяч, 1);
      реєстр.вмісткість = 1;
      реєстр.дані[0] = пусто як адреса<ЕлементРеєстру<К, З>>;
    } інакше якщо ((д64(реєстр.розмір) / д64(реєстр.вмісткість)) > 0.7) {
       розширити_реєстр<К, З>(реєстр, 0);
    }

    змінна позиція = реєстр.дія_змішування(ключ, реєстр.аргумент) % реєстр.вмісткість;

    змінна елемент = реєстр.дані[позиція];

    поки елемент != пусто {
      якщо реєстр.дія_перевірки(елемент.ключ, ключ, реєстр.аргумент) {
        якщо реєстр.дія_перед_заміною != пусто {
          реєстр.дія_перед_заміною(елемент.ключ, елемент.значення, ключ::адреса, значення::адреса, реєстр.аргумент);
        }

        елемент.ключ = ключ;
        елемент.значення = значення;

        вернути;
      }

      елемент = елемент.наступний;
    }

    змінна новий_елемент = виділити<ЕлементРеєстру<К, З>>(реєстр.виділяч);
    новий_елемент.ключ = ключ;
    новий_елемент.значення = значення;
    новий_елемент.наступний = реєстр.дані[позиція];
    реєстр.дані[позиція] = новий_елемент;

    реєстр.розмір += 1;
  }

  дія знайти_в_реєстрі<К, З>(реєстр: адреса<Реєстр<К, З>>, ключ: К, вихід: адреса<З>): логічне {
    якщо реєстр.вмісткість == 0 {
      вернути ні;
    }

    змінна позиція = реєстр.дія_змішування(ключ, реєстр.аргумент) % реєстр.вмісткість;

    змінна елемент = реєстр.дані[позиція];

    поки елемент != пусто {
      якщо реєстр.дія_перевірки(елемент.ключ, ключ, реєстр.аргумент) {
        вихід::вміст = елемент.значення;
        вернути так;
      }

      елемент = елемент.наступний;
    }

    вернути ні;
  }

  дія видалити_з_реєстру<К, З>(реєстр: адреса<Реєстр<К, З>>, ключ: К) {
    змінна позиція = реєстр.дія_змішування(ключ, реєстр.аргумент) % реєстр.вмісткість;

    змінна елемент = реєстр.дані[позиція];
    змінна попередній: адреса<ЕлементРеєстру<К, З>> = пусто;

    поки елемент != пусто {
      якщо реєстр.дія_перевірки(елемент.ключ, ключ, реєстр.аргумент) {
        якщо реєстр.дія_перед_видаленням != пусто {
          реєстр.дія_перед_видаленням(елемент.ключ, елемент.значення, реєстр.аргумент);
        }

        якщо попередній == пусто {
          реєстр.дані[позиція] = елемент.наступний;
        } інакше {
          попередній.наступний = елемент.наступний;
        }

        звільнити(реєстр.виділяч, елемент);

        реєстр.розмір -= 1;

        вернути;
      }

      попередній = елемент;
      елемент = елемент.наступний;
    }
  }

  дія перебрати_реєстр<К, З>(реєстр: адреса<Реєстр<К, З>>, дія_перебору: (реєстр: адреса<Реєстр<К, З>>, аргумент: невідома_адреса, ключ: К, значення: З) -> логічне, аргумент: невідома_адреса): логічне {
    змінна п: позитивне = 0;

    поки п < реєстр.вмісткість {
      змінна елемент = реєстр.дані[п];

      поки елемент != пусто {
        якщо дія_перебору(реєстр, аргумент, елемент.ключ, елемент.значення) == ні {
          вернути ні;
        }

        елемент = елемент.наступний;
      }

      п += 1;
    }

    вернути так;
  }

  дія звільнити_реєстр<К, З>(реєстр: адреса<Реєстр<К, З>>) {
    змінна п: позитивне = 0;

    поки п < реєстр.вмісткість {
      змінна елемент = реєстр.дані[п];

      поки елемент != пусто {
        якщо реєстр.дія_перед_видаленням != пусто {
          реєстр.дія_перед_видаленням(елемент.ключ, елемент.значення, реєстр.аргумент);
        }

        змінна наступний = елемент.наступний;

        звільнити(реєстр.виділяч, елемент);

        елемент = наступний;
      }

      п += 1;
    }

    звільнити_памʼять(реєстр.виділяч, реєстр.дані);
    звільнити(реєстр.виділяч, реєстр);
  }
}