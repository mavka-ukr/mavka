взяти визначення ./Виділяч;

секція біб {
  структура ЕлементРеєстру<К, З>;
  структура Реєстр<К, З>;

  структура ЕлементРеєстру<К, З> {
    ключ: К;
    значення: З;
    наступний: адреса<ЕлементРеєстру<К, З>>;
  }

  синонім ДіяЗмішуванняКлючаРеєстру<К, З> = (ключ: К, аргумент: невідома_адреса) -> позитивне;
  синонім ДіяПеревіркиКлючаРеєстру<К, З> = (а: К, б: К, аргумент: невідома_адреса) -> логічне;
  синонім ДіяПередЗаміноюЕлементаРеєстру<К, З> = (ак: К, аз: З, бк: К, бз: З, аргумент: невідома_адреса) -> ніщо;
  синонім ДіяПередВидаленнямЕлементаРеєстру<К, З> = (ключ: К, значення: З, аргумент: невідома_адреса) -> ніщо;

  структура Реєстр<К, З> {
    розмір: позитивне;
    дані: памʼять<адреса<ЕлементРеєстру<К, З>>>;
    вмісткість: позитивне;
    виділяч: адреса<Виділяч>;
    аргумент: невідома_адреса;
    дія_змішування: ДіяЗмішуванняКлючаРеєстру<К, З>;
    дія_перевірки: ДіяПеревіркиКлючаРеєстру<К, З>;
    дія_перед_заміною: ДіяПередЗаміноюЕлементаРеєстру<К, З>;
    дія_перед_видаленням: ДіяПередВидаленнямЕлементаРеєстру<К, З>;
  }

  дія виділити_реєстр<К, З>(виділяч: адреса<Виділяч>,
                            початкова_вмісткість: позитивне,
                            аргумент: невідома_адреса,
                            дія_змішування: ДіяЗмішуванняКлючаРеєстру<К, З>,
                            дія_перевірки: ДіяПеревіркиКлючаРеєстру<К, З>,
                            дія_перед_заміною: ДіяПередЗаміноюЕлементаРеєстру<К, З>,
                            дія_перед_видаленням: ДіяПередВидаленнямЕлементаРеєстру<К, З>): адреса<Реєстр<К, З>> {
    змінна реєстр = виділити<Реєстр<К, З>>(виділяч);
    реєстр.розмір = 0;
    якщо початкова_вмісткість > 0 {
      реєстр.дані = виділити_памʼять<адреса<ЕлементРеєстру<К, З>>>(виділяч, початкова_вмісткість);
    } інакше {
      реєстр.дані = пусто;
    }
    реєстр.вмісткість = початкова_вмісткість;
    реєстр.виділяч = виділяч;
    реєстр.аргумент = аргумент;
    реєстр.дія_змішування = дія_змішування;
    реєстр.дія_перевірки = дія_перевірки;
    реєстр.дія_перед_заміною = дія_перед_заміною;
    реєстр.дія_перед_видаленням = дія_перед_видаленням;
    змінна п: позитивне = 0;
    поки п < реєстр.вмісткість {
      реєстр.дані[п] = пусто як адреса<ЕлементРеєстру<К, З>>;
      п += 1;
    }
    вернути реєстр;
  }

  дія розширити_реєстр<К, З>(реєстр: адреса<Реєстр<К, З>>, нова_вмісткість: позитивне) {
    якщо нова_вмісткість == 0 {
      нова_вмісткість = реєстр.вмісткість * 2;
    } інакше якщо нова_вмісткість <= реєстр.вмісткість {
      вернути;
    }
    змінна нові_дані = виділити_памʼять<адреса<ЕлементРеєстру<К, З>>>(реєстр.виділяч, нова_вмісткість);

    змінна п: позитивне = 0;
    поки п < нова_вмісткість {
      нові_дані[п] = пусто як адреса<ЕлементРеєстру<К, З>>;
      п += 1;
    }

    п = 0;
    поки п < реєстр.вмісткість {
      змінна поточний_елемент = реєстр.дані[п];
      поки поточний_елемент != пусто {
        ціль нова_позиція = реєстр.дія_змішування(поточний_елемент.ключ, реєстр.аргумент) % нова_вмісткість;
        ціль наступний = поточний_елемент.наступний;
        поточний_елемент.наступний = нові_дані[нова_позиція];
        нові_дані[нова_позиція] = поточний_елемент;
        поточний_елемент = наступний;
      }
      п += 1;
    }

    звільнити_памʼять(реєстр.виділяч, реєстр.дані);

    реєстр.дані = нові_дані;
    реєстр.вмісткість = нова_вмісткість;
  }

  дія покласти_в_реєстр<К, З>(реєстр: адреса<Реєстр<К, З>>, ключ: К, значення: З) {
    якщо реєстр.вмісткість == 0 {
      реєстр.дані = виділити_памʼять<адреса<ЕлементРеєстру<К, З>>>(реєстр.виділяч, 1);
      реєстр.вмісткість = 1;
      реєстр.дані[0] = пусто як адреса<ЕлементРеєстру<К, З>>;
    } інакше якщо ((д64(реєстр.розмір) / д64(реєстр.вмісткість)) > 0.7) {
       розширити_реєстр<К, З>(реєстр, 0);
    }

    ціль позиція = реєстр.дія_змішування(ключ, реєстр.аргумент) % реєстр.вмісткість;

    змінна елемент = реєстр.дані[позиція];

    поки елемент != пусто {
      змінна перевірено = ні;
      якщо реєстр.дія_перевірки == пусто {
        перевірено = елемент.ключ == ключ;
      } інакше {
        перевірено = реєстр.дія_перевірки(елемент.ключ, ключ, реєстр.аргумент);
      }
      якщо перевірено {
        якщо реєстр.дія_перед_заміною != пусто {
          реєстр.дія_перед_заміною(елемент.ключ, елемент.значення, ключ, значення, реєстр.аргумент);
        }
        елемент.ключ = ключ;
        елемент.значення = значення;
        вернути;
      }
      елемент = елемент.наступний;
    }

    змінна новий_елемент = виділити<ЕлементРеєстру<К, З>>(реєстр.виділяч);
    новий_елемент.ключ = ключ;
    новий_елемент.значення = значення;
    новий_елемент.наступний = реєстр.дані[позиція];
    реєстр.дані[позиція] = новий_елемент;

    реєстр.розмір += 1;
  }

  дія знайти_в_реєстрі<К, З>(реєстр: адреса<Реєстр<К, З>>, ключ: К): адреса<ЕлементРеєстру<К, З>> {
    ціль позиція = реєстр.дія_змішування(ключ, реєстр.аргумент) % реєстр.вмісткість;

    змінна елемент = реєстр.дані[позиція];

    поки елемент != пусто {
      змінна перевірено = ні;
      якщо реєстр.дія_перевірки == пусто {
        перевірено = елемент.ключ == ключ;
      } інакше {
        перевірено = реєстр.дія_перевірки(елемент.ключ, ключ, реєстр.аргумент);
      }
      якщо перевірено {
        вернути елемент;
      }
      елемент = елемент.наступний;
    }

    вернути пусто;
  }

  дія видалити_з_реєстру<К, З>(реєстр: адреса<Реєстр<К, З>>, ключ: К) {
    ціль позиція = реєстр.дія_змішування(ключ, реєстр.аргумент) % реєстр.вмісткість;

    змінна елемент = реєстр.дані[позиція];
    змінна попередній: адреса<ЕлементРеєстру<К, З>> = пусто;

    поки елемент != пусто {
      змінна перевірено = ні;
      якщо реєстр.дія_перевірки == пусто {
        перевірено = елемент.ключ == ключ;
      } інакше {
        перевірено = реєстр.дія_перевірки(елемент.ключ, ключ, реєстр.аргумент);
      }
      якщо перевірено {
        якщо реєстр.дія_перед_видаленням != пусто {
          реєстр.дія_перед_видаленням(елемент.ключ, елемент.значення, реєстр.аргумент);
        }
        якщо попередній == пусто {
          реєстр.дані[позиція] = елемент.наступний;
        } інакше {
          попередній.наступний = елемент.наступний;
        }
        звільнити(реєстр.виділяч, елемент);
        реєстр.розмір -= 1;
        вернути;
      }
      попередній = елемент;
      елемент = елемент.наступний;
    }
  }
}