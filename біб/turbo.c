#include <arpa/inet.h>
#include <idn2.h>
#include <liburing.h>
#include <netdb.h>
#include <netinet/in.h>
#include <poll.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/timerfd.h>
#include <unistd.h>

#define TURBO_DEBUG

#define QUEUE_DEPTH 8
#define BUF_SIZE 1024

int make_nonblocking(int fd) {
  int flags = fcntl(fd, F_GETFL, 0);
  return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
}

#define п8 uint8_t
#define п16 uint16_t
#define п32 uint32_t
#define п64 uint64_t
#define ц8 int8_t
#define ц16 int16_t
#define ц32 int32_t
#define ц64 int64_t
#define д32 float
#define д64 double
#define логічне uint8_t
#define позитивне п64
#define ціле ц64
#define дійсне д64
#define ніщо void
#define невідома_адреса void*
#define невідома_памʼять void*
#define памʼять_п8 п8*
#define адреса_памʼять_п8 п8**
#define памʼять_памʼять_п8 п8**
#define адреса_позитивне позитивне*
typedef struct т8 {
  позитивне розмір;
  памʼять_п8 дані;
} т8;
typedef struct ю8 {
  позитивне розмір;
  памʼять_п8 дані;
} ю8;
#define памʼять_т8 т8*
#define памʼять_ю8 ю8*

static char* перетворити_ю8_в_chars(ю8 value) {
  char* copy = (char*)malloc(value.розмір + 1);
  memcpy(copy, value.дані, value.розмір);
  copy[value.розмір] = 0;
  return copy;
}

typedef struct Виділяч Виділяч;

struct Виділяч {
  невідома_адреса користувацькі_дані;

  памʼять_п8 (*виділити_сиру_памʼять)(Виділяч* виділяч, позитивне розмір);

  памʼять_п8 (*перевиділити_сиру_памʼять)(Виділяч* виділяч,
                                          памʼять_п8 значення,
                                          позитивне новий_розмір);

  void (*звільнити_сиру_памʼять)(Виділяч* виділяч, памʼять_п8 значення);
};

extern Виділяч* __біб__отримати_системний_виділяч();

// <турбо.в>

typedef struct Турбіна Турбіна;
typedef struct Подія Подія;
typedef struct Відкладене Відкладене;
typedef struct Періодичне Періодичне;
typedef struct ІнтернетЗвʼязок ІнтернетЗвʼязок;
typedef struct ЕлементЧергиЗаписуІнтернетЗвʼязку
    ЕлементЧергиЗаписуІнтернетЗвʼязку;
typedef struct ПрочитанеІнтернетЗвʼязку ПрочитанеІнтернетЗвʼязку;
typedef struct ІнтернетОбслуговувач ІнтернетОбслуговувач;
typedef struct ТурбоПомилкаВідкликуТурбіни ТурбоПомилкаВідкликуТурбіни;

typedef enum {
  ТипПодіїІнтернетОбслуговувачКлієнтПідключено,
  ТипПодіїІнтернетЗвʼязокПідключено,
  ТипПодіїІнтернетЗвʼязокПрочитано,
  ТипПодіїІнтернетЗвʼязокЗаписано,
  ТипПодіїВідкладенеГотово,
  ТипПодіїВідкладенеСкасовано,
  ТипПодіїПеріодичнеГотово,
  ТипПодіїПеріодичнеСкасовано
} ТипПодії;

typedef логічне (*ТурбоВідкликТурбіни)(
    Турбіна* турбіна,
    невідома_адреса аргумент,
    ТурбоПомилкаВідкликуТурбіни* вихід_помилки);

typedef логічне (*ТурбоВідкликВідкладеного)(Турбіна* турбіна,
                                            Відкладене* відкладене,
                                            невідома_адреса аргумент,
                                            логічне скасовано,
                                            логічне успішно,
                                            ц32 код_помилки);

typedef логічне (*ТурбоВідкликПеріодичного)(Турбіна* турбіна,
                                            Періодичне* періодичне,
                                            невідома_адреса аргумент,
                                            логічне скасовано,
                                            логічне успішно,
                                            ц32 код_помилки);

typedef void (*ТурбоОбробникПідключенняІнтернетЗвʼязку)(
    Турбіна* турбіна,
    ІнтернетЗвʼязок* інтернет_звʼязок,
    невідома_адреса аргумент,
    логічне успішно,
    позитивне код_помилки);

typedef void (*ТурбоОбробникВідключенняІнтернетЗвʼязку)(
    Турбіна* турбіна,
    ІнтернетЗвʼязок* інтернет_звʼязок,
    невідома_адреса аргумент,
    логічне з_помилкою,
    позитивне код_помилки);

typedef void (*ТурбоОбробникДанихІнтернетЗвʼязку)(
    Турбіна* турбіна,
    ІнтернетЗвʼязок* інтернет_звʼязок,
    невідома_адреса аргумент,
    позитивне розмір,
    памʼять_п8 дані);

typedef void (*ТурбоОбробникЗакриттяІнтернетЗвʼязку)(
    Турбіна* турбіна,
    ІнтернетЗвʼязок* інтернет_звʼязок,
    невідома_адреса аргумент);

typedef void (*ТурбоОбробникЗаписуІнтернетЗвʼязку)(
    Турбіна* турбіна,
    ІнтернетЗвʼязок* інтернет_звʼязок,
    невідома_адреса аргумент_інтернет_звʼязку,
    невідома_адреса аргумент_запису,
    позитивне розмір,
    памʼять_п8 дані);

typedef void (*ТурбоОбробникЗапускуІнтернетОбслуговувача)(
    Турбіна* турбіна,
    ІнтернетОбслуговувач* інтернет_обслуговувач,
    невідома_адреса аргумент,
    логічне успішно,
    ц32 код_помилки,
    позитивне іа,
    позитивне порт);

typedef void (*ТурбоОбробникПідключенняКлієнтаІнтернетОбслуговувача)(
    Турбіна* турбіна,
    ІнтернетОбслуговувач* інтернет_обслуговувач,
    ІнтернетЗвʼязок* інтернет_звʼязок,
    невідома_адреса аргумент);

typedef void (*ТурбоОбробникЗупинкиІнтернетОбслуговувача)(
    Турбіна* турбіна,
    ІнтернетОбслуговувач* інтернет_обслуговувач,
    невідома_адреса аргумент);

struct ІнтернетОбслуговувач {
  int fd;
  ТурбоОбробникПідключенняКлієнтаІнтернетОбслуговувача
  обробник_підключення_клієнта;
  ТурбоОбробникЗупинкиІнтернетОбслуговувача обробник_зупинки;
  невідома_адреса аргумент;
};

struct Відкладене {
  int fd;
  uint64_t expirations;
  ТурбоВідкликВідкладеного відклик;
  невідома_адреса аргумент;
  Подія* подія;
};

struct Періодичне {
  int fd;
  uint64_t expirations;
  ТурбоВідкликПеріодичного відклик;
  невідома_адреса аргумент;
  Подія* подія;
};

struct ІнтернетЗвʼязок {
  int fd;
  ТурбоОбробникПідключенняІнтернетЗвʼязку обробник_підключення;
  ТурбоОбробникВідключенняІнтернетЗвʼязку обробник_відключення;
  ТурбоОбробникДанихІнтернетЗвʼязку обробник_даних;
  ТурбоОбробникЗакриттяІнтернетЗвʼязку обробник_закриття;
  невідома_адреса аргумент;
  ЕлементЧергиЗаписуІнтернетЗвʼязку* перший_елемент_черги_запису;
  ЕлементЧергиЗаписуІнтернетЗвʼязку* останній_елемент_черги_запису;
  логічне очікує_закінчення_запису;
  логічне закінчено_запис;
  логічне закінчено_читання;
  логічне очікує_відключення;
  логічне відключення_з_помилкою;
  позитивне код_помилки_відключення;
};

struct ЕлементЧергиЗаписуІнтернетЗвʼязку {
  ЕлементЧергиЗаписуІнтернетЗвʼязку* наступний;
  ІнтернетЗвʼязок* інтернет_звʼязок;
  позитивне розмір;
  памʼять_п8 дані;
  позитивне розмір_записаного;
  ТурбоОбробникЗаписуІнтернетЗвʼязку обробник_запису;
  невідома_адреса аргумент;
};

struct ПрочитанеІнтернетЗвʼязку {
  ІнтернетЗвʼязок* інтернет_звʼязок;
  позитивне розмір;
  памʼять_п8 дані;
};

struct Подія {
  ТипПодії тип;
  union {
    Відкладене* відкладене;
    Періодичне* періодичне;
    ІнтернетОбслуговувач* інтернет_обслуговувач;
    ІнтернетЗвʼязок* інтернет_звʼязок;
    ЕлементЧергиЗаписуІнтернетЗвʼязку* елемент_черги_запису_інтернет_звʼязку;
    ПрочитанеІнтернетЗвʼязку* прочитане_інтернет_звʼязку;
  } обʼєкт;
};

struct Турбіна {
  Виділяч* виділяч;
  struct io_uring ring;
  int qcount;
};

struct ТурбоПомилкаВідкликуТурбіни {
  позитивне тип;
  невідома_адреса дані;
};

extern Турбіна* __турбо__створити_турбіну(Виділяч* виділяч) {
  Турбіна* турбіна =
      (Турбіна*)виділяч->виділити_сиру_памʼять(виділяч, sizeof(Турбіна));

  турбіна->виділяч = виділяч;

  io_uring_queue_init(QUEUE_DEPTH, &турбіна->ring, 0);

  турбіна->qcount = 0;

  return турбіна;
}

Турбіна* глобальна_турбіна = NULL;

extern Турбіна* __турбо__отримати_глобальну_турбіну() {
  return глобальна_турбіна;
}

extern void __турбо__змінити_глобальну_турбіну(Турбіна* турбіна) {
  глобальна_турбіна = турбіна;
}

void слухати_відкладене_готово(Турбіна* турбіна, Відкладене* відкладене) {
  Подія* подія = (Подія*)турбіна->виділяч->виділити_сиру_памʼять(
      турбіна->виділяч, sizeof(Подія));
  подія->тип = ТипПодіїВідкладенеГотово;
  подія->обʼєкт.відкладене = відкладене;

  struct io_uring_sqe* sqe = io_uring_get_sqe(&турбіна->ring);
  io_uring_prep_read(sqe, відкладене->fd, &відкладене->expirations,
                     sizeof(відкладене->expirations), 0);
  io_uring_sqe_set_data(sqe, подія);
  io_uring_submit(&турбіна->ring);

  турбіна->qcount++;

  відкладене->подія = подія;
}

void слухати_періодичне_готово(Турбіна* турбіна, Періодичне* періодичне) {
  Подія* подія = (Подія*)турбіна->виділяч->виділити_сиру_памʼять(
      турбіна->виділяч, sizeof(Подія));
  подія->тип = ТипПодіїПеріодичнеГотово;
  подія->обʼєкт.періодичне = періодичне;

  struct io_uring_sqe* sqe = io_uring_get_sqe(&турбіна->ring);
  io_uring_prep_read(sqe, періодичне->fd, &періодичне->expirations,
                     sizeof(періодичне->expirations), 0);
  io_uring_sqe_set_data(sqe, подія);
  io_uring_submit(&турбіна->ring);

  турбіна->qcount++;

  періодичне->подія = подія;
}

void слухати_інтернет_обслуговувач_клієнт_підключено(
    Турбіна* турбіна,
    ІнтернетОбслуговувач* інтернет_обслуговувач) {
  Подія* подія = (Подія*)турбіна->виділяч->виділити_сиру_памʼять(
      турбіна->виділяч, sizeof(Подія));
  подія->тип = ТипПодіїІнтернетОбслуговувачКлієнтПідключено;
  подія->обʼєкт.інтернет_обслуговувач = інтернет_обслуговувач;

  struct io_uring_sqe* sqe = io_uring_get_sqe(&турбіна->ring);
  io_uring_prep_accept(sqe, інтернет_обслуговувач->fd, NULL, NULL, 0);
  io_uring_sqe_set_data(sqe, подія);
  io_uring_submit(&турбіна->ring);

  турбіна->qcount++;
}

void слухати_інтернет_звʼязок_підключено(Турбіна* турбіна,
                                         ІнтернетЗвʼязок* інтернет_звʼязок) {
  Подія* подія = (Подія*)турбіна->виділяч->виділити_сиру_памʼять(
      турбіна->виділяч, sizeof(Подія));
  подія->тип = ТипПодіїІнтернетЗвʼязокПідключено;
  подія->обʼєкт.інтернет_звʼязок = інтернет_звʼязок;

  struct io_uring_sqe* sqe = io_uring_get_sqe(&турбіна->ring);
  io_uring_prep_poll_add(sqe, інтернет_звʼязок->fd, POLLOUT);
  io_uring_sqe_set_data(sqe, подія);
  io_uring_submit(&турбіна->ring);

  турбіна->qcount++;
}

void слухати_інтернет_звʼязок_прочитано(Турбіна* турбіна,
                                        ІнтернетЗвʼязок* інтернет_звʼязок) {
  ПрочитанеІнтернетЗвʼязку* прочитане =
      (ПрочитанеІнтернетЗвʼязку*)турбіна->виділяч->виділити_сиру_памʼять(
          турбіна->виділяч, sizeof(ПрочитанеІнтернетЗвʼязку));
  прочитане->інтернет_звʼязок = інтернет_звʼязок;
  прочитане->розмір = 4096;
  прочитане->дані =
      турбіна->виділяч->виділити_сиру_памʼять(турбіна->виділяч, 4096);

#ifdef TURBO_DEBUG
  memset(прочитане->дані, 0, 4096);
#endif

  Подія* подія = (Подія*)турбіна->виділяч->виділити_сиру_памʼять(
      турбіна->виділяч, sizeof(Подія));
  подія->тип = ТипПодіїІнтернетЗвʼязокПрочитано;
  подія->обʼєкт.прочитане_інтернет_звʼязку = прочитане;

  struct io_uring_sqe* sqe = io_uring_get_sqe(&турбіна->ring);
  io_uring_prep_read(sqe, інтернет_звʼязок->fd, прочитане->дані,
                     прочитане->розмір, 0);
  io_uring_sqe_set_data(sqe, подія);
  io_uring_submit(&турбіна->ring);

  турбіна->qcount++;
}

void слухати_інтернет_звʼязок_записано(
    Турбіна* турбіна,
    ІнтернетЗвʼязок* інтернет_звʼязок,
    ЕлементЧергиЗаписуІнтернетЗвʼязку* елемент_черги_запису_інтернет_звʼязку) {
  Подія* подія = (Подія*)турбіна->виділяч->виділити_сиру_памʼять(
      турбіна->виділяч, sizeof(Подія));
  подія->тип = ТипПодіїІнтернетЗвʼязокЗаписано;
  подія->обʼєкт.елемент_черги_запису_інтернет_звʼязку =
      елемент_черги_запису_інтернет_звʼязку;

  struct io_uring_sqe* sqe = io_uring_get_sqe(&турбіна->ring);
  io_uring_prep_write(
      sqe, інтернет_звʼязок->fd,
      елемент_черги_запису_інтернет_звʼязку->дані +
          елемент_черги_запису_інтернет_звʼязку->розмір_записаного,
      елемент_черги_запису_інтернет_звʼязку->розмір -
          елемент_черги_запису_інтернет_звʼязку->розмір_записаного,
      0);
  io_uring_sqe_set_data(sqe, подія);
  io_uring_submit(&турбіна->ring);

  турбіна->qcount++;
}

extern логічне __турбо__отримати_інтернет_адресу_з_ю8(Турбіна* турбіна,
                                                      ю8 значення,
                                                      позитивне* вихід) {
  char* hostname_unicode = перетворити_ю8_в_chars(значення);

  char* hostname = NULL;

  int idn2res =
      idn2_lookup_u8((const uint8_t*)hostname_unicode, (uint8_t**)&hostname, 0);
  if (idn2res == IDN2_OK) {
    free(hostname_unicode);
  } else {
    free(hostname_unicode);
    return false;
  }

  struct addrinfo hints, *res;
  struct in_addr addr;

  memset(&hints, 0, sizeof(hints));
  hints.ai_family = AF_INET;

  int addres = getaddrinfo(hostname, NULL, &hints, &res);

  idn2_free(hostname);

  if (addres != 0) {
    return false;
  }

  addr = ((struct sockaddr_in*)res->ai_addr)->sin_addr;

  freeaddrinfo(res);

  *вихід = ntohl(addr.s_addr);

  return true;
}

extern логічне __турбо__підключити_інтернет_звʼязок(
    Турбіна* турбіна,
    позитивне іа,
    позитивне порт,
    ТурбоОбробникПідключенняІнтернетЗвʼязку обробник_підключення,
    ТурбоОбробникДанихІнтернетЗвʼязку обробник_даних,
    ТурбоОбробникЗакриттяІнтернетЗвʼязку обробник_закриття,
    ТурбоОбробникВідключенняІнтернетЗвʼязку обробник_відключення,
    невідома_адреса аргумент) {
  int sockfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sockfd == -1) {
    обробник_підключення(турбіна, NULL, аргумент, false, errno);
    return false;
  }

  if (make_nonblocking(sockfd) == -1) {
    close(sockfd);
    обробник_підключення(турбіна, NULL, аргумент, false, errno);
    return false;
  }

  struct sockaddr_in addr = {.sin_family = AF_INET,
                             .sin_addr = {.s_addr = htonl(іа)},
                             .sin_port = htons(порт)};

  int res = connect(sockfd, (struct sockaddr*)&addr, sizeof(addr));
  if (res == -1 && errno != EINPROGRESS) {
    close(sockfd);
    обробник_підключення(турбіна, NULL, аргумент, false, errno);
    return false;
  }

  ІнтернетЗвʼязок* інтернет_звʼязок =
      (ІнтернетЗвʼязок*)турбіна->виділяч->виділити_сиру_памʼять(
          турбіна->виділяч, sizeof(ІнтернетЗвʼязок));
  інтернет_звʼязок->fd = sockfd;
  інтернет_звʼязок->обробник_підключення = обробник_підключення;
  інтернет_звʼязок->обробник_даних = обробник_даних;
  інтернет_звʼязок->обробник_закриття = обробник_закриття;
  інтернет_звʼязок->обробник_відключення = обробник_відключення;
  інтернет_звʼязок->аргумент = аргумент;
  інтернет_звʼязок->перший_елемент_черги_запису = NULL;
  інтернет_звʼязок->останній_елемент_черги_запису = NULL;
  інтернет_звʼязок->очікує_закінчення_запису = false;
  інтернет_звʼязок->закінчено_запис = false;
  інтернет_звʼязок->закінчено_читання = false;
  інтернет_звʼязок->очікує_відключення = false;
  інтернет_звʼязок->відключення_з_помилкою = false;
  інтернет_звʼязок->код_помилки_відключення = 0;

  слухати_інтернет_звʼязок_підключено(турбіна, інтернет_звʼязок);

  return true;
}

void закрити_інтернет_звʼязок(Турбіна* турбіна,
                              ІнтернетЗвʼязок* інтернет_звʼязок,
                              логічне з_помилкою,
                              позитивне помилка) {
  close(інтернет_звʼязок->fd);

  ЕлементЧергиЗаписуІнтернетЗвʼязку* елемет_черги_запису =
      інтернет_звʼязок->перший_елемент_черги_запису;

  while (елемет_черги_запису != NULL) {
    if (елемет_черги_запису->обробник_запису != NULL) {
      елемет_черги_запису->обробник_запису(
          турбіна, інтернет_звʼязок, інтернет_звʼязок->аргумент,
          елемет_черги_запису->аргумент, елемет_черги_запису->розмір,
          елемет_черги_запису->дані);
    }

    ЕлементЧергиЗаписуІнтернетЗвʼязку* наступний =
        елемет_черги_запису->наступний;

    free(елемет_черги_запису);

    елемет_черги_запису = наступний;
  }

  інтернет_звʼязок->обробник_відключення(турбіна, інтернет_звʼязок,
                                         інтернет_звʼязок->аргумент, з_помилкою,
                                         помилка);

  free(інтернет_звʼязок);
}

static void обробити_відкладене_готово(Турбіна* турбіна,
                                       Відкладене* відкладене,
                                       int res) {
  close(відкладене->fd);

  if (res < 0) {
    відкладене->відклик(турбіна, відкладене, відкладене->аргумент,
                        res == -ECANCELED != 0, false, -res);
  } else {
    відкладене->відклик(турбіна, відкладене, відкладене->аргумент, false, true,
                        0);
  }

  free(відкладене);
}

static void обробити_періодичне_готово(Турбіна* турбіна,
                                       Періодичне* періодичне,
                                       int res) {
  if (res < 0) {
    close(періодичне->fd);

    періодичне->відклик(турбіна, періодичне, періодичне->аргумент,
                        res == -ECANCELED != 0, false, -res);

    free(періодичне);
  } else {
    слухати_періодичне_готово(турбіна, періодичне);

    періодичне->відклик(турбіна, періодичне, періодичне->аргумент, false, true,
                        0);
  }
}

static void обробити_інтернет_обслуговувач_підключено_клієнт(
    Турбіна* турбіна,
    ІнтернетОбслуговувач* інтернет_обслуговувач,
    int res) {
  make_nonblocking(res);

  слухати_інтернет_обслуговувач_клієнт_підключено(турбіна,
                                                  інтернет_обслуговувач);

  ІнтернетЗвʼязок* інтернет_звʼязок =
      (ІнтернетЗвʼязок*)турбіна->виділяч->виділити_сиру_памʼять(
          турбіна->виділяч, sizeof(ІнтернетЗвʼязок));
  інтернет_звʼязок->fd = res;
  інтернет_звʼязок->обробник_підключення = NULL;
  інтернет_звʼязок->обробник_даних = NULL;
  інтернет_звʼязок->обробник_закриття = NULL;
  інтернет_звʼязок->обробник_відключення = NULL;
  інтернет_звʼязок->аргумент = NULL;
  інтернет_звʼязок->перший_елемент_черги_запису = NULL;
  інтернет_звʼязок->останній_елемент_черги_запису = NULL;
  інтернет_звʼязок->очікує_закінчення_запису = false;
  інтернет_звʼязок->закінчено_запис = false;
  інтернет_звʼязок->закінчено_читання = false;
  інтернет_звʼязок->очікує_відключення = false;
  інтернет_звʼязок->відключення_з_помилкою = false;
  інтернет_звʼязок->код_помилки_відключення = 0;

  слухати_інтернет_звʼязок_прочитано(турбіна, інтернет_звʼязок);

  інтернет_обслуговувач->обробник_підключення_клієнта(
      турбіна, інтернет_обслуговувач, інтернет_звʼязок,
      інтернет_обслуговувач->аргумент);
}

static void обробити_інтернет_звʼязок_підключено(
    Турбіна* турбіна,
    ІнтернетЗвʼязок* інтернет_звʼязок) {
  int err = 0;
  socklen_t len = sizeof(err);
  int result =
      getsockopt(інтернет_звʼязок->fd, SOL_SOCKET, SO_ERROR, &err, &len);

  if (result == -1 || err != 0) {
    close(інтернет_звʼязок->fd);

    інтернет_звʼязок->обробник_підключення(
        турбіна, інтернет_звʼязок, інтернет_звʼязок->аргумент, false, err);

    free(інтернет_звʼязок);
  } else {
    інтернет_звʼязок->обробник_підключення(турбіна, інтернет_звʼязок,
                                           інтернет_звʼязок->аргумент, true, 0);

    слухати_інтернет_звʼязок_прочитано(турбіна, інтернет_звʼязок);
  }
}

static void обробити_інтернет_звʼязок_прочитано(
    Турбіна* турбіна,
    ПрочитанеІнтернетЗвʼязку* прочитане_інтернет_звʼязку,
    int res) {
  ІнтернетЗвʼязок* інтернет_звʼязок =
      прочитане_інтернет_звʼязку->інтернет_звʼязок;

  if (інтернет_звʼязок->очікує_відключення) {
    // відключення ініційовано під час запису (ймовірно за все через помилку)
    free(прочитане_інтернет_звʼязку->дані);
    free(прочитане_інтернет_звʼязку);

    закрити_інтернет_звʼязок(турбіна, інтернет_звʼязок,
                             інтернет_звʼязок->відключення_з_помилкою,
                             інтернет_звʼязок->код_помилки_відключення);
  } else if (res < 0) {
    free(прочитане_інтернет_звʼязку->дані);
    free(прочитане_інтернет_звʼязку);

    if (res == -EAGAIN) {
      слухати_інтернет_звʼязок_прочитано(турбіна, інтернет_звʼязок);
    } else {
      if (інтернет_звʼязок->перший_елемент_черги_запису == NULL ||
          інтернет_звʼязок->закінчено_запис) {
        закрити_інтернет_звʼязок(турбіна, інтернет_звʼязок, true, res);
      } else {
        інтернет_звʼязок->очікує_відключення = true;
        інтернет_звʼязок->відключення_з_помилкою = true;
        інтернет_звʼязок->код_помилки_відключення = res;
      }
    }
  } else if (res == 0) {
    free(прочитане_інтернет_звʼязку->дані);
    free(прочитане_інтернет_звʼязку);

    інтернет_звʼязок->закінчено_читання = true;

    інтернет_звʼязок->обробник_закриття(турбіна, інтернет_звʼязок,
                                        інтернет_звʼязок->аргумент);

    if (інтернет_звʼязок->перший_елемент_черги_запису == NULL ||
        інтернет_звʼязок->закінчено_запис) {
      закрити_інтернет_звʼязок(турбіна, інтернет_звʼязок,
                               інтернет_звʼязок->відключення_з_помилкою,
                               інтернет_звʼязок->код_помилки_відключення);
    }
  } else {
    інтернет_звʼязок->обробник_даних(турбіна, інтернет_звʼязок,
                                     інтернет_звʼязок->аргумент, res,
                                     прочитане_інтернет_звʼязку->дані);

    слухати_інтернет_звʼязок_прочитано(турбіна, інтернет_звʼязок);

    free(прочитане_інтернет_звʼязку);
  }
}

static void обробити_інтернет_звʼязок_записано(
    Турбіна* турбіна,
    ЕлементЧергиЗаписуІнтернетЗвʼязку* елемент_черги_запису_інтернет_звʼязку,
    int res) {
  ІнтернетЗвʼязок* інтернет_звʼязок =
      елемент_черги_запису_інтернет_звʼязку->інтернет_звʼязок;

  if (інтернет_звʼязок->очікує_відключення) {
    // відключення ініційовано під час прочитання (ймовірно за все через помилку)
    закрити_інтернет_звʼязок(турбіна, інтернет_звʼязок,
                             інтернет_звʼязок->відключення_з_помилкою,
                             інтернет_звʼязок->код_помилки_відключення);
  } else if (res < 0) {
    if (інтернет_звʼязок->закінчено_читання) {
      закрити_інтернет_звʼязок(турбіна, інтернет_звʼязок, true, res);
    } else {
      інтернет_звʼязок->очікує_відключення = true;
      інтернет_звʼязок->відключення_з_помилкою = true;
      інтернет_звʼязок->код_помилки_відключення = res;
    }
  } else {
    інтернет_звʼязок->перший_елемент_черги_запису =
        елемент_черги_запису_інтернет_звʼязку->наступний;

    if (інтернет_звʼязок->останній_елемент_черги_запису ==
        елемент_черги_запису_інтернет_звʼязку) {
      інтернет_звʼязок->останній_елемент_черги_запису = NULL;
    }

    if (інтернет_звʼязок->перший_елемент_черги_запису == NULL) {
      if (інтернет_звʼязок->очікує_закінчення_запису) {
        shutdown(інтернет_звʼязок->fd, SHUT_WR);
        інтернет_звʼязок->закінчено_запис = true;
      }
    } else {
      слухати_інтернет_звʼязок_записано(
          турбіна, інтернет_звʼязок,
          інтернет_звʼязок->перший_елемент_черги_запису);
    }

    if (елемент_черги_запису_інтернет_звʼязку->обробник_запису != NULL) {
      елемент_черги_запису_інтернет_звʼязку->обробник_запису(
          турбіна, інтернет_звʼязок, інтернет_звʼязок->аргумент,
          елемент_черги_запису_інтернет_звʼязку->аргумент,
          елемент_черги_запису_інтернет_звʼязку->розмір,
          елемент_черги_запису_інтернет_звʼязку->дані);
    }

    free(елемент_черги_запису_інтернет_звʼязку);
  }
}

extern void __турбо__встановити_обробники_інтернет_звʼязку(
    Турбіна* турбіна,
    ІнтернетЗвʼязок* інтернет_звʼязок,
    ТурбоОбробникДанихІнтернетЗвʼязку обробник_даних,
    ТурбоОбробникЗакриттяІнтернетЗвʼязку обробник_закриття,
    ТурбоОбробникВідключенняІнтернетЗвʼязку обробник_відключення,
    невідома_адреса аргумент) {
  інтернет_звʼязок->обробник_даних = обробник_даних;
  інтернет_звʼязок->обробник_закриття = обробник_закриття;
  інтернет_звʼязок->обробник_відключення = обробник_відключення;
  інтернет_звʼязок->аргумент = аргумент;
}

extern void __турбо__запустити_інтернет_обслуговувач(
    Турбіна* турбіна,
    позитивне іа,
    позитивне порт,
    ТурбоОбробникЗапускуІнтернетОбслуговувача обробник_запуску,
    ТурбоОбробникПідключенняКлієнтаІнтернетОбслуговувача
        обробник_підключення_клієнта,
    ТурбоОбробникЗупинкиІнтернетОбслуговувача обробник_зупинки,
    невідома_адреса аргумент) {
  int server_fd = socket(AF_INET, SOCK_STREAM, 0);
  if (server_fd == -1) {
    обробник_запуску(турбіна, NULL, аргумент, false, errno, іа, порт);
    return;
  }

  struct sockaddr_in addr = {0};

  make_nonblocking(server_fd);

  int opt = 1;
  setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

  addr.sin_family = AF_INET;
  addr.sin_port = htons(порт);
  addr.sin_addr.s_addr = INADDR_ANY;

  int bindres = bind(server_fd, (struct sockaddr*)&addr, sizeof(addr));
  if (bindres == -1) {
    обробник_запуску(турбіна, NULL, аргумент, false, errno, іа, порт);
    return;
  }

  int listres = listen(server_fd, 128);
  if (listres == -1) {
    обробник_запуску(турбіна, NULL, аргумент, false, errno, іа, порт);
    return;
  }

  ІнтернетОбслуговувач* інтернет_обслуговувач =
      (ІнтернетОбслуговувач*)турбіна->виділяч->виділити_сиру_памʼять(
          турбіна->виділяч, sizeof(ІнтернетОбслуговувач));
  інтернет_обслуговувач->fd = server_fd;
  інтернет_обслуговувач->обробник_підключення_клієнта =
      обробник_підключення_клієнта;
  інтернет_обслуговувач->обробник_зупинки = обробник_зупинки;
  інтернет_обслуговувач->аргумент = аргумент;

  слухати_інтернет_обслуговувач_клієнт_підключено(турбіна,
                                                  інтернет_обслуговувач);

  обробник_запуску(турбіна, інтернет_обслуговувач, аргумент, true, 0, іа, порт);
}

extern логічне __турбо__запустити_турбіну(
    Турбіна* турбіна,
    ТурбоВідкликТурбіни відклик_перед,
    ТурбоВідкликТурбіни відклик_після,
    невідома_адреса аргумент,
    ТурбоПомилкаВідкликуТурбіни* вихід_помилки) {
  while (1) {
    if (турбіна->qcount == 0) {
      if (io_uring_cq_ready(&турбіна->ring) == 0) {
        return true;
      }
    }

    if (відклик_перед != NULL) {
      if (відклик_перед(турбіна, аргумент, вихід_помилки)) {
        return false;
      }
    }

    struct io_uring_cqe* cqe;
    io_uring_wait_cqe(&турбіна->ring, &cqe);
    io_uring_cqe_seen(&турбіна->ring, cqe);
    турбіна->qcount--;

    Подія* подія = io_uring_cqe_get_data(cqe);

    if (подія->тип == ТипПодіїВідкладенеГотово) {
      обробити_відкладене_готово(турбіна, подія->обʼєкт.відкладене, cqe->res);
    } else if (подія->тип == ТипПодіїВідкладенеСкасовано) {
      // ignore
    } else if (подія->тип == ТипПодіїПеріодичнеГотово) {
      обробити_періодичне_готово(турбіна, подія->обʼєкт.періодичне, cqe->res);
    } else if (подія->тип == ТипПодіїПеріодичнеСкасовано) {
      // ignore
    } else if (подія->тип == ТипПодіїІнтернетОбслуговувачКлієнтПідключено) {
      обробити_інтернет_обслуговувач_підключено_клієнт(
          турбіна, подія->обʼєкт.інтернет_обслуговувач, cqe->res);
    } else if (подія->тип == ТипПодіїІнтернетЗвʼязокПідключено) {
      обробити_інтернет_звʼязок_підключено(турбіна,
                                           подія->обʼєкт.інтернет_звʼязок);
    } else if (подія->тип == ТипПодіїІнтернетЗвʼязокЗаписано) {
      обробити_інтернет_звʼязок_записано(
          турбіна, подія->обʼєкт.елемент_черги_запису_інтернет_звʼязку,
          cqe->res);
    } else if (подія->тип == ТипПодіїІнтернетЗвʼязокПрочитано) {
      обробити_інтернет_звʼязок_прочитано(
          турбіна, подія->обʼєкт.прочитане_інтернет_звʼязку, cqe->res);
    }

    free(подія);

    if (відклик_після != NULL) {
      if (!відклик_після(турбіна, аргумент, вихід_помилки)) {
        return false;
      }
    }
  }
}

extern void __турбо__знищити_турбіну(Турбіна* турбіна) {
  io_uring_queue_exit(&турбіна->ring);

  турбіна->виділяч->звільнити_сиру_памʼять(турбіна->виділяч,
                                           (памʼять_п8)турбіна);
}

extern void __турбо__закінчити_інтернет_звʼязок(
    Турбіна* турбіна,
    ІнтернетЗвʼязок* інтернет_звʼязок) {
  if (інтернет_звʼязок->очікує_закінчення_запису ||
      інтернет_звʼязок->закінчено_запис) {
    return;
  }

  if (інтернет_звʼязок->перший_елемент_черги_запису == NULL) {
    shutdown(інтернет_звʼязок->fd, SHUT_WR);
    інтернет_звʼязок->закінчено_запис = true;
  } else {
    інтернет_звʼязок->очікує_закінчення_запису = true;
  }
}

extern void __турбо__записати_в_інтернет_звʼязок(
    Турбіна* турбіна,
    ІнтернетЗвʼязок* інтернет_звʼязок,
    позитивне розмір,
    памʼять_п8 дані,
    ТурбоОбробникЗаписуІнтернетЗвʼязку обробник_запису,
    невідома_адреса аргумент) {
  if (інтернет_звʼязок->очікує_відключення ||
      інтернет_звʼязок->очікує_закінчення_запису ||
      інтернет_звʼязок->закінчено_запис) {
    обробник_запису(турбіна, інтернет_звʼязок, інтернет_звʼязок->аргумент,
                    аргумент, розмір, дані);
    return;
  }

  ЕлементЧергиЗаписуІнтернетЗвʼязку* елемент =
      (ЕлементЧергиЗаписуІнтернетЗвʼязку*)
          турбіна->виділяч->виділити_сиру_памʼять(
              турбіна->виділяч, sizeof(ЕлементЧергиЗаписуІнтернетЗвʼязку));
  елемент->наступний = NULL;
  елемент->інтернет_звʼязок = інтернет_звʼязок;
  елемент->розмір = розмір;
  елемент->дані = дані;
  елемент->розмір_записаного = 0;
  елемент->обробник_запису = обробник_запису;
  елемент->аргумент = аргумент;

  if (інтернет_звʼязок->перший_елемент_черги_запису == NULL) {
    інтернет_звʼязок->перший_елемент_черги_запису = елемент;
  }
  if (інтернет_звʼязок->останній_елемент_черги_запису == NULL) {
    інтернет_звʼязок->останній_елемент_черги_запису = елемент;
    слухати_інтернет_звʼязок_записано(турбіна, інтернет_звʼязок, елемент);
  } else {
    інтернет_звʼязок->останній_елемент_черги_запису->наступний = елемент;
    інтернет_звʼязок->останній_елемент_черги_запису = елемент;
  }
}

extern ц32 __турбо__отримати_ідентифікатор_інтернет_звʼязку(
    Турбіна* турбіна,
    ІнтернетЗвʼязок* інтернет_звʼязок) {
  return інтернет_звʼязок->fd;
}

extern ц32 __турбо__отримати_ідентифікатор_інтернет_обслуговувача(
    Турбіна* турбіна,
    ІнтернетОбслуговувач* інтернет_обслуговувач) {
  return інтернет_обслуговувач->fd;
}

extern Відкладене* __турбо__відкласти_виконання(
    Турбіна* турбіна,
    позитивне тривалість,
    ТурбоВідкликВідкладеного відклик,
    невідома_адреса аргумент) {
  int tfd = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK);
  if (tfd == -1) {
    return NULL;
  }

  if (тривалість == 0) {
    тривалість = 1;
  }

  struct itimerspec ts = {0};
  ts.it_value.tv_sec = (long int)тривалість / 1000;
  ts.it_value.tv_nsec = (long int)(тривалість % 1000) * 1000000;

  if (timerfd_settime(tfd, 0, &ts, NULL) == -1) {
    close(tfd);
    return NULL;
  }

  if (make_nonblocking(tfd) == -1) {
    close(tfd);
    return NULL;
  }

  Відкладене* відкладене = (Відкладене*)турбіна->виділяч->виділити_сиру_памʼять(
      турбіна->виділяч, sizeof(Відкладене));
  відкладене->fd = tfd;
  відкладене->expirations = 0;
  відкладене->відклик = відклик;
  відкладене->аргумент = аргумент;
  відкладене->подія = NULL;

  слухати_відкладене_готово(турбіна, відкладене);

  return відкладене;
}

extern void __турбо__скасувати_відкладене(Турбіна* турбіна,
                                          Відкладене* відкладене) {
  Подія* подія = (Подія*)турбіна->виділяч->виділити_сиру_памʼять(
      турбіна->виділяч, sizeof(Подія));
  подія->тип = ТипПодіїВідкладенеСкасовано;

  struct io_uring_sqe* sqe = io_uring_get_sqe(&турбіна->ring);
  io_uring_prep_cancel(sqe, відкладене->подія, 0);
  io_uring_sqe_set_data(sqe, подія);
  io_uring_submit(&турбіна->ring);

  турбіна->qcount++;
}

extern Періодичне* __турбо__виконувати_періодично(
    Турбіна* турбіна,
    позитивне тривалість,
    ТурбоВідкликПеріодичного відклик,
    невідома_адреса аргумент) {
  int tfd = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK);
  if (tfd == -1) {
    return NULL;
  }

  if (тривалість == 0) {
    тривалість = 1;
  }

  struct itimerspec ts = {0};
  ts.it_value.tv_sec = (long int)тривалість / 1000;
  ts.it_value.tv_nsec = ((long int)тривалість % 1000) * 1000000;
  ts.it_interval.tv_sec = (long int)тривалість / 1000;
  ts.it_interval.tv_nsec = ((long int)тривалість % 1000) * 1000000;

  if (timerfd_settime(tfd, 0, &ts, NULL) == -1) {
    close(tfd);
    return NULL;
  }

  if (make_nonblocking(tfd) == -1) {
    close(tfd);
    return NULL;
  }

  Періодичне* періодичне = (Періодичне*)турбіна->виділяч->виділити_сиру_памʼять(
      турбіна->виділяч, sizeof(Періодичне));
  періодичне->fd = tfd;
  періодичне->expirations = 0;
  періодичне->відклик = відклик;
  періодичне->аргумент = аргумент;
  періодичне->подія = NULL;

  слухати_періодичне_готово(турбіна, періодичне);

  return періодичне;
}

extern void __турбо__скасувати_періодичне(Турбіна* турбіна,
                                          Періодичне* періодичне) {
  Подія* подія = (Подія*)турбіна->виділяч->виділити_сиру_памʼять(
      турбіна->виділяч, sizeof(Подія));
  подія->тип = ТипПодіїПеріодичнеСкасовано;

  struct io_uring_sqe* sqe = io_uring_get_sqe(&турбіна->ring);
  io_uring_prep_cancel(sqe, періодичне->подія, 0);
  io_uring_sqe_set_data(sqe, подія);
  io_uring_submit(&турбіна->ring);

  турбіна->qcount++;
}

// </турбо.в>