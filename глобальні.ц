взяти визначення мавка;

секція мавка {
  місцева дія вивести_предмет(М: адреса<Машина>, предмет: адреса<Предмет>, глибина: натуральне);

  дія вивести_параметри(М: адреса<Машина>, розмір: натуральне, дані: памʼять<адреса<ПредметПараметра>>, глибина: натуральне) {
    змінна п: натуральне = 0;

    поки п < розмір {
      вивести_предмет(М, дані[п] як адреса<Предмет>, глибина + 1);
      
      якщо п < (розмір - 1) {
        вивести(М, ", ");
      }

      п += 1;
    }
  }

  дія вивести_властивості(М: адреса<Машина>, властивості: Реєстр<адреса<ПредметТексту>, адреса<Предмет>>, глибина: натуральне) {
    змінна п: натуральне = 0;
    
    поки п < властивості.елементи.розмір {
      вивести(М, властивості.елементи.дані[п].ключ.значення);
      вивести(М, "=");
      вивести_предмет(М, властивості.елементи.дані[п].значення, глибина + 1);
      
      якщо п < властивості.елементи.розмір - 1 {
        вивести(М, ", ");
      }

      п += 1;
    }
  }

  // позначка: прохід по типах предмета
  місцева дія вивести_предмет(М: адреса<Машина>, предмет: адреса<Предмет>, глибина: натуральне) {
    якщо предмет == пусто {
      вивести(М, "пусто");
    } інакше якщо предмет.с == М.предмет_структури_Структура {
      змінна предмет_структури = предмет як адреса<ПредметСтруктури>;
      вивести(М, "<структура");
      якщо предмет_структури.назва != пусто {
        вивести(М, " ");
        вивести(М, предмет_структури.назва.значення);
      }
      якщо предмет_структури.параметри.розмір > 0 {
        вивести(М, ": ");
        змінна п: натуральне = 0;
        поки п < предмет_структури.параметри.розмір {
          вивести(М, предмет_структури.параметри.дані[п].назва.значення);
          якщо п < (предмет_структури.параметри.розмір - 1) {
            вивести(М, " ");
          }
          п += 1;
        }
      }
      вивести(М, ">");
    } інакше якщо предмет.с == М.предмет_структури_Код {
      вивести(М, "<код>");
    } інакше якщо предмет.с == М.предмет_структури_Середовище {
      вивести(М, "<середовище>");
    } інакше якщо предмет.с == М.предмет_структури_Дія {
      змінна предмет_дії = предмет як адреса<ПредметДії>;
      вивести(М, "<дія");
      якщо предмет_дії.назва != пусто {
        вивести(М, " ");
        вивести(М, предмет_дії.назва.значення);
      }
      якщо предмет_дії.параметри.розмір > 0 {
        вивести(М, "(");
        змінна п: натуральне = 0;
        поки п < предмет_дії.параметри.розмір {
          вивести(М, предмет_дії.параметри.дані[п].назва.значення);
          якщо п < (предмет_дії.параметри.розмір - 1) {
            вивести(М, ", ");
          }
          п += 1;
        }
        вивести(М, ")");
      }
      вивести(М, ">");
    } інакше якщо предмет.с == М.предмет_структури_логічне {
      змінна предмет_логічного = предмет як адреса<ПредметЛогічного>;
      якщо предмет_логічного.значення == натуральне(так) {
        вивести(М, "так");
      } інакше {
        вивести(М, "ні");
      }
    } інакше якщо предмет.с == М.предмет_структури_число {
      змінна предмет_числа = предмет як адреса<ПредметЧисла>;
      вивести_р64(М, предмет_числа.значення);
    } інакше якщо предмет.с == М.предмет_структури_текст {
      змінна предмет_тексту = предмет як адреса<ПредметТексту>;
      якщо глибина > 0 {
        вивести(М, "\"");
        змінна текст_з_закодованими_недрукованими = т8 { 0, пусто };
        якщо отримати_з_т8_т8_з_закодованими_недрукованими(М, предмет_тексту.значення, текст_з_закодованими_недрукованими::адреса) == ні {
          // потім: помилка
        }
        вивести(М, текст_з_закодованими_недрукованими);
        звільнити_памʼять(М, текст_з_закодованими_недрукованими.дані);
        вивести(М, "\"");
      } інакше {
        вивести(М, предмет_тексту.значення);
      }
    } інакше якщо предмет.с == М.предмет_структури_список {
      змінна предмет_списку = предмет як адреса<ПредметСписку>;
      вивести(М, "[");
      змінна п: натуральне = 0;
      поки п < предмет_списку.елементи.розмір {
        вивести_предмет(М, предмет_списку.елементи.дані[п], глибина + 1);
        якщо п < (предмет_списку.елементи.розмір - 1) {
          вивести(М, ", ");
        }
        п += 1;
      }
      вивести(М, "]");
    } інакше якщо предмет.с == М.предмет_структури_послідовність {
      змінна предмет_послідовності = предмет як адреса<ПредметПослідовності>;
      вивести(М, "послідовність([");
      змінна п: натуральне = 0;
      поки п < предмет_послідовності.елементи.розмір {
        вивести_предмет(М, предмет_послідовності.елементи.дані[п], глибина + 1);
        якщо п < (предмет_послідовності.елементи.розмір - 1) {
          вивести(М, ", ");
        }
        п += 1;
      }
      вивести(М, "])");
    } інакше якщо предмет.с == М.предмет_структури_словник {
      змінна предмет_словника = предмет як адреса<ПредметСловника>;
      вивести(М, "{");
      змінна п: натуральне = 0;
      поки п < предмет_словника.елементи.елементи.розмір {
        вивести_предмет(М, предмет_словника.елементи.елементи.дані[п].ключ, глибина + 1);
        вивести(М, "=");
        вивести_предмет(М, предмет_словника.елементи.елементи.дані[п].значення, глибина + 1);
        якщо п < (предмет_словника.елементи.елементи.розмір - 1) {
          вивести(М, ", ");
        }
        п += 1;
      }
      вивести(М, "}");
    } інакше якщо предмет.с == М.предмет_структури_байти {
      змінна предмет_байтів = предмет як адреса<ПредметБайтів>;
      вивести(М, "<байти ");
      вивести_позитивне(М, предмет_байтів.розмір);
      вивести(М, ">");
    } інакше якщо предмет.с == М.предмет_структури_Буфер {
      змінна предмет_буфера = предмет як адреса<ПредметБуфера>;
      вивести(М, "<буфер ");
      вивести_позитивне(М, предмет_буфера.значення.розмір);
      вивести(М, ">");
    } інакше якщо предмет.с == М.предмет_структури_Модуль {
      змінна предмет_модуля = предмет як адреса<ПредметМодуля>;
      вивести(М, "<модуль");
      якщо предмет_модуля.назва != пусто {
        вивести(М, " ");
        вивести(М, предмет_модуля.назва.значення);
      }
      вивести(М, "[");
      змінна п: натуральне = 0;
      поки п < предмет_модуля.властивості.елементи.розмір {
        вивести(М, предмет_модуля.властивості.елементи.дані[п].ключ.значення);
        
        якщо п < предмет_модуля.властивості.елементи.розмір - 1 {
          вивести(М, ", ");
        }
  
        п += 1;
      }
      вивести(М, "]");
      вивести(М, ">");
    } інакше якщо предмет.с == М.предмет_структури_Параметр {
      змінна предмет_параметра = предмет як адреса<ПредметПараметра>;
      вивести(М, "<параметр");
      якщо предмет_параметра.назва != пусто {
        вивести(М, " ");
        вивести(М, предмет_параметра.назва.значення);
      }
      вивести(М, ">");
    } інакше якщо предмет.с == М.предмет_структури_ДіапазонЧисел {
      змінна предмет_діапазону_чисел = предмет як адреса<ПредметДіапазонуЧисел>;
      вивести_предмет(М, предмет_діапазону_чисел.від як адреса<Предмет>, 0);
      вивести(М, "..");
      вивести_предмет(М, предмет_діапазону_чисел.до як адреса<Предмет>, 0);
    } інакше якщо предмет.с == М.предмет_структури_ПеребірДіапазонуЧисел {
      вивести(М, "<перебір_діапазону_чисел>");
    } інакше якщо предмет.с == М.предмет_структури_ПеребірСписку {
      вивести(М, "<перебір_списку>");
    } інакше якщо предмет.с == М.предмет_структури_ПеребірПослідовності {
      вивести(М, "<перебір_послідовності>");
    } інакше якщо предмет.с == М.предмет_структури_ПеребірТексту {
      вивести(М, "<перебір_тексту>");
    } інакше якщо предмет.с == М.предмет_структури_ПеребірБайтів {
      вивести(М, "<перебір_байтів>");
    } інакше {
      якщо предмет.с == пусто {
        вивести(М, "<предмет>");
      } інакше {
        вивести(М, предмет.с.назва.значення);
        вивести(М, "(");
        змінна складений_предмет = предмет як адреса<СкладенийПредмет>;
        вивести_властивості(М, складений_предмет.властивості, глибина);
        вивести(М, ")");
      }
    }
  }

  дія рідна_дія_вивести(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: натуральне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>) -> ПредметАбоСтанПадіння<Предмет> {
    змінна п: натуральне = 0;
    поки п < кількість_аргументів {
      вивести_предмет(М, аргументи[п], 0);
      якщо п != кількість_аргументів - 1 {
        вивести(М, " ");
      }
      п += 1;
    }
    вернути пусто;
  }

  дія рідна_дія_вивести_байти(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: натуральне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>) -> ПредметАбоСтанПадіння<Предмет> {
    змінна п: натуральне = 0;
    поки п < кількість_аргументів {
      змінна аргумент = аргументи[п];
      якщо аргумент.с == М.предмет_структури_байти {
        змінна предмет_байтів = аргумент як адреса<ПредметБайтів>;
        вивести_байти(М, предмет_байтів.розмір, предмет_байтів.дані);
      } інакше {
        вивести_предмет(М, аргумент, 0);
      }
      якщо п != кількість_аргументів - 1 {
        вивести(М, " ");
      }
      п += 1;
    }
    вернути пусто;
  }

  дія рідна_дія_друк(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: натуральне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>) -> ПредметАбоСтанПадіння<Предмет> {
    змінна п: натуральне = 0;
    поки п < кількість_аргументів {
      вивести_предмет(М, аргументи[п], 0);
      якщо п != кількість_аргументів - 1 {
        вивести(М, " ");
      }
      п += 1;
    }
    вивести(М, "\р");
    вернути пусто;
  }

  дія рідна_дія_друк_байти(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: натуральне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>) -> ПредметАбоСтанПадіння<Предмет> {
    змінна п: натуральне = 0;
    поки п < кількість_аргументів {
      змінна аргумент = аргументи[п];
      якщо аргумент.с == М.предмет_структури_байти {
        змінна предмет_байтів = аргумент як адреса<ПредметБайтів>;
        вивести_байти(М, предмет_байтів.розмір, предмет_байтів.дані);
      } інакше {
        вивести_предмет(М, аргумент, 0);
      }
      якщо п != кількість_аргументів - 1 {
        вивести(М, " ");
      }
      п += 1;
    }
    вивести(М, "\р");
    вернути пусто;
  }

  дія рідна_дія_дізнатись_назву(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: натуральне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>) -> ПредметАбоСтанПадіння<Предмет> {
    змінна аргумент_значення: адреса<Предмет> = пусто;
    змінна знайдено_аргумент_значення = ні;
    якщо іменовані_аргументи != пусто {
      знайдено_аргумент_значення = знайти_іменований_аргумент(М, іменовані_аргументи, створити_назву(М, "значення"), аргумент_значення::адреса);
    }
    якщо кількість_аргументів > 0 {
      якщо не знайдено_аргумент_значення {
        аргумент_значення = аргументи[0];
        знайдено_аргумент_значення = так;
      }
    }
    змінна предмет_модуля = аргумент_значення як адреса<ПредметМодуля>;
    вернути предмет_модуля.назва як адреса<Предмет>;
  }

  дія створити_предмет_рідної_дії_дізнатись_назву(М: адреса<Машина>) -> ПредметАбоСтанПадіння<Предмет> {
    змінна параметр_значення = створити_предмет_параметра(М, створити_назву(М, "значення"), пусто);
    змінна дані_параметрів_дії_дізнатись_назву = виділити_памʼять<адреса<ПредметПараметра>>(М, 1);
    дані_параметрів_дії_дізнатись_назву[0] = параметр_значення;
    вернути створити_предмет_рідної_дії(М, створити_назву(М, "дізнатись_назву"), 1, дані_параметрів_дії_дізнатись_назву, рідна_дія_дізнатись_назву, пусто, пусто, пусто) як адреса<Предмет>;
  }

  дія рідна_дія_дізнатись_структуру(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: натуральне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>) -> ПредметАбоСтанПадіння<Предмет> {
    змінна аргумент_значення: адреса<Предмет> = пусто;
    змінна знайдено_аргумент_значення = ні;
    якщо іменовані_аргументи != пусто {
      знайдено_аргумент_значення = знайти_іменований_аргумент(М, іменовані_аргументи, створити_назву(М, "значення"), аргумент_значення::адреса);
    }
    якщо кількість_аргументів > 0 {
      якщо не знайдено_аргумент_значення {
        аргумент_значення = аргументи[0];
        знайдено_аргумент_значення = так;
      }
    }
    якщо аргумент_значення == пусто {
      вернути пусто;
    }
    вернути аргумент_значення.с як адреса<Предмет>;
  }

  дія створити_предмет_рідної_дії_дізнатись_структуру(М: адреса<Машина>) -> ПредметАбоСтанПадіння<Предмет> {
    змінна параметр_значення = створити_предмет_параметра(М, створити_назву(М, "значення"), пусто);
    змінна дані_параметрів_дії_дізнатись_структуру = виділити_памʼять<адреса<ПредметПараметра>>(М, 1);
    дані_параметрів_дії_дізнатись_структуру[0] = параметр_значення;
    вернути створити_предмет_рідної_дії(М, створити_назву(М, "дізнатись_структуру"), 1, дані_параметрів_дії_дізнатись_структуру, рідна_дія_дізнатись_структуру, пусто, пусто, пусто) як адреса<Предмет>;
  }

  дія створити_модуль_мавка(М: адреса<Машина>) -> ПредметАбоСтанПадіння<ПредметМодуля> {
    змінна предмет_модуля_мавка = створити_предмет_модуля(М, створити_назву(М, "мавка"));
    
    змінна предмет_тексту_версія = створити_предмет_тексту_без_копіювання(М, отримати_версію_мавки_як_т8(М)) як адреса<Предмет>;
    якщо перевірити_чи_стан_падіння(М) {
      вернути пусто;
    }
    предмет_модуля_змінити_властивість(М, предмет_модуля_мавка, створити_назву(М, "версія"), предмет_тексту_версія, Місцезнаходження { пусто як адреса<ПредметТексту>, 0 });
    якщо перевірити_чи_стан_падіння(М) {
      вернути пусто;
    }

    вернути предмет_модуля_мавка;
  }

  місцева дія визначити_глобальні(М: адреса<Машина>) -> ніщо_або_стан_падіння {
    змінна предмет_дії_друк = створити_предмет_рідної_дії(М, створити_назву(М, "друк"), 0, пусто, рідна_дія_друк, пусто, пусто, пусто) як адреса<Предмет>;
    якщо перевірити_чи_стан_падіння(М) {
      вернути;
    }
    змінити_в_глобальному_середовищі(М, створити_назву(М, "друк"), предмет_дії_друк);
    якщо перевірити_чи_стан_падіння(М) {
      вернути;
    }
    
    змінна предмет_дії_друк_байти = створити_предмет_рідної_дії(М, створити_назву(М, "друк_байти"), 0, пусто, рідна_дія_друк_байти, пусто, пусто, пусто) як адреса<Предмет>;
    якщо перевірити_чи_стан_падіння(М) {
      вернути;
    }
    змінити_в_глобальному_середовищі(М, створити_назву(М, "друк_байти"), предмет_дії_друк_байти);
    якщо перевірити_чи_стан_падіння(М) {
      вернути;
    }

    змінна предмет_дії_вивести = створити_предмет_рідної_дії(М, створити_назву(М, "вивести"), 0, пусто, рідна_дія_вивести, пусто, пусто, пусто) як адреса<Предмет>;
    якщо перевірити_чи_стан_падіння(М) {
      вернути;
    }
    змінити_в_глобальному_середовищі(М, створити_назву(М, "вивести"), предмет_дії_вивести);
    якщо перевірити_чи_стан_падіння(М) {
      вернути;
    }

    змінна предмет_дії_вивести_байти = створити_предмет_рідної_дії(М, створити_назву(М, "вивести_байти"), 0, пусто, рідна_дія_вивести_байти, пусто, пусто, пусто) як адреса<Предмет>;
    якщо перевірити_чи_стан_падіння(М) {
      вернути;
    }
    змінити_в_глобальному_середовищі(М, створити_назву(М, "вивести_байти"), предмет_дії_вивести_байти);
    якщо перевірити_чи_стан_падіння(М) {
      вернути;
    }

    змінна предмет_дії_дізнатись_назву = створити_предмет_рідної_дії_дізнатись_назву(М);
    змінити_в_глобальному_середовищі(М, створити_назву(М, "дізнатись_назву"), предмет_дії_дізнатись_назву);
    якщо перевірити_чи_стан_падіння(М) {
      вернути;
    }

    змінна предмет_дії_дізнатись_структуру = створити_предмет_рідної_дії_дізнатись_структуру(М);
    змінити_в_глобальному_середовищі(М, створити_назву(М, "дізнатись_структуру"), предмет_дії_дізнатись_структуру);
    якщо перевірити_чи_стан_падіння(М) {
      вернути;
    }

    змінна предмет_модуля_мавка = створити_модуль_мавка(М);
    змінити_в_глобальному_середовищі(М, створити_назву(М, "мавка"), предмет_модуля_мавка як адреса<Предмет>);
    якщо перевірити_чи_стан_падіння(М) {
      вернути;
    }

    змінна предмет_числа_нескінченність = створити_предмет_числа(М, р64(1.0) / 0.0);
    змінити_в_глобальному_середовищі(М, створити_назву(М, "нескінченність"), предмет_числа_нескінченність як адреса<Предмет>);
    якщо перевірити_чи_стан_падіння(М) {
      вернути;
    }

    змінна предмет_числа_невизначеність = створити_предмет_числа(М, р64(0.0) / 0.0);
    змінити_в_глобальному_середовищі(М, створити_назву(М, "невизначеність"), предмет_числа_невизначеність як адреса<Предмет>);
    якщо перевірити_чи_стан_падіння(М) {
      вернути;
    }
  }
}