взяти визначення мавка;

секція мавка {
  // позначка: прохід по типах предмета
  місцева дія вивести_предмет(М: адреса<Машина>, предмет: адреса<Предмет>, глибина: позитивне) {
    якщо предмет == пусто {
      вивести(М, "пусто");
    } інакше якщо предмет.тип == М.предмет_структури_Структура {
      вивести(М, "<структура>");
    } інакше якщо предмет.тип == М.предмет_структури_Код {
      вивести(М, "<код>");
    } інакше якщо предмет.тип == М.предмет_структури_Середовище {
      вивести(М, "<середовище>");
    } інакше якщо предмет.тип == М.предмет_структури_Дія {
      вивести(М, "<дія>");
    } інакше якщо предмет.тип == М.предмет_структури_логічне {
      змінна предмет_логічного = предмет як адреса<ПредметЛогічного>;
      якщо предмет_логічного.значення == позитивне(так) {
        вивести(М, "так");
      } інакше {
        вивести(М, "ні");
      }
    } інакше якщо предмет.тип == М.предмет_структури_число {
      змінна предмет_числа = предмет як адреса<ПредметЧисла>;
      вивести_д64(М, предмет_числа.значення);
    } інакше якщо предмет.тип == М.предмет_структури_текст {
      змінна предмет_тексту = предмет як адреса<ПредметТексту>;
      якщо глибина > 0 {
        вивести(М, "\"");
        змінна текст_з_закодованими_недрукованими = т8 { 0, пусто };
        якщо отримати_з_т8_т8_з_закодованими_недрукованими(М, предмет_тексту.значення, текст_з_закодованими_недрукованими::адреса) == ні {
          // потім: помилка
        }
        вивести(М, текст_з_закодованими_недрукованими);
        звільнити_памʼять(М, текст_з_закодованими_недрукованими.дані);
        вивести(М, "\"");
      } інакше {
        вивести(М, предмет_тексту.значення);
      }
    } інакше якщо предмет.тип == М.предмет_структури_список {
      змінна предмет_списку = предмет як адреса<ПредметСписку>;
      вивести(М, "[");
      змінна п: позитивне = 0;
      поки п < предмет_списку.елементи.розмір {
        вивести_предмет(М, предмет_списку.елементи.дані[п], глибина + 1);
        якщо п < (предмет_списку.елементи.розмір - 1) {
          вивести(М, ", ");
        }
        п += 1;
      }
      вивести(М, "]");
    } інакше якщо предмет.тип == М.предмет_структури_словник {
      вивести(М, "<словник>");
    } інакше якщо предмет.тип == М.предмет_структури_байти {
      вивести(М, "<байти>");
    } інакше якщо предмет.тип == М.предмет_структури_Буфер {
      вивести(М, "<Буфер>");
    } інакше якщо предмет.тип == М.предмет_структури_Модуль {
      вивести(М, "<модуль>");
    } інакше якщо предмет.тип == М.предмет_структури_Тип {
      вивести(М, "<тип>");
    } інакше якщо предмет.тип == М.предмет_структури_Параметр {
      вивести(М, "<параметр>");
    } інакше якщо предмет.тип == М.предмет_структури_ДіапазонЧисел {
      вивести(М, "<ДіапазонЧисел>");
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірДіапазонуЧисел {
      вивести(М, "<ПеребірДіапазонуЧисел>");
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірСписку {
      вивести(М, "<ПеребірСписку>");
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірТексту {
      вивести(М, "<ПеребірТексту>");
    } інакше якщо предмет.тип == М.предмет_структури_Розширення {
      вивести(М, "<Розширення>");
    } інакше якщо предмет.тип == М.предмет_структури_ПеребірБайтів {
      вивести(М, "<ПеребірБайтів>");
    } інакше якщо предмет.тип == М.предмет_структури_Шлях {
      вивести(М, "<Шлях>");
    } інакше {
      якщо предмет.тип == пусто {
        вивести(М, "<предмет>");
      } інакше {
        вивести(М, предмет.тип.назва.значення);
        вивести(М, "(");
        змінна складений_предмет = предмет як адреса<СкладенийПредмет>;
        змінна п: позитивне = 0;
        поки п < складений_предмет.властивості.елементи.розмір {
          вивести(М, складений_предмет.властивості.елементи.дані[п].ключ.значення);
          вивести(М, "=");
          вивести_предмет(М, складений_предмет.властивості.елементи.дані[п].значення, глибина + 1);
          якщо п < складений_предмет.властивості.елементи.розмір - 1 {
            вивести(М, ", ");
          }
          п += 1;
        }
        вивести(М, ")");
      }
    }
  }

  дія рідна_дія_вивести(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>)-> ПредметАбоСтанПадіння<Предмет> {
    змінна п: позитивне = 0;
    поки п < кількість_аргументів {
      вивести_предмет(М, аргументи[п], 0);
      якщо п != кількість_аргументів - 1 {
        вивести(М, " ");
      }
      п += 1;
    }
    вернути пусто;
  }

  дія рідна_дія_друк(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>)-> ПредметАбоСтанПадіння<Предмет> {
    змінна п: позитивне = 0;
    поки п < кількість_аргументів {
      вивести_предмет(М, аргументи[п], 0);
      якщо п != кількість_аргументів - 1 {
        вивести(М, " ");
      }
      п += 1;
    }
    вивести(М, "\р");
    вернути пусто;
  }

  дія рідна_дія_дізнатись_назву(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>)-> ПредметАбоСтанПадіння<Предмет> {
    змінна аргумент_значення: адреса<Предмет> = пусто;
    змінна знайдено_аргумент_значення = ні;
    якщо іменовані_аргументи != пусто {
      знайдено_аргумент_значення = знайти_іменований_аргумент(М, іменовані_аргументи, створити_назву(М, "значення"), аргумент_значення::адреса);
    }
    якщо кількість_аргументів > 0 {
      якщо не знайдено_аргумент_значення {
        аргумент_значення = аргументи[0];
        знайдено_аргумент_значення = так;
      }
    }
    змінна предмет_модуля = аргумент_значення як адреса<ПредметМодуля>;
    вернути предмет_модуля.назва як адреса<Предмет>;
  }

  дія створити_предмет_рідної_дії_дізнатись_назву(М: адреса<Машина>)-> ПредметАбоСтанПадіння<Предмет> {
    змінна допустимі_структури_типу_параметра_значення = виділити_памʼять<адреса<ПредметСтруктури>>(М, 1);
    допустимі_структури_типу_параметра_значення[0] = М.предмет_структури_Модуль;
    змінна тип_параметра_значення = створити_предмет_типу(М, ні, Послідовність<адреса<ПредметСтруктури>> { 1, допустимі_структури_типу_параметра_значення });
    змінна параметр_значення = створити_предмет_параметра(М, створити_назву(М, "значення"), тип_параметра_значення, пусто);
    змінна дані_параметрів_дії_дізнатись_назву = виділити_памʼять<адреса<ПредметПараметра>>(М, 1);
    дані_параметрів_дії_дізнатись_назву[0] = параметр_значення;
    вернути створити_предмет_рідної_дії(М, створити_назву(М, "дізнатись_назву"), 1, дані_параметрів_дії_дізнатись_назву, пусто, рідна_дія_дізнатись_назву, пусто, пусто, пусто) як адреса<Предмет>;
  }

  дія рідна_дія_дізнатись_структуру(М: адреса<Машина>, предмет_дії: адреса<ПредметДії>, предмет_я: адреса<Предмет>, кількість_аргументів: позитивне, аргументи: памʼять<адреса<Предмет>>, іменовані_аргументи: адреса<ІменованіАргументи>)-> ПредметАбоСтанПадіння<Предмет> {
    змінна аргумент_значення: адреса<Предмет> = пусто;
    змінна знайдено_аргумент_значення = ні;
    якщо іменовані_аргументи != пусто {
      знайдено_аргумент_значення = знайти_іменований_аргумент(М, іменовані_аргументи, створити_назву(М, "значення"), аргумент_значення::адреса);
    }
    якщо кількість_аргументів > 0 {
      якщо не знайдено_аргумент_значення {
        аргумент_значення = аргументи[0];
        знайдено_аргумент_значення = так;
      }
    }
    якщо аргумент_значення == пусто {
      вернути пусто;
    }
    вернути аргумент_значення.тип як адреса<Предмет>;
  }

  дія створити_предмет_рідної_дії_дізнатись_структуру(М: адреса<Машина>)-> ПредметАбоСтанПадіння<Предмет> {
    змінна параметр_значення = створити_предмет_параметра(М, створити_назву(М, "значення"), пусто, пусто);
    змінна дані_параметрів_дії_дізнатись_структуру = виділити_памʼять<адреса<ПредметПараметра>>(М, 1);
    дані_параметрів_дії_дізнатись_структуру[0] = параметр_значення;
    вернути створити_предмет_рідної_дії(М, створити_назву(М, "дізнатись_структуру"), 1, дані_параметрів_дії_дізнатись_структуру, пусто, рідна_дія_дізнатись_структуру, пусто, пусто, пусто) як адреса<Предмет>;
  }

  місцева дія визначити_глобальні(М: адреса<Машина>)-> ПредметАбоСтанПадіння<Предмет> {
    змінна результат_створення_рідної_дії_друк = створити_предмет_рідної_дії(М, створити_назву(М, "друк"), 0, пусто, пусто, рідна_дія_друк, пусто, пусто, пусто) як адреса<Предмет>;
    якщо перевірити_чи_стан_падіння(М) {
      вернути результат_створення_рідної_дії_друк;
    }
    змінна результат_зміни_в_глобальному_середовищі = змінити_в_глобальному_середовищі(М, створити_назву(М, "друк"), результат_створення_рідної_дії_друк);
    якщо перевірити_чи_стан_падіння(М) {
      вернути результат_зміни_в_глобальному_середовищі;
    }

    змінна результат_створення_рідної_дії_вивести = створити_предмет_рідної_дії(М, створити_назву(М, "вивести"), 0, пусто, пусто, рідна_дія_вивести, пусто, пусто, пусто) як адреса<Предмет>;
    якщо перевірити_чи_стан_падіння(М) {
      вернути результат_створення_рідної_дії_вивести;
    }
    результат_зміни_в_глобальному_середовищі = змінити_в_глобальному_середовищі(М, створити_назву(М, "вивести"), результат_створення_рідної_дії_вивести);
    якщо перевірити_чи_стан_падіння(М) {
      вернути результат_зміни_в_глобальному_середовищі;
    }

    змінна предмет_дії_дізнатись_назву = створити_предмет_рідної_дії_дізнатись_назву(М);
    результат_зміни_в_глобальному_середовищі = змінити_в_глобальному_середовищі(М, створити_назву(М, "дізнатись_назву"), предмет_дії_дізнатись_назву);
    якщо перевірити_чи_стан_падіння(М) {
      вернути результат_зміни_в_глобальному_середовищі;
    }

    змінна предмет_дії_дізнатись_структуру = створити_предмет_рідної_дії_дізнатись_структуру(М);
    результат_зміни_в_глобальному_середовищі = змінити_в_глобальному_середовищі(М, створити_назву(М, "дізнатись_структуру"), предмет_дії_дізнатись_структуру);
    якщо перевірити_чи_стан_падіння(М) {
      вернути результат_зміни_в_глобальному_середовищі;
    }

    вернути пусто;
  }
}