взяти визначення ./Виділяч;
взяти визначення ./Друк;

секція біб {
  структура ЕлементРеєстру<К, З>;
  структура Реєстр<К, З>;

  структура ЕлементРеєстру<К, З> {
    ключ: К;
    значення: З;
    наступний: адреса<ЕлементРеєстру<К, З>>;
  }

  синонім ДіяЗмішуванняКлючаРеєстру<К, З> = (реєстр: адреса<Реєстр<К, З>>, ключ: К) -> натуральне;
  синонім ДіяПеревіркиКлючаРеєстру<К, З> = (реєстр: адреса<Реєстр<К, З>>, а: К, б: К) -> логічне;
  синонім ДіяПередЗаміноюЕлементаРеєстру<К, З> = (реєстр: адреса<Реєстр<К, З>>, ак: К, аз: З, бк: адреса<К>, бз: адреса<З>) -> ніщо;
  синонім ДіяПередВидаленнямЕлементаРеєстру<К, З> = (реєстр: адреса<Реєстр<К, З>>, ключ: К, значення: З) -> ніщо;

  структура Реєстр<К, З> {
    розмір: натуральне;
    дані: памʼять<адреса<ЕлементРеєстру<К, З>>>;
    вмісткість: натуральне;
    виділяч: адреса<Виділяч>;
    аргумент: невідома_адреса;
    дія_змішування: ДіяЗмішуванняКлючаРеєстру<К, З>;
    дія_перевірки: ДіяПеревіркиКлючаРеєстру<К, З>;
    дія_перед_заміною: ДіяПередЗаміноюЕлементаРеєстру<К, З>;
    дія_перед_видаленням: ДіяПередВидаленнямЕлементаРеєстру<К, З>;
  }

  дія виділити_реєстр<К, З>(виділяч: адреса<Виділяч>,
                            початкова_вмісткість: натуральне,
                            аргумент: невідома_адреса,
                            дія_змішування: ДіяЗмішуванняКлючаРеєстру<К, З>,
                            дія_перевірки: ДіяПеревіркиКлючаРеєстру<К, З>,
                            дія_перед_заміною: ДіяПередЗаміноюЕлементаРеєстру<К, З>,
                            дія_перед_видаленням: ДіяПередВидаленнямЕлементаРеєстру<К, З>) -> адреса<Реєстр<К, З>> {
    змінна реєстр = виділити<Реєстр<К, З>>(виділяч);

    реєстр.розмір = 0;

    якщо початкова_вмісткість > 0 {
      реєстр.дані = виділити_памʼять<адреса<ЕлементРеєстру<К, З>>>(виділяч, початкова_вмісткість);
    } інакше {
      реєстр.дані = пусто;
    }

    реєстр.вмісткість = початкова_вмісткість;
    реєстр.виділяч = виділяч;
    реєстр.аргумент = аргумент;
    реєстр.дія_змішування = дія_змішування;
    реєстр.дія_перевірки = дія_перевірки;
    реєстр.дія_перед_заміною = дія_перед_заміною;
    реєстр.дія_перед_видаленням = дія_перед_видаленням;

    змінна п: натуральне = 0;

    поки п < реєстр.вмісткість {
      реєстр.дані[п] = пусто як адреса<ЕлементРеєстру<К, З>>;
      п += 1;
    }

    вернути реєстр;
  }

  дія розширити_реєстр<К, З>(реєстр: адреса<Реєстр<К, З>>, нова_вмісткість: натуральне) {
    якщо нова_вмісткість == 0 {
      нова_вмісткість = реєстр.вмісткість * 2;
    } інакше якщо нова_вмісткість <= реєстр.вмісткість {
      вернути;
    }

    змінна нові_дані = виділити_памʼять<адреса<ЕлементРеєстру<К, З>>>(реєстр.виділяч, нова_вмісткість);

    змінна п: натуральне = 0;

    поки п < нова_вмісткість {
      нові_дані[п] = пусто як адреса<ЕлементРеєстру<К, З>>;

      п += 1;
    }

    п = 0;

    поки п < реєстр.вмісткість {
      змінна поточний_елемент = реєстр.дані[п];

      поки поточний_елемент != пусто {
        змінна нова_позиція = реєстр.дія_змішування(реєстр, поточний_елемент.ключ) % нова_вмісткість;

        змінна наступний = поточний_елемент.наступний;

        поточний_елемент.наступний = нові_дані[нова_позиція];

        нові_дані[нова_позиція] = поточний_елемент;

        поточний_елемент = наступний;
      }

      п += 1;
    }

    звільнити_памʼять(реєстр.виділяч, реєстр.дані);

    реєстр.дані = нові_дані;
    реєстр.вмісткість = нова_вмісткість;
  }

  дія змінити_в_реєстрі<К, З>(реєстр: адреса<Реєстр<К, З>>, ключ: К, значення: З) {
    якщо реєстр.вмісткість == 0 {
      реєстр.дані = виділити_памʼять<адреса<ЕлементРеєстру<К, З>>>(реєстр.виділяч, 1);
      реєстр.вмісткість = 1;
      реєстр.дані[0] = пусто як адреса<ЕлементРеєстру<К, З>>;
    } інакше якщо ((д64(реєстр.розмір) / д64(реєстр.вмісткість)) > 0.7) {
       розширити_реєстр<К, З>(реєстр, 0);
    }

    змінна позиція = реєстр.дія_змішування(реєстр, ключ) % реєстр.вмісткість;

    змінна елемент = реєстр.дані[позиція];

    поки елемент != пусто {
      якщо реєстр.дія_перевірки(реєстр, елемент.ключ, ключ) {
        якщо реєстр.дія_перед_заміною != пусто {
          реєстр.дія_перед_заміною(реєстр, елемент.ключ, елемент.значення, ключ::адреса, значення::адреса);
        }

        елемент.ключ = ключ;
        елемент.значення = значення;

        вернути;
      }

      елемент = елемент.наступний;
    }

    змінна новий_елемент = виділити<ЕлементРеєстру<К, З>>(реєстр.виділяч);
    новий_елемент.ключ = ключ;
    новий_елемент.значення = значення;
    новий_елемент.наступний = реєстр.дані[позиція];
    реєстр.дані[позиція] = новий_елемент;

    реєстр.розмір += 1;
  }

  дія знайти_в_реєстрі<К, З>(реєстр: адреса<Реєстр<К, З>>, ключ: К, вихід: адреса<З>) -> логічне {
    якщо реєстр.вмісткість == 0 {
      вернути ні;
    }

    змінна позиція = реєстр.дія_змішування(реєстр, ключ) % реєстр.вмісткість;

    змінна елемент = реєстр.дані[позиція];

    поки елемент != пусто {
      якщо реєстр.дія_перевірки(реєстр, елемент.ключ, ключ) {
        вихід::вміст = елемент.значення;
        вернути так;
      }

      елемент = елемент.наступний;
    }

    вернути ні;
  }

  дія видалити_з_реєстру<К, З>(реєстр: адреса<Реєстр<К, З>>, ключ: К) {
    змінна позиція = реєстр.дія_змішування(реєстр, ключ) % реєстр.вмісткість;

    змінна елемент = реєстр.дані[позиція];
    змінна попередній: адреса<ЕлементРеєстру<К, З>> = пусто;

    поки елемент != пусто {
      якщо реєстр.дія_перевірки(реєстр, елемент.ключ, ключ) {
        якщо реєстр.дія_перед_видаленням != пусто {
          реєстр.дія_перед_видаленням(реєстр, елемент.ключ, елемент.значення);
        }

        якщо попередній == пусто {
          реєстр.дані[позиція] = елемент.наступний;
        } інакше {
          попередній.наступний = елемент.наступний;
        }

        звільнити(реєстр.виділяч, елемент);

        реєстр.розмір -= 1;

        вернути;
      }

      попередній = елемент;
      елемент = елемент.наступний;
    }
  }

  дія перебрати_реєстр<К, З>(реєстр: адреса<Реєстр<К, З>>, дія_перебору: (реєстр: адреса<Реєстр<К, З>>, аргумент: невідома_адреса, ключ: К, значення: З) -> логічне, аргумент: невідома_адреса) -> логічне {
    змінна п: натуральне = 0;

    поки п < реєстр.вмісткість {
      змінна елемент = реєстр.дані[п];

      поки елемент != пусто {
        якщо дія_перебору(реєстр, аргумент, елемент.ключ, елемент.значення) == ні {
          вернути ні;
        }

        елемент = елемент.наступний;
      }

      п += 1;
    }

    вернути так;
  }

  дія звільнити_реєстр<К, З>(реєстр: адреса<Реєстр<К, З>>) {
    змінна п: натуральне = 0;

    поки п < реєстр.вмісткість {
      змінна елемент = реєстр.дані[п];

      поки елемент != пусто {
        якщо реєстр.дія_перед_видаленням != пусто {
          реєстр.дія_перед_видаленням(реєстр, елемент.ключ, елемент.значення);
        }

        змінна наступний = елемент.наступний;

        звільнити(реєстр.виділяч, елемент);

        елемент = наступний;
      }

      п += 1;
    }

    звільнити_памʼять(реєстр.виділяч, реєстр.дані);
    звільнити(реєстр.виділяч, реєстр);
  }

  дія дія_змішування_т8<З>(реєстр: адреса<Реєстр<т8, З>>, ключ: т8) -> натуральне {
    змінна змішане: натуральне = 5381;
    змінна п: натуральне = 0;

    поки п < ключ.розмір {
      змішане = (змішане * 33) + натуральне(ключ.дані[п]);
      
      п += 1;
    }

    вернути змішане;
  }

  дія дія_перевірки_т8<З>(реєстр: адреса<Реєстр<т8, З>>, а: т8, б: т8) -> логічне {
    якщо а.розмір != б.розмір {
      вернути ні;
    }

    змінна п: натуральне = 0;

    поки п < а.розмір {
      якщо а.дані[п] != б.дані[п] {
        вернути ні;
      }

      п += 1;
    }

    вернути так;
  }

  дія дія_перед_заміною_у_текстовому_реєстру<З>(реєстр: адреса<Реєстр<т8, З>>, ак: т8, аз: З, бк: адреса<т8>, бз: адреса<З>) {
  }

  дія дія_перед_видаленням_з_текстового_реєстру<З>(реєстр: адреса<Реєстр<т8, З>>, ключ: т8, значення: З) {
  }

  дія виділити_текстовий_реєстр<З>(виділяч: адреса<Виділяч>,
                                   початкова_вмісткість: натуральне,
                                   аргумент: невідома_адреса) -> адреса<Реєстр<т8, З>> {
    вернути виділити_реєстр<т8, З>(
      виділяч,
      початкова_вмісткість,
      аргумент,
      дія_змішування_т8<З>,
      дія_перевірки_т8<З>,
      дія_перед_заміною_у_текстовому_реєстру<З>,
      дія_перед_видаленням_з_текстового_реєстру<З>
    );
  }
}