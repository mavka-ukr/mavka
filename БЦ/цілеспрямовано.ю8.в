взяти визначення ./Виділяч;
взяти визначення ./Накопичувач;
взяти визначення ./КД;
взяти визначення ./Друк;

секція цілеспрямовано {
  дія перевірити_чи_Т_рівні<Т>(а: Т, б: Т): логічне {
    якщо а.розмір != б.розмір {
      вернути ні;
    }

    змінна п: позитивне = 0;

    поки п < а.розмір {
      якщо а.дані[п] != б.дані[п] {
        вернути ні;
      }
      п += 1;
    }

    вернути так;
  }

  дія перевірити_чи_Т_починається_на<Т>(значення: Т, очікуване: Т): логічне {
    якщо значення.розмір < очікуване.розмір {
      вернути ні;
    }

    змінна п: позитивне = 0;

    поки п < очікуване.розмір {
      якщо очікуване.дані[п] != значення.дані[п] {
        вернути ні;
      }

      п += 1;
    }

    вернути так;
  }

  структура можливо<Т> {
    заповнено: позитивне;
    значення: Т;
  }

  структура Опція<Т> {
    ключ: Т;
    значення: можливо<Т>;
  }

  структура Опції<Т> {
    розмір: позитивне;
    дані: памʼять<Опція<Т>>;
  }

  структура ВихідКоманди<Т> {
    значення: Т;
    опції: Опції<Т>;
  }

  структура ВиходиКоманди<Т> {
    розмір: позитивне;
    дані: памʼять<ВихідКоманди<Т>>;
  }

  структура ВхідКоманди<Т> {
    значення: Т;
    опції: Опції<Т>;
  }

  структура ВходиКоманди<Т> {
    розмір: позитивне;
    дані: памʼять<ВхідКоманди<Т>>;
  }

  структура Команда<Т> {
    опції_програми: Опції<Т>;
    виходи: ВиходиКоманди<Т>;
    команда: Т;
    опції_команди: Опції<Т>;
    входи: ВходиКоманди<Т>;
  }

  структура АргументиДляРозбору<Т> {
    розмір: позитивне;
    дані: памʼять<Т>;
  }

  структура ДоступніКомандиДляРозбору<Т> {
    розмір: позитивне;
    дані: памʼять<Т>;
  }

  дія розібрати_опцію<Т>(виділяч: адреса<біб::Виділяч>,
                         аргументи: АргументиДляРозбору<Т>,
                         позиція_початку: позитивне,
                         знак_початку_опції: Т,
                         знак_розділення_опції: Т,
                         вихід: адреса<Опція<Т>>,
                         вихід_позиції_кінця: адреса<позитивне>): логічне {
    якщо позиція_початку >= аргументи.розмір {
      стрибнути вихід_з_помилкою;
    }

    змінна поточна_позиція = позиція_початку;
    змінна аргумент = аргументи.дані[поточна_позиція];

    якщо перевірити_чи_Т_починається_на<Т>(аргумент, знак_початку_опції) {
      змінна опція = Опція<Т> {
        ключ = Т { 0, пусто },
        значення = можливо<Т> { позитивне(ні), Т { 0, пусто } }
      };

      змінна пп: позитивне = 0;

      поки пп < аргумент.розмір {
        якщо аргумент.дані[пп] == знак_розділення_опції.дані[0] {
          опція.ключ = Т {
            пп - 2,
            аргумент.дані[2]::адреса як памʼять<п8>
          };
          опція.значення = можливо<Т> {
            позитивне(так),
            Т {
              аргумент.розмір - пп - 1,
              аргумент.дані[пп + 1]::адреса як памʼять<п8>
            }
          };

          вихід::вміст = опція;
          вихід_позиції_кінця::вміст = поточна_позиція;
          вернути так;
        }

        пп += 1;
      }

      опція.ключ = Т {
        аргумент.розмір - 2,
        аргумент.дані[2]::адреса як памʼять<п8>
      };

      вихід::вміст = опція;
      вихід_позиції_кінця::вміст = поточна_позиція;
      вернути так;
    }

  вихід_з_помилкою:
    вернути ні;
  }

  дія розібрати_опції<Т>(виділяч: адреса<біб::Виділяч>,
                        аргументи: АргументиДляРозбору<Т>,
                        позиція_початку: позитивне,
                        знак_початку_опції: Т,
                        знак_розділення_опції: Т,
                        вихід: адреса<Опції<Т>>,
                        вихід_позиції_кінця: адреса<позитивне>): логічне {
    якщо позиція_початку >= аргументи.розмір {
      вернути ні;
    }

    змінна опції = біб::зробити_накопичувач<Опція<Т>>(виділяч, 0);

    змінна поточна_позиція = позиція_початку;

    змінна опція: Опція<Т>;

    якщо розібрати_опцію<Т>(виділяч, аргументи, поточна_позиція, знак_початку_опції, знак_розділення_опції, опція::адреса, поточна_позиція::адреса) {
      біб::покласти_в_накопичувач<Опція<Т>>(
        опції::адреса,
        опція
      );
    } інакше {
      стрибнути вихід_з_помилкою;
    }

    поточна_позиція += 1;

    поки поточна_позиція < аргументи.розмір {
      змінна аргумент = аргументи.дані[поточна_позиція];

      якщо розібрати_опцію<Т>(виділяч, аргументи, поточна_позиція, знак_початку_опції, знак_розділення_опції, опція::адреса, поточна_позиція::адреса) {
        біб::покласти_в_накопичувач<Опція<Т>>(
          опції::адреса,
          опція
        );
      } інакше {
        стрибнути успішний_вихід;
      }

      поточна_позиція += 1;
    }

  успішний_вихід:
    вихід::вміст = Опції<Т> { опції.розмір, опції.дані };
    вихід_позиції_кінця::вміст = поточна_позиція - 1;
    вернути так;

  вихід_з_помилкою:
    біб::звільнити_значення_накопичувача<Опція<Т>>(опції);
    вернути ні;
  }

  дія зробити_розібрану_команду<Т>(): Команда<Т> {
    вернути Команда<Т> {
      опції_програми = Опції<Т> { 0, пусто },
      виходи = ВиходиКоманди<Т> { 0, пусто },
      команда = Т { 0, пусто },
      опції_команди = Опції<Т> { 0, пусто },
      входи = ВходиКоманди<Т> { 0, пусто }
    };
  }

  дія знищити_розібрану_команду<Т>(виділяч: адреса<біб::Виділяч>, розібрана_команда: Команда<Т>) {
    біб::звільнити_памʼять(виділяч, розібрана_команда.опції_програми.дані);

    змінна п: позитивне = 0;

    поки п < розібрана_команда.виходи.розмір {
      біб::звільнити_памʼять(виділяч, розібрана_команда.виходи.дані[п].опції.дані);
      п += 1;
    }
    біб::звільнити_памʼять(виділяч, розібрана_команда.виходи.дані);

    біб::звільнити_памʼять(виділяч, розібрана_команда.опції_команди.дані);

    п = 0;

    поки п < розібрана_команда.входи.розмір {
      біб::звільнити_памʼять(виділяч, розібрана_команда.входи.дані[п].опції.дані);
      п += 1;
    }
    біб::звільнити_памʼять(виділяч, розібрана_команда.входи.дані);
  }

  // не робить копії значень аргументів
  дія розібрати_команду<Т>(виділяч: адреса<біб::Виділяч>,
                           аргументи: АргументиДляРозбору<Т>,
                           доступні_команди: ДоступніКомандиДляРозбору<Т>,
                           знак_початку_опції: Т,
                           знак_розділення_опції: Т,
                           вихід: адреса<Команда<Т>>): логічне {
    змінна розібрана_команда = зробити_розібрану_команду<Т>();

    якщо аргументи.розмір == 0 {
      стрибнути успішний_вихід;
    }

    змінна п: позитивне = 0;

  розбір_опцій_програми:
    якщо розібрати_опції<Т>(виділяч, аргументи, п, знак_початку_опції, знак_розділення_опції, розібрана_команда.опції_програми::адреса, п::адреса) {
      п += 1;
    }

    якщо п >= аргументи.розмір {
      стрибнути успішний_вихід;
    }

  розбір_вихідних:
    змінна виходи = біб::зробити_накопичувач<ВихідКоманди<Т>>(виділяч, 0);

    поки п < аргументи.розмір {
      змінна аргумент = аргументи.дані[п];

      змінна пп: позитивне = 0;
      поки пп < доступні_команди.розмір {
        якщо перевірити_чи_Т_рівні<Т>(аргумент, доступні_команди.дані[пп]) {
          розібрана_команда.команда = аргумент;
          розібрана_команда.виходи = ВиходиКоманди<Т> { виходи.розмір, виходи.дані };

          п += 1;

          стрибнути розбір_опцій_команди;
        }

        пп += 1;
      }

      біб::покласти_в_накопичувач<ВихідКоманди<Т>>(
        виходи::адреса,
        ВихідКоманди<Т> {
          значення = аргумент,
          опції = Опції<Т> { 0, пусто }
        }
      );

      п += 1;

      якщо розібрати_опції<Т>(виділяч, аргументи, п, знак_початку_опції, знак_розділення_опції, виходи.дані[виходи.розмір - 1].опції::адреса, п::адреса) {
        п += 1;
      }
    }

    розібрана_команда.виходи = ВиходиКоманди<Т> { виходи.розмір, виходи.дані };

    якщо розібрана_команда.команда.розмір == 0 {
      стрибнути вихід_з_помилкою;
    }

  розбір_опцій_команди:
    якщо розібрати_опції<Т>(виділяч, аргументи, п, знак_початку_опції, знак_розділення_опції, розібрана_команда.опції_команди::адреса, п::адреса) {
      п += 1;
    }

  розбір_вхідних:
    змінна входи = біб::зробити_накопичувач<ВхідКоманди<Т>>(виділяч, 0);

    поки п < аргументи.розмір {
      змінна аргумент = аргументи.дані[п];

      біб::покласти_в_накопичувач<ВхідКоманди<Т>>(
        входи::адреса,
        ВхідКоманди<Т> {
          значення = аргумент,
          опції = Опції<Т> { 0, пусто }
        }
      );

      п += 1;

      якщо розібрати_опції<Т>(виділяч, аргументи, п, знак_початку_опції, знак_розділення_опції, входи.дані[входи.розмір - 1].опції::адреса, п::адреса) {
        п += 1;
      }
    }

    розібрана_команда.входи = ВходиКоманди<Т> { входи.розмір, входи.дані };

  успішний_вихід:
    вихід::вміст = розібрана_команда;
    вернути так;

  вихід_з_помилкою:
    знищити_розібрану_команду<Т>(виділяч, розібрана_команда);
    вернути ні;
  }
}