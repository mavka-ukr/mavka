#include <arpa/inet.h>
#include <idn2.h>
#include <liburing.h>
#include <netdb.h>
#include <netinet/in.h>
#include <poll.h>
#include <pthread.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/timerfd.h>
#include <unistd.h>
// do not remove this comment
#define USE_VARARGS
#define PREFER_STDARG
#include <readline/readline.h>

#define TURBO_DEBUG

#define QUEUE_DEPTH 8
#define BUF_SIZE 1024

int make_nonblocking(int fd) {
  int flags = fcntl(fd, F_GETFL, 0);
  return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
}

#define п8 uint8_t
#define п16 uint16_t
#define п32 uint32_t
#define п64 uint64_t
#define ц8 int8_t
#define ц16 int16_t
#define ц32 int32_t
#define ц64 int64_t
#define д32 float
#define д64 double
#define логічне uint8_t
#define позитивне п64
#define ціле ц64
#define дійсне д64
#define ніщо void
#define невідома_адреса void*
#define невідома_памʼять void*
#define памʼять_п8 п8*
#define адреса_памʼять_п8 п8**
#define памʼять_памʼять_п8 п8**
#define адреса_позитивне позитивне*
typedef struct т8 {
  позитивне розмір;
  памʼять_п8 дані;
} т8;
typedef struct ю8 {
  позитивне розмір;
  памʼять_п8 дані;
} ю8;
#define памʼять_т8 т8*
#define памʼять_ю8 ю8*

static char* перетворити_ю8_в_chars(ю8 value) {
  char* copy = (char*)malloc(value.розмір + 1);
  memcpy(copy, value.дані, value.розмір);
  copy[value.розмір] = 0;
  return copy;
}

typedef struct Виділяч Виділяч;

struct Виділяч {
  невідома_адреса користувацькі_дані;

  памʼять_п8 (*виділити_сиру_памʼять)(Виділяч* виділяч, позитивне розмір);

  памʼять_п8 (*перевиділити_сиру_памʼять)(Виділяч* виділяч,
                                          памʼять_п8 значення,
                                          позитивне новий_розмір);

  void (*звільнити_сиру_памʼять)(Виділяч* виділяч, памʼять_п8 значення);
};

extern Виділяч* __біб__отримати_системний_виділяч();

// <турбо.ю8.в>

typedef struct Турбіна Турбіна;
typedef struct Подія Подія;
typedef struct Ввід Ввід;
typedef struct Відкладене Відкладене;
typedef struct Періодичне Періодичне;
typedef struct ІнтернетЗвʼязок ІнтернетЗвʼязок;
typedef struct ЕлементЧергиЗаписуІнтернетЗвʼязку
    ЕлементЧергиЗаписуІнтернетЗвʼязку;
typedef struct ПрочитанеІнтернетЗвʼязку ПрочитанеІнтернетЗвʼязку;
typedef struct ІнтернетОбслуговувач ІнтернетОбслуговувач;
typedef struct ТурбоПомилкаВідкликуТурбіни ТурбоПомилкаВідкликуТурбіни;

typedef enum {
  ТипПодіїІнтернетОбслуговувачКлієнтПідключено,
  ТипПодіїІнтернетЗвʼязокПідключено,
  ТипПодіїІнтернетЗвʼязокПрочитано,
  ТипПодіїІнтернетЗвʼязокЗаписано,
  ТипПодіїВідкладенеГотово,
  ТипПодіїВідкладенеСкасовано,
  ТипПодіїПеріодичнеГотово,
  ТипПодіїПеріодичнеСкасовано,
  ТипПодіїВвід
} ТипПодії;

typedef логічне (*ТурбоВідкликТурбіни)(
    Турбіна* турбіна,
    невідома_адреса аргумент,
    ТурбоПомилкаВідкликуТурбіни* вихід_помилки);

typedef логічне (*ТурбоВідкликВідкладеного)(Турбіна* турбіна,
                                            Відкладене* відкладене,
                                            невідома_адреса аргумент,
                                            логічне скасовано,
                                            логічне успішно,
                                            ц32 код_помилки);

typedef логічне (*ТурбоВідкликПеріодичного)(Турбіна* турбіна,
                                            Періодичне* періодичне,
                                            невідома_адреса аргумент,
                                            логічне скасовано,
                                            логічне успішно,
                                            ц32 код_помилки);

typedef логічне (*ТурбоВідкликВводу)(Турбіна* турбіна,
                                     невідома_адреса аргумент,
                                     логічне скасовано,
                                     позитивне розмір_префікса,
                                     памʼять_п8 дані_префікса,
                                     позитивне розмір,
                                     памʼять_п8 дані);

typedef void (*ТурбоОбробникПідключенняІнтернетЗвʼязку)(
    Турбіна* турбіна,
    ІнтернетЗвʼязок* інтернет_звʼязок,
    невідома_адреса аргумент,
    логічне успішно,
    позитивне код_помилки);

typedef void (*ТурбоОбробникВідключенняІнтернетЗвʼязку)(
    Турбіна* турбіна,
    ІнтернетЗвʼязок* інтернет_звʼязок,
    невідома_адреса аргумент,
    логічне з_помилкою,
    позитивне код_помилки);

typedef void (*ТурбоОбробникДанихІнтернетЗвʼязку)(
    Турбіна* турбіна,
    ІнтернетЗвʼязок* інтернет_звʼязок,
    невідома_адреса аргумент,
    позитивне розмір,
    памʼять_п8 дані);

typedef void (*ТурбоОбробникЗакриттяІнтернетЗвʼязку)(
    Турбіна* турбіна,
    ІнтернетЗвʼязок* інтернет_звʼязок,
    невідома_адреса аргумент);

typedef void (*ТурбоОбробникЗаписуІнтернетЗвʼязку)(
    Турбіна* турбіна,
    ІнтернетЗвʼязок* інтернет_звʼязок,
    невідома_адреса аргумент_інтернет_звʼязку,
    невідома_адреса аргумент_запису,
    позитивне розмір,
    памʼять_п8 дані);

typedef void (*ТурбоОбробникЗапускуІнтернетОбслуговувача)(
    Турбіна* турбіна,
    ІнтернетОбслуговувач* інтернет_обслуговувач,
    невідома_адреса аргумент,
    логічне успішно,
    ц32 код_помилки,
    позитивне іа,
    позитивне порт);

typedef void (*ТурбоОбробникПідключенняКлієнтаІнтернетОбслуговувача)(
    Турбіна* турбіна,
    ІнтернетОбслуговувач* інтернет_обслуговувач,
    ІнтернетЗвʼязок* інтернет_звʼязок,
    невідома_адреса аргумент);

typedef void (*ТурбоОбробникЗупинкиІнтернетОбслуговувача)(
    Турбіна* турбіна,
    ІнтернетОбслуговувач* інтернет_обслуговувач,
    невідома_адреса аргумент);

struct ІнтернетОбслуговувач {
  int fd;
  ТурбоОбробникПідключенняКлієнтаІнтернетОбслуговувача
  обробник_підключення_клієнта;
  ТурбоОбробникЗупинкиІнтернетОбслуговувача обробник_зупинки;
  невідома_адреса аргумент;
};

struct Ввід {
  int read_fd;
  int write_fd;
  pthread_t tid;
  ТурбоВідкликВводу відклик;
  невідома_адреса аргумент;
  позитивне розмір_префікса;
  памʼять_п8 дані_префікса;
  позитивне розмір;
  памʼять_п8 дані;
  памʼять_п8 дані_прочитаного;
};

void доповнити_дані(Турбіна* турбіна,
                    позитивне* розмір,
                    памʼять_п8* дані,
                    позитивне розмір_доповнення,
                    памʼять_п8 дані_доповнення) {
  позитивне р = *розмір;
  *розмір = *розмір + розмір_доповнення;
  *дані = realloc(*дані, *розмір);
  memcpy(*дані + р, дані_доповнення, розмір_доповнення);
}

struct Відкладене {
  int fd;
  uint64_t expirations;
  ТурбоВідкликВідкладеного відклик;
  невідома_адреса аргумент;
  Подія* подія;
};

struct Періодичне {
  int fd;
  uint64_t expirations;
  ТурбоВідкликПеріодичного відклик;
  невідома_адреса аргумент;
  Подія* подія;
};

struct ІнтернетЗвʼязок {
  int fd;
  ТурбоОбробникПідключенняІнтернетЗвʼязку обробник_підключення;
  ТурбоОбробникВідключенняІнтернетЗвʼязку обробник_відключення;
  ТурбоОбробникДанихІнтернетЗвʼязку обробник_даних;
  ТурбоОбробникЗакриттяІнтернетЗвʼязку обробник_закриття;
  невідома_адреса аргумент;
  ЕлементЧергиЗаписуІнтернетЗвʼязку* перший_елемент_черги_запису;
  ЕлементЧергиЗаписуІнтернетЗвʼязку* останній_елемент_черги_запису;
  логічне очікує_закінчення_запису;
  логічне закінчено_запис;
  логічне закінчено_читання;
  логічне очікує_відключення;
  логічне відключення_з_помилкою;
  позитивне код_помилки_відключення;
};

struct ЕлементЧергиЗаписуІнтернетЗвʼязку {
  ЕлементЧергиЗаписуІнтернетЗвʼязку* наступний;
  ІнтернетЗвʼязок* інтернет_звʼязок;
  позитивне розмір;
  памʼять_п8 дані;
  позитивне розмір_записаного;
  ТурбоОбробникЗаписуІнтернетЗвʼязку обробник_запису;
  невідома_адреса аргумент;
};

struct ПрочитанеІнтернетЗвʼязку {
  ІнтернетЗвʼязок* інтернет_звʼязок;
  позитивне розмір;
  памʼять_п8 дані;
};

struct Подія {
  ТипПодії тип;
  union {
    Ввід* ввід;
    Відкладене* відкладене;
    Періодичне* періодичне;
    ІнтернетОбслуговувач* інтернет_обслуговувач;
    ІнтернетЗвʼязок* інтернет_звʼязок;
    ЕлементЧергиЗаписуІнтернетЗвʼязку* елемент_черги_запису_інтернет_звʼязку;
    ПрочитанеІнтернетЗвʼязку* прочитане_інтернет_звʼязку;
  } обʼєкт;
};

struct Турбіна {
  Виділяч* виділяч;
  struct io_uring ring;
  int qcount;
  логічне очікує_ввід;
};

struct ТурбоПомилкаВідкликуТурбіни {
  позитивне тип;
  невідома_адреса дані;
};

extern Турбіна* __турбо__створити_турбіну(Виділяч* виділяч) {
  Турбіна* турбіна =
      (Турбіна*)виділяч->виділити_сиру_памʼять(виділяч, sizeof(Турбіна));

  турбіна->виділяч = виділяч;

  io_uring_queue_init(QUEUE_DEPTH, &турбіна->ring, 0);

  турбіна->qcount = 0;
  турбіна->очікує_ввід = false;

  return турбіна;
}

Турбіна* глобальна_турбіна = NULL;

extern Турбіна* __турбо__отримати_глобальну_турбіну() {
  return глобальна_турбіна;
}

extern void __турбо__змінити_глобальну_турбіну(Турбіна* турбіна) {
  глобальна_турбіна = турбіна;
}

void слухати_ввід(Турбіна* турбіна, Ввід* ввід) {
  Подія* подія = (Подія*)турбіна->виділяч->виділити_сиру_памʼять(
      турбіна->виділяч, sizeof(Подія));
  подія->тип = ТипПодіїВвід;
  подія->обʼєкт.ввід = ввід;

  struct io_uring_sqe* sqe = io_uring_get_sqe(&турбіна->ring);
  io_uring_prep_read(sqe, ввід->read_fd, ввід->дані_прочитаного, 256, 0);
  io_uring_sqe_set_data(sqe, подія);
  io_uring_submit(&турбіна->ring);

  турбіна->qcount++;
}

void слухати_відкладене_готово(Турбіна* турбіна, Відкладене* відкладене) {
  Подія* подія = (Подія*)турбіна->виділяч->виділити_сиру_памʼять(
      турбіна->виділяч, sizeof(Подія));
  подія->тип = ТипПодіїВідкладенеГотово;
  подія->обʼєкт.відкладене = відкладене;

  struct io_uring_sqe* sqe = io_uring_get_sqe(&турбіна->ring);
  io_uring_prep_read(sqe, відкладене->fd, &відкладене->expirations,
                     sizeof(відкладене->expirations), 0);
  io_uring_sqe_set_data(sqe, подія);
  io_uring_submit(&турбіна->ring);

  турбіна->qcount++;

  відкладене->подія = подія;
}

void слухати_періодичне_готово(Турбіна* турбіна, Періодичне* періодичне) {
  Подія* подія = (Подія*)турбіна->виділяч->виділити_сиру_памʼять(
      турбіна->виділяч, sizeof(Подія));
  подія->тип = ТипПодіїПеріодичнеГотово;
  подія->обʼєкт.періодичне = періодичне;

  struct io_uring_sqe* sqe = io_uring_get_sqe(&турбіна->ring);
  io_uring_prep_read(sqe, періодичне->fd, &періодичне->expirations,
                     sizeof(періодичне->expirations), 0);
  io_uring_sqe_set_data(sqe, подія);
  io_uring_submit(&турбіна->ring);

  турбіна->qcount++;

  періодичне->подія = подія;
}

void слухати_інтернет_обслуговувач_клієнт_підключено(
    Турбіна* турбіна,
    ІнтернетОбслуговувач* інтернет_обслуговувач) {
  Подія* подія = (Подія*)турбіна->виділяч->виділити_сиру_памʼять(
      турбіна->виділяч, sizeof(Подія));
  подія->тип = ТипПодіїІнтернетОбслуговувачКлієнтПідключено;
  подія->обʼєкт.інтернет_обслуговувач = інтернет_обслуговувач;

  struct io_uring_sqe* sqe = io_uring_get_sqe(&турбіна->ring);
  io_uring_prep_accept(sqe, інтернет_обслуговувач->fd, NULL, NULL, 0);
  io_uring_sqe_set_data(sqe, подія);
  io_uring_submit(&турбіна->ring);

  турбіна->qcount++;
}

void слухати_інтернет_звʼязок_підключено(Турбіна* турбіна,
                                         ІнтернетЗвʼязок* інтернет_звʼязок) {
  Подія* подія = (Подія*)турбіна->виділяч->виділити_сиру_памʼять(
      турбіна->виділяч, sizeof(Подія));
  подія->тип = ТипПодіїІнтернетЗвʼязокПідключено;
  подія->обʼєкт.інтернет_звʼязок = інтернет_звʼязок;

  struct io_uring_sqe* sqe = io_uring_get_sqe(&турбіна->ring);
  io_uring_prep_poll_add(sqe, інтернет_звʼязок->fd, POLLOUT);
  io_uring_sqe_set_data(sqe, подія);
  io_uring_submit(&турбіна->ring);

  турбіна->qcount++;
}

void слухати_інтернет_звʼязок_прочитано(Турбіна* турбіна,
                                        ІнтернетЗвʼязок* інтернет_звʼязок) {
  ПрочитанеІнтернетЗвʼязку* прочитане =
      (ПрочитанеІнтернетЗвʼязку*)турбіна->виділяч->виділити_сиру_памʼять(
          турбіна->виділяч, sizeof(ПрочитанеІнтернетЗвʼязку));
  прочитане->інтернет_звʼязок = інтернет_звʼязок;
  прочитане->розмір = 4096;
  прочитане->дані =
      турбіна->виділяч->виділити_сиру_памʼять(турбіна->виділяч, 4096);

#ifdef TURBO_DEBUG
  memset(прочитане->дані, 0, 4096);
#endif

  Подія* подія = (Подія*)турбіна->виділяч->виділити_сиру_памʼять(
      турбіна->виділяч, sizeof(Подія));
  подія->тип = ТипПодіїІнтернетЗвʼязокПрочитано;
  подія->обʼєкт.прочитане_інтернет_звʼязку = прочитане;

  struct io_uring_sqe* sqe = io_uring_get_sqe(&турбіна->ring);
  io_uring_prep_read(sqe, інтернет_звʼязок->fd, прочитане->дані,
                     прочитане->розмір, 0);
  io_uring_sqe_set_data(sqe, подія);
  io_uring_submit(&турбіна->ring);

  турбіна->qcount++;
}

void слухати_інтернет_звʼязок_записано(
    Турбіна* турбіна,
    ІнтернетЗвʼязок* інтернет_звʼязок,
    ЕлементЧергиЗаписуІнтернетЗвʼязку* елемент_черги_запису_інтернет_звʼязку) {
  Подія* подія = (Подія*)турбіна->виділяч->виділити_сиру_памʼять(
      турбіна->виділяч, sizeof(Подія));
  подія->тип = ТипПодіїІнтернетЗвʼязокЗаписано;
  подія->обʼєкт.елемент_черги_запису_інтернет_звʼязку =
      елемент_черги_запису_інтернет_звʼязку;

  struct io_uring_sqe* sqe = io_uring_get_sqe(&турбіна->ring);
  io_uring_prep_write(
      sqe, інтернет_звʼязок->fd,
      елемент_черги_запису_інтернет_звʼязку->дані +
          елемент_черги_запису_інтернет_звʼязку->розмір_записаного,
      елемент_черги_запису_інтернет_звʼязку->розмір -
          елемент_черги_запису_інтернет_звʼязку->розмір_записаного,
      0);
  io_uring_sqe_set_data(sqe, подія);
  io_uring_submit(&турбіна->ring);

  турбіна->qcount++;
}

extern логічне __турбо__отримати_інтернет_адресу_з_ю8(Турбіна* турбіна,
                                                      ю8 значення,
                                                      позитивне* вихід) {
  char* hostname_unicode = перетворити_ю8_в_chars(значення);

  char* hostname = NULL;

  int idn2res =
      idn2_lookup_u8((const uint8_t*)hostname_unicode, (uint8_t**)&hostname, 0);
  if (idn2res == IDN2_OK) {
    free(hostname_unicode);
  } else {
    free(hostname_unicode);
    return false;
  }

  struct addrinfo hints, *res;
  struct in_addr addr;

  memset(&hints, 0, sizeof(hints));
  hints.ai_family = AF_INET;

  int addres = getaddrinfo(hostname, NULL, &hints, &res);

  idn2_free(hostname);

  if (addres != 0) {
    return false;
  }

  addr = ((struct sockaddr_in*)res->ai_addr)->sin_addr;

  freeaddrinfo(res);

  *вихід = ntohl(addr.s_addr);

  return true;
}

extern логічне __турбо__підключити_інтернет_звʼязок(
    Турбіна* турбіна,
    позитивне іа,
    позитивне порт,
    ТурбоОбробникПідключенняІнтернетЗвʼязку обробник_підключення,
    ТурбоОбробникДанихІнтернетЗвʼязку обробник_даних,
    ТурбоОбробникЗакриттяІнтернетЗвʼязку обробник_закриття,
    ТурбоОбробникВідключенняІнтернетЗвʼязку обробник_відключення,
    невідома_адреса аргумент) {
  int sockfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sockfd == -1) {
    обробник_підключення(турбіна, NULL, аргумент, false, errno);
    return false;
  }

  if (make_nonblocking(sockfd) == -1) {
    close(sockfd);
    обробник_підключення(турбіна, NULL, аргумент, false, errno);
    return false;
  }

  struct sockaddr_in addr = {.sin_family = AF_INET,
                             .sin_addr = {.s_addr = htonl(іа)},
                             .sin_port = htons(порт)};

  int res = connect(sockfd, (struct sockaddr*)&addr, sizeof(addr));
  if (res == -1 && errno != EINPROGRESS) {
    close(sockfd);
    обробник_підключення(турбіна, NULL, аргумент, false, errno);
    return false;
  }

  ІнтернетЗвʼязок* інтернет_звʼязок =
      (ІнтернетЗвʼязок*)турбіна->виділяч->виділити_сиру_памʼять(
          турбіна->виділяч, sizeof(ІнтернетЗвʼязок));
  інтернет_звʼязок->fd = sockfd;
  інтернет_звʼязок->обробник_підключення = обробник_підключення;
  інтернет_звʼязок->обробник_даних = обробник_даних;
  інтернет_звʼязок->обробник_закриття = обробник_закриття;
  інтернет_звʼязок->обробник_відключення = обробник_відключення;
  інтернет_звʼязок->аргумент = аргумент;
  інтернет_звʼязок->перший_елемент_черги_запису = NULL;
  інтернет_звʼязок->останній_елемент_черги_запису = NULL;
  інтернет_звʼязок->очікує_закінчення_запису = false;
  інтернет_звʼязок->закінчено_запис = false;
  інтернет_звʼязок->закінчено_читання = false;
  інтернет_звʼязок->очікує_відключення = false;
  інтернет_звʼязок->відключення_з_помилкою = false;
  інтернет_звʼязок->код_помилки_відключення = 0;

  слухати_інтернет_звʼязок_підключено(турбіна, інтернет_звʼязок);

  return true;
}

void закрити_інтернет_звʼязок(Турбіна* турбіна,
                              ІнтернетЗвʼязок* інтернет_звʼязок,
                              логічне з_помилкою,
                              позитивне помилка) {
  close(інтернет_звʼязок->fd);

  ЕлементЧергиЗаписуІнтернетЗвʼязку* елемет_черги_запису =
      інтернет_звʼязок->перший_елемент_черги_запису;

  while (елемет_черги_запису != NULL) {
    if (елемет_черги_запису->обробник_запису != NULL) {
      елемет_черги_запису->обробник_запису(
          турбіна, інтернет_звʼязок, інтернет_звʼязок->аргумент,
          елемет_черги_запису->аргумент, елемет_черги_запису->розмір,
          елемет_черги_запису->дані);
    }

    ЕлементЧергиЗаписуІнтернетЗвʼязку* наступний =
        елемет_черги_запису->наступний;

    free(елемет_черги_запису);

    елемет_черги_запису = наступний;
  }

  інтернет_звʼязок->обробник_відключення(турбіна, інтернет_звʼязок,
                                         інтернет_звʼязок->аргумент, з_помилкою,
                                         помилка);

  free(інтернет_звʼязок);
}

static void обробити_ввід(Турбіна* турбіна, Ввід* ввід, int res) {
  if (res < 0) {
    ввід->відклик(турбіна, ввід->аргумент, true, ввід->розмір_префікса,
                  ввід->дані_префікса, 0, NULL);

    free(ввід->дані);
    free(ввід->дані_прочитаного);

    pthread_detach(ввід->tid);
    close(ввід->read_fd);
    close(ввід->write_fd);
    free(ввід);

    турбіна->очікує_ввід = false;
  } else {
    if (res == 0) {
      ввід->відклик(турбіна, ввід->аргумент, true, ввід->розмір_префікса,
                    ввід->дані_префікса, 0, NULL);

      free(ввід->дані);
      free(ввід->дані_прочитаного);

      pthread_detach(ввід->tid);
      close(ввід->read_fd);
      close(ввід->write_fd);
      free(ввід);

      турбіна->очікує_ввід = false;
    } else if (ввід->дані_прочитаного[res - 1] != 0) {
      доповнити_дані(турбіна, &ввід->розмір, &ввід->дані, res,
                     ввід->дані_прочитаного);

      слухати_ввід(турбіна, ввід);
    } else {
      доповнити_дані(турбіна, &ввід->розмір, &ввід->дані, res - 1,
                     ввід->дані_прочитаного);

      ввід->відклик(турбіна, ввід->аргумент, false, ввід->розмір_префікса,
                    ввід->дані_префікса, ввід->розмір, ввід->дані);

      free(ввід->дані_прочитаного);

      pthread_detach(ввід->tid);
      close(ввід->read_fd);
      close(ввід->write_fd);
      free(ввід);

      турбіна->очікує_ввід = false;
    }
  }
}

static void обробити_відкладене_готово(Турбіна* турбіна,
                                       Відкладене* відкладене,
                                       int res) {
  close(відкладене->fd);

  if (res < 0) {
    відкладене->відклик(турбіна, відкладене, відкладене->аргумент,
                        res == -ECANCELED != 0, false, -res);
  } else {
    відкладене->відклик(турбіна, відкладене, відкладене->аргумент, false, true,
                        0);
  }

  free(відкладене);
}

static void обробити_періодичне_готово(Турбіна* турбіна,
                                       Періодичне* періодичне,
                                       int res) {
  if (res < 0) {
    close(періодичне->fd);

    періодичне->відклик(турбіна, періодичне, періодичне->аргумент,
                        res == -ECANCELED != 0, false, -res);

    free(періодичне);
  } else {
    слухати_періодичне_готово(турбіна, періодичне);

    періодичне->відклик(турбіна, періодичне, періодичне->аргумент, false, true,
                        0);
  }
}

static void обробити_інтернет_обслуговувач_підключено_клієнт(
    Турбіна* турбіна,
    ІнтернетОбслуговувач* інтернет_обслуговувач,
    int res) {
  make_nonblocking(res);

  слухати_інтернет_обслуговувач_клієнт_підключено(турбіна,
                                                  інтернет_обслуговувач);

  ІнтернетЗвʼязок* інтернет_звʼязок =
      (ІнтернетЗвʼязок*)турбіна->виділяч->виділити_сиру_памʼять(
          турбіна->виділяч, sizeof(ІнтернетЗвʼязок));
  інтернет_звʼязок->fd = res;
  інтернет_звʼязок->обробник_підключення = NULL;
  інтернет_звʼязок->обробник_даних = NULL;
  інтернет_звʼязок->обробник_закриття = NULL;
  інтернет_звʼязок->обробник_відключення = NULL;
  інтернет_звʼязок->аргумент = NULL;
  інтернет_звʼязок->перший_елемент_черги_запису = NULL;
  інтернет_звʼязок->останній_елемент_черги_запису = NULL;
  інтернет_звʼязок->очікує_закінчення_запису = false;
  інтернет_звʼязок->закінчено_запис = false;
  інтернет_звʼязок->закінчено_читання = false;
  інтернет_звʼязок->очікує_відключення = false;
  інтернет_звʼязок->відключення_з_помилкою = false;
  інтернет_звʼязок->код_помилки_відключення = 0;

  слухати_інтернет_звʼязок_прочитано(турбіна, інтернет_звʼязок);

  інтернет_обслуговувач->обробник_підключення_клієнта(
      турбіна, інтернет_обслуговувач, інтернет_звʼязок,
      інтернет_обслуговувач->аргумент);
}

static void обробити_інтернет_звʼязок_підключено(
    Турбіна* турбіна,
    ІнтернетЗвʼязок* інтернет_звʼязок) {
  int err = 0;
  socklen_t len = sizeof(err);
  int result =
      getsockopt(інтернет_звʼязок->fd, SOL_SOCKET, SO_ERROR, &err, &len);

  if (result == -1 || err != 0) {
    close(інтернет_звʼязок->fd);

    інтернет_звʼязок->обробник_підключення(
        турбіна, інтернет_звʼязок, інтернет_звʼязок->аргумент, false, err);

    free(інтернет_звʼязок);
  } else {
    інтернет_звʼязок->обробник_підключення(турбіна, інтернет_звʼязок,
                                           інтернет_звʼязок->аргумент, true, 0);

    слухати_інтернет_звʼязок_прочитано(турбіна, інтернет_звʼязок);
  }
}

static void обробити_інтернет_звʼязок_прочитано(
    Турбіна* турбіна,
    ПрочитанеІнтернетЗвʼязку* прочитане_інтернет_звʼязку,
    int res) {
  ІнтернетЗвʼязок* інтернет_звʼязок =
      прочитане_інтернет_звʼязку->інтернет_звʼязок;

  if (інтернет_звʼязок->очікує_відключення) {
    // відключення ініційовано під час запису (ймовірно за все через помилку)
    free(прочитане_інтернет_звʼязку->дані);
    free(прочитане_інтернет_звʼязку);

    закрити_інтернет_звʼязок(турбіна, інтернет_звʼязок,
                             інтернет_звʼязок->відключення_з_помилкою,
                             інтернет_звʼязок->код_помилки_відключення);
  } else if (res < 0) {
    free(прочитане_інтернет_звʼязку->дані);
    free(прочитане_інтернет_звʼязку);

    if (res == -EAGAIN) {
      слухати_інтернет_звʼязок_прочитано(турбіна, інтернет_звʼязок);
    } else {
      if (інтернет_звʼязок->перший_елемент_черги_запису == NULL ||
          інтернет_звʼязок->закінчено_запис) {
        закрити_інтернет_звʼязок(турбіна, інтернет_звʼязок, true, res);
      } else {
        інтернет_звʼязок->очікує_відключення = true;
        інтернет_звʼязок->відключення_з_помилкою = true;
        інтернет_звʼязок->код_помилки_відключення = res;
      }
    }
  } else if (res == 0) {
    free(прочитане_інтернет_звʼязку->дані);
    free(прочитане_інтернет_звʼязку);

    інтернет_звʼязок->закінчено_читання = true;

    інтернет_звʼязок->обробник_закриття(турбіна, інтернет_звʼязок,
                                        інтернет_звʼязок->аргумент);

    if (інтернет_звʼязок->перший_елемент_черги_запису == NULL ||
        інтернет_звʼязок->закінчено_запис) {
      закрити_інтернет_звʼязок(турбіна, інтернет_звʼязок,
                               інтернет_звʼязок->відключення_з_помилкою,
                               інтернет_звʼязок->код_помилки_відключення);
    } else {
      інтернет_звʼязок->очікує_відключення = true;
    }
  } else {
    інтернет_звʼязок->обробник_даних(турбіна, інтернет_звʼязок,
                                     інтернет_звʼязок->аргумент, res,
                                     прочитане_інтернет_звʼязку->дані);

    слухати_інтернет_звʼязок_прочитано(турбіна, інтернет_звʼязок);

    free(прочитане_інтернет_звʼязку);
  }
}

static void обробити_інтернет_звʼязок_записано(
    Турбіна* турбіна,
    ЕлементЧергиЗаписуІнтернетЗвʼязку* елемент_черги_запису_інтернет_звʼязку,
    int res) {
  ІнтернетЗвʼязок* інтернет_звʼязок =
      елемент_черги_запису_інтернет_звʼязку->інтернет_звʼязок;

  if (інтернет_звʼязок->очікує_відключення) {
    // відключення ініційовано під час прочитання (ймовірно за все через помилку)
    закрити_інтернет_звʼязок(турбіна, інтернет_звʼязок,
                             інтернет_звʼязок->відключення_з_помилкою,
                             інтернет_звʼязок->код_помилки_відключення);
  } else if (res < 0) {
    if (інтернет_звʼязок->закінчено_читання) {
      закрити_інтернет_звʼязок(турбіна, інтернет_звʼязок, true, res);
    } else {
      інтернет_звʼязок->очікує_відключення = true;
      інтернет_звʼязок->відключення_з_помилкою = true;
      інтернет_звʼязок->код_помилки_відключення = res;
    }
  } else {
    інтернет_звʼязок->перший_елемент_черги_запису =
        елемент_черги_запису_інтернет_звʼязку->наступний;

    if (інтернет_звʼязок->останній_елемент_черги_запису ==
        елемент_черги_запису_інтернет_звʼязку) {
      інтернет_звʼязок->останній_елемент_черги_запису = NULL;
    }

    if (інтернет_звʼязок->перший_елемент_черги_запису == NULL) {
      if (інтернет_звʼязок->очікує_закінчення_запису) {
        shutdown(інтернет_звʼязок->fd, SHUT_WR);
        інтернет_звʼязок->закінчено_запис = true;
      }
    } else {
      слухати_інтернет_звʼязок_записано(
          турбіна, інтернет_звʼязок,
          інтернет_звʼязок->перший_елемент_черги_запису);
    }

    if (елемент_черги_запису_інтернет_звʼязку->обробник_запису != NULL) {
      елемент_черги_запису_інтернет_звʼязку->обробник_запису(
          турбіна, інтернет_звʼязок, інтернет_звʼязок->аргумент,
          елемент_черги_запису_інтернет_звʼязку->аргумент,
          елемент_черги_запису_інтернет_звʼязку->розмір,
          елемент_черги_запису_інтернет_звʼязку->дані);
    }

    free(елемент_черги_запису_інтернет_звʼязку);
  }
}

extern void __турбо__встановити_обробники_інтернет_звʼязку(
    Турбіна* турбіна,
    ІнтернетЗвʼязок* інтернет_звʼязок,
    ТурбоОбробникДанихІнтернетЗвʼязку обробник_даних,
    ТурбоОбробникЗакриттяІнтернетЗвʼязку обробник_закриття,
    ТурбоОбробникВідключенняІнтернетЗвʼязку обробник_відключення,
    невідома_адреса аргумент) {
  інтернет_звʼязок->обробник_даних = обробник_даних;
  інтернет_звʼязок->обробник_закриття = обробник_закриття;
  інтернет_звʼязок->обробник_відключення = обробник_відключення;
  інтернет_звʼязок->аргумент = аргумент;
}

extern void __турбо__запустити_інтернет_обслуговувач(
    Турбіна* турбіна,
    позитивне іа,
    позитивне порт,
    ТурбоОбробникЗапускуІнтернетОбслуговувача обробник_запуску,
    ТурбоОбробникПідключенняКлієнтаІнтернетОбслуговувача
        обробник_підключення_клієнта,
    ТурбоОбробникЗупинкиІнтернетОбслуговувача обробник_зупинки,
    невідома_адреса аргумент) {
  int server_fd = socket(AF_INET, SOCK_STREAM, 0);
  if (server_fd == -1) {
    обробник_запуску(турбіна, NULL, аргумент, false, errno, іа, порт);
    return;
  }

  struct sockaddr_in addr = {0};

  make_nonblocking(server_fd);

  int opt = 1;
  setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

  addr.sin_family = AF_INET;
  addr.sin_port = htons(порт);
  addr.sin_addr.s_addr = INADDR_ANY;

  int bindres = bind(server_fd, (struct sockaddr*)&addr, sizeof(addr));
  if (bindres == -1) {
    обробник_запуску(турбіна, NULL, аргумент, false, errno, іа, порт);
    return;
  }

  int listres = listen(server_fd, 128);
  if (listres == -1) {
    обробник_запуску(турбіна, NULL, аргумент, false, errno, іа, порт);
    return;
  }

  ІнтернетОбслуговувач* інтернет_обслуговувач =
      (ІнтернетОбслуговувач*)турбіна->виділяч->виділити_сиру_памʼять(
          турбіна->виділяч, sizeof(ІнтернетОбслуговувач));
  інтернет_обслуговувач->fd = server_fd;
  інтернет_обслуговувач->обробник_підключення_клієнта =
      обробник_підключення_клієнта;
  інтернет_обслуговувач->обробник_зупинки = обробник_зупинки;
  інтернет_обслуговувач->аргумент = аргумент;

  слухати_інтернет_обслуговувач_клієнт_підключено(турбіна,
                                                  інтернет_обслуговувач);

  обробник_запуску(турбіна, інтернет_обслуговувач, аргумент, true, 0, іа, порт);
}

extern логічне __турбо__запустити_турбіну(
    Турбіна* турбіна,
    ТурбоВідкликТурбіни відклик_перед,
    ТурбоВідкликТурбіни відклик_після,
    невідома_адреса аргумент,
    ТурбоПомилкаВідкликуТурбіни* вихід_помилки) {
  while (1) {
    if (турбіна->qcount == 0) {
      if (io_uring_cq_ready(&турбіна->ring) == 0) {
        return true;
      }
    }

    if (відклик_перед != NULL) {
      if (відклик_перед(турбіна, аргумент, вихід_помилки)) {
        return false;
      }
    }

    struct io_uring_cqe* cqe;
    int ret = io_uring_wait_cqe(&турбіна->ring, &cqe);
    if (ret == -EINTR) {
      continue;
    } else if (ret < 0) {
      printf("Помилка Турбіни io_uring_wait_cqe exit with %d\n", -ret);
      exit(1);
      return false;
    }
    io_uring_cqe_seen(&турбіна->ring, cqe);
    турбіна->qcount--;

    Подія* подія = io_uring_cqe_get_data(cqe);

    if (подія->тип == ТипПодіїВвід) {
      обробити_ввід(турбіна, подія->обʼєкт.ввід, cqe->res);
    } else if (подія->тип == ТипПодіїВідкладенеГотово) {
      обробити_відкладене_готово(турбіна, подія->обʼєкт.відкладене, cqe->res);
    } else if (подія->тип == ТипПодіїВідкладенеСкасовано) {
      // ignore
    } else if (подія->тип == ТипПодіїПеріодичнеГотово) {
      обробити_періодичне_готово(турбіна, подія->обʼєкт.періодичне, cqe->res);
    } else if (подія->тип == ТипПодіїПеріодичнеСкасовано) {
      // ignore
    } else if (подія->тип == ТипПодіїІнтернетОбслуговувачКлієнтПідключено) {
      обробити_інтернет_обслуговувач_підключено_клієнт(
          турбіна, подія->обʼєкт.інтернет_обслуговувач, cqe->res);
    } else if (подія->тип == ТипПодіїІнтернетЗвʼязокПідключено) {
      обробити_інтернет_звʼязок_підключено(турбіна,
                                           подія->обʼєкт.інтернет_звʼязок);
    } else if (подія->тип == ТипПодіїІнтернетЗвʼязокЗаписано) {
      обробити_інтернет_звʼязок_записано(
          турбіна, подія->обʼєкт.елемент_черги_запису_інтернет_звʼязку,
          cqe->res);
    } else if (подія->тип == ТипПодіїІнтернетЗвʼязокПрочитано) {
      обробити_інтернет_звʼязок_прочитано(
          турбіна, подія->обʼєкт.прочитане_інтернет_звʼязку, cqe->res);
    }

    free(подія);

    if (відклик_після != NULL) {
      if (!відклик_після(турбіна, аргумент, вихід_помилки)) {
        return false;
      }
    }
  }
}

extern void __турбо__знищити_турбіну(Турбіна* турбіна) {
  io_uring_queue_exit(&турбіна->ring);

  турбіна->виділяч->звільнити_сиру_памʼять(турбіна->виділяч,
                                           (памʼять_п8)турбіна);
}

extern void __турбо__закінчити_інтернет_звʼязок(
    Турбіна* турбіна,
    ІнтернетЗвʼязок* інтернет_звʼязок) {
  if (інтернет_звʼязок->очікує_закінчення_запису ||
      інтернет_звʼязок->закінчено_запис) {
    return;
  }

  if (інтернет_звʼязок->перший_елемент_черги_запису == NULL) {
    shutdown(інтернет_звʼязок->fd, SHUT_WR);
    інтернет_звʼязок->закінчено_запис = true;
  } else {
    інтернет_звʼязок->очікує_закінчення_запису = true;
  }
}

extern void __турбо__записати_в_інтернет_звʼязок(
    Турбіна* турбіна,
    ІнтернетЗвʼязок* інтернет_звʼязок,
    позитивне розмір,
    памʼять_п8 дані,
    ТурбоОбробникЗаписуІнтернетЗвʼязку обробник_запису,
    невідома_адреса аргумент) {
  if (інтернет_звʼязок->очікує_відключення ||
      інтернет_звʼязок->очікує_закінчення_запису ||
      інтернет_звʼязок->закінчено_запис) {
    обробник_запису(турбіна, інтернет_звʼязок, інтернет_звʼязок->аргумент,
                    аргумент, розмір, дані);
    return;
  }

  ЕлементЧергиЗаписуІнтернетЗвʼязку* елемент =
      (ЕлементЧергиЗаписуІнтернетЗвʼязку*)
          турбіна->виділяч->виділити_сиру_памʼять(
              турбіна->виділяч, sizeof(ЕлементЧергиЗаписуІнтернетЗвʼязку));
  елемент->наступний = NULL;
  елемент->інтернет_звʼязок = інтернет_звʼязок;
  елемент->розмір = розмір;
  елемент->дані = дані;
  елемент->розмір_записаного = 0;
  елемент->обробник_запису = обробник_запису;
  елемент->аргумент = аргумент;

  if (інтернет_звʼязок->перший_елемент_черги_запису == NULL) {
    інтернет_звʼязок->перший_елемент_черги_запису = елемент;
  }
  if (інтернет_звʼязок->останній_елемент_черги_запису == NULL) {
    інтернет_звʼязок->останній_елемент_черги_запису = елемент;
    слухати_інтернет_звʼязок_записано(турбіна, інтернет_звʼязок, елемент);
  } else {
    інтернет_звʼязок->останній_елемент_черги_запису->наступний = елемент;
    інтернет_звʼязок->останній_елемент_черги_запису = елемент;
  }
}

extern ц32 __турбо__отримати_ідентифікатор_інтернет_звʼязку(
    Турбіна* турбіна,
    ІнтернетЗвʼязок* інтернет_звʼязок) {
  return інтернет_звʼязок->fd;
}

extern ц32 __турбо__отримати_ідентифікатор_інтернет_обслуговувача(
    Турбіна* турбіна,
    ІнтернетОбслуговувач* інтернет_обслуговувач) {
  return інтернет_обслуговувач->fd;
}

extern Відкладене* __турбо__відкласти_виконання(
    Турбіна* турбіна,
    позитивне тривалість,
    ТурбоВідкликВідкладеного відклик,
    невідома_адреса аргумент) {
  int tfd = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK);
  if (tfd == -1) {
    return NULL;
  }

  if (тривалість == 0) {
    тривалість = 1;
  }

  struct itimerspec ts = {0};
  ts.it_value.tv_sec = (long int)тривалість / 1000;
  ts.it_value.tv_nsec = (long int)(тривалість % 1000) * 1000000;

  if (timerfd_settime(tfd, 0, &ts, NULL) == -1) {
    close(tfd);
    return NULL;
  }

  if (make_nonblocking(tfd) == -1) {
    close(tfd);
    return NULL;
  }

  Відкладене* відкладене = (Відкладене*)турбіна->виділяч->виділити_сиру_памʼять(
      турбіна->виділяч, sizeof(Відкладене));
  відкладене->fd = tfd;
  відкладене->expirations = 0;
  відкладене->відклик = відклик;
  відкладене->аргумент = аргумент;
  відкладене->подія = NULL;

  слухати_відкладене_готово(турбіна, відкладене);

  return відкладене;
}

extern void __турбо__скасувати_відкладене(Турбіна* турбіна,
                                          Відкладене* відкладене) {
  Подія* подія = (Подія*)турбіна->виділяч->виділити_сиру_памʼять(
      турбіна->виділяч, sizeof(Подія));
  подія->тип = ТипПодіїВідкладенеСкасовано;

  struct io_uring_sqe* sqe = io_uring_get_sqe(&турбіна->ring);
  io_uring_prep_cancel(sqe, відкладене->подія, 0);
  io_uring_sqe_set_data(sqe, подія);
  io_uring_submit(&турбіна->ring);

  турбіна->qcount++;
}

extern Періодичне* __турбо__виконувати_періодично(
    Турбіна* турбіна,
    позитивне тривалість,
    ТурбоВідкликПеріодичного відклик,
    невідома_адреса аргумент) {
  int tfd = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK);
  if (tfd == -1) {
    return NULL;
  }

  if (тривалість == 0) {
    тривалість = 1;
  }

  struct itimerspec ts = {0};
  ts.it_value.tv_sec = (long int)тривалість / 1000;
  ts.it_value.tv_nsec = ((long int)тривалість % 1000) * 1000000;
  ts.it_interval.tv_sec = (long int)тривалість / 1000;
  ts.it_interval.tv_nsec = ((long int)тривалість % 1000) * 1000000;

  if (timerfd_settime(tfd, 0, &ts, NULL) == -1) {
    close(tfd);
    return NULL;
  }

  if (make_nonblocking(tfd) == -1) {
    close(tfd);
    return NULL;
  }

  Періодичне* періодичне = (Періодичне*)турбіна->виділяч->виділити_сиру_памʼять(
      турбіна->виділяч, sizeof(Періодичне));
  періодичне->fd = tfd;
  періодичне->expirations = 0;
  періодичне->відклик = відклик;
  періодичне->аргумент = аргумент;
  періодичне->подія = NULL;

  слухати_періодичне_готово(турбіна, періодичне);

  return періодичне;
}

extern void __турбо__скасувати_періодичне(Турбіна* турбіна,
                                          Періодичне* періодичне) {
  Подія* подія = (Подія*)турбіна->виділяч->виділити_сиру_памʼять(
      турбіна->виділяч, sizeof(Подія));
  подія->тип = ТипПодіїПеріодичнеСкасовано;

  struct io_uring_sqe* sqe = io_uring_get_sqe(&турбіна->ring);
  io_uring_prep_cancel(sqe, періодичне->подія, 0);
  io_uring_sqe_set_data(sqe, подія);
  io_uring_submit(&турбіна->ring);

  турбіна->qcount++;
}

void* readline_thread(void* ptr) {
  Ввід* ввід = ptr;
  int read_fd = ввід->read_fd;
  int write_fd = ввід->write_fd;

  char* prefix = malloc(ввід->розмір_префікса + 1);
  memcpy(prefix, ввід->дані_префікса, ввід->розмір_префікса);
  prefix[ввід->розмір_префікса] = 0;

  char* line = readline(prefix);

  free(prefix);

  if (line) {
    write(write_fd, line, strlen(line));
    char zero = 0;
    write(write_fd, &zero, 1);
  } else {
    close(write_fd);
  }

  free(line);

  return NULL;
}

extern void __турбо__прочитати_ввід(Турбіна* турбіна,
                                    ТурбоВідкликВводу відклик,
                                    невідома_адреса аргумент,
                                    позитивне розмір_префікса,
                                    памʼять_п8 дані_префікса) {
  if (турбіна->очікує_ввід) {
    // потім: обробити
  }

  rl_catch_signals = 0;

  int pipe_fds[2];
  pipe(pipe_fds);

  if (make_nonblocking(pipe_fds[0]) == -1) {
    close(pipe_fds[0]);
    close(pipe_fds[1]);
    return;
  }

  турбіна->очікує_ввід = true;

  Ввід* ввід = (Ввід*)турбіна->виділяч->виділити_сиру_памʼять(турбіна->виділяч,
                                                              sizeof(Ввід));
  ввід->read_fd = pipe_fds[0];
  ввід->write_fd = pipe_fds[1];
  ввід->відклик = відклик;
  ввід->аргумент = аргумент;
  ввід->розмір_префікса = розмір_префікса;
  ввід->дані_префікса = дані_префікса;
  ввід->розмір = 0;
  ввід->дані = NULL;
  ввід->дані_прочитаного = malloc(256);
  memset(ввід->дані_прочитаного, 0, 256);

  pthread_create(&ввід->tid, NULL, readline_thread, (void*)ввід);

  слухати_ввід(турбіна, ввід);
}

extern void __турбо__вивести(Турбіна* турбіна,
                             позитивне розмір,
                             памʼять_п8 дані) {
  fwrite(дані, розмір, 1, stdout);
}

// </турбо.ю8.в>