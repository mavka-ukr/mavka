/* Розбирач Мавки */

взяти означення мавка/розбирач;

// це треба ще разок переписати так як є проблеми які складно виловити
// в цілому змінити багато не вийде і не треба
// з чистого листа буде краще

простір мавка {
  простір розбирач {
    дія визначити_розмір_символа(перший_байт: п8) -> п8 {
      якщо (перший_байт & 128) == 0 {
        вернути 1;
      }

      якщо (перший_байт & 224) == 192 {
        вернути 2;
      }

      якщо (перший_байт & 240) == 224 {
        вернути 3;
      }

      якщо (перший_байт & 248) == 240 {
        вернути 4;
      }

      вернути 0;
    }

    дія виділити_копію_кд(М: адреса<Машина>, вхід: кд, вихід: адреса<кд>) -> логічне {
      змінна дані = виділити_памʼять<п8>(М, вхід.розмір);

      змінна п: природне = 0;

      поки п < вхід.розмір {
        дані[п] = вхід.дані[п];

        п += 1;
      }

      вихід::вміст = кд { вхід.розмір, дані };

      вернути так;
    }
  }
}

простір мавка {
  простір розбирач {
    дія перевірити_чи_початок_ідентифікатора(М: адреса<Машина>, значення_кд: кд, позиція_початку: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>) -> логічне;
    дія перевірити_чи_продовження_ідентифікатора(М: адреса<Машина>, значення_кд: кд, позиція_початку: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>) -> логічне;
    дія перевірити_чи_починається_з(М: адреса<Машина>, значення_кд: кд, позиція_початку: ПозиціяСлова, значення: кд, вихід_позиції_кінця: адреса<ПозиціяСлова>) -> логічне;
    дія перевірити_чи_починається_з_ключового_слова(М: адреса<Машина>, значення_кд: кд, позиція_початку: ПозиціяСлова, значення: кд, вихід_позиції_кінця: адреса<ПозиціяСлова>, вихід_це_ідентифікатор: адреса<логічне>) -> логічне;
    дія перевірити_чи_число(М: адреса<Машина>, значення_кд: кд, позиція_початку: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>, вихід_має_крапку: адреса<логічне>) -> логічне;
    дія перевірити_чи_має_ідентифікатор_за_позицією_початку(М: адреса<Машина>, значення_кд: кд, позиція_початку: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>) -> логічне;

    дія перевірити_чи_початок_ідентифікатора(М: адреса<Машина>, значення_кд: кд, позиція_початку: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>) -> логічне {
      якщо позиція_початку.позиція_в_тексті >= значення_кд.розмір {
        вернути ні;
      }
      якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "а", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "б", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "в", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "г", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "д", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "е", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "є", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "ж", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "з", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "и", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "і", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "ї", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "й", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "к", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "л", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "м", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "н", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "о", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "п", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "р", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "с", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "т", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "у", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "ф", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "х", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "ц", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "ч", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "ш", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "щ", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "ь", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "ю", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "я", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "ґ", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "А", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Б", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "В", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Г", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Д", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Е", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Є", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Ж", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "З", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "И", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "І", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Ї", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Й", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "К", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Л", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "М", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Н", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "О", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "П", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Р", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "С", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Т", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "У", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Ф", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Х", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Ц", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Ч", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Ш", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Щ", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Ь", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Ю", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Я", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Ґ", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "_", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "ʼ", вихід_позиції_кінця) {
      } інакше {
        вернути ні;
      }
      вернути так;
    }

    дія перевірити_чи_продовження_ідентифікатора(М: адреса<Машина>, значення_кд: кд, позиція_початку: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>) -> логічне {
      якщо позиція_початку.позиція_в_тексті >= значення_кд.розмір {
        вернути ні;
      }
      якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "а", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "б", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "в", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "г", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "д", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "е", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "є", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "ж", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "з", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "и", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "і", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "ї", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "й", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "к", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "л", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "м", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "н", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "о", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "п", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "р", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "с", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "т", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "у", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "ф", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "х", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "ц", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "ч", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "ш", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "щ", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "ь", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "ю", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "я", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "ґ", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "А", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Б", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "В", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Г", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Д", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Е", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Є", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Ж", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "З", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "И", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "І", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Ї", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Й", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "К", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Л", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "М", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Н", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "О", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "П", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Р", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "С", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Т", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "У", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Ф", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Х", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Ц", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Ч", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Ш", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Щ", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Ь", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Ю", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Я", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "Ґ", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "_", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "ʼ", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "0", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "1", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "2", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "3", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "4", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "5", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "6", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "7", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "8", вихід_позиції_кінця) {
      } інакше якщо перевірити_чи_починається_з(М, значення_кд, позиція_початку, "9", вихід_позиції_кінця) {
      } інакше {
        вернути ні;
      }
      вернути так;
    }

    дія перевірити_чи_починається_з(М: адреса<Машина>, значення_кд: кд, позиція_початку: ПозиціяСлова, значення: кд, вихід_позиції_кінця: адреса<ПозиціяСлова>) -> логічне {
      якщо позиція_початку.позиція_в_тексті >= значення_кд.розмір {
        вернути ні;
      }
      вихід_позиції_кінця::вміст = позиція_початку;
      змінна п: природне = 0;
      поки п < значення.розмір {
        змінна розмір_символа = визначити_розмір_символа(значення.дані[п]);
        якщо розмір_символа == 1 {
          якщо (позиція_початку.позиція_в_тексті + п) >= значення_кд.розмір {
            вернути ні;
          }
          якщо значення_кд.дані[позиція_початку.позиція_в_тексті + п] != значення.дані[п] {
            вернути ні;
          }
          якщо значення.дані[п] == КД_РОЗРИВ {
            вихід_позиції_кінця.позиція_в_тексті = позиція_початку.позиція_в_тексті + п;
            вихід_позиції_кінця.рядок += 1;
          } інакше {
            вихід_позиції_кінця.позиція_в_тексті = позиція_початку.позиція_в_тексті + п;
            вихід_позиції_кінця.рядок = позиція_початку.рядок;
          }
          п += 1;
        } інакше якщо розмір_символа == 2 {
          якщо (позиція_початку.позиція_в_тексті + п + 1) >= значення_кд.розмір {
            вернути ні;
          }
          якщо значення_кд.дані[позиція_початку.позиція_в_тексті + п] != значення.дані[п] {
            вернути ні;
          }
          якщо значення_кд.дані[позиція_початку.позиція_в_тексті + п + 1] != значення.дані[п + 1] {
            вернути ні;
          }
          вихід_позиції_кінця.позиція_в_тексті = позиція_початку.позиція_в_тексті + п + 1;
          вихід_позиції_кінця.рядок = позиція_початку.рядок;
          п += 2;
        } інакше якщо розмір_символа == 3 {
          якщо (позиція_початку.позиція_в_тексті + п + 1 + 1) >= значення_кд.розмір {
            вернути ні;
          }
          якщо значення_кд.дані[позиція_початку.позиція_в_тексті + п] != значення.дані[п] {
            вернути ні;
          }
          якщо значення_кд.дані[позиція_початку.позиція_в_тексті + п + 1] != значення.дані[п + 1] {
            вернути ні;
          }
          якщо значення_кд.дані[позиція_початку.позиція_в_тексті + п + 1 + 1] != значення.дані[п + 1 + 1] {
            вернути ні;
          }
          вихід_позиції_кінця.позиція_в_тексті = позиція_початку.позиція_в_тексті + п + 1 + 1;
          вихід_позиції_кінця.рядок = позиція_початку.рядок;
          п += 3;
        } інакше якщо розмір_символа == 4 {
          якщо (позиція_початку.позиція_в_тексті + п + 1 + 1 + 1) >= значення_кд.розмір {
            вернути ні;
          }
          якщо значення_кд.дані[позиція_початку.позиція_в_тексті + п] != значення.дані[п] {
            вернути ні;
          }
          якщо значення_кд.дані[позиція_початку.позиція_в_тексті + п + 1] != значення.дані[п + 1] {
            вернути ні;
          }
          якщо значення_кд.дані[позиція_початку.позиція_в_тексті + п + 1 + 1] != значення.дані[п + 1 + 1] {
            вернути ні;
          }
          якщо значення_кд.дані[позиція_початку.позиція_в_тексті + п + 1 + 1 + 1] != значення.дані[п + 1 + 1 + 1] {
            вернути ні;
          }
          вихід_позиції_кінця.позиція_в_тексті = позиція_початку.позиція_в_тексті + п + 1 + 1 + 1;
          вихід_позиції_кінця.рядок = позиція_початку.рядок;
          п += 4;
        } інакше {
          вернути ні;
        }
      }
      вернути так;
    }

    дія перевірити_чи_починається_з_ключового_слова(М: адреса<Машина>, значення_кд: кд, позиція_початку: ПозиціяСлова, значення: кд, вихід_позиції_кінця: адреса<ПозиціяСлова>, вихід_це_ідентифікатор: адреса<логічне>) -> логічне {
      якщо позиція_початку.позиція_в_тексті >= значення_кд.розмір {
        вернути ні;
      }
      вихід_позиції_кінця::вміст = позиція_початку;
      змінна п: природне = 0;
      поки п < значення.розмір {
        змінна розмір_символа = визначити_розмір_символа(значення.дані[п]);
        якщо розмір_символа == 1 {
          якщо (позиція_початку.позиція_в_тексті + п) >= значення_кд.розмір {
            вернути ні;
          }
          якщо значення_кд.дані[позиція_початку.позиція_в_тексті + п] != значення.дані[п] {
            вернути ні;
          }
          вихід_позиції_кінця.позиція_в_тексті = позиція_початку.позиція_в_тексті + п;
          вихід_позиції_кінця.рядок = позиція_початку.рядок;
          п += 1;
        } інакше якщо розмір_символа == 2 {
          якщо (позиція_початку.позиція_в_тексті + п + 1) >= значення_кд.розмір {
            вернути ні;
          }
          якщо значення_кд.дані[позиція_початку.позиція_в_тексті + п] != значення.дані[п] {
            вернути ні;
          }
          якщо значення_кд.дані[позиція_початку.позиція_в_тексті + п + 1] != значення.дані[п + 1] {
            вернути ні;
          }
          вихід_позиції_кінця.позиція_в_тексті = позиція_початку.позиція_в_тексті + п + 1;
          вихід_позиції_кінця.рядок = позиція_початку.рядок;
          п += 2;
        } інакше якщо розмір_символа == 3 {
          якщо (позиція_початку.позиція_в_тексті + п + 1 + 1) >= значення_кд.розмір {
            вернути ні;
          }
          якщо значення_кд.дані[позиція_початку.позиція_в_тексті + п] != значення.дані[п] {
            вернути ні;
          }
          якщо значення_кд.дані[позиція_початку.позиція_в_тексті + п + 1] != значення.дані[п + 1] {
            вернути ні;
          }
          якщо значення_кд.дані[позиція_початку.позиція_в_тексті + п + 1 + 1] != значення.дані[п + 1 + 1] {
            вернути ні;
          }
          вихід_позиції_кінця.позиція_в_тексті = позиція_початку.позиція_в_тексті + п + 1 + 1;
          вихід_позиції_кінця.рядок = позиція_початку.рядок;
          п += 3;
        } інакше якщо розмір_символа == 4 {
          якщо (позиція_початку.позиція_в_тексті + п + 1 + 1 + 1) >= значення_кд.розмір {
            вернути ні;
          }
          якщо значення_кд.дані[позиція_початку.позиція_в_тексті + п] != значення.дані[п] {
            вернути ні;
          }
          якщо значення_кд.дані[позиція_початку.позиція_в_тексті + п + 1] != значення.дані[п + 1] {
            вернути ні;
          }
          якщо значення_кд.дані[позиція_початку.позиція_в_тексті + п + 1 + 1] != значення.дані[п + 1 + 1] {
            вернути ні;
          }
          якщо значення_кд.дані[позиція_початку.позиція_в_тексті + п + 1 + 1 + 1] != значення.дані[п + 1 + 1 + 1] {
            вернути ні;
          }
          вихід_позиції_кінця.позиція_в_тексті = позиція_початку.позиція_в_тексті + п + 1 + 1 + 1;
          вихід_позиції_кінця.рядок = позиція_початку.рядок;
          п += 4;
        } інакше {
          вернути ні;
        }
      }
      якщо (позиція_початку.позиція_в_тексті + п) >= значення_кд.розмір {
        вернути так;
      }
      змінна пкп = ПозиціяСлова { 0, 0, 0 };
      якщо перевірити_чи_продовження_ідентифікатора(М, значення_кд, ПозиціяСлова { позиція_початку.позиція_в_тексті + п, вихід_позиції_кінця.рядок, вихід_позиції_кінця.стовпець }, пкп::адреса) {
        вихід_це_ідентифікатор::вміст = так;
        вернути ні;
      }
      вернути так;
    }

    дія перевірити_чи_число(М: адреса<Машина>, значення_кд: кд, позиція_початку: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>, вихід_має_крапку: адреса<логічне>) -> логічне {
      змінна має_крапку: логічне = ні;
      змінна має_символ_після_крапки: логічне = ні;
      змінна п = позиція_початку;

      якщо п.позиція_в_тексті >= значення_кд.розмір {
        вернути ні;
      }

      якщо значення_кд.дані[п.позиція_в_тексті] == КД_0 {
        п.позиція_в_тексті += 1;
        якщо п.позиція_в_тексті >= значення_кд.розмір {
          п.позиція_в_тексті -= 1;
          вихід_позиції_кінця::вміст = п;
          вихід_має_крапку::вміст = має_крапку;
          вернути так;
        }
      } інакше якщо значення_кд.дані[п.позиція_в_тексті] == КД_1 {
        п.позиція_в_тексті += 1;
      } інакше якщо значення_кд.дані[п.позиція_в_тексті] == КД_2 {
        п.позиція_в_тексті += 1;
      } інакше якщо значення_кд.дані[п.позиція_в_тексті] == КД_3 {
        п.позиція_в_тексті += 1;
      } інакше якщо значення_кд.дані[п.позиція_в_тексті] == КД_4 {
        п.позиція_в_тексті += 1;
      } інакше якщо значення_кд.дані[п.позиція_в_тексті] == КД_5 {
        п.позиція_в_тексті += 1;
      } інакше якщо значення_кд.дані[п.позиція_в_тексті] == КД_6 {
        п.позиція_в_тексті += 1;
      } інакше якщо значення_кд.дані[п.позиція_в_тексті] == КД_7 {
        п.позиція_в_тексті += 1;
      } інакше якщо значення_кд.дані[п.позиція_в_тексті] == КД_8 {
        п.позиція_в_тексті += 1;
      } інакше якщо значення_кд.дані[п.позиція_в_тексті] == КД_9 {
        п.позиція_в_тексті += 1;
      } інакше {
        вернути ні;
      }

    перевірка_продовження_числа:
      якщо п.позиція_в_тексті >= значення_кд.розмір {
        якщо має_крапку {
          якщо має_символ_після_крапки {
            п.позиція_в_тексті -= 1;
            вихід_позиції_кінця::вміст = п;
            вихід_має_крапку::вміст = має_крапку;
            вернути так;
          } інакше {
            вернути ні;
          }
        }
        п.позиція_в_тексті -= 1;
        вихід_позиції_кінця::вміст = п;
        вихід_має_крапку::вміст = має_крапку;
        вернути так;
      }

      якщо значення_кд.дані[п.позиція_в_тексті] == КД_КРАПКА {
        якщо має_крапку {
          якщо має_символ_після_крапки {
            п.позиція_в_тексті -= 1;
            вихід_позиції_кінця::вміст = п;
            вихід_має_крапку::вміст = має_крапку;
            вернути так;
          } інакше {
            п.позиція_в_тексті -= 2;
            вихід_позиції_кінця::вміст = п;
            вихід_має_крапку::вміст = ні  ;
            вернути так;
          }
        } інакше {
          має_крапку = так;
          п.позиція_в_тексті += 1;
          стрибнути перевірка_продовження_числа;
        }
      }

      якщо значення_кд.дані[п.позиція_в_тексті] == КД_0 {
        якщо має_крапку { має_символ_після_крапки = так; }
        п.позиція_в_тексті += 1;
        стрибнути перевірка_продовження_числа;
      }
      якщо значення_кд.дані[п.позиція_в_тексті] == КД_1 {
        якщо має_крапку { має_символ_після_крапки = так; }
        п.позиція_в_тексті += 1;
        стрибнути перевірка_продовження_числа;
      }
      якщо значення_кд.дані[п.позиція_в_тексті] == КД_2 {
        якщо має_крапку { має_символ_після_крапки = так; }
        п.позиція_в_тексті += 1;
        стрибнути перевірка_продовження_числа;
      }
      якщо значення_кд.дані[п.позиція_в_тексті] == КД_3 {
        якщо має_крапку { має_символ_після_крапки = так; }
        п.позиція_в_тексті += 1;
        стрибнути перевірка_продовження_числа;
      }
      якщо значення_кд.дані[п.позиція_в_тексті] == КД_4 {
        якщо має_крапку { має_символ_після_крапки = так; }
        п.позиція_в_тексті += 1;
        стрибнути перевірка_продовження_числа;
      }
      якщо значення_кд.дані[п.позиція_в_тексті] == КД_5 {
        якщо має_крапку { має_символ_після_крапки = так; }
        п.позиція_в_тексті += 1;
        стрибнути перевірка_продовження_числа;
      }
      якщо значення_кд.дані[п.позиція_в_тексті] == КД_6 {
        якщо має_крапку { має_символ_після_крапки = так; }
        п.позиція_в_тексті += 1;
        стрибнути перевірка_продовження_числа;
      }
      якщо значення_кд.дані[п.позиція_в_тексті] == КД_7 {
        якщо має_крапку { має_символ_після_крапки = так; }
        п.позиція_в_тексті += 1;
        стрибнути перевірка_продовження_числа;
      }
      якщо значення_кд.дані[п.позиція_в_тексті] == КД_8 {
        якщо має_крапку { має_символ_після_крапки = так; }
        п.позиція_в_тексті += 1;
        стрибнути перевірка_продовження_числа;
      }
      якщо значення_кд.дані[п.позиція_в_тексті] == КД_9 {
        якщо має_крапку { має_символ_після_крапки = так; }
        п.позиція_в_тексті += 1;
        стрибнути перевірка_продовження_числа;
      }

      якщо має_крапку {
        якщо має_символ_після_крапки {
          п.позиція_в_тексті -= 1;
          вихід_позиції_кінця::вміст = п;
          вихід_має_крапку::вміст = має_крапку;
          вернути так;
        } інакше {
          вернути ні;
        }
      }

      п.позиція_в_тексті -= 1;
      вихід_позиції_кінця::вміст = п;
      вихід_має_крапку::вміст = має_крапку;
      вернути так;
    }

    дія перевірити_чи_має_ідентифікатор_за_позицією_початку(М: адреса<Машина>, значення_кд: кд, позиція_початку: ПозиціяСлова, вихід_позиції_кінця: адреса<ПозиціяСлова>) -> логічне {
      якщо позиція_початку.позиція_в_тексті >= значення_кд.розмір {
        вернути ні;
      }
      змінна п = позиція_початку;
      якщо перевірити_чи_початок_ідентифікатора(М, значення_кд, п, п::адреса) {
      } інакше {
        вихід_позиції_кінця::вміст = п;
        вернути ні;
      }
      п.позиція_в_тексті += 1;
      змінна є_продовження: логічне = так;
      поки є_продовження {
        якщо перевірити_чи_продовження_ідентифікатора(М, значення_кд, п, п::адреса) {
          п.позиція_в_тексті += 1;
        } інакше {
          вихід_позиції_кінця::вміст = п;
          є_продовження = ні;
        }
      }
      п.позиція_в_тексті -= 1;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    структура Накопичувач<Т> {
      розмір: природне;
      дані: памʼять<Т>;
      вмісткість: природне;
    }

    дія покласти_в_накопичувач<Т>(М: адреса<Машина>, накопичувач: адреса<Накопичувач<Т>>, елемент: Т) {
      якщо накопичувач.розмір == накопичувач.вмісткість {
        накопичувач.вмісткість += 1;
        накопичувач.дані = перевиділити_памʼять<Т>(М, накопичувач.дані, накопичувач.вмісткість);
      }

      накопичувач.дані[накопичувач.розмір] = елемент;
      накопичувач.розмір += 1;
    }

    дія зробити_накопичувач<Т>(М: адреса<Машина>) -> Накопичувач<Т> {
      вернути Накопичувач<Т> { 0, пусто, 0 };
    }

    дія звільнити_накопичувач<Т>(М: адреса<Машина>, накопичувач: Накопичувач<Т>) {
      звільнити_памʼять(М, накопичувач.дані);
    }

    дія розібрати_на_слова_0(М: адреса<Машина>, значення_кд: кд, позиція_початку: ПозиціяСлова, до_закритої_дужки: логічне, вихід_позиції_кінця: адреса<ПозиціяСлова>, вихід: адреса<Слова>, вихід_помилки: адреса<ПомилкаРозборуНаСлова>) -> логічне {
      змінна накопичувач_слів = зробити_накопичувач<Слово>(М);

      змінна п = позиція_початку;
      змінна позиція_помилки = ПозиціяСлова { 0, 0, 0 };

      поки п.позиція_в_тексті < значення_кд.розмір {
        якщо значення_кд.дані[п.позиція_в_тексті] == КД_ПРОПУСК {
          стрибнути далі;
        }

        змінна позиція_кінця = ПозиціяСлова { 0, 1, 1 };
        змінна це_ідентифікатор: логічне = ні;

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "кінець", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаКінець,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "дія", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаДія,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "структура", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСтруктура,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "перебрати", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаПеребрати,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "як", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаЯк,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "якщо", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаЯкщо,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "чекати", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаЧекати,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "взяти", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаВзяти,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "власна", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаВласна,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "дати", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаДати,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "є", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаЄ,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "вернути", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаВернути,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "тривала", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаТривала,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "цикл", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаЦикл,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "і", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаІ,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "інакше", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаІнакше,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "або", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаАбо,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "спробувати", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСпробувати,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "зловити", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаЗловити,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "впасти", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаВпасти,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "поки", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаПоки,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "модуль", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаМодуль,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "рівно", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаРівно,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "більше", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаБільше,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "менше", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаМенше,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з_ключового_слова(М, значення_кд, п, "не", позиція_кінця::адреса, це_ідентифікатор::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаНе,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "вабо", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволВиключнеАбо,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }
        якщо це_ідентифікатор {
          стрибнути перевірка_ідентифікатора;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "=", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволРівно,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, ">", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволБільше,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "<", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволМенше,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, ".", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволКрапка,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "+", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволПлюс,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "-", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволМінус,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "*", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволПомножити,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "/", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволПоділити,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "%", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволЗалишку,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "∧", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволІ,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "&", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволІ,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "∨", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволАбо,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "|", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволАбо,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "(", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволВідкритаДужка,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, ")", позиція_кінця::адреса) {
          якщо до_закритої_дужки {
            вихід::вміст = Слова {
              накопичувач_слів.розмір,
              накопичувач_слів.дані
            };
            вихід_позиції_кінця::вміст = позиція_кінця;
            вернути так;
          }
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволЗакритаДужка,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "[", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволКвадратнаВідкритаДужка,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "]", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволКвадратнаЗакритаДужка,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "{", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволФігурнаВідкритаДужка,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "}", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволФігурнаЗакритаДужка,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "?", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволЗнакПитання,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, ":", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволДвокрапка,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "¬", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволДвійковеНе,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "~", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволДвійковеНе,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "!", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволЗнакОклику,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, ",", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволКома,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "\р", позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаСимволМіжряд,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "'", позиція_кінця::адреса) {
          змінна пп = позиція_кінця;
          пп.позиція_в_тексті += 1;
          змінна закінчено: логічне = ні;
          поки пп.позиція_в_тексті < значення_кд.розмір {
            якщо значення_кд.дані[пп.позиція_в_тексті] == КД_ОБЕРНЕНА_ПОХИЛА {
              пп.позиція_в_тексті += 1;
              стрибнути далі3;
            }
            якщо значення_кд.дані[пп.позиція_в_тексті] == КД_ЛАПКА {
              закінчено = так;
              стрибнути закінчити_перебір_символів;
            }
            якщо значення_кд.дані[пп.позиція_в_тексті] == КД_РОЗРИВ {
              пп.рядок += 1;
              стрибнути закінчити_перебір_символів;
            }
            далі3:
            пп.позиція_в_тексті += 1;
          }
          закінчити_перебір_символів:
          якщо закінчено {
            покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
              вид = ВидСловаСимвол,
              позиція_початку = п,
              позиція_кінця = пп
            });
            п = пп;
            стрибнути далі;
          }
          стрибнути вийти_з_помилкою;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "\"\"\"", позиція_кінця::адреса) {
          змінна пп = позиція_кінця;
          пп.позиція_в_тексті += 1;
          змінна закінчено = ні;
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаПочатокЗбитогоТексту,
            позиція_початку = п,
            позиція_кінця = пп
          });
          п = пп;
          п.позиція_в_тексті -= 1;
          поки пп.позиція_в_тексті < значення_кд.розмір {
            якщо значення_кд.дані[пп.позиція_в_тексті] == КД_ОБЕРНЕНА_ПОХИЛА {
              пп.позиція_в_тексті += 1;
              стрибнути багаторяд_далі1;
            }
            якщо значення_кд.дані[пп.позиція_в_тексті] == КД_ВІДСОТОК {
              пп.позиція_в_тексті += 1;
              якщо значення_кд.дані[пп.позиція_в_тексті] == КД_ВІДКРИТА_ДУЖКА {
                змінна пч = п;
                п.позиція_в_тексті += 1;
                змінна ппч = пп;
                ппч.позиція_в_тексті -= 1;
                покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
                  вид = ВидСловаЧастинаЗбитогоТексту,
                  позиція_початку = пч,
                  позиція_кінця = ппч
                });
                покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
                  вид = ВидСловаРоздільникЗбитогоТексту,
                  позиція_початку = п,
                  позиція_кінця = пп
                });
                п = пп;
                пп.позиція_в_тексті += 1;
                змінна слова = Слова { 0, пусто };
                змінна помилка_розбору_на_слова = ПомилкаРозборуНаСлова { ... };
                якщо розібрати_на_слова_0(М, значення_кд, пп, так, пп::адреса, слова::адреса, помилка_розбору_на_слова::адреса) {
                  змінна ппп: природне = 0;
                  поки ппп < слова.розмір {
                    покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, слова.дані[ппп]);
                    ппп += 1;
                  }
                  звільнити_памʼять(М, слова.дані);
                  покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
                    вид = ВидСловаРоздільникЗбитогоТексту,
                    позиція_початку = п,
                    позиція_кінця = пп
                  });
                  п = пп;
                  стрибнути багаторяд_далі1;
                } інакше {
                  вихід_помилки::вміст = помилка_розбору_на_слова;
                  вернути ні;
                }
              } інакше {
                пп.позиція_в_тексті -= 1;
              }
            }
            якщо значення_кд.дані[пп.позиція_в_тексті] == КД_ОБЕРНЕНА_ПОХИЛА {
              стрибнути багаторяд_далі1;
            }
            якщо перевірити_чи_починається_з(М, значення_кд, пп, "\"\"\"", пп::адреса) {
              закінчено = так;
              стрибнути закінчити_перебір_багаторядкового_тексту;
            }
            багаторяд_далі1:
            пп.позиція_в_тексті += 1;
          }
          закінчити_перебір_багаторядкового_тексту:
          якщо закінчено {
            змінна пч = п;
            змінна ппч = пп;
            ппч.позиція_в_тексті -= 2;
            покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
              вид = ВидСловаЧастинаЗбитогоТексту,
              позиція_початку = пч,
              позиція_кінця = ппч
            });
            п = пп;
            покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
              вид = ВидСловаКінецьЗбитогоТексту,
              позиція_початку = п,
              позиція_кінця = пп
            });
            стрибнути далі;
          }
          стрибнути вийти_з_помилкою;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, "\"", позиція_кінця::адреса) {
          змінна пп = позиція_кінця;
          пп.позиція_в_тексті += 1;
          змінна закінчено = ні;
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаПочатокЗбитогоТексту,
            позиція_початку = п,
            позиція_кінця = пп
          });
          поки пп.позиція_в_тексті < значення_кд.розмір {
            якщо значення_кд.дані[пп.позиція_в_тексті] == КД_ОБЕРНЕНА_ПОХИЛА {
              пп.позиція_в_тексті += 1;
              стрибнути далі1;
            }
            якщо значення_кд.дані[пп.позиція_в_тексті] == КД_ВІДСОТОК {
              пп.позиція_в_тексті += 1;
              якщо значення_кд.дані[пп.позиція_в_тексті] == КД_ВІДКРИТА_ДУЖКА {
                змінна пч = п;
                п.позиція_в_тексті += 1;
                змінна ппч = пп;
                ппч.позиція_в_тексті -= 1;
                покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
                  вид = ВидСловаЧастинаЗбитогоТексту,
                  позиція_початку = пч,
                  позиція_кінця = ппч
                });
                покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
                  вид = ВидСловаРоздільникЗбитогоТексту,
                  позиція_початку = п,
                  позиція_кінця = пп
                });
                п = пп;
                пп.позиція_в_тексті += 1;
                змінна слова = Слова { 0, пусто };
                змінна помилка_розбору_на_слова = ПомилкаРозборуНаСлова { ... };
                якщо розібрати_на_слова_0(М, значення_кд, пп, так, пп::адреса, слова::адреса, помилка_розбору_на_слова::адреса) {
                  змінна ппп: природне = 0;
                  поки ппп < слова.розмір {
                    покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, слова.дані[ппп]);
                    ппп += 1;
                  }
                  звільнити_памʼять(М, слова.дані);
                  покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
                    вид = ВидСловаРоздільникЗбитогоТексту,
                    позиція_початку = п,
                    позиція_кінця = пп
                  });
                  п = пп;
                  стрибнути далі1;
                } інакше {
                  вихід_помилки::вміст = помилка_розбору_на_слова;
                  вернути ні;
                }
              } інакше {
                пп.позиція_в_тексті -= 1;
              }
            }
            якщо значення_кд.дані[пп.позиція_в_тексті] == КД_ДВОЛАПКА {
              закінчено = так;
              стрибнути закінчити_перебір_тексту;
            }
            якщо значення_кд.дані[пп.позиція_в_тексті] == КД_РОЗРИВ {
              пп.рядок += 1;
              стрибнути закінчити_перебір_тексту;
            }
            далі1:
            пп.позиція_в_тексті += 1;
          }
          закінчити_перебір_тексту:
          якщо закінчено {
            змінна пч = п;
            п.позиція_в_тексті += 1;
            змінна ппч = пп;
            покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
              вид = ВидСловаЧастинаЗбитогоТексту,
              позиція_початку = пч,
              позиція_кінця = ппч
            });
            п = пп;
            покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
              вид = ВидСловаКінецьЗбитогоТексту,
              позиція_початку = п,
              позиція_кінця = пп
            });
            стрибнути далі;
          }
          стрибнути вийти_з_помилкою;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, ";;", позиція_кінця::адреса) {
          змінна пп = позиція_кінця;
          пп.позиція_в_тексті += 1;
          змінна закінчено: логічне = ні;
          поки пп.позиція_в_тексті < значення_кд.розмір {
            якщо значення_кд.дані[пп.позиція_в_тексті] == КД_РОЗРИВ {
              пп.рядок += 1;
              закінчено = так;
              стрибнути закінчити_перебір_коментаря;
            }
            пп.позиція_в_тексті += 1;
          }
          закінчити_перебір_коментаря:
  //        покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
  //          вид = ВидСловаКоментар,
  //          позиція_початку = п,
  //          позиція_кінця = пп - 1
  //        });
          якщо закінчено {
            покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
              вид = ВидСловаСимволМіжряд,
              позиція_початку = пп,
              позиція_кінця = пп
            });
          }
          п = пп;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        якщо перевірити_чи_починається_з(М, значення_кд, п, ";*", позиція_кінця::адреса) {
          змінна пп = позиція_кінця;
          пп.позиція_в_тексті += 1;
          змінна закінчено: логічне = ні;
          поки пп.позиція_в_тексті < значення_кд.розмір {
            якщо значення_кд.дані[пп.позиція_в_тексті] == КД_РОЗРИВ {
              пп.рядок += 1;
            }
            якщо перевірити_чи_починається_з(М, значення_кд, пп, "*;", пп::адреса) {
              закінчено = так;
              стрибнути закінчити_перебір_багаторядкового_коментаря;
            }
            пп.позиція_в_тексті += 1;
          }
          закінчити_перебір_багаторядкового_коментаря:
          якщо закінчено {
  //          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
  //            вид = ВидСловаБагаторядковийКоментар,
  //            позиція_початку = п,
  //            позиція_кінця = пп
  //          });
            п = пп;
            стрибнути далі;
          }
          стрибнути вийти_з_помилкою;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        змінна число_має_крапку = ні;
        якщо перевірити_чи_число(М, значення_кд, п, позиція_кінця::адреса, число_має_крапку::адреса) {
          якщо число_має_крапку {
            покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
              вид = ВидСловаДробове,
              позиція_початку = п,
              позиція_кінця = позиція_кінця
            });
          } інакше {
            покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
              вид = ВидСловаЦіле,
              позиція_початку = п,
              позиція_кінця = позиція_кінця
            });
          }
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

    перевірка_ідентифікатора:
        якщо перевірити_чи_має_ідентифікатор_за_позицією_початку(М, значення_кд, п, позиція_кінця::адреса) {
          покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
            вид = ВидСловаІдентифікатор,
            позиція_початку = п,
            позиція_кінця = позиція_кінця
          });
          п = позиція_кінця;
          стрибнути далі;
        }
        якщо позиція_кінця.позиція_в_тексті == 0 {
          позиція_кінця = п;
        }
        якщо позиція_кінця.позиція_в_тексті > позиція_помилки.позиція_в_тексті {
          позиція_помилки = позиція_кінця;
        }

        стрибнути вийти_з_помилкою;

    далі:
        п.позиція_в_тексті += 1;
      }

      покласти_в_накопичувач<Слово>(М, накопичувач_слів::адреса, Слово {
        вид = ВидСловаКІНЕЦЬСЛІВ,
        позиція_початку = ПозиціяСлова { 0, 0, 0 },
        позиція_кінця = ПозиціяСлова { 0, 0, 0 }
      });

      вихід::вміст = Слова {
        накопичувач_слів.розмір,
        накопичувач_слів.дані
      };
      вихід_позиції_кінця::вміст = п;
      вернути так;

    вийти_з_помилкою:
      звільнити_памʼять(М, накопичувач_слів.дані);
      вихід_помилки::вміст = ПомилкаРозборуНаСлова {
        позиція_в_тексті = позиція_помилки.позиція_в_тексті,
        рядок = позиція_помилки.рядок,
        стовпець = позиція_помилки.стовпець
      };
      вернути ні;
    }

    місцева дія розібрати_на_слова(М: адреса<Машина>, значення_кд: кд, вихід: адреса<Слова>, вихід_помилки: адреса<ПомилкаРозборуНаСлова>) -> логічне {
      змінна позиція_кінця = ПозиціяСлова { 0, 0, 0 };
      вернути розібрати_на_слова_0(М, значення_кд, ПозиціяСлова { 0, 1, 1 }, ні, позиція_кінця::адреса, вихід, вихід_помилки);
    }

    місцева дія звільнити_слова(М: адреса<Машина>, слова: Слова) {
      звільнити_памʼять(М, слова.дані);
    }

    місцева дія звільнити_помилку_розбору_на_слова(М: адреса<Машина>, помилка: ПомилкаРозборуНаСлова) {
      // ...
    }

    місцева дія отримати_помилку_розбору_на_слова(М: адреса<Машина>, помилка: ПомилкаРозборуНаСлова, вихід: адреса<кд>) -> логічне {
      виділити_копію_кд(М, "Не вдалось розібрати на слова0", вихід);
      вернути так;
    }

    місцева дія отримати_рядок_помилки_розбору_на_слова(М: адреса<Машина>, помилка: ПомилкаРозборуНаСлова) -> природне {
      вернути помилка.рядок;
    }

    місцева дія отримати_стовпець_помилки_розбору_на_слова(М: адреса<Машина>, помилка: ПомилкаРозборуНаСлова) -> природне {
      вернути помилка.стовпець;
    }

    місцева дія отримати_значення_ідентифікатора(значення_кд: кд, слова: Слова, ідентифікатор: Ідентифікатор) -> кд {
      вернути отримати_значення_слова(значення_кд, слова, слова.дані[ідентифікатор.позиція_слова]);
    }

    місцева дія отримати_значення_слова(значення_кд: кд, слова: Слова, слово: Слово) -> кд {
      вернути кд {
        розмір = (слово.позиція_кінця.позиція_в_тексті - слово.позиція_початку.позиція_в_тексті) + 1,
        дані = значення_кд.дані[слово.позиція_початку.позиція_в_тексті]::адреса як памʼять<п8>
      };
    }

    місцева дія отримати_значення_тексту(значення_кд: кд, слова: Слова, слово: Слово) -> кд {
      змінна значення_слова = отримати_значення_слова(значення_кд, слова, слово);
      вернути кд { значення_слова.розмір - 2, значення_слова.дані[1]::адреса як памʼять<п8> };
    }

    місцева дія отримати_значення_символу(значення_кд: кд, слова: Слова, слово: Слово) -> кд {
      змінна значення_слова = отримати_значення_слова(значення_кд, слова, слово);
      вернути кд { значення_слова.розмір - 2, значення_слова.дані[1]::адреса як памʼять<п8> };
    }

    місцева дія отримати_рядок_з_місцезнаходження(значення_кд: кд, слова: Слова, місцезнаходження: Місцезнаходження) -> природне {
      вернути слова.дані[місцезнаходження.позиція_слова].позиція_початку.рядок;
    }

    місцева дія отримати_стовпець_з_місцезнаходження(значення_кд: кд, слова: Слова, місцезнаходження: Місцезнаходження) -> природне {
      вернути слова.дані[місцезнаходження.позиція_слова].позиція_початку.стовпець;
    }
  }
}

простір мавка {
  простір розбирач {
    дія зробити_повну_копію_сполуки(М: адреса<Машина>, сполука: адреса<Сполука>) -> адреса<Сполука>;
    дія зробити_повну_копію_тіла(М: адреса<Машина>, тіло: Сполуки) -> Сполуки;
    дія зробити_повну_копію_типу(М: адреса<Машина>, тип: Тип) -> Тип;
    дія зробити_повну_копію_можливо_типу(М: адреса<Машина>, тип: можливо<Тип>) -> можливо<Тип>;
    дія зробити_повну_копію_параметра(М: адреса<Машина>, параметр: Параметр) -> Параметр;
    дія зробити_повну_копію_параметрів(М: адреса<Машина>, кількість_параметрів: природне, параметри: памʼять<Параметр>) -> памʼять<Параметр>;
    дія зробити_повну_копію_аргумента(М: адреса<Машина>, аргумент: Аргумент) -> Аргумент;
    дія зробити_повну_копію_аргументів(М: адреса<Машина>, кількість_аргументів: природне, аргументи: памʼять<Аргумент>) -> памʼять<Аргумент>;
    дія зробити_повну_копію_гілок(М: адреса<Машина>, кількість_гілок: природне, сполуки: памʼять<адреса<Сполука>>) -> памʼять<адреса<Сполука>>;
    дія зробити_повну_копію_елемента_словника(М: адреса<Машина>, елемент: ЕлементСловника) -> ЕлементСловника;
    дія зробити_повну_копію_елементів_словника(М: адреса<Машина>, кількість_елементів: природне, елементи: памʼять<ЕлементСловника>) -> памʼять<ЕлементСловника>;
    дія зробити_повну_копію_ідентифікаторів(М: адреса<Машина>, кількість_ідентифікаторів: природне, ідентифікатори: памʼять<Ідентифікатор>) -> памʼять<Ідентифікатор>;
    дія зробити_повну_копію_елемента_взяти(М: адреса<Машина>, елемент: ЕлементВзяти) -> ЕлементВзяти;
    дія зробити_повну_копію_елементів_взяти(М: адреса<Машина>, кількість_елементів: природне, елементи: памʼять<ЕлементВзяти>) -> памʼять<ЕлементВзяти>;
    дія зробити_повну_копію_елемента_дати(М: адреса<Машина>, елемент: ЕлементДати) -> ЕлементДати;
    дія зробити_повну_копію_елементів_дати(М: адреса<Машина>, кількість_елементів: природне, елементи: памʼять<ЕлементДати>) -> памʼять<ЕлементДати>;
    дія звільнити_сполуку(М: адреса<Машина>, сполука: адреса<Сполука>);
    дія звільнити_тіло(М: адреса<Машина>, тіло: Сполуки);
    дія звільнити_тип(М: адреса<Машина>, тип: Тип);
    дія звільнити_параметри(М: адреса<Машина>, кількість_параметрів: природне, параметри: памʼять<Параметр>);
    дія звільнити_аргументи(М: адреса<Машина>, кількість_аргументів: природне, аргументи: памʼять<Аргумент>);
    дія звільнити_елементи_словника(М: адреса<Машина>, кількість_елементів: природне, елементи: памʼять<ЕлементСловника>);

    дія зробити_повну_копію_сполуки(М: адреса<Машина>, сполука: адреса<Сполука>) -> адреса<Сполука> {
      якщо сполука == пусто {
        вернути пусто;
      }
      змінна копія = виділити<Сполука>(М);
      копія.вид = сполука.вид;
      якщо сполука.вид == ВидСполукиВизначити {
        змінна дані = сполука.дані як ДаніСполукиВизначити;
        копія.дані = ДаніСполукиВизначити {
          ідентифікатор = дані.ідентифікатор,
          значення = зробити_повну_копію_сполуки(М, дані.значення)
        };
      } інакше якщо сполука.вид == ВидСполукиЗвернутись {
        змінна дані = сполука.дані як ДаніСполукиЗвернутись;
        копія.дані = ДаніСполукиЗвернутись {
          ідентифікатор = дані.ідентифікатор
        };
      } інакше якщо сполука.вид == ВидСполукиОтриматиВластивість {
        змінна дані = сполука.дані як ДаніСполукиОтриматиВластивість;
        копія.дані = ДаніСполукиОтриматиВластивість {
          предмет = зробити_повну_копію_сполуки(М, дані.предмет),
          ідентифікатор = дані.ідентифікатор
        };
      } інакше якщо сполука.вид == ВидСполукиОтриматиЕлемент {
        змінна дані = сполука.дані як ДаніСполукиОтриматиЕлемент;
        копія.дані = ДаніСполукиОтриматиЕлемент {
          предмет = зробити_повну_копію_сполуки(М, дані.предмет),
          ключ = зробити_повну_копію_сполуки(М, дані.ключ)
        };
      } інакше якщо сполука.вид == ВидСполукиЗмінитиВластивість {
        змінна дані = сполука.дані як ДаніСполукиЗмінитиВластивість;
        копія.дані = ДаніСполукиЗмінитиВластивість {
          предмет = зробити_повну_копію_сполуки(М, дані.предмет),
          ідентифікатор = дані.ідентифікатор,
          значення = зробити_повну_копію_сполуки(М, дані.значення)
        };
      } інакше якщо сполука.вид == ВидСполукиЗмінитиЕлемент {
        змінна дані = сполука.дані як ДаніСполукиЗмінитиЕлемент;
        копія.дані = ДаніСполукиЗмінитиЕлемент {
          предмет = зробити_повну_копію_сполуки(М, дані.предмет),
          ключ = зробити_повну_копію_сполуки(М, дані.ключ),
          значення = зробити_повну_копію_сполуки(М, дані.значення)
        };
      } інакше якщо сполука.вид == ВидСполукиВиконати {
        змінна дані = сполука.дані як ДаніСполукиВиконати;
        копія.дані = ДаніСполукиВиконати {
          предмет = зробити_повну_копію_сполуки(М, дані.предмет),
          кількість_аргументів = дані.кількість_аргументів,
          аргументи = зробити_повну_копію_аргументів(М, дані.кількість_аргументів, дані.аргументи)
        };
      } інакше якщо сполука.вид == ВидСполукиДія {
        змінна дані = сполука.дані як ДаніСполукиДія;
        копія.дані = ДаніСполукиДія {
          тривала = дані.тривала,
          власна = дані.власна,
          структура_ = зробити_повну_копію_сполуки(М, дані.структура_),
          ідентифікатор = дані.ідентифікатор,
          кількість_параметрів = дані.кількість_параметрів,
          параметри = зробити_повну_копію_параметрів(М, дані.кількість_параметрів, дані.параметри),
          тип_результату = зробити_повну_копію_можливо_типу(М, дані.тип_результату),
          тіло = зробити_повну_копію_тіла(М, дані.тіло)
        };
      } інакше якщо сполука.вид == ВидСполукиСтруктура {
        змінна дані = сполука.дані як ДаніСполукиСтруктура;
        копія.дані = ДаніСполукиСтруктура {
          ідентифікатор = дані.ідентифікатор,
          предок = зробити_повну_копію_сполуки(М, дані.предок),
          кількість_параметрів = дані.кількість_параметрів,
          параметри = зробити_повну_копію_параметрів(М, дані.кількість_параметрів, дані.параметри)
        };
      } інакше якщо сполука.вид == ВидСполукиЦіле {
        змінна дані = сполука.дані як ДаніСполукиЦіле;
        копія.дані = ДаніСполукиЦіле {
          позиція_слова = дані.позиція_слова
        };
      } інакше якщо сполука.вид == ВидСполукиДробове {
        змінна дані = сполука.дані як ДаніСполукиДробове;
        копія.дані = ДаніСполукиДробове {
          позиція_слова = дані.позиція_слова
        };
      } інакше якщо сполука.вид == ВидСполукиТекст {
        змінна дані = сполука.дані як ДаніСполукиТекст;
        копія.дані = ДаніСполукиТекст {
          ідентифікатор = дані.ідентифікатор,
          позиція_слова = дані.позиція_слова
        };
      } інакше якщо сполука.вид == ВидСполукиОперація {
        змінна дані = сполука.дані як ДаніСполукиОперація;
        копія.дані = ДаніСполукиОперація {
          ліво = зробити_повну_копію_сполуки(М, дані.ліво),
          операція = дані.операція,
          право = зробити_повну_копію_сполуки(М, дані.право)
        };
      } інакше якщо сполука.вид == ВидСполукиЯкщо {
        змінна дані = сполука.дані як ДаніСполукиЯкщо;
        копія.дані = ДаніСполукиЯкщо {
          умова = зробити_повну_копію_сполуки(М, дані.умова),
          тіло = зробити_повну_копію_тіла(М, дані.тіло),
          тіло_інакше = зробити_повну_копію_тіла(М, дані.тіло_інакше)
        };
      } інакше якщо сполука.вид == ВидСполукиПоки {
        змінна дані = сполука.дані як ДаніСполукиПоки;
        копія.дані = ДаніСполукиПоки {
          умова = зробити_повну_копію_сполуки(М, дані.умова),
          тіло = зробити_повну_копію_тіла(М, дані.тіло)
        };
      } інакше якщо сполука.вид == ВидСполукиВернути {
        змінна дані = сполука.дані як ДаніСполукиВернути;
        копія.дані = ДаніСполукиВернути {
          значення = зробити_повну_копію_сполуки(М, дані.значення)
        };
      } інакше якщо сполука.вид == ВидСполукиЗначенняЯкщо {
        змінна дані = сполука.дані як ДаніСполукиЗначенняЯкщо;
        копія.дані = ДаніСполукиЗначенняЯкщо {
          умова = зробити_повну_копію_сполуки(М, дані.умова),
          значення_так = зробити_повну_копію_сполуки(М, дані.значення_так),
          значення_ні = зробити_повну_копію_сполуки(М, дані.значення_ні)
        };
      } інакше якщо сполука.вид == ВидСполукиСамоОперація {
        змінна дані = сполука.дані як ДаніСполукиСамоОперація;
        копія.дані = ДаніСполукиСамоОперація {
          операція = дані.операція,
          предмет = зробити_повну_копію_сполуки(М, дані.предмет)
        };
      } інакше якщо сполука.вид == ВидСполукиВзяти {
        змінна дані = сполука.дані як ДаніСполукиВзяти;
        копія.дані = ДаніСполукиВзяти {
          тип = дані.тип,
          довжина_шляху = дані.довжина_шляху,
          шлях = зробити_повну_копію_ідентифікаторів(М, дані.довжина_шляху, дані.шлях),
          ідентифікатор_як = дані.ідентифікатор_як,
          кількість_елементів = дані.кількість_елементів,
          елементи = зробити_повну_копію_елементів_взяти(М, дані.кількість_елементів, дані.елементи)
        };
      } інакше якщо сполука.вид == ВидСполукиСпробувати {
        змінна дані = сполука.дані як ДаніСполукиСпробувати;
        копія.дані = ДаніСполукиСпробувати {
          тіло = зробити_повну_копію_тіла(М, дані.тіло),
          ідентифікатор_зловити = дані.ідентифікатор_зловити,
          тіло_зловити = зробити_повну_копію_тіла(М, дані.тіло_зловити)
        };
      } інакше якщо сполука.вид == ВидСполукиВпасти {
        змінна дані = сполука.дані як ДаніСполукиВпасти;
        копія.дані = ДаніСполукиВпасти {
          значення = зробити_повну_копію_сполуки(М, дані.значення)
        };
      } інакше якщо сполука.вид == ВидСполукиДати {
        змінна дані = сполука.дані як ДаніСполукиДати;
        копія.дані = ДаніСполукиДати {
          кількість_елементів = дані.кількість_елементів,
          елементи = зробити_повну_копію_елементів_дати(М, дані.кількість_елементів, дані.елементи)
        };
      } інакше якщо сполука.вид == ВидСполукиМодуль {
        змінна дані = сполука.дані як ДаніСполукиМодуль;
        копія.дані = ДаніСполукиМодуль {
          ідентифікатор = дані.ідентифікатор,
          тіло = зробити_повну_копію_тіла(М, дані.тіло)
        };
      } інакше якщо сполука.вид == ВидСполукиСписок {
        змінна дані = сполука.дані як ДаніСполукиСписок;
        копія.дані = ДаніСполукиСписок {
          кількість_елементів = дані.кількість_елементів,
          елементи = зробити_повну_копію_гілок(М, дані.кількість_елементів, дані.елементи)
        };
      } інакше якщо сполука.вид == ВидСполукиСловник {
        змінна дані = сполука.дані як ДаніСполукиСловник;
        копія.дані = ДаніСполукиСловник {
          кількість_елементів = дані.кількість_елементів,
          елементи = зробити_повну_копію_елементів_словника(М, дані.кількість_елементів, дані.елементи)
        };
      } інакше якщо сполука.вид == ВидСполукиСимвол {
        змінна дані = сполука.дані як ДаніСполукиСимвол;
        копія.дані = ДаніСполукиСимвол {
          ідентифікатор = дані.ідентифікатор,
          позиція_слова = дані.позиція_слова
        };
      } інакше якщо сполука.вид == ВидСполукиПеребрати {
        змінна дані = сполука.дані як ДаніСполукиПеребрати;
        копія.дані = ДаніСполукиПеребрати {
          предмет = зробити_повну_копію_сполуки(М, дані.предмет),
          ідентифікатор = дані.ідентифікатор,
          тіло = зробити_повну_копію_тіла(М, дані.тіло)
        };
      } інакше якщо сполука.вид == ВидСполукиЦикл {
        змінна дані = сполука.дані як ДаніСполукиЦикл;
        копія.дані = ДаніСполукиЦикл {
          старт = зробити_повну_копію_тіла(М, дані.старт),
          умова = зробити_повну_копію_сполуки(М, дані.умова),
          тіло = зробити_повну_копію_тіла(М, дані.тіло),
          ітерація = зробити_повну_копію_тіла(М, дані.ітерація)
        };
      } інакше якщо сполука.вид == ВидСполукиВизначитиЗзовні {
        змінна дані = сполука.дані як ДаніСполукиВизначитиЗзовні;
        копія.дані = ДаніСполукиВизначитиЗзовні {
          ідентифікатор = дані.ідентифікатор,
          значення = зробити_повну_копію_сполуки(М, дані.значення)
        };
      } інакше якщо сполука.вид == ВидСполукиВічнийЦикл {
        змінна дані = сполука.дані як ДаніСполукиВічнийЦикл;
        копія.дані = ДаніСполукиВічнийЦикл {
          тіло = зробити_повну_копію_тіла(М, дані.тіло)
        };
      } інакше якщо сполука.вид == ВидСполукиЧекати {
        змінна дані = сполука.дані як ДаніСполукиЧекати;
        копія.дані = ДаніСполукиЧекати {
          значення = зробити_повну_копію_сполуки(М, дані.значення)
        };
      } інакше якщо сполука.вид == ВидСполукиДіапазон {
        змінна дані = сполука.дані як ДаніСполукиДіапазон;
        копія.дані = ДаніСполукиДіапазон {
          від = зробити_повну_копію_сполуки(М, дані.від),
          до = зробити_повну_копію_сполуки(М, дані.до),
          включно = дані.включно
        };
      } інакше якщо сполука.вид == ВидСполукиЗбитийТекст {
        змінна дані = сполука.дані як ДаніСполукиЗбитийТекст;
        копія.дані = ДаніСполукиЗбитийТекст {
          ідентифікатор = дані.ідентифікатор,
          кількість_гілок = дані.кількість_гілок,
          сполуки = зробити_повну_копію_гілок(М, дані.кількість_гілок, дані.сполуки)
        };
      } інакше {
//        надрукувати_кд("НЕВІДОМИЙ ВИД ГІЛКИ ДЛЯ КОПІЮВАННЯ");
      }
      копія.місцезнаходження = сполука.місцезнаходження;
      вернути копія;
    }

    дія зробити_повну_копію_тіла(М: адреса<Машина>, тіло: Сполуки) -> Сполуки {
      вернути Сполуки { тіло.розмір, зробити_повну_копію_гілок(М, тіло.розмір, тіло.дані) };
    }

    дія зробити_повну_копію_типу(М: адреса<Машина>, тип: Тип) -> Тип {
      вернути Тип { тип.кількість_гілок, зробити_повну_копію_гілок(М, тип.кількість_гілок, тип.сполуки) };
    }

    дія зробити_повну_копію_можливо_типу(М: адреса<Машина>, тип: можливо<Тип>) -> можливо<Тип> {
      якщо тип.заповнено {
        вернути можливо<Тип> { так, зробити_повну_копію_типу(М, тип.значення) };
      }
      вернути можливо<Тип> { ні, ... };
    }

    дія зробити_повну_копію_параметра(М: адреса<Машина>, параметр: Параметр) -> Параметр {
      вернути Параметр {
        ідентифікатор = параметр.ідентифікатор,
        тип = зробити_повну_копію_можливо_типу(М, параметр.тип),
        значення = зробити_повну_копію_сполуки(М, параметр.значення),
        місцезнаходження = параметр.місцезнаходження
      };
    }

    дія зробити_повну_копію_параметрів(М: адреса<Машина>, кількість_параметрів: природне, параметри: памʼять<Параметр>) -> памʼять<Параметр> {
      якщо кількість_параметрів == 0 {
        вернути пусто;
      }
      змінна нові_параметри = виділити_памʼять<Параметр>(М, кількість_параметрів);
      змінна п: природне = 0;
      поки п < кількість_параметрів {
        нові_параметри[п] = зробити_повну_копію_параметра(М, параметри[п]);
        п += 1;
      }
      вернути нові_параметри;
    }

    дія зробити_повну_копію_аргумента(М: адреса<Машина>, аргумент: Аргумент) -> Аргумент {
      вернути Аргумент {
        ідентифікатор = аргумент.ідентифікатор,
        значення = зробити_повну_копію_сполуки(М, аргумент.значення),
        місцезнаходження = аргумент.місцезнаходження
      };
    }

    дія зробити_повну_копію_аргументів(М: адреса<Машина>, кількість_аргументів: природне, аргументи: памʼять<Аргумент>) -> памʼять<Аргумент> {
      якщо кількість_аргументів == 0 {
        вернути пусто;
      }
      змінна нові_аргументи = виділити_памʼять<Аргумент>(М, кількість_аргументів);
      змінна п: природне = 0;
      поки п < кількість_аргументів {
        нові_аргументи[п] = зробити_повну_копію_аргумента(М, аргументи[п]);
        п += 1;
      }
      вернути нові_аргументи;
    }

    дія зробити_повну_копію_гілок(М: адреса<Машина>, кількість_гілок: природне, сполуки: памʼять<адреса<Сполука>>) -> памʼять<адреса<Сполука>> {
      якщо кількість_гілок == 0 {
        вернути пусто;
      }
      змінна нові_сполуки = виділити_памʼять<адреса<Сполука>>(М, кількість_гілок);
      змінна п: природне = 0;
      поки п < кількість_гілок {
        нові_сполуки[п] = зробити_повну_копію_сполуки(М, сполуки[п]);
        п += 1;
      }
      вернути нові_сполуки;
    }

    дія зробити_повну_копію_елемента_словника(М: адреса<Машина>, елемент: ЕлементСловника) -> ЕлементСловника {
      вернути ЕлементСловника {
        ключ = зробити_повну_копію_сполуки(М, елемент.ключ),
        значення = зробити_повну_копію_сполуки(М, елемент.значення),
        місцезнаходження = елемент.місцезнаходження
      };
    }

    дія зробити_повну_копію_елементів_словника(М: адреса<Машина>, кількість_елементів: природне, елементи: памʼять<ЕлементСловника>) -> памʼять<ЕлементСловника> {
      якщо кількість_елементів == 0 {
        вернути пусто;
      }
      змінна нові_елементи = виділити_памʼять<ЕлементСловника>(М, кількість_елементів);
      змінна п: природне = 0;
      поки п < кількість_елементів {
        нові_елементи[п] = зробити_повну_копію_елемента_словника(М, елементи[п]);
        п += 1;
      }
      вернути нові_елементи;
    }

    дія зробити_повну_копію_ідентифікаторів(М: адреса<Машина>, кількість_ідентифікаторів: природне, ідентифікатори: памʼять<Ідентифікатор>) -> памʼять<Ідентифікатор> {
      якщо кількість_ідентифікаторів == 0 {
        вернути пусто;
      }
      змінна нові_ідентифікатори = виділити_памʼять<Ідентифікатор>(М, кількість_ідентифікаторів);
      змінна п: природне = 0;
      поки п < кількість_ідентифікаторів {
        нові_ідентифікатори[п] = ідентифікатори[п];
        п += 1;
      }
      вернути нові_ідентифікатори;
    }

    дія зробити_повну_копію_елемента_взяти(М: адреса<Машина>, елемент: ЕлементВзяти) -> ЕлементВзяти {
      вернути елемент;
    }

    дія зробити_повну_копію_елементів_взяти(М: адреса<Машина>, кількість_елементів: природне, елементи: памʼять<ЕлементВзяти>) -> памʼять<ЕлементВзяти> {
      якщо кількість_елементів == 0 {
        вернути пусто;
      }
      змінна нові_елементи = виділити_памʼять<ЕлементВзяти>(М, кількість_елементів);
      змінна п: природне = 0;
      поки п < кількість_елементів {
        нові_елементи[п] = зробити_повну_копію_елемента_взяти(М, елементи[п]);
        п += 1;
      }
      вернути нові_елементи;
    }

    дія зробити_повну_копію_елемента_дати(М: адреса<Машина>, елемент: ЕлементДати) -> ЕлементДати {
      вернути елемент;
    }

    дія зробити_повну_копію_елементів_дати(М: адреса<Машина>, кількість_елементів: природне, елементи: памʼять<ЕлементДати>) -> памʼять<ЕлементДати> {
      якщо кількість_елементів == 0 {
        вернути пусто;
      }
      змінна нові_елементи = виділити_памʼять<ЕлементДати>(М, кількість_елементів);
      змінна п: природне = 0;
      поки п < кількість_елементів {
        нові_елементи[п] = зробити_повну_копію_елемента_дати(М, елементи[п]);
        п += 1;
      }
      вернути нові_елементи;
    }

    дія звільнити_сполуку(М: адреса<Машина>, сполука: адреса<Сполука>) {
      якщо сполука != пусто {
        якщо сполука.вид == ВидСполукиВизначити {
          змінна дані = сполука.дані як ДаніСполукиВизначити;
          звільнити_сполуку(М, дані.значення);
        } інакше якщо сполука.вид == ВидСполукиОтриматиВластивість {
          змінна дані = сполука.дані як ДаніСполукиОтриматиВластивість;
          звільнити_сполуку(М, дані.предмет);
        } інакше якщо сполука.вид == ВидСполукиОтриматиЕлемент {
          змінна дані = сполука.дані як ДаніСполукиОтриматиЕлемент;
          звільнити_сполуку(М, дані.предмет);
          звільнити_сполуку(М, дані.ключ);
        } інакше якщо сполука.вид == ВидСполукиЗмінитиВластивість {
          змінна дані = сполука.дані як ДаніСполукиЗмінитиВластивість;
          звільнити_сполуку(М, дані.предмет);
          звільнити_сполуку(М, дані.значення);
        } інакше якщо сполука.вид == ВидСполукиЗмінитиЕлемент {
          змінна дані = сполука.дані як ДаніСполукиЗмінитиЕлемент;
          звільнити_сполуку(М, дані.предмет);
          звільнити_сполуку(М, дані.ключ);
          звільнити_сполуку(М, дані.значення);
        } інакше якщо сполука.вид == ВидСполукиВиконати {
          змінна дані = сполука.дані як ДаніСполукиВиконати;
          звільнити_сполуку(М, дані.предмет);
          звільнити_аргументи(М, дані.кількість_аргументів, дані.аргументи);
        } інакше якщо сполука.вид == ВидСполукиДія {
          змінна дані = сполука.дані як ДаніСполукиДія;
          звільнити_сполуку(М, дані.структура_);
          звільнити_параметри(М, дані.кількість_параметрів, дані.параметри);
          якщо дані.тип_результату.заповнено {
            звільнити_тип(М, дані.тип_результату.значення);
          }
          звільнити_тіло(М, дані.тіло);
        } інакше якщо сполука.вид == ВидСполукиСтруктура {
          змінна дані = сполука.дані як ДаніСполукиСтруктура;
          звільнити_сполуку(М, дані.предок);
          звільнити_параметри(М, дані.кількість_параметрів, дані.параметри);
        } інакше якщо сполука.вид == ВидСполукиОперація {
          змінна дані = сполука.дані як ДаніСполукиОперація;
          звільнити_сполуку(М, дані.ліво);
          звільнити_сполуку(М, дані.право);
        } інакше якщо сполука.вид == ВидСполукиЯкщо {
          змінна дані = сполука.дані як ДаніСполукиЯкщо;
          звільнити_сполуку(М, дані.умова);
          звільнити_тіло(М, дані.тіло);
          звільнити_тіло(М, дані.тіло_інакше);
        } інакше якщо сполука.вид == ВидСполукиПоки {
          змінна дані = сполука.дані як ДаніСполукиПоки;
          звільнити_сполуку(М, дані.умова);
          звільнити_тіло(М, дані.тіло);
        } інакше якщо сполука.вид == ВидСполукиВернути {
          змінна дані = сполука.дані як ДаніСполукиВернути;
          звільнити_сполуку(М, дані.значення);
        } інакше якщо сполука.вид == ВидСполукиЗначенняЯкщо {
          змінна дані = сполука.дані як ДаніСполукиЗначенняЯкщо;
          звільнити_сполуку(М, дані.умова);
          звільнити_сполуку(М, дані.значення_так);
          звільнити_сполуку(М, дані.значення_ні);
        } інакше якщо сполука.вид == ВидСполукиСамоОперація {
          змінна дані = сполука.дані як ДаніСполукиСамоОперація;
          звільнити_сполуку(М, дані.предмет);
        } інакше якщо сполука.вид == ВидСполукиВзяти {
          змінна дані = сполука.дані як ДаніСполукиВзяти;
          звільнити_памʼять(М, дані.шлях);
          звільнити_памʼять(М, дані.елементи);
        } інакше якщо сполука.вид == ВидСполукиСпробувати {
          змінна дані = сполука.дані як ДаніСполукиСпробувати;
          звільнити_тіло(М, дані.тіло);
          звільнити_тіло(М, дані.тіло_зловити);
        } інакше якщо сполука.вид == ВидСполукиВпасти {
          змінна дані = сполука.дані як ДаніСполукиВпасти;
          звільнити_сполуку(М, дані.значення);
        } інакше якщо сполука.вид == ВидСполукиДати {
          змінна дані = сполука.дані як ДаніСполукиДати;
          звільнити_памʼять(М, дані.елементи);
        } інакше якщо сполука.вид == ВидСполукиМодуль {
          змінна дані = сполука.дані як ДаніСполукиМодуль;
          звільнити_тіло(М, дані.тіло);
        } інакше якщо сполука.вид == ВидСполукиСписок {
          змінна дані = сполука.дані як ДаніСполукиСписок;
          звільнити_сполуки(М, Сполуки { дані.кількість_елементів, дані.елементи });
        } інакше якщо сполука.вид == ВидСполукиСловник {
          змінна дані = сполука.дані як ДаніСполукиСловник;
          звільнити_елементи_словника(М, дані.кількість_елементів, дані.елементи);
        } інакше якщо сполука.вид == ВидСполукиПеребрати {
          змінна дані = сполука.дані як ДаніСполукиПеребрати;
          звільнити_сполуку(М, дані.предмет);
          звільнити_тіло(М, дані.тіло);
        } інакше якщо сполука.вид == ВидСполукиЦикл {
          змінна дані = сполука.дані як ДаніСполукиЦикл;
          звільнити_тіло(М, дані.старт);
          звільнити_сполуку(М, дані.умова);
          звільнити_тіло(М, дані.тіло);
          звільнити_тіло(М, дані.ітерація);
        } інакше якщо сполука.вид == ВидСполукиВизначитиЗзовні {
          змінна дані = сполука.дані як ДаніСполукиВизначитиЗзовні;
          звільнити_сполуку(М, дані.значення);
        } інакше якщо сполука.вид == ВидСполукиВічнийЦикл {
          змінна дані = сполука.дані як ДаніСполукиВічнийЦикл;
          звільнити_тіло(М, дані.тіло);
        } інакше якщо сполука.вид == ВидСполукиЧекати {
          змінна дані = сполука.дані як ДаніСполукиЧекати;
          звільнити_сполуку(М, дані.значення);
        } інакше якщо сполука.вид == ВидСполукиДіапазон {
          змінна дані = сполука.дані як ДаніСполукиДіапазон;
          звільнити_сполуку(М, дані.від);
          звільнити_сполуку(М, дані.до);
        } інакше якщо сполука.вид == ВидСполукиЗбитийТекст {
          змінна дані = сполука.дані як ДаніСполукиЗбитийТекст;
          звільнити_сполуки(М, Сполуки { дані.кількість_гілок, дані.сполуки });
        }
        звільнити(М, сполука);
      }
    }

    дія звільнити_тіло(М: адреса<Машина>, тіло: Сполуки) {
      змінна п: природне = 0;
      поки п < тіло.розмір {
        звільнити_сполуку(М, тіло.дані[п]);
        п += 1;
      }
      звільнити_памʼять(М, тіло.дані);
    }

    дія звільнити_тип(М: адреса<Машина>, тип: Тип) {
      змінна п: природне = 0;
      поки п < тип.кількість_гілок {
        звільнити_сполуку(М, тип.сполуки[п]);
        п += 1;
      }
      звільнити_памʼять(М, тип.сполуки);
    }

    дія звільнити_параметри(М: адреса<Машина>, кількість_параметрів: природне, параметри: памʼять<Параметр>) {
      змінна п: природне = 0;
      поки п < кількість_параметрів {
        якщо параметри[п].тип.заповнено {
          звільнити_тип(М, параметри[п].тип.значення);
        }
        звільнити_сполуку(М, параметри[п].значення);
        п += 1;
      }
      звільнити_памʼять(М, параметри);
    }

    дія звільнити_аргументи(М: адреса<Машина>, кількість_аргументів: природне, аргументи: памʼять<Аргумент>) {
      змінна п: природне = 0;
      поки п < кількість_аргументів {
        звільнити_сполуку(М, аргументи[п].значення);
        п += 1;
      }
      звільнити_памʼять(М, аргументи);
    }

    дія звільнити_елементи_словника(М: адреса<Машина>, кількість_елементів: природне, елементи: памʼять<ЕлементСловника>) {
      змінна п: природне = 0;
      поки п < кількість_елементів {
        звільнити_сполуку(М, елементи[п].ключ);
        звільнити_сполуку(М, елементи[п].значення);
        п += 1;
      }
      звільнити_памʼять(М, елементи);
    }

    дія зʼїсти_міжрядки(слова: Слова, позиція_початку: природне, вихід_позиції_кінця: адреса<природне>) -> логічне;
    дія спробувати_розібрати_заперечення(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_двійкове_заперечення(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_префікс_плюс(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_префікс_мінус(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_чекати(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_частинку(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_атом(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_аргумент(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<Аргумент>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_молекулу(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_молекулу__хвіст(М: адреса<Машина>, слова: Слова, позиція_початку: природне, позиція_початку_молекули: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, сполука_атома: адреса<Сполука>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_мікрооперацію(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_операцію(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, в_гнізді: логічне, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_операцію_1(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, сполука_ліво: адреса<Сполука>, мін: природне, в_гнізді: логічне, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_значення(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, в_гнізді: логічне, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_вернути(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_впасти(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_елемент_взяти(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<ЕлементВзяти>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_взяти(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_елемент_дати(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<ЕлементДати>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_дати(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_елемент_тіла(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_тіло(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<Сполуки>, вихід_позиції_кінця: адреса<природне>, вид_слова_закінчення: природне, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_тип(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<Тип>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_параметр(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<Параметр>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_дію(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_структуру(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_модуль(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_якщо(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_поки(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_цикл(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_перебрати(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;
    дія спробувати_розібрати_спробувати(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне;

    дія зʼїсти_міжрядки(слова: Слова, позиція_початку: природне, вихід_позиції_кінця: адреса<природне>) -> логічне {
      якщо слова.дані[позиція_початку].вид != ВидСловаСимволМіжряд {
        вернути ні;
      }
      змінна п = позиція_початку;
      поки слова.дані[п].вид == ВидСловаСимволМіжряд {
        п += 1;
      }
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія спробувати_розібрати_заперечення(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна п = позиція_початку;

      якщо слова.дані[п].вид != ВидСловаСимволЗнакОклику {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;

      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: природне = 0;
      якщо не спробувати_розібрати_мікрооперацію(М, слова, п, сполука_значення::адреса, п::адреса, позиція_помилки_сполуки_значення::адреса) {
        вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
        вернути ні;
      }

      змінна сполука_самооперація = виділити<Сполука>(М);
      сполука_самооперація.вид = ВидСполукиСамоОперація;
      сполука_самооперація.дані = ДаніСполукиСамоОперація {
        операція = ВидСамоОпераціїЛогічнеНі,
        предмет = сполука_значення
      };
      сполука_самооперація.місцезнаходження = Місцезнаходження { позиція_початку };
      вихід::вміст = сполука_самооперація;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія спробувати_розібрати_двійкове_заперечення(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна п = позиція_початку;

      якщо слова.дані[п].вид != ВидСловаСимволДвійковеНе {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;

      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: природне = 0;
      якщо не спробувати_розібрати_мікрооперацію(М, слова, п, сполука_значення::адреса, п::адреса, позиція_помилки_сполуки_значення::адреса) {
        вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
        вернути ні;
      }

      змінна сполука_самооперація = виділити<Сполука>(М);
      сполука_самооперація.вид = ВидСполукиСамоОперація;
      сполука_самооперація.дані = ДаніСполукиСамоОперація {
        операція = ВидСамоОпераціїДвійковеНі,
        предмет = сполука_значення
      };
      сполука_самооперація.місцезнаходження = Місцезнаходження { позиція_початку };
      вихід::вміст = сполука_самооперація;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія спробувати_розібрати_префікс_плюс(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна п = позиція_початку;

      якщо слова.дані[п].вид != ВидСловаСимволПлюс {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;

      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: природне = 0;
      якщо не спробувати_розібрати_мікрооперацію(М, слова, п, сполука_значення::адреса, п::адреса, позиція_помилки_сполуки_значення::адреса) {
        вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
        вернути ні;
      }

      змінна сполука_самооперація = виділити<Сполука>(М);
      сполука_самооперація.вид = ВидСполукиСамоОперація;
      сполука_самооперація.дані = ДаніСполукиСамоОперація {
        операція = ВидСамоОпераціїПлюс,
        предмет = сполука_значення
      };
      сполука_самооперація.місцезнаходження = Місцезнаходження { позиція_початку };
      вихід::вміст = сполука_самооперація;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія спробувати_розібрати_префікс_мінус(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна п = позиція_початку;

      якщо слова.дані[п].вид != ВидСловаСимволМінус {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;

      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: природне = 0;
      якщо не спробувати_розібрати_мікрооперацію(М, слова, п, сполука_значення::адреса, п::адреса, позиція_помилки_сполуки_значення::адреса) {
        вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
        вернути ні;
      }

      змінна сполука_самооперація = виділити<Сполука>(М);
      сполука_самооперація.вид = ВидСполукиСамоОперація;
      сполука_самооперація.дані = ДаніСполукиСамоОперація {
        операція = ВидСамоОпераціїМінус,
        предмет = сполука_значення
      };
      сполука_самооперація.місцезнаходження = Місцезнаходження { позиція_початку };
      вихід::вміст = сполука_самооперація;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія спробувати_розібрати_чекати(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна п = позиція_початку;

      якщо слова.дані[п].вид != ВидСловаЧекати {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;

      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: природне = 0;
      якщо не спробувати_розібрати_мікрооперацію(М, слова, п, сполука_значення::адреса, п::адреса, позиція_помилки_сполуки_значення::адреса) {
        вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
        вернути ні;
      }

      змінна сполука_чекати = виділити<Сполука>(М);
      сполука_чекати.вид = ВидСполукиЧекати;
      сполука_чекати.дані = ДаніСполукиЧекати {
        значення = сполука_значення
      };
      сполука_чекати.місцезнаходження = Місцезнаходження { позиція_початку };
      вихід::вміст = сполука_чекати;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія спробувати_розібрати_частинку(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна п = позиція_початку;

      якщо слова.дані[п].вид == ВидСловаСимволВідкритаДужка {
        п += 1;

        зʼїсти_міжрядки(слова, п, п::адреса);

        змінна сполука_гнізда: адреса<Сполука> = пусто;
        змінна позиція_помилки_сполуки_гнізда: природне = 0;
        якщо спробувати_розібрати_значення(М, слова, п, сполука_гнізда::адреса, п::адреса, так, позиція_помилки_сполуки_гнізда::адреса) {
          п += 1;

          зʼїсти_міжрядки(слова, п, п::адреса);

          якщо слова.дані[п].вид == ВидСловаСимволЗакритаДужка {
            вихід::вміст = сполука_гнізда;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          } інакше {
            позиція_помилки_сполуки_гнізда = п;
            звільнити_сполуку(М, сполука_гнізда);
          }
        }

        вихід_позиції_помилки::вміст = позиція_помилки_сполуки_гнізда;
        вернути ні;
      }

      п = позиція_початку;

      якщо слова.дані[п].вид == ВидСловаІдентифікатор {
        змінна позиція_ідентифікатора = п;

        п += 1;

        якщо слова.дані[п].вид == ВидСловаТекст {
          змінна сполука_тексту = виділити<Сполука>(М);
          сполука_тексту.вид = ВидСполукиТекст;
          сполука_тексту.дані = ДаніСполукиТекст {
            ідентифікатор = можливо<Ідентифікатор> { так, Ідентифікатор { позиція_ідентифікатора } },
            позиція_слова = п
          };
          сполука_тексту.місцезнаходження = Місцезнаходження { позиція_ідентифікатора };
          вихід::вміст = сполука_тексту;
          вихід_позиції_кінця::вміст = п;
          вернути так;
        } інакше якщо слова.дані[п].вид == ВидСловаСимвол {
          змінна сполука_символа = виділити<Сполука>(М);
          сполука_символа.вид = ВидСполукиСимвол;
          сполука_символа.дані = ДаніСполукиСимвол {
            ідентифікатор = можливо<Ідентифікатор> { так, Ідентифікатор { позиція_ідентифікатора } },
            позиція_слова = п
          };
          сполука_символа.місцезнаходження = Місцезнаходження { позиція_ідентифікатора };
          вихід::вміст = сполука_символа;
          вихід_позиції_кінця::вміст = п;
          вернути так;
        } інакше якщо слова.дані[п].вид == ВидСловаПочатокЗбитогоТексту {
          п += 1;

          змінна накопичувач_гілок = зробити_накопичувач<адреса<Сполука>>(М);

          поки п < слова.розмір {
            змінна сполука_значення: адреса<Сполука> = пусто;
            змінна позиція_помилки_збитого_тексту: природне = 0;

            якщо слова.дані[п].вид == ВидСловаЧастинаЗбитогоТексту {
              змінна сполука_тексту = виділити<Сполука>(М);
              сполука_тексту.вид = ВидСполукиТекст;
              сполука_тексту.дані = ДаніСполукиТекст {
                ідентифікатор = можливо<Ідентифікатор> { так, Ідентифікатор { позиція_ідентифікатора } },
                позиція_слова = п
              };
              сполука_тексту.місцезнаходження = Місцезнаходження { позиція_ідентифікатора };
              покласти_в_накопичувач<адреса<Сполука>>(М, накопичувач_гілок::адреса, сполука_тексту);
              п += 1;
            } інакше якщо спробувати_розібрати_значення(М, слова, п, сполука_значення::адреса, п::адреса, ні, позиція_помилки_збитого_тексту::адреса) {
              покласти_в_накопичувач<адреса<Сполука>>(М, накопичувач_гілок::адреса, сполука_значення);
              п += 1;
            } інакше {
              вихід_позиції_помилки::вміст = позиція_помилки_збитого_тексту;
              звільнити_сполуки(М, Сполуки { накопичувач_гілок.розмір, накопичувач_гілок.дані });
              вернути ні;
            }

            якщо слова.дані[п].вид == ВидСловаРоздільникЗбитогоТексту {
              п += 1;
            } інакше якщо слова.дані[п].вид == ВидСловаКінецьЗбитогоТексту {
              стрибнути вихід_збитого_тексту_з_ідентифікатором;
            } інакше {
              вихід_позиції_помилки::вміст = п;
              звільнити_сполуки(М, Сполуки { накопичувач_гілок.розмір, накопичувач_гілок.дані });
              вернути ні;
            }
          }

    вихід_збитого_тексту_з_ідентифікатором:
          якщо накопичувач_гілок.розмір == 1 {
            змінна сполука = накопичувач_гілок.дані[0];
            звільнити_памʼять(М, накопичувач_гілок.дані);
            вихід::вміст = сполука;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          } інакше {
            змінна сполука_збитого_тексту = виділити<Сполука>(М);
            сполука_збитого_тексту.вид = ВидСполукиЗбитийТекст;
            сполука_збитого_тексту.дані = ДаніСполукиЗбитийТекст {
              ідентифікатор = можливо<Ідентифікатор> { так, Ідентифікатор { позиція_ідентифікатора } },
              кількість_гілок = накопичувач_гілок.розмір,
              сполуки = накопичувач_гілок.дані,
            };
            сполука_збитого_тексту.місцезнаходження = Місцезнаходження { п };
            вихід::вміст = сполука_збитого_тексту;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          }
        } інакше {
          п -= 1;
        }

        змінна сполука_звернення = виділити<Сполука>(М);
        сполука_звернення.вид = ВидСполукиЗвернутись;
        сполука_звернення.дані = ДаніСполукиЗвернутись {
          ідентифікатор = Ідентифікатор { п }
        };
        сполука_звернення.місцезнаходження = Місцезнаходження { п };
        вихід::вміст = сполука_звернення;
        вихід_позиції_кінця::вміст = п;
        вернути так;
      }

      якщо слова.дані[п].вид == ВидСловаЦіле {
        змінна сполука_числа = виділити<Сполука>(М);
        сполука_числа.вид = ВидСполукиЦіле;
        сполука_числа.дані = ДаніСполукиЦіле {
          позиція_слова = п
        };
        сполука_числа.місцезнаходження = Місцезнаходження { п };
        вихід::вміст = сполука_числа;
        вихід_позиції_кінця::вміст = п;
        вернути так;
      }

      якщо слова.дані[п].вид == ВидСловаДробове {
        змінна сполука_числа = виділити<Сполука>(М);
        сполука_числа.вид = ВидСполукиДробове;
        сполука_числа.дані = ДаніСполукиДробове {
          позиція_слова = п
        };
        сполука_числа.місцезнаходження = Місцезнаходження { п };
        вихід::вміст = сполука_числа;
        вихід_позиції_кінця::вміст = п;
        вернути так;
      }

      якщо слова.дані[п].вид == ВидСловаТекст {
        змінна сполука_тексту = виділити<Сполука>(М);
        сполука_тексту.вид = ВидСполукиТекст;
        сполука_тексту.дані = ДаніСполукиТекст {
          ідентифікатор = можливо<Ідентифікатор> { ні, ... },
          позиція_слова = п
        };
        сполука_тексту.місцезнаходження = Місцезнаходження { п };
        вихід::вміст = сполука_тексту;
        вихід_позиції_кінця::вміст = п;
        вернути так;
      }

      якщо слова.дані[п].вид == ВидСловаСимвол {
        змінна сполука_символа = виділити<Сполука>(М);
        сполука_символа.вид = ВидСполукиСимвол;
        сполука_символа.дані = ДаніСполукиСимвол {
          ідентифікатор = можливо<Ідентифікатор> { ні, ... },
          позиція_слова = п
        };
        сполука_символа.місцезнаходження = Місцезнаходження { п };
        вихід::вміст = сполука_символа;
        вихід_позиції_кінця::вміст = п;
        вернути так;
      }

      якщо слова.дані[п].вид == ВидСловаПочатокЗбитогоТексту {
        п += 1;

        змінна накопичувач_гілок = зробити_накопичувач<адреса<Сполука>>(М);

        поки п < слова.розмір {
          змінна сполука_значення: адреса<Сполука> = пусто;
          змінна позиція_помилки_збитого_тексту: природне = 0;
          якщо слова.дані[п].вид == ВидСловаЧастинаЗбитогоТексту {
            змінна сполука_тексту = виділити<Сполука>(М);
            сполука_тексту.вид = ВидСполукиТекст;
            сполука_тексту.дані = ДаніСполукиТекст {
              ідентифікатор = можливо<Ідентифікатор> { ні, ... },
              позиція_слова = п
            };
            сполука_тексту.місцезнаходження = Місцезнаходження { п };
            покласти_в_накопичувач<адреса<Сполука>>(М, накопичувач_гілок::адреса, сполука_тексту);
            п += 1;
          } інакше якщо спробувати_розібрати_значення(М, слова, п, сполука_значення::адреса, п::адреса, ні, позиція_помилки_збитого_тексту::адреса) {
            покласти_в_накопичувач<адреса<Сполука>>(М, накопичувач_гілок::адреса, сполука_значення);
            п += 1;
          } інакше {
            вихід_позиції_помилки::вміст = позиція_помилки_збитого_тексту;
            звільнити_сполуки(М, Сполуки { накопичувач_гілок.розмір, накопичувач_гілок.дані });
            вернути ні;
          }

          якщо слова.дані[п].вид == ВидСловаРоздільникЗбитогоТексту {
            п += 1;
          } інакше якщо слова.дані[п].вид == ВидСловаКінецьЗбитогоТексту {
            стрибнути вихід_збитого_тексту;
          } інакше {
            вихід_позиції_помилки::вміст = п;
            звільнити_сполуки(М, Сполуки { накопичувач_гілок.розмір, накопичувач_гілок.дані });
            вернути ні;
          }
        }

    вихід_збитого_тексту:
        якщо накопичувач_гілок.розмір == 1 {
          змінна сполука = накопичувач_гілок.дані[0];
          звільнити_памʼять(М, накопичувач_гілок.дані);
          вихід::вміст = сполука;
          вихід_позиції_кінця::вміст = п;
          вернути так;
        } інакше {
          змінна сполука_збитого_тексту = виділити<Сполука>(М);
          сполука_збитого_тексту.вид = ВидСполукиЗбитийТекст;
          сполука_збитого_тексту.дані = ДаніСполукиЗбитийТекст {
            ідентифікатор = можливо<Ідентифікатор> { ні, ... },
            кількість_гілок = накопичувач_гілок.розмір,
            сполуки = накопичувач_гілок.дані,
          };
          сполука_збитого_тексту.місцезнаходження = Місцезнаходження { п };
          вихід::вміст = сполука_збитого_тексту;
          вихід_позиції_кінця::вміст = п;
          вернути так;
        }
      }

      вихід_позиції_помилки::вміст = п;
      вернути ні;
    }

    дія спробувати_розібрати_атом(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна п = позиція_початку;

      якщо слова.дані[п].вид == ВидСловаСимволКвадратнаВідкритаДужка {
        змінна позиція_початку_списку = п;

        п += 1;

        зʼїсти_міжрядки(слова, п, п::адреса);

        якщо слова.дані[п].вид == ВидСловаСимволКвадратнаЗакритаДужка {
          змінна сполука_списку = виділити<Сполука>(М);
          сполука_списку.вид = ВидСполукиСписок;
          сполука_списку.дані = ДаніСполукиСписок {
            кількість_елементів = 0,
            елементи = пусто
          };
          сполука_списку.місцезнаходження = Місцезнаходження { позиція_початку_списку };
          вихід::вміст = сполука_списку;
          вихід_позиції_кінця::вміст = п;
          вернути так;
        }

        змінна елементи_списку = зробити_накопичувач<адреса<Сполука>>(М);

        поки п < слова.розмір {
          змінна сполука_значення_елемента: адреса<Сполука> = пусто;
          змінна позиція_помилки_елемента: природне = 0;

          якщо спробувати_розібрати_значення(М, слова, п, сполука_значення_елемента::адреса, п::адреса, ні, позиція_помилки_елемента::адреса) {
            п += 1;

            зʼїсти_міжрядки(слова, п, п::адреса);
          } інакше {
            звільнити_сполуки(М, Сполуки { елементи_списку.розмір, елементи_списку.дані });
            вихід_позиції_помилки::вміст = позиція_помилки_елемента;
            вернути ні;
          }

          покласти_в_накопичувач<адреса<Сполука>>(М, елементи_списку::адреса, сполука_значення_елемента);

          зʼїсти_міжрядки(слова, п, п::адреса);

          якщо слова.дані[п].вид == ВидСловаСимволКома {
            п += 1;
            зʼїсти_міжрядки(слова, п, п::адреса);
          } інакше якщо слова.дані[п].вид == ВидСловаСимволКвадратнаЗакритаДужка {
            змінна сполука_списку = виділити<Сполука>(М);
            сполука_списку.вид = ВидСполукиСписок;
            сполука_списку.дані = ДаніСполукиСписок {
              кількість_елементів = елементи_списку.розмір,
              елементи = елементи_списку.дані
            };
            сполука_списку.місцезнаходження = Місцезнаходження { позиція_початку_списку };
            вихід::вміст = сполука_списку;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          } інакше {
            звільнити_сполуки(М, Сполуки { елементи_списку.розмір, елементи_списку.дані });
            вихід_позиції_помилки::вміст = п;
            вернути ні;
          }
        }

        звільнити_сполуки(М, Сполуки { елементи_списку.розмір, елементи_списку.дані });
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      } інакше якщо слова.дані[п].вид == ВидСловаСимволФігурнаВідкритаДужка {
        змінна позиція_початку_словника = п;

        п += 1;

        зʼїсти_міжрядки(слова, п, п::адреса);

        якщо слова.дані[п].вид == ВидСловаСимволФігурнаЗакритаДужка {
          змінна сполука_словника = виділити<Сполука>(М);
          сполука_словника.вид = ВидСполукиСловник;
          сполука_словника.дані = ДаніСполукиСловник {
            кількість_елементів = 0,
            елементи = пусто
          };
          сполука_словника.місцезнаходження = Місцезнаходження { позиція_початку_словника };
          вихід::вміст = сполука_словника;
          вихід_позиції_кінця::вміст = п;
          вернути так;
        }

        змінна елементи_словника = зробити_накопичувач<ЕлементСловника>(М);

        поки п < слова.розмір {
          змінна сполука_ключа_елемента: адреса<Сполука> = пусто;
          змінна сполука_значення_елемента: адреса<Сполука> = пусто;
          змінна позиція_помилки_елемента: природне = 0;

          якщо спробувати_розібрати_значення(М, слова, п, сполука_ключа_елемента::адреса, п::адреса, ні, позиція_помилки_елемента::адреса) {
            п += 1;

            зʼїсти_міжрядки(слова, п, п::адреса);

            якщо слова.дані[п].вид == ВидСловаСимволРівно {
              п += 1;

              якщо слова.дані[п].вид == ВидСловаСимволБільше {
                п += 1;

                зʼїсти_міжрядки(слова, п, п::адреса);

                якщо спробувати_розібрати_значення(М, слова, п, сполука_значення_елемента::адреса, п::адреса, ні, позиція_помилки_елемента::адреса) {
                  п += 1;
                } інакше {
                  звільнити_сполуку(М, сполука_ключа_елемента);
                  звільнити_елементи_словника(М, елементи_словника.розмір, елементи_словника.дані);
                  вихід_позиції_помилки::вміст = позиція_помилки_елемента;
                  вернути ні;
                }
              } інакше {
                звільнити_елементи_словника(М, елементи_словника.розмір, елементи_словника.дані);
                вихід_позиції_помилки::вміст = п;
                вернути ні;
              }
            } інакше {
              звільнити_елементи_словника(М, елементи_словника.розмір, елементи_словника.дані);
              вихід_позиції_помилки::вміст = п;
              вернути ні;
            }
          } інакше {
            звільнити_елементи_словника(М, елементи_словника.розмір, елементи_словника.дані);
            вихід_позиції_помилки::вміст = позиція_помилки_елемента;
            вернути ні;
          }

          покласти_в_накопичувач<ЕлементСловника>(М, елементи_словника::адреса, ЕлементСловника {
            ключ = сполука_ключа_елемента,
            значення = сполука_значення_елемента,
            місцезнаходження = Місцезнаходження { позиція_початку }
          });

          зʼїсти_міжрядки(слова, п, п::адреса);

          якщо слова.дані[п].вид == ВидСловаСимволКома {
            п += 1;
            зʼїсти_міжрядки(слова, п, п::адреса);
          } інакше якщо слова.дані[п].вид == ВидСловаСимволФігурнаЗакритаДужка {
            змінна сполука_словника = виділити<Сполука>(М);
            сполука_словника.вид = ВидСполукиСловник;
            сполука_словника.дані = ДаніСполукиСловник {
              кількість_елементів = елементи_словника.розмір,
              елементи = елементи_словника.дані
            };
            сполука_словника.місцезнаходження = Місцезнаходження { позиція_початку_словника };
            вихід::вміст = сполука_словника;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          } інакше {
            звільнити_елементи_словника(М, елементи_словника.розмір, елементи_словника.дані);
            вихід_позиції_помилки::вміст = п;
            вернути ні;
          }
        }

        звільнити_елементи_словника(М, елементи_словника.розмір, елементи_словника.дані);
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }

      п = позиція_початку;

      якщо спробувати_розібрати_частинку(М, слова, п, вихід, вихід_позиції_кінця, вихід_позиції_помилки) {
        вернути так;
      }

      вернути ні;
    }

    дія спробувати_розібрати_аргумент(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<Аргумент>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна п = позиція_початку;

      змінна має_ідентифікатор = ні;
      змінна позиція_ідентифікатора = п;

      якщо слова.дані[п].вид == ВидСловаІдентифікатор {
        має_ідентифікатор = так;
        п += 1;

        зʼїсти_міжрядки(слова, п, п::адреса);

        якщо слова.дані[п].вид == ВидСловаСимволРівно {
          п += 1;

          якщо слова.дані[п].вид == ВидСловаСимволРівно {
            має_ідентифікатор = ні;
            п = позиція_ідентифікатора;
          } інакше {
            зʼїсти_міжрядки(слова, п, п::адреса);
          }
        } інакше {
          має_ідентифікатор = ні;
          п = позиція_ідентифікатора;
        }
      }

      змінна сполука_значення_аргумента: адреса<Сполука> = пусто;
      змінна позиція_помилки_аргумента: природне = 0;
      якщо спробувати_розібрати_значення(М, слова, п, сполука_значення_аргумента::адреса, п::адреса, ні, позиція_помилки_аргумента::адреса) {
        якщо має_ідентифікатор {
          вихід::вміст = Аргумент {
            ідентифікатор = можливо<Ідентифікатор> { так, Ідентифікатор { позиція_ідентифікатора } },
            значення = сполука_значення_аргумента,
            місцезнаходження = Місцезнаходження { позиція_початку }
          };
        } інакше {
          вихід::вміст = Аргумент {
            ідентифікатор = можливо<Ідентифікатор> { ні, ... },
            значення = сполука_значення_аргумента,
            місцезнаходження = Місцезнаходження { позиція_початку }
          };
        }

        вихід_позиції_кінця::вміст = п;
        вернути так;
      }

      вихід_позиції_помилки::вміст = позиція_помилки_аргумента;
      вернути ні;
    }

    //
    // --- з рекурсією ---
    // молекула = (молекула ('.' ідентифікатор)) | атом;
    //
    // --- без рекурсії ---
    // молекула = атом хвіст_молекули;
    // хвіст_молекули = ('.' ідентифікатор хвіст_молекули) | ;
    //
    дія спробувати_розібрати_молекулу(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна п = позиція_початку;

      змінна сполука_атома: адреса<Сполука> = пусто;
      змінна позиція_помилки_атома: природне = 0;
      якщо спробувати_розібрати_атом(М, слова, п, сполука_атома::адреса, п::адреса, позиція_помилки_атома::адреса) {
        п += 1;

        змінна сполука_хвоста: адреса<Сполука> = пусто;
        змінна позиція_помилки_хвоста: природне = 0;
        якщо спробувати_розібрати_молекулу__хвіст(М, слова, п, позиція_початку, сполука_хвоста::адреса, п::адреса, сполука_атома, позиція_помилки_хвоста::адреса) {
          вихід::вміст = сполука_хвоста;
          вихід_позиції_кінця::вміст = п;
          вернути так;
        } інакше {
          п -= 1;
        }

        вихід::вміст = сполука_атома;
        вихід_позиції_кінця::вміст = п;
        вернути так;
      } інакше {
        вихід_позиції_помилки::вміст = позиція_помилки_атома;
        стрибнути звільнити_і_вийти;
      }

    звільнити_і_вийти:
      вернути ні;
    }

    дія спробувати_розібрати_молекулу__хвіст(М: адреса<Машина>, слова: Слова, позиція_початку: природне, позиція_початку_молекули: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, сполука_атома: адреса<Сполука>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна п = позиція_початку;
      змінна п_перед_зʼїданням = п;

      якщо зʼїсти_міжрядки(слова, п, п::адреса) {
        якщо слова.дані[п].вид == ВидСловаСимволКрапка {
          стрибнути отримання_властивості;
        } інакше {
          п = п_перед_зʼїданням;
        }
      }

      якщо слова.дані[п].вид == ВидСловаСимволКрапка { // отримати властивість
    отримання_властивості:
        п += 1;

        зʼїсти_міжрядки(слова, п, п::адреса);

        якщо слова.дані[п].вид == ВидСловаІдентифікатор або слова.дані[п].вид == ВидСловаЦіле {
          змінна сполука_отримати_властивість = виділити<Сполука>(М);
          сполука_отримати_властивість.вид = ВидСполукиОтриматиВластивість;
          сполука_отримати_властивість.дані = ДаніСполукиОтриматиВластивість {
            предмет = сполука_атома,
            ідентифікатор = Ідентифікатор { п }
          };
          сполука_отримати_властивість.місцезнаходження = Місцезнаходження { позиція_початку_молекули };
          п += 1;
          змінна позиція_помилки_молекули_хвоста: природне = 0;
          якщо спробувати_розібрати_молекулу__хвіст(М, слова, п, позиція_початку_молекули, вихід, вихід_позиції_кінця, сполука_отримати_властивість, позиція_помилки_молекули_хвоста::адреса) {
            вернути так;
          } інакше {
            звільнити(М, сполука_отримати_властивість);
            вихід_позиції_помилки::вміст = позиція_помилки_молекули_хвоста;
            вернути ні;
          }
        }

        вихід_позиції_помилки::вміст = п;
        вернути ні;
      } інакше якщо слова.дані[п].вид == ВидСловаСимволКвадратнаВідкритаДужка { // отримати елемент
        п += 1;

        зʼїсти_міжрядки(слова, п, п::адреса);

        змінна сполука_ключа: адреса<Сполука> = пусто;
        змінна позиція_помилки_ключа: природне = 0;
        якщо спробувати_розібрати_молекулу(М, слова, п, сполука_ключа::адреса, п::адреса, позиція_помилки_ключа::адреса) {
          п += 1;
        } інакше {
          вихід_позиції_помилки::вміст = позиція_помилки_ключа;
          вернути ні;
        }

        змінна сполука_отримати_елемент = виділити<Сполука>(М);
        сполука_отримати_елемент.вид = ВидСполукиОтриматиЕлемент;
        сполука_отримати_елемент.дані = ДаніСполукиОтриматиЕлемент {
          предмет = сполука_атома,
          ключ = сполука_ключа
        };
        сполука_отримати_елемент.місцезнаходження = Місцезнаходження { позиція_початку_молекули };

        зʼїсти_міжрядки(слова, п, п::адреса);

        якщо слова.дані[п].вид == ВидСловаСимволКвадратнаЗакритаДужка {
          п += 1;
          змінна позиція_помилки_молекули_хвоста: природне = 0;
          якщо спробувати_розібрати_молекулу__хвіст(М, слова, п, позиція_початку_молекули, вихід, вихід_позиції_кінця, сполука_отримати_елемент, позиція_помилки_молекули_хвоста::адреса) {
            вернути так;
          } інакше {
            звільнити(М, сполука_ключа);
            звільнити(М, сполука_отримати_елемент);
            вихід_позиції_помилки::вміст = позиція_помилки_молекули_хвоста;
            вернути ні;
          }
        }

        звільнити(М, сполука_ключа);
        звільнити(М, сполука_отримати_елемент);
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      } інакше якщо слова.дані[п].вид == ВидСловаСимволВідкритаДужка { // виконати дію
        п += 1;

        зʼїсти_міжрядки(слова, п, п::адреса);

        змінна аргументи = зробити_накопичувач<Аргумент>(М);
        якщо слова.дані[п].вид == ВидСловаСимволЗакритаДужка {
          п += 1;
          стрибнути виклик__хвіст;
        }

        поки п < слова.розмір {
          змінна аргумент = Аргумент { ... };
          змінна позиція_помилки_аргумента: природне = 0;
          якщо спробувати_розібрати_аргумент(М, слова, п, аргумент::адреса, п::адреса, позиція_помилки_аргумента::адреса) {
            покласти_в_накопичувач<Аргумент>(М, аргументи::адреса, аргумент);

            п += 1;

            зʼїсти_міжрядки(слова, п, п::адреса);

            якщо слова.дані[п].вид == ВидСловаСимволЗакритаДужка {
              п += 1;
              стрибнути виклик__хвіст;
            } інакше якщо слова.дані[п].вид == ВидСловаСимволКома {
              п += 1;
              зʼїсти_міжрядки(слова, п, п::адреса);
            } інакше {
              звільнити_аргументи(М, аргументи.розмір, аргументи.дані);
              вихід_позиції_помилки::вміст = п;
              вернути ні;
            }
          } інакше {
            звільнити_аргументи(М, аргументи.розмір, аргументи.дані);
            вихід_позиції_помилки::вміст = позиція_помилки_аргумента;
            вернути ні;
          }
        }

        якщо слова.дані[п].вид == ВидСловаСимволЗакритаДужка {
          п += 1;

    виклик__хвіст:
          змінна сполука_виконати = виділити<Сполука>(М);
          сполука_виконати.вид = ВидСполукиВиконати;
          сполука_виконати.дані = ДаніСполукиВиконати {
            предмет = сполука_атома,
            кількість_аргументів = аргументи.розмір,
            аргументи = аргументи.дані,
          };
          сполука_виконати.місцезнаходження = Місцезнаходження { позиція_початку_молекули };

          змінна позиція_помилки_молекули_хвоста: природне = 0;
          якщо спробувати_розібрати_молекулу__хвіст(М, слова, п, позиція_початку_молекули, вихід, вихід_позиції_кінця, сполука_виконати, позиція_помилки_молекули_хвоста::адреса) {
            вернути так;
          } інакше {
            звільнити_аргументи(М, аргументи.розмір, аргументи.дані);
            вихід_позиції_помилки::вміст = позиція_помилки_молекули_хвоста;
            вернути ні;
          }
        }

        звільнити_аргументи(М, аргументи.розмір, аргументи.дані);
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }

      вихід::вміст = сполука_атома;
      вихід_позиції_кінця::вміст = п - 1;
      вернути так;
    }

    дія спробувати_розібрати_мікрооперацію(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна п = позиція_початку;

      змінна сполука_молекули: адреса<Сполука> = пусто;
      змінна позиція_помилки_молекули: природне = 0;
      якщо спробувати_розібрати_молекулу(М, слова, п, сполука_молекули::адреса, п::адреса, позиція_помилки_молекули::адреса) {
        п += 1;

        якщо слова.дані[п].вид == ВидСловаСимволКрапка {
          п += 1;

          якщо слова.дані[п].вид == ВидСловаСимволКрапка {
            п += 1;

            змінна включно = ні;
            якщо слова.дані[п].вид == ВидСловаСимволРівно {
              включно = так;
              п += 1;
            }

            змінна сполука_молекули_право: адреса<Сполука> = пусто;
            змінна позиція_помилки_молекули_право: природне = 0;
            якщо спробувати_розібрати_молекулу(М, слова, п, сполука_молекули_право::адреса, п::адреса, позиція_помилки_молекули_право::адреса) {
              змінна сполука_діапазон = виділити<Сполука>(М);
              сполука_діапазон.вид = ВидСполукиДіапазон;
              сполука_діапазон.дані = ДаніСполукиДіапазон {
                від = сполука_молекули,
                до = сполука_молекули_право,
                включно = включно
              };
              сполука_діапазон.місцезнаходження = Місцезнаходження { позиція_початку };
              вихід::вміст = сполука_діапазон;
              вихід_позиції_кінця::вміст = п;
              вернути так;
            } інакше {
              вихід_позиції_помилки::вміст = позиція_помилки_молекули_право;
              вернути ні;
            }
          } інакше {
            вихід::вміст = сполука_молекули;
            вихід_позиції_кінця::вміст = п - 2;
            вернути так;
          }
        } інакше {
          вихід::вміст = сполука_молекули;
          вихід_позиції_кінця::вміст = п - 1;
          вернути так;
        }
      }

      змінна позиція_помилки: природне = позиція_помилки_молекули;
      змінна найдовша_позиція_помилки: природне = позиція_помилки;

      якщо спробувати_розібрати_заперечення(М, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_двійкове_заперечення(М, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_префікс_плюс(М, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_префікс_мінус(М, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_чекати(М, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      вихід_позиції_помилки::вміст = найдовша_позиція_помилки;
      вернути ні;
    }

    дія спробувати_розібрати_операцію(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, в_гнізді: логічне, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна п = позиція_початку;

      змінна сполука_ліво: адреса<Сполука> = пусто;
      змінна позиція_помилки_ліво: природне = 0;
      якщо спробувати_розібрати_мікрооперацію(М, слова, п, сполука_ліво::адреса, п::адреса, позиція_помилки_ліво::адреса) {
        п += 1;

        змінна сполука_результату: адреса<Сполука> = пусто;
        змінна позиція_помилки_сполуки_результату: природне = 0;
        якщо спробувати_розібрати_операцію_1(М, слова, п, сполука_результату::адреса, п::адреса, сполука_ліво, 0, в_гнізді, позиція_помилки_сполуки_результату::адреса) {
          вихід::вміст = сполука_результату;
          вихід_позиції_кінця::вміст = п;
          вернути так;
        } інакше {
          вихід::вміст = сполука_ліво;
          вихід_позиції_кінця::вміст = п - 1;
          вернути так;
        }
      } інакше {
        вихід_позиції_помилки::вміст = позиція_помилки_ліво;
        стрибнути звільнити_і_вийти;
      }

    звільнити_і_вийти:
      звільнити_сполуку(М, сполука_ліво);
      вернути ні;
    }

    структура ІнформаціяОперації {
      вид_операції: природне;
      кількість_слів: природне;
      пріоритет: природне;
    }

    дія дізнатись_інформацію_операції(слова: Слова, позиція: природне) -> ІнформаціяОперації {
      якщо слова.дані[позиція].вид == ВидСловаКІНЕЦЬСЛІВ {
        вернути ІнформаціяОперації { 0, 0, 0 };
      }

      змінна вид = слова.дані[позиція].вид;
      змінна вид_далі = слова.дані[позиція + 1].вид;

      якщо вид == ВидСловаСимволПлюс {
        вернути ІнформаціяОперації { ВидОпераціїДодавання, 1, 97 };
      }

      якщо вид == ВидСловаСимволМінус {
        вернути ІнформаціяОперації { ВидОпераціїВіднімання, 1, 97 };
      }

      якщо вид == ВидСловаСимволПомножити {
        якщо вид_далі == ВидСловаСимволПомножити {
          вернути ІнформаціяОперації { ВидОпераціїПіднесенняДоСтепеня, 2, 100 };
        }

        вернути ІнформаціяОперації { ВидОпераціїМноження, 1, 98 };
      }

      якщо вид == ВидСловаСимволПоділити {
        якщо вид_далі == ВидСловаСимволПоділити {
          вернути ІнформаціяОперації { ВидОпераціїДіленняНаціло, 2, 99 };
        }

        вернути ІнформаціяОперації { ВидОпераціїДілення, 1, 98 };
      }

      якщо вид == ВидСловаСимволЗалишку {
        вернути ІнформаціяОперації { ВидОпераціїМодуль, 1, 98 };
      }

      якщо вид == ВидСловаСимволБільше {
        якщо вид_далі == ВидСловаСимволБільше {
          якщо слова.дані[позиція + 2].вид == ВидСловаСимволБільше {
            вернути ІнформаціяОперації { ВидОпераціїЗсувВправоЗнаковий, 3, 96 };
          }

          вернути ІнформаціяОперації { ВидОпераціїЗсувВправо, 2, 96 };
        }

        якщо вид_далі == ВидСловаСимволРівно {
          вернути ІнформаціяОперації { ВидОпераціїБільшеРівне, 2, 95 };
        }

        вернути ІнформаціяОперації { ВидОпераціїБільше, 1, 95 };
      }

      якщо вид == ВидСловаСимволМенше {
        якщо вид_далі == ВидСловаСимволМенше {
          вернути ІнформаціяОперації { ВидОпераціїЗсувВліво, 2, 96 };
        }

        якщо вид_далі == ВидСловаСимволРівно {
          вернути ІнформаціяОперації { ВидОпераціїМеншеРівне, 2, 95 };
        }

        вернути ІнформаціяОперації { ВидОпераціїМенше, 1, 95 };
      }

      якщо вид == ВидСловаБільше {
        вернути ІнформаціяОперації { ВидОпераціїБільше, 1, 95 };
      }

      якщо вид == ВидСловаМенше {
        вернути ІнформаціяОперації { ВидОпераціїМенше, 1, 95 };
      }

      якщо вид == ВидСловаЄ {
        вернути ІнформаціяОперації { ВидОпераціїЄ, 1, 93 };
      }

      якщо вид == ВидСловаНе {
        якщо вид_далі == ВидСловаБільше {
          вернути ІнформаціяОперації { ВидОпераціїМеншеРівне, 2, 95 };
        }

        якщо вид_далі == ВидСловаМенше {
          вернути ІнформаціяОперації { ВидОпераціїБільшеРівне, 2, 95 };
        }

        якщо вид_далі == ВидСловаРівно {
          вернути ІнформаціяОперації { ВидОпераціїНерівне, 2, 94 };
        }

        якщо вид_далі == ВидСловаЄ {
          вернути ІнформаціяОперації { ВидОпераціїНеЄ, 2, 93 };
        }
      }

      якщо вид == ВидСловаСимволЗнакОклику {
        якщо вид_далі == ВидСловаСимволРівно {
          вернути ІнформаціяОперації { ВидОпераціїНерівне, 2, 94 };
        }
      }

      якщо вид == ВидСловаСимволРівно {
        якщо вид_далі == ВидСловаСимволРівно {
          вернути ІнформаціяОперації { ВидОпераціїРівне, 2, 94 };
        }
      }

      якщо вид == ВидСловаРівно {
        вернути ІнформаціяОперації { ВидОпераціїРівне, 1, 94 };
      }

      якщо вид == ВидСловаСимволІ {
        якщо вид_далі == ВидСловаСимволІ {
          вернути ІнформаціяОперації { ВидОпераціїІ, 2, 89 };
        }

        вернути ІнформаціяОперації { ВидОпераціїДІ, 1, 92 };
      }

      якщо вид == ВидСловаІ {
        вернути ІнформаціяОперації { ВидОпераціїІ, 1, 89 };
      }

      якщо вид == ВидСловаСимволВиключнеАбо {
        вернути ІнформаціяОперації { ВидОпераціїВАБО, 1, 91 };
      }

      якщо вид == ВидСловаСимволАбо {
        якщо вид_далі == ВидСловаСимволАбо {
          вернути ІнформаціяОперації { ВидОпераціїАБО, 2, 88 };
        }

        вернути ІнформаціяОперації { ВидОпераціїДАБО, 1, 90 };
      }

      якщо вид == ВидСловаАбо {
        вернути ІнформаціяОперації { ВидОпераціїАБО, 1, 88 };
      }

      вернути ІнформаціяОперації { 0, 0, 0 };
    }

    дія перевірити_оп1(інформація_операції: ІнформаціяОперації, мін: природне) -> логічне {
      якщо інформація_операції.вид_операції == 0 {
        вернути ні;
      }

      якщо інформація_операції.пріоритет >= мін {
        вернути так;
      }

      вернути ні;
    }

    дія перевірити_оп2(інформація_операції: ІнформаціяОперації, збережена_інформація_операції: ІнформаціяОперації) -> логічне {
      якщо інформація_операції.вид_операції == 0 {
        вернути ні;
      }

      якщо інформація_операції.пріоритет > збережена_інформація_операції.пріоритет {
        вернути так;
      }

      якщо інформація_операції.вид_операції == ВидОпераціїПіднесенняДоСтепеня {
        вернути інформація_операції.пріоритет == збережена_інформація_операції.пріоритет;
      }

      вернути ні;
    }

    дія спробувати_розібрати_операцію_1(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, сполука_ліво: адреса<Сполука>, мін: природне, в_гнізді: логічне, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна п = позиція_початку;
      змінна має_міжряд = ні;

      якщо в_гнізді == так {
        якщо слова.дані[п].вид == ВидСловаСимволМіжряд {
          має_міжряд = так;
          п += 1;
        }
      }

      змінна інформація_операції = дізнатись_інформацію_операції(слова, п);

      поки перевірити_оп1(інформація_операції, мін) {
        має_міжряд = ні;

        змінна збережена_інформація_операції = інформація_операції;

        п += інформація_операції.кількість_слів;

        якщо в_гнізді == так {
          зʼїсти_міжрядки(слова, п, п::адреса);
        }

        змінна сполука_право: адреса<Сполука> = пусто;
        змінна позиція_помилки_право: природне = 0;
        якщо спробувати_розібрати_мікрооперацію(М, слова, п, сполука_право::адреса, п::адреса, позиція_помилки_право::адреса) {
          п += 1;

          якщо в_гнізді == так {
            зʼїсти_міжрядки(слова, п, п::адреса);
          }

          інформація_операції = дізнатись_інформацію_операції(слова, п);

          поки перевірити_оп2(інформація_операції, збережена_інформація_операції) {
            змінна рсп = ні;
            змінна позиція_помилки_рсп: природне = 0;

            якщо інформація_операції.пріоритет > збережена_інформація_операції.пріоритет {
              рсп = спробувати_розібрати_операцію_1(М, слова, п, сполука_право::адреса, п::адреса, сполука_право, збережена_інформація_операції.пріоритет + 1, в_гнізді, позиція_помилки_рсп::адреса);
            } інакше {
              рсп = спробувати_розібрати_операцію_1(М, слова, п, сполука_право::адреса, п::адреса, сполука_право, збережена_інформація_операції.пріоритет, в_гнізді, позиція_помилки_рсп::адреса);
            }

            якщо рсп {
              п += 1;
            } інакше {
              звільнити_сполуку(М, сполука_право);
              вихід_позиції_помилки::вміст = позиція_помилки_рсп;
              вернути ні;
            }

            інформація_операції = дізнатись_інформацію_операції(слова, п);
          }

          змінна нова_сполука_ліво = виділити<Сполука>(М);
          нова_сполука_ліво.вид = ВидСполукиОперація;
          нова_сполука_ліво.дані = ДаніСполукиОперація {
            ліво = сполука_ліво,
            операція = збережена_інформація_операції.вид_операції,
            право = сполука_право,
          };

          нова_сполука_ліво.місцезнаходження = Місцезнаходження { позиція_початку };
          сполука_ліво = нова_сполука_ліво;

          якщо в_гнізді == так {
            якщо слова.дані[п].вид == ВидСловаСимволМіжряд {
              має_міжряд = так;
              п += 1;
            }
          }

          інформація_операції = дізнатись_інформацію_операції(слова, п);
        } інакше {
          вихід_позиції_помилки::вміст = позиція_помилки_право;
          вернути ні;
        }
      }

      вихід::вміст = сполука_ліво;

      якщо має_міжряд {
        вихід_позиції_кінця::вміст = п - 2;
      } інакше {
        вихід_позиції_кінця::вміст = п - 1;
      }

      вернути так;
    }

    дія спробувати_розібрати_значення(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, в_гнізді: логічне, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна найдовша_позиція_помилки: природне = 0;
      змінна позиція_помилки: природне = 0;

      якщо спробувати_розібрати_дію(М, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_структуру(М, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_модуль(М, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      змінна п = позиція_початку;

      змінна сполука_операція: адреса<Сполука> = пусто;
      змінна позиція_кінця_сполуки_операція: природне = 0;
      якщо спробувати_розібрати_операцію(М, слова, п, сполука_операція::адреса, позиція_кінця_сполуки_операція::адреса, в_гнізді, позиція_помилки::адреса) {
        п = позиція_кінця_сполуки_операція;
        п += 1;

        якщо слова.дані[п].вид == ВидСловаЯкщо {
          п += 1;

          змінна сполука_операція_значення: адреса<Сполука> = пусто;
          якщо спробувати_розібрати_операцію(М, слова, п, сполука_операція_значення::адреса, п::адреса, в_гнізді, позиція_помилки::адреса) {
            п += 1;

            якщо слова.дані[п].вид == ВидСловаІнакше {
              п += 1;

              змінна сполука_операція_значення_інакше: адреса<Сполука> = пусто;
              якщо спробувати_розібрати_операцію(М, слова, п, сполука_операція_значення_інакше::адреса, п::адреса, в_гнізді, позиція_помилки::адреса) {
                змінна сполука_значення_якщо = виділити<Сполука>(М);
                сполука_значення_якщо.вид = ВидСполукиЗначенняЯкщо;
                сполука_значення_якщо.дані = ДаніСполукиЗначенняЯкщо {
                  умова = сполука_операція_значення,
                  значення_так = сполука_операція,
                  значення_ні = сполука_операція_значення_інакше,
                };
                сполука_значення_якщо.місцезнаходження = Місцезнаходження { позиція_початку };
                вихід::вміст = сполука_значення_якщо;
                вихід_позиції_кінця::вміст = п;
                вернути так;
              } інакше {
                звільнити_сполуку(М, сполука_операція);
                звільнити_сполуку(М, сполука_операція_значення);
                якщо позиція_помилки > найдовша_позиція_помилки {
                  найдовша_позиція_помилки = позиція_помилки;
                }
                вихід_позиції_помилки::вміст = найдовша_позиція_помилки;
                вернути ні;
              }
            } інакше {
              звільнити_сполуку(М, сполука_операція);
              звільнити_сполуку(М, сполука_операція_значення);
              вихід_позиції_помилки::вміст = п;
              вернути ні;
            }
          } інакше {
            звільнити_сполуку(М, сполука_операція);
            якщо позиція_помилки > найдовша_позиція_помилки {
              найдовша_позиція_помилки = позиція_помилки;
            }
            вихід_позиції_помилки::вміст = найдовша_позиція_помилки;
            вернути ні;
          }
        } інакше {
          п -= 1;
        }

        вихід::вміст = сполука_операція;
        вихід_позиції_кінця::вміст = позиція_кінця_сполуки_операція;
        вернути так;
      }

      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      вихід_позиції_помилки::вміст = найдовша_позиція_помилки;
      вернути ні;
    }

    дія спробувати_розібрати_вернути(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна п = позиція_початку;

      якщо слова.дані[п].вид != ВидСловаВернути {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;

      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: природне = 0;
      якщо не спробувати_розібрати_значення(М, слова, п, сполука_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення::адреса) {
        п -= 1;
      }

      змінна сполука_вернути = виділити<Сполука>(М);
      сполука_вернути.вид = ВидСполукиВернути;
      сполука_вернути.дані = ДаніСполукиВернути {
        значення = сполука_значення
      };
      сполука_вернути.місцезнаходження = Місцезнаходження { позиція_початку };
      вихід::вміст = сполука_вернути;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія спробувати_розібрати_впасти(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна п = позиція_початку;

      якщо слова.дані[п].вид != ВидСловаВпасти {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;

      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: природне = 0;
      якщо не спробувати_розібрати_значення(М, слова, п, сполука_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення::адреса) {
        п -= 1;
      }

      змінна сполука_впасти = виділити<Сполука>(М);
      сполука_впасти.вид = ВидСполукиВпасти;
      сполука_впасти.дані = ДаніСполукиВпасти {
        значення = сполука_значення
      };
      сполука_впасти.місцезнаходження = Місцезнаходження { позиція_початку };
      вихід::вміст = сполука_впасти;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія спробувати_розібрати_елемент_взяти(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<ЕлементВзяти>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна п = позиція_початку;

      змінна позиція_ідентифікатора = п;
      якщо слова.дані[п].вид != ВидСловаІдентифікатор {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;

      змінна має_ідентифікатор_як = ні;
      змінна позиція_ідентифікатора_як = п + 1;
      якщо слова.дані[п].вид == ВидСловаЯк {
        п += 1;

        якщо слова.дані[п].вид != ВидСловаІдентифікатор {
          вихід_позиції_помилки::вміст = п;
          вернути ні;
        }

        має_ідентифікатор_як = так;
        позиція_ідентифікатора_як = п;
      } інакше {
        п -= 1;
      }

      вихід::вміст = ЕлементВзяти {
        ідентифікатор = Ідентифікатор { позиція_ідентифікатора },
        ідентифікатор_як = можливо<Ідентифікатор> { має_ідентифікатор_як, Ідентифікатор { позиція_ідентифікатора_як } },
        місцезнаходження = Місцезнаходження { позиція_початку }
      };

      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія спробувати_розібрати_взяти(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна п = позиція_початку;

      змінна шлях = зробити_накопичувач<Ідентифікатор>(М);
      якщо слова.дані[п].вид != ВидСловаВзяти {
        звільнити_накопичувач<Ідентифікатор>(М, шлях);
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }

      п += 1;
      змінна позиція_виду_взяти = п;
      якщо слова.дані[п].вид == ВидСловаМодуль {
        п += 1;
      } інакше якщо слова.дані[п].вид == ВидСловаІдентифікатор {
        п += 1;
      } інакше {
        звільнити_накопичувач<Ідентифікатор>(М, шлях);
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }

      поки п < слова.розмір {
        якщо слова.дані[п].вид == ВидСловаІдентифікатор {
          покласти_в_накопичувач<Ідентифікатор>(М, шлях::адреса, Ідентифікатор { п });
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволКрапка {
            п += 1;
          } інакше {
            стрибнути після_шляху;
          }
        } інакше {
          звільнити_накопичувач<Ідентифікатор>(М, шлях);
        вихід_позиції_помилки::вміст = п;
          вернути ні;
        }
      }

    після_шляху:
      якщо слова.дані[п].вид == ВидСловаЯк {
        п += 1;

        змінна ідентифікатор_як = п;
        якщо слова.дані[п].вид != ВидСловаІдентифікатор {
          звільнити_накопичувач<Ідентифікатор>(М, шлях);
          вихід_позиції_помилки::вміст = п;
          вернути ні;
        }

        змінна сполука_взяти = виділити<Сполука>(М);
        сполука_взяти.вид = ВидСполукиВзяти;
        сполука_взяти.дані = ДаніСполукиВзяти {
          тип = можливо<Ідентифікатор> { так, Ідентифікатор { позиція_виду_взяти } },
          довжина_шляху = шлях.розмір,
          шлях = шлях.дані,
          ідентифікатор_як = можливо<Ідентифікатор> { так, Ідентифікатор { ідентифікатор_як } },
          кількість_елементів = 0,
          елементи = пусто
        };
        сполука_взяти.місцезнаходження = Місцезнаходження { позиція_початку };
        вихід::вміст = сполука_взяти;
        вихід_позиції_кінця::вміст = п;
        вернути так;
      } інакше якщо слова.дані[п].вид == ВидСловаСимволКвадратнаВідкритаДужка {
        п += 1;

        змінна елементи = зробити_накопичувач<ЕлементВзяти>(М);
        поки п < слова.розмір {
          змінна елемент_взяти = ЕлементВзяти { ... };
          змінна позиція_помилки_елемента_взяти: природне = 0;
          якщо спробувати_розібрати_елемент_взяти(М, слова, п, елемент_взяти::адреса, п::адреса, позиція_помилки_елемента_взяти::адреса) {
            покласти_в_накопичувач<ЕлементВзяти>(М, елементи::адреса, елемент_взяти);
            п += 1;
            якщо слова.дані[п].вид == ВидСловаСимволКома {
              п += 1;
            } інакше якщо слова.дані[п].вид == ВидСловаСимволКвадратнаЗакритаДужка {
              змінна сполука_взяти = виділити<Сполука>(М);
              сполука_взяти.вид = ВидСполукиВзяти;
              сполука_взяти.дані = ДаніСполукиВзяти {
                тип = можливо<Ідентифікатор> { так, Ідентифікатор { позиція_виду_взяти } },
                довжина_шляху = шлях.розмір,
                шлях = шлях.дані,
                ідентифікатор_як = можливо<Ідентифікатор> { ні, ... },
                кількість_елементів = елементи.розмір,
                елементи = елементи.дані
              };
              сполука_взяти.місцезнаходження = Місцезнаходження { позиція_початку };
              вихід::вміст = сполука_взяти;
              вихід_позиції_кінця::вміст = п;
              вернути так;
            } інакше {
              звільнити_накопичувач<Ідентифікатор>(М, шлях);
              звільнити_накопичувач<ЕлементВзяти>(М, елементи);
              вихід_позиції_помилки::вміст = п;
              вернути ні;
            }
          } інакше {
            звільнити_накопичувач<Ідентифікатор>(М, шлях);
            звільнити_накопичувач<ЕлементВзяти>(М, елементи);
            вихід_позиції_помилки::вміст = позиція_помилки_елемента_взяти;
            вернути ні;
          }
        }

        звільнити_накопичувач<Ідентифікатор>(М, шлях);
        звільнити_накопичувач<ЕлементВзяти>(М, елементи);
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      } інакше {
        змінна сполука_взяти = виділити<Сполука>(М);
        сполука_взяти.вид = ВидСполукиВзяти;
        сполука_взяти.дані = ДаніСполукиВзяти {
          тип = можливо<Ідентифікатор> { так, Ідентифікатор { позиція_виду_взяти } },
          довжина_шляху = шлях.розмір,
          шлях = шлях.дані,
          ідентифікатор_як = можливо<Ідентифікатор> { ні, ... },
          кількість_елементів = 0,
          елементи = пусто
        };
        сполука_взяти.місцезнаходження = Місцезнаходження { позиція_початку };
        вихід::вміст = сполука_взяти;
        вихід_позиції_кінця::вміст = п - 1;
        вернути так;
      }

      звільнити_накопичувач<Ідентифікатор>(М, шлях);
      вихід_позиції_помилки::вміст = п;
      вернути ні;
    }

    дія спробувати_розібрати_елемент_дати(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<ЕлементДати>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна п = позиція_початку;

      змінна позиція_ідентифікатора = п;
      якщо слова.дані[п].вид != ВидСловаІдентифікатор {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;

      змінна має_ідентифікатор_як = ні;
      змінна позиція_ідентифікатора_як = п + 1;
      якщо слова.дані[п].вид == ВидСловаЯк {
        п += 1;

        якщо слова.дані[п].вид != ВидСловаІдентифікатор {
          вихід_позиції_помилки::вміст = п;
          вернути ні;
        }

        має_ідентифікатор_як = так;
        позиція_ідентифікатора_як = п;
      } інакше {
        п -= 1;
      }

      вихід::вміст = ЕлементДати {
        ідентифікатор = Ідентифікатор { позиція_ідентифікатора },
        ідентифікатор_як = можливо<Ідентифікатор> { має_ідентифікатор_як, Ідентифікатор { позиція_ідентифікатора_як } },
        місцезнаходження = Місцезнаходження { позиція_початку }
      };

      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія спробувати_розібрати_дати(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна п = позиція_початку;

      якщо слова.дані[п].вид != ВидСловаДати {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }

      п += 1;

      змінна елементи = зробити_накопичувач<ЕлементДати>(М);
      поки п < слова.розмір {
        змінна елемент_дати = ЕлементДати { ... };
        змінна позиція_помилки_елемента_дати: природне = 0;
        якщо спробувати_розібрати_елемент_дати(М, слова, п, елемент_дати::адреса, п::адреса, позиція_помилки_елемента_дати::адреса) {
          покласти_в_накопичувач<ЕлементДати>(М, елементи::адреса, елемент_дати);
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволКома {
            п += 1;
          } інакше {
            п -= 1;
            стрибнути завершення;
          }
        } інакше {
          звільнити_накопичувач<ЕлементДати>(М, елементи);
          вихід_позиції_помилки::вміст = позиція_помилки_елемента_дати;
          вернути ні;
        }
      }

    завершення:
      змінна сполука_дати = виділити<Сполука>(М);
      сполука_дати.вид = ВидСполукиДати;
      сполука_дати.дані = ДаніСполукиДати {
        кількість_елементів = елементи.розмір,
        елементи = елементи.дані
      };
      сполука_дати.місцезнаходження = Місцезнаходження { позиція_початку };
      вихід::вміст = сполука_дати;
      вихід_позиції_кінця::вміст = п;
      вернути так;
    }

    дія спробувати_розібрати_елемент_тіла(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна позиція_помилки: природне = 0;
      змінна найдовша_позиція_помилки: природне = 0;

      якщо спробувати_розібрати_вернути(М, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_впасти(М, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_взяти(М, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_дати(М, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_якщо(М, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_поки(М, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_цикл(М, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_перебрати(М, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      якщо спробувати_розібрати_спробувати(М, слова, позиція_початку, вихід, вихід_позиції_кінця, позиція_помилки::адреса) {
        вернути так;
      }
      якщо позиція_помилки > найдовша_позиція_помилки {
        найдовша_позиція_помилки = позиція_помилки;
      }

      змінна п = позиція_початку;
      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: природне = 0;
      якщо спробувати_розібрати_значення(М, слова, п, сполука_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення::адреса) {
        п += 1;
        змінна вид_операції: природне = 0;
        якщо слова.дані[п].вид == ВидСловаСимволПлюс {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволРівно {
            вид_операції = ВидОпераціїДодавання;
            стрибнути спроба2;
          } інакше {
            п -= 2;
            стрибнути вихід;
          }
        } інакше якщо слова.дані[п].вид == ВидСловаСимволМінус {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволРівно {
            вид_операції = ВидОпераціїВіднімання;
            стрибнути спроба2;
          } інакше {
            п -= 2;
            стрибнути вихід;
          }
        } інакше якщо слова.дані[п].вид == ВидСловаСимволПомножити {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволПомножити {
            п += 1;
            якщо слова.дані[п].вид == ВидСловаСимволРівно {
              вид_операції = ВидОпераціїПіднесенняДоСтепеня;
              стрибнути спроба2;
            } інакше {
              п -= 3;
              стрибнути вихід;
            }
          } інакше якщо слова.дані[п].вид == ВидСловаСимволРівно {
            вид_операції = ВидОпераціїМноження;
            стрибнути спроба2;
          } інакше {
            п -= 2;
            стрибнути вихід;
          }
        } інакше якщо слова.дані[п].вид == ВидСловаСимволПоділити {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволПоділити {
            п += 1;
            якщо слова.дані[п].вид == ВидСловаСимволРівно {
              вид_операції = ВидОпераціїДіленняНаціло;
              стрибнути спроба2;
            } інакше {
              п -= 3;
              стрибнути вихід;
            }
          } інакше якщо слова.дані[п].вид == ВидСловаСимволРівно {
            вид_операції = ВидОпераціїДілення;
            стрибнути спроба2;
          } інакше {
            п -= 2;
            стрибнути вихід;
          }
        } інакше якщо слова.дані[п].вид == ВидСловаСимволЗалишку {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволРівно {
            вид_операції = ВидОпераціїМодуль;
            стрибнути спроба2;
          } інакше {
            п -= 2;
            стрибнути вихід;
          }
        } інакше якщо слова.дані[п].вид == ВидСловаСимволІ {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволРівно {
            вид_операції = ВидОпераціїДІ;
            стрибнути спроба2;
          } інакше {
            п -= 2;
            стрибнути вихід;
          }
        } інакше якщо слова.дані[п].вид == ВидСловаСимволАбо {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволРівно {
            вид_операції = ВидОпераціїДАБО;
            стрибнути спроба2;
          } інакше {
            п -= 2;
            стрибнути вихід;
          }
        } інакше якщо слова.дані[п].вид == ВидСловаСимволВиключнеАбо {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволРівно {
            вид_операції = ВидОпераціїВАБО;
            стрибнути спроба2;
          } інакше {
            п -= 2;
            стрибнути вихід;
          }
        } інакше якщо слова.дані[п].вид == ВидСловаСимволБільше {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволБільше {
            п += 1;
            якщо слова.дані[п].вид == ВидСловаСимволБільше {
              п += 1;
              якщо слова.дані[п].вид == ВидСловаСимволРівно {
                вид_операції = ВидОпераціїЗсувВправоЗнаковий;
                стрибнути спроба2;
              } інакше {
                п -= 4;
                стрибнути вихід;
              }
            } інакше якщо слова.дані[п].вид == ВидСловаСимволРівно {
              вид_операції = ВидОпераціїЗсувВправо;
              стрибнути спроба2;
            } інакше {
              п -= 3;
              стрибнути вихід;
            }
          } інакше {
            п -= 2;
            стрибнути вихід;
          }
        } інакше якщо слова.дані[п].вид == ВидСловаСимволМенше {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволМенше {
            п += 1;
            якщо слова.дані[п].вид == ВидСловаСимволРівно {
              вид_операції = ВидОпераціїЗсувВліво;
              стрибнути спроба2;
            } інакше {
              п -= 3;
              стрибнути вихід;
            }
          } інакше {
            п -= 2;
            стрибнути вихід;
          }
        } інакше якщо слова.дані[п].вид == ВидСловаСимволРівно {
          стрибнути спроба;
        } інакше якщо слова.дані[п].вид == ВидСловаСимволДвокрапка {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаСимволРівно {
            стрибнути спроба_ззовні;
          } інакше {
            п -= 2;
            стрибнути вихід;
          }
          стрибнути спроба;
        } інакше {
          п -= 1;
          стрибнути вихід;
        }
        спроба:
        якщо сполука_значення.вид == ВидСполукиЗвернутись {
          змінна дані = сполука_значення.дані як ДаніСполукиЗвернутись;
          змінна ідентифікатор = дані.ідентифікатор;
          п += 1;
          змінна сполука_значення_значення: адреса<Сполука> = пусто;
          змінна позиція_помилки_сполуки_значення_значення: природне = 0;
          якщо спробувати_розібрати_значення(М, слова, п, сполука_значення_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення_значення::адреса) {
            змінна сполука_визначити = виділити<Сполука>(М);
            сполука_визначити.вид = ВидСполукиВизначити;
            сполука_визначити.дані = ДаніСполукиВизначити {
              ідентифікатор = ідентифікатор,
              значення = сполука_значення_значення
            };
            сполука_визначити.місцезнаходження = сполука_значення.місцезнаходження;
            вихід::вміст = сполука_визначити;
            вихід_позиції_кінця::вміст = п;
            звільнити(М, сполука_значення);
            вернути так;
          } інакше {
            звільнити_сполуку(М, сполука_значення);
            вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення_значення;
            вернути ні;
          }
        } інакше якщо сполука_значення.вид == ВидСполукиОтриматиВластивість {
          змінна дані = сполука_значення.дані як ДаніСполукиОтриматиВластивість;
          змінна предмет = дані.предмет;
          змінна ідентифікатор = дані.ідентифікатор;
          п += 1;
          змінна сполука_значення_значення: адреса<Сполука> = пусто;
          змінна позиція_помилки_сполуки_значення_значення: природне = 0;
          якщо спробувати_розібрати_значення(М, слова, п, сполука_значення_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення_значення::адреса) {
            змінна сполука_змінити_властивість = виділити<Сполука>(М);
            сполука_змінити_властивість.вид = ВидСполукиЗмінитиВластивість;
            сполука_змінити_властивість.дані = ДаніСполукиЗмінитиВластивість {
              предмет = предмет,
              ідентифікатор = ідентифікатор,
              значення = сполука_значення_значення
            };
            сполука_змінити_властивість.місцезнаходження = сполука_значення.місцезнаходження;
            вихід::вміст = сполука_змінити_властивість;
            вихід_позиції_кінця::вміст = п;
            звільнити(М, сполука_значення);
            вернути так;
          } інакше {
            звільнити_сполуку(М, сполука_значення);
            вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення_значення;
            вернути ні;
          }
        } інакше якщо сполука_значення.вид == ВидСполукиОтриматиЕлемент {
          змінна дані = сполука_значення.дані як ДаніСполукиОтриматиЕлемент;
          змінна предмет = дані.предмет;
          змінна ключ = дані.ключ;
          п += 1;
          змінна сполука_значення_значення: адреса<Сполука> = пусто;
          змінна позиція_помилки_сполуки_значення_значення: природне = 0;
          якщо спробувати_розібрати_значення(М, слова, п, сполука_значення_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення_значення::адреса) {
            змінна сполука_змінити_елемент = виділити<Сполука>(М);
            сполука_змінити_елемент.вид = ВидСполукиЗмінитиЕлемент;
            сполука_змінити_елемент.дані = ДаніСполукиЗмінитиЕлемент {
              предмет = предмет,
              ключ = ключ,
              значення = сполука_значення_значення
            };
            сполука_змінити_елемент.місцезнаходження = сполука_значення.місцезнаходження;
            вихід::вміст = сполука_змінити_елемент;
            вихід_позиції_кінця::вміст = п;
            звільнити(М, сполука_значення);
            вернути так;
          } інакше {
            звільнити_сполуку(М, сполука_значення);
            вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення_значення;
            вернути ні;
          }
        } інакше {
          вихід_позиції_помилки::вміст = п;
          вернути ні;
        }
        спроба_ззовні:
        якщо сполука_значення.вид == ВидСполукиЗвернутись {
          змінна дані = сполука_значення.дані як ДаніСполукиЗвернутись;
          змінна ідентифікатор = дані.ідентифікатор;
          п += 1;
          змінна сполука_значення_значення: адреса<Сполука> = пусто;
          змінна позиція_помилки_сполуки_значення_значення: природне = 0;
          якщо спробувати_розібрати_значення(М, слова, п, сполука_значення_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення_значення::адреса) {
            змінна сполука_визначити_ззовні = виділити<Сполука>(М);
            сполука_визначити_ззовні.вид = ВидСполукиВизначитиЗзовні;
            сполука_визначити_ззовні.дані = ДаніСполукиВизначитиЗзовні {
              ідентифікатор = ідентифікатор,
              значення = сполука_значення_значення
            };
            сполука_визначити_ззовні.місцезнаходження = сполука_значення.місцезнаходження;
            вихід::вміст = сполука_визначити_ззовні;
            вихід_позиції_кінця::вміст = п;
            звільнити(М, сполука_значення);
            вернути так;
          } інакше {
            звільнити_сполуку(М, сполука_значення);
            вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення_значення;
            вернути ні;
          }
        } інакше {
          вихід_позиції_помилки::вміст = п;
          вернути ні;
        }
        спроба2:
        якщо сполука_значення.вид == ВидСполукиЗвернутись {
          змінна дані = сполука_значення.дані як ДаніСполукиЗвернутись;
          змінна ідентифікатор = дані.ідентифікатор;
          п += 1;
          змінна сполука_значення_значення: адреса<Сполука> = пусто;
          змінна позиція_помилки_сполуки_значення_значення: природне = 0;
          якщо спробувати_розібрати_значення(М, слова, п, сполука_значення_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення_значення::адреса) {
            змінна сполука_операція = виділити<Сполука>(М);
            сполука_операція.вид = ВидСполукиОперація;
            сполука_операція.дані = ДаніСполукиОперація {
              ліво = сполука_значення,
              операція = вид_операції,
              право = сполука_значення_значення
            };
            сполука_операція.місцезнаходження = сполука_значення.місцезнаходження;
            змінна сполука_визначити = виділити<Сполука>(М);
            сполука_визначити.вид = ВидСполукиВизначити;
            сполука_визначити.дані = ДаніСполукиВизначити {
              ідентифікатор = ідентифікатор,
              значення = сполука_операція
            };
            сполука_визначити.місцезнаходження = сполука_значення.місцезнаходження;
            вихід::вміст = сполука_визначити;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          } інакше {
            звільнити_сполуку(М, сполука_значення);
            вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення_значення;
            вернути ні;
          }
        } інакше якщо сполука_значення.вид == ВидСполукиОтриматиВластивість {
          змінна дані = сполука_значення.дані як ДаніСполукиОтриматиВластивість;
          змінна предмет = дані.предмет;
          змінна ідентифікатор = дані.ідентифікатор;
          п += 1;
          змінна сполука_значення_значення: адреса<Сполука> = пусто;
          змінна позиція_помилки_сполуки_значення_значення: природне = 0;
          якщо спробувати_розібрати_значення(М, слова, п, сполука_значення_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення_значення::адреса) {
            змінна сполука_операція = виділити<Сполука>(М);
            сполука_операція.вид = ВидСполукиОперація;
            сполука_операція.дані = ДаніСполукиОперація {
              ліво = сполука_значення,
              операція = вид_операції,
              право = сполука_значення_значення
            };
            сполука_операція.місцезнаходження = сполука_значення.місцезнаходження;
            змінна сполука_змінити_властивість = виділити<Сполука>(М);
            сполука_змінити_властивість.вид = ВидСполукиЗмінитиВластивість;
            сполука_змінити_властивість.дані = ДаніСполукиЗмінитиВластивість {
              предмет = зробити_повну_копію_сполуки(М, предмет),
              ідентифікатор = ідентифікатор,
              значення = сполука_операція
            };
            сполука_змінити_властивість.місцезнаходження = сполука_значення.місцезнаходження;
            вихід::вміст = сполука_змінити_властивість;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          } інакше {
            звільнити_сполуку(М, сполука_значення);
            вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення_значення;
            вернути ні;
          }
        } інакше якщо сполука_значення.вид == ВидСполукиОтриматиЕлемент {
          змінна дані = сполука_значення.дані як ДаніСполукиОтриматиЕлемент;
          змінна предмет = дані.предмет;
          змінна ключ = дані.ключ;
          п += 1;
          змінна сполука_значення_значення: адреса<Сполука> = пусто;
          змінна позиція_помилки_сполуки_значення_значення: природне = 0;
          якщо спробувати_розібрати_значення(М, слова, п, сполука_значення_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення_значення::адреса) {
            змінна сполука_операція = виділити<Сполука>(М);
            сполука_операція.вид = ВидСполукиОперація;
            сполука_операція.дані = ДаніСполукиОперація {
              ліво = сполука_значення,
              операція = вид_операції,
              право = сполука_значення_значення
            };
            сполука_операція.місцезнаходження = сполука_значення.місцезнаходження;
            змінна сполука_змінити_елемент = виділити<Сполука>(М);
            сполука_змінити_елемент.вид = ВидСполукиЗмінитиЕлемент;
            сполука_змінити_елемент.дані = ДаніСполукиЗмінитиЕлемент {
              предмет = зробити_повну_копію_сполуки(М, предмет),
              ключ = зробити_повну_копію_сполуки(М, ключ),
              значення = сполука_операція
            };
            сполука_змінити_елемент.місцезнаходження = сполука_значення.місцезнаходження;
            вихід::вміст = сполука_змінити_елемент;
            вихід_позиції_кінця::вміст = п;
            вернути так;
          } інакше {
            звільнити_сполуку(М, сполука_значення);
            вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення_значення;
            вернути ні;
          }
        } інакше {
          вихід_позиції_помилки::вміст = п;
          вернути ні;
        }
        вихід:
        вихід::вміст = сполука_значення;
        вихід_позиції_кінця::вміст = п;
        вернути так;
      }
      вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
      вернути ні;
    }

    дія спробувати_розібрати_тіло(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<Сполуки>, вихід_позиції_кінця: адреса<природне>, вид_слова_закінчення: природне, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна п = позиція_початку;
      зʼїсти_міжрядки(слова, п, п::адреса);
      змінна елементи = зробити_накопичувач<адреса<Сполука>>(М);
      поки п < слова.розмір {
        якщо слова.дані[п].вид == вид_слова_закінчення {
          вихід::вміст = Сполуки { елементи.розмір, елементи.дані };
          вихід_позиції_кінця::вміст = п;
          вернути так;
        }
        змінна сполука_елемента_тіла: адреса<Сполука> = пусто;
        змінна позиція_помилки_елемента_тіла: природне = 0;
        якщо спробувати_розібрати_елемент_тіла(М, слова, п, сполука_елемента_тіла::адреса, п::адреса, позиція_помилки_елемента_тіла::адреса) {
          покласти_в_накопичувач<адреса<Сполука>>(М, елементи::адреса, сполука_елемента_тіла);
          п += 1;
          якщо зʼїсти_міжрядки(слова, п, п::адреса) {
          } інакше якщо слова.дані[п].вид == вид_слова_закінчення {
            вихід::вміст = Сполуки { елементи.розмір, елементи.дані };
            вихід_позиції_кінця::вміст = п;
            вернути так;
          } інакше {
            звільнити_сполуки(М, Сполуки { елементи.розмір, елементи.дані });
            вихід_позиції_помилки::вміст = п;
            вернути ні;
          }
        } інакше {
          звільнити_сполуки(М, Сполуки { елементи.розмір, елементи.дані });
          вихід_позиції_помилки::вміст = позиція_помилки_елемента_тіла;
          вернути ні;
        }
      }
      звільнити_сполуки(М, Сполуки { елементи.розмір, елементи.дані });
      вихід_позиції_помилки::вміст = п;
      вернути ні;
    }

    дія спробувати_розібрати_тип(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<Тип>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна п = позиція_початку;
      змінна типи = зробити_накопичувач<адреса<Сполука>>(М);
      поки п < слова.розмір {
        змінна сполука_типу: адреса<Сполука> = пусто;
        змінна позиція_помилки_молекули: природне = 0;
        якщо спробувати_розібрати_молекулу(М, слова, п, сполука_типу::адреса, п::адреса, позиція_помилки_молекули::адреса) {
          покласти_в_накопичувач<адреса<Сполука>>(М, типи::адреса, сполука_типу);
          п += 1;
          якщо слова.дані[п].вид == ВидСловаАбо {
            п += 1;
          } інакше {
            вихід::вміст = Тип {
              кількість_гілок = типи.розмір,
              сполуки = типи.дані,
            };
            вихід_позиції_кінця::вміст = п - 1;
            вернути так;
          }
        } інакше {
          звільнити_сполуки(М, Сполуки { типи.розмір, типи.дані });
          вихід_позиції_помилки::вміст = позиція_помилки_молекули;
          вернути ні;
        }
      }
      звільнити_сполуки(М, Сполуки { типи.розмір, типи.дані });
      вихід_позиції_помилки::вміст = п;
      вернути ні;
    }

    дія спробувати_розібрати_параметр(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<Параметр>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна п = позиція_початку;
      змінна сполука_значення: адреса<Сполука> = пусто;
      // ідентифікатор параметра
      змінна позиція_ідентифікатора = п;
      якщо слова.дані[п].вид != ВидСловаІдентифікатор і слова.дані[п].вид != ВидСловаЦіле {
        вихід_позиції_помилки::вміст = п;
        вернути ні;
      }
      п += 1;
      // тип параметра
      змінна тип = Тип { ... };
      змінна позиція_помилки_типу: природне = 0;
      якщо спробувати_розібрати_тип(М, слова, п, тип::адреса, п::адреса, позиція_помилки_типу::адреса) {
        п += 1;
        якщо слова.дані[п].вид == ВидСловаСимволРівно {
          п += 1;
          змінна позиція_помилки_сполуки_значення: природне = 0;
          якщо спробувати_розібрати_значення(М, слова, п, сполука_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення::адреса) {
          } інакше {
            звільнити_тип(М, тип);
            вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
            вернути ні;
          }
        } інакше {
          п -= 1;
        }
        вихід::вміст = Параметр {
          ідентифікатор = Ідентифікатор { позиція_ідентифікатора },
          тип = можливо<Тип> { так, тип },
          значення = сполука_значення,
          місцезнаходження = Місцезнаходження { позиція_початку }
        };
        вихід_позиції_кінця::вміст = п;
      } інакше {
        якщо слова.дані[п].вид == ВидСловаСимволРівно {
          п += 1;
          змінна позиція_помилки_сполуки_значення: природне = 0;
          якщо спробувати_розібрати_значення(М, слова, п, сполука_значення::адреса, п::адреса, ні, позиція_помилки_сполуки_значення::адреса) {
          } інакше {
            звільнити_сполуку(М, сполука_значення);
            вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
            вернути ні;
          }
        } інакше {
          п -= 1;
        }
        вихід::вміст = Параметр {
          ідентифікатор = Ідентифікатор { позиція_ідентифікатора },
          тип = можливо<Тип> { ні, ... },
          значення = сполука_значення,
          місцезнаходження = Місцезнаходження { позиція_початку }
        };
        вихід_позиції_кінця::вміст = п;
      }
      вернути так;
    }

    дія спробувати_розібрати_дію(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна дані_сполуки_дія = ДаніСполукиДія {
        тривала = ні,
        власна = ні,
        структура_ = пусто,
        ідентифікатор = можливо<Ідентифікатор> { ні, ... },
        кількість_параметрів = 0,
        параметри = пусто,
        тип_результату = можливо<Тип> { ні, ... },
        тіло = Сполуки { 0, пусто }
      };
      змінна п = позиція_початку;
      // дія власна?
      якщо слова.дані[п].вид == ВидСловаВласна {
        дані_сполуки_дія.власна = так;
        п += 1;
      }
      // дія тривала?
      якщо слова.дані[п].вид == ВидСловаТривала {
        дані_сполуки_дія.тривала = так;
        п += 1;
      }
      // дія?
      якщо слова.дані[п].вид != ВидСловаДія {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      // структура та/або ідентифікатор дії
      якщо слова.дані[п].вид == ВидСловаІдентифікатор {
        дані_сполуки_дія.ідентифікатор = можливо<Ідентифікатор> { так, Ідентифікатор { п } };
        п += 1;
        якщо слова.дані[п].вид == ВидСловаСимволКрапка {
          п += 1;
          якщо слова.дані[п].вид == ВидСловаІдентифікатор {
            змінна сполука_звернення = виділити<Сполука>(М);
            сполука_звернення.вид = ВидСполукиЗвернутись;
            сполука_звернення.дані = ДаніСполукиЗвернутись {
              ідентифікатор = дані_сполуки_дія.ідентифікатор.значення
            };
            сполука_звернення.місцезнаходження = Місцезнаходження { п };
            дані_сполуки_дія.структура_ = сполука_звернення;
            дані_сполуки_дія.ідентифікатор = можливо<Ідентифікатор> { так, Ідентифікатор { п } };
            п += 1;
          } інакше {
            вихід_позиції_помилки::вміст = п;
            стрибнути звільнити_і_вийти;
          }
        }
      }
      якщо слова.дані[п].вид != ВидСловаСимволВідкритаДужка {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      зʼїсти_міжрядки(слова, п, п::адреса);
      // параметри дії
      змінна параметри = зробити_накопичувач<Параметр>(М);
      поки п < слова.розмір {
        якщо слова.дані[п].вид == ВидСловаСимволЗакритаДужка {
          п += 1;
          стрибнути після_параметрів;
        }
        змінна параметр = Параметр { ... };
        змінна позиція_помилки_параметра: природне = 0;
        якщо спробувати_розібрати_параметр(М, слова, п, параметр::адреса, п::адреса, позиція_помилки_параметра::адреса) {
          покласти_в_накопичувач<Параметр>(М, параметри::адреса, параметр);
          п += 1;
        } інакше {
          вихід_позиції_помилки::вміст = позиція_помилки_параметра;
          стрибнути звільнити_і_вийти;
        }
        зʼїсти_міжрядки(слова, п, п::адреса);
        якщо слова.дані[п].вид == ВидСловаСимволКома {
          п += 1;
          зʼїсти_міжрядки(слова, п, п::адреса);
        } інакше якщо слова.дані[п].вид == ВидСловаСимволЗакритаДужка {
          п += 1;
          стрибнути після_параметрів;
        } інакше {
          звільнити_параметри(М, параметри.розмір, параметри.дані);
          вихід_позиції_помилки::вміст = п;
          стрибнути звільнити_і_вийти;
        }
      }
      після_параметрів:
      дані_сполуки_дія.кількість_параметрів = параметри.розмір;
      дані_сполуки_дія.параметри = параметри.дані;
      // тип результату дії
      якщо слова.дані[п].вид == ВидСловаСимволМіжряд {
        стрибнути розбір_тіла;
      } інакше якщо слова.дані[п].вид == ВидСловаСимволДвокрапка {
        стрибнути розбір_короткого_тіла;
      } інакше {
        змінна позиція_помилки_типу_результату: природне = 0;
        якщо спробувати_розібрати_тип(М, слова, п, дані_сполуки_дія.тип_результату.значення::адреса, п::адреса, позиція_помилки_типу_результату::адреса) {
          дані_сполуки_дія.тип_результату.заповнено = так;
          п += 1;
        } інакше {
          вихід_позиції_помилки::вміст = позиція_помилки_типу_результату;
          стрибнути звільнити_і_вийти;
        }
      }
      якщо слова.дані[п].вид == ВидСловаСимволМіжряд {
        стрибнути розбір_тіла;
      } інакше {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      // тіло дії
      розбір_короткого_тіла:
      п += 1;
      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: природне = 0;
      якщо спробувати_розібрати_елемент_тіла(М, слова, п, сполука_значення::адреса, п::адреса, позиція_помилки_сполуки_значення::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
        стрибнути звільнити_і_вийти;
      }
      дані_сполуки_дія.тіло.дані = перевиділити_памʼять<адреса<Сполука>>(М, дані_сполуки_дія.тіло.дані, 1);
      дані_сполуки_дія.тіло.дані[0] = сполука_значення;
      дані_сполуки_дія.тіло.розмір = 1;
      стрибнути після_тіла;
      розбір_тіла:
      п += 1;
      змінна позиція_помилки_тіла: природне = 0;
      якщо спробувати_розібрати_тіло(М, слова, п, дані_сполуки_дія.тіло::адреса, п::адреса, ВидСловаКінець, позиція_помилки_тіла::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_тіла;
        стрибнути звільнити_і_вийти;
      }
      після_тіла:
      змінна сполука_дія = виділити<Сполука>(М);
      сполука_дія.вид = ВидСполукиДія;
      сполука_дія.дані = дані_сполуки_дія;
      сполука_дія.місцезнаходження = Місцезнаходження {
        позиція_початку
      };
      вихід::вміст = сполука_дія;
      вихід_позиції_кінця::вміст = п;
      вернути так;
      звільнити_і_вийти:
      звільнити_параметри(М, дані_сполуки_дія.кількість_параметрів, дані_сполуки_дія.параметри);
      якщо дані_сполуки_дія.тип_результату.заповнено {
        звільнити_тип(М, дані_сполуки_дія.тип_результату.значення);
      }
      звільнити_тіло(М, дані_сполуки_дія.тіло);
      вернути ні;
    }

    дія спробувати_розібрати_структуру(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна дані_сполуки_структура = ДаніСполукиСтруктура {
        ідентифікатор = можливо<Ідентифікатор> { ні, ... },
        предок = пусто,
        кількість_параметрів = 0,
        параметри = пусто
      };
      змінна п = позиція_початку;
      // структура?
      якщо слова.дані[п].вид != ВидСловаСтруктура {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      // ідентифікатор структури
      якщо слова.дані[п].вид == ВидСловаІдентифікатор {
        дані_сполуки_структура.ідентифікатор = можливо<Ідентифікатор> { так, Ідентифікатор { п } };
        п += 1;
      }
      // предок структури
      якщо слова.дані[п].вид == ВидСловаЄ {
        п += 1;
        змінна позиція_помилки_молекули: природне = 0;
        якщо спробувати_розібрати_молекулу(М, слова, п, дані_сполуки_структура.предок::адреса, п::адреса, позиція_помилки_молекули::адреса) {
          п += 1;
        } інакше {
          вихід_позиції_помилки::вміст = позиція_помилки_молекули;
          стрибнути звільнити_і_вийти;
        }
      }
      якщо слова.дані[п].вид != ВидСловаСимволМіжряд {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      зʼїсти_міжрядки(слова, п, п::адреса);
      // параметри структури
      змінна параметри = зробити_накопичувач<Параметр>(М);
      поки п < слова.розмір {
        якщо слова.дані[п].вид == ВидСловаКінець {
          стрибнути після_параметрів;
        }
        змінна параметр = Параметр { ... };
        змінна позиція_помилки_параметра: природне = 0;
        якщо спробувати_розібрати_параметр(М, слова, п, параметр::адреса, п::адреса, позиція_помилки_параметра::адреса) {
          покласти_в_накопичувач<Параметр>(М, параметри::адреса, параметр);
          п += 1;
        } інакше {
          вихід_позиції_помилки::вміст = позиція_помилки_параметра;
          стрибнути звільнити_і_вийти;
        }
        якщо зʼїсти_міжрядки(слова, п, п::адреса) {
        } інакше якщо слова.дані[п].вид == ВидСловаКінець {
          стрибнути після_параметрів;
        } інакше {
          звільнити_параметри(М, параметри.розмір, параметри.дані);
          вихід_позиції_помилки::вміст = п;
          стрибнути звільнити_і_вийти;
        }
      }
      після_параметрів:
      дані_сполуки_структура.кількість_параметрів = параметри.розмір;
      дані_сполуки_структура.параметри = параметри.дані;
      змінна сполука_структура = виділити<Сполука>(М);
      сполука_структура.вид = ВидСполукиСтруктура;
      сполука_структура.дані = дані_сполуки_структура;
      сполука_структура.місцезнаходження = Місцезнаходження {
        позиція_початку
      };
      вихід::вміст = сполука_структура;
      вихід_позиції_кінця::вміст = п;
      вернути так;
      звільнити_і_вийти:
      звільнити_сполуку(М, дані_сполуки_структура.предок);
      звільнити_параметри(М, дані_сполуки_структура.кількість_параметрів, дані_сполуки_структура.параметри);
      вернути ні;
    }

    дія спробувати_розібрати_модуль(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна дані_сполуки_модуль = ДаніСполукиМодуль {
        ідентифікатор = можливо<Ідентифікатор> { ні, ... },
        тіло = Сполуки { 0, пусто }
      };
      змінна п = позиція_початку;
      // модуль?
      якщо слова.дані[п].вид != ВидСловаМодуль {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      // ідентифікатор модуля
      якщо слова.дані[п].вид == ВидСловаІдентифікатор {
        дані_сполуки_модуль.ідентифікатор = можливо<Ідентифікатор> { так, Ідентифікатор { п } };
        п += 1;
      }
      якщо слова.дані[п].вид != ВидСловаСимволМіжряд {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      // тіло модуля
      змінна позиція_помилки_тіла: природне = 0;
      якщо спробувати_розібрати_тіло(М, слова, п, дані_сполуки_модуль.тіло::адреса, п::адреса, ВидСловаКінець, позиція_помилки_тіла::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_тіла;
        стрибнути звільнити_і_вийти;
      }
      змінна сполука_модуль = виділити<Сполука>(М);
      сполука_модуль.вид = ВидСполукиМодуль;
      сполука_модуль.дані = дані_сполуки_модуль;
      сполука_модуль.місцезнаходження = Місцезнаходження {
        позиція_початку
      };
      вихід::вміст = сполука_модуль;
      вихід_позиції_кінця::вміст = п;
      вернути так;
      звільнити_і_вийти:
      звільнити_тіло(М, дані_сполуки_модуль.тіло);
      вернути ні;
    }

    дія спробувати_розібрати_якщо(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна дані_сполуки_якщо = ДаніСполукиЯкщо {
        умова = пусто,
        тіло = Сполуки { 0, пусто },
        тіло_інакше = Сполуки { 0, пусто }
      };
      змінна п = позиція_початку;
      // якщо?
      якщо слова.дані[п].вид != ВидСловаЯкщо {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      // умова якщо
      змінна позиція_помилки_умови: природне = 0;
      якщо спробувати_розібрати_операцію(М, слова, п, дані_сполуки_якщо.умова::адреса, п::адреса, ні, позиція_помилки_умови::адреса) {
        п += 1;
      } інакше {
        вихід_позиції_помилки::вміст = позиція_помилки_умови;
        стрибнути звільнити_і_вийти;
      }
      якщо слова.дані[п].вид != ВидСловаСимволМіжряд {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      // тіло якщо
      змінна тіло = зробити_накопичувач<адреса<Сполука>>(М);
      поки п < слова.розмір {
        якщо слова.дані[п].вид == ВидСловаКінець {
          дані_сполуки_якщо.тіло.розмір = тіло.розмір;
          дані_сполуки_якщо.тіло.дані = тіло.дані;
          стрибнути після_тіла;
        }
        якщо слова.дані[п].вид == ВидСловаІнакше {
          дані_сполуки_якщо.тіло.розмір = тіло.розмір;
          дані_сполуки_якщо.тіло.дані = тіло.дані;
          стрибнути розбір_інакше;
        }
        зʼїсти_міжрядки(слова, п, п::адреса);
        змінна сполука_елемента_тіла: адреса<Сполука> = пусто;
        змінна позиція_помилки_елемента_тіла: природне = 0;
        якщо спробувати_розібрати_елемент_тіла(М, слова, п, сполука_елемента_тіла::адреса, п::адреса, позиція_помилки_елемента_тіла::адреса) {
          покласти_в_накопичувач<адреса<Сполука>>(М, тіло::адреса, сполука_елемента_тіла);
          п += 1;
          якщо зʼїсти_міжрядки(слова, п, п::адреса) {
          } інакше якщо слова.дані[п].вид == ВидСловаКінець {
            дані_сполуки_якщо.тіло.розмір = тіло.розмір;
            дані_сполуки_якщо.тіло.дані = тіло.дані;
            стрибнути після_тіла;
          } інакше якщо слова.дані[п].вид == ВидСловаІнакше {
            дані_сполуки_якщо.тіло.розмір = тіло.розмір;
            дані_сполуки_якщо.тіло.дані = тіло.дані;
            стрибнути розбір_інакше;
          } інакше {
            дані_сполуки_якщо.тіло.розмір = тіло.розмір;
            дані_сполуки_якщо.тіло.дані = тіло.дані;
            вихід_позиції_помилки::вміст = п;
            стрибнути звільнити_і_вийти;
          }
        } інакше {
          дані_сполуки_якщо.тіло.розмір = тіло.розмір;
          дані_сполуки_якщо.тіло.дані = тіло.дані;
          вихід_позиції_помилки::вміст = позиція_помилки_елемента_тіла;
          стрибнути звільнити_і_вийти;
        }
      }
      вихід_позиції_помилки::вміст = п;
      стрибнути звільнити_і_вийти;
      розбір_інакше:
      п += 1;
      // інакше якщо
      якщо слова.дані[п].вид == ВидСловаЯкщо {
        змінна сполука_інакше_якщо: адреса<Сполука> = пусто;
        змінна позиція_помилки_інакше_якщо: природне = 0;
        якщо спробувати_розібрати_якщо(М, слова, п, сполука_інакше_якщо::адреса, п::адреса, позиція_помилки_інакше_якщо::адреса) {
          змінна накопичувач_інакше_якщо = зробити_накопичувач<адреса<Сполука>>(М);
          покласти_в_накопичувач<адреса<Сполука>>(М, накопичувач_інакше_якщо::адреса, сполука_інакше_якщо);
          дані_сполуки_якщо.тіло_інакше = Сполуки {
            накопичувач_інакше_якщо.розмір,
            накопичувач_інакше_якщо.дані
          };
          стрибнути після_тіла;
        }
        вихід_позиції_помилки::вміст = позиція_помилки_інакше_якщо;
        стрибнути звільнити_і_вийти;
      } інакше якщо зʼїсти_міжрядки(слова, п, п::адреса) {
        // тіло інакше
        змінна позиція_помилки_інакше: природне = 0;
        якщо спробувати_розібрати_тіло(М, слова, п, дані_сполуки_якщо.тіло_інакше::адреса, п::адреса, ВидСловаКінець, позиція_помилки_інакше::адреса) == ні {
          вихід_позиції_помилки::вміст = позиція_помилки_інакше;
          стрибнути звільнити_і_вийти;
        }
        стрибнути після_тіла;
      } інакше {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      після_тіла:
      змінна сполука_якщо = виділити<Сполука>(М);
      сполука_якщо.вид = ВидСполукиЯкщо;
      сполука_якщо.дані = дані_сполуки_якщо;
      сполука_якщо.місцезнаходження = Місцезнаходження {
        позиція_початку
      };
      вихід::вміст = сполука_якщо;
      вихід_позиції_кінця::вміст = п;
      вернути так;
      звільнити_і_вийти:
      звільнити_сполуку(М, дані_сполуки_якщо.умова);
      звільнити_тіло(М, дані_сполуки_якщо.тіло);
      звільнити_тіло(М, дані_сполуки_якщо.тіло_інакше);
      вернути ні;
    }

    дія спробувати_розібрати_поки(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна дані_сполуки_поки = ДаніСполукиПоки {
        умова = пусто,
        тіло = Сполуки { 0, пусто }
      };
      змінна п = позиція_початку;
      // поки?
      якщо слова.дані[п].вид != ВидСловаПоки {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      // умова поки
      змінна позиція_помилки_умови: природне = 0;
      якщо спробувати_розібрати_операцію(М, слова, п, дані_сполуки_поки.умова::адреса, п::адреса, ні, позиція_помилки_умови::адреса) {
        п += 1;
      } інакше {
        вихід_позиції_помилки::вміст = позиція_помилки_умови;
        стрибнути звільнити_і_вийти;
      }
      // тіло поки
      якщо слова.дані[п].вид == ВидСловаСимволМіжряд {
        стрибнути розбір_тіла;
      } інакше якщо слова.дані[п].вид == ВидСловаСимволДвокрапка {
        стрибнути розбір_короткого_тіла;
      } інакше {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      розбір_короткого_тіла:
      п += 1;
      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: природне = 0;
      якщо спробувати_розібрати_елемент_тіла(М, слова, п, сполука_значення::адреса, п::адреса, позиція_помилки_сполуки_значення::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
        стрибнути звільнити_і_вийти;
      }
      дані_сполуки_поки.тіло.дані = перевиділити_памʼять<адреса<Сполука>>(М, дані_сполуки_поки.тіло.дані, 1);
      дані_сполуки_поки.тіло.дані[0] = сполука_значення;
      дані_сполуки_поки.тіло.розмір = 1;
      стрибнути після_тіла;
      розбір_тіла:
      п += 1;
      змінна позиція_помилки_тіла: природне = 0;
      якщо спробувати_розібрати_тіло(М, слова, п, дані_сполуки_поки.тіло::адреса, п::адреса, ВидСловаКінець, позиція_помилки_тіла::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_тіла;
        стрибнути звільнити_і_вийти;
      }
      після_тіла:
      змінна сполука_поки = виділити<Сполука>(М);
      сполука_поки.вид = ВидСполукиПоки;
      сполука_поки.дані = дані_сполуки_поки;
      сполука_поки.місцезнаходження = Місцезнаходження {
        позиція_початку
      };
      вихід::вміст = сполука_поки;
      вихід_позиції_кінця::вміст = п;
      вернути так;
      звільнити_і_вийти:
      звільнити_сполуку(М, дані_сполуки_поки.умова);
      звільнити_тіло(М, дані_сполуки_поки.тіло);
      вернути ні;
    }

    дія спробувати_розібрати_цикл(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      вихід_позиції_помилки::вміст = позиція_початку;
      вернути ні;
    }

    дія спробувати_розібрати_перебрати(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна дані_сполуки_перебрати = ДаніСполукиПеребрати {
        предмет = пусто,
        ідентифікатор = можливо<Ідентифікатор> { ні, ... },
        тіло = Сполуки { 0, пусто }
      };
      змінна п = позиція_початку;
      // перебрати?
      якщо слова.дані[п].вид != ВидСловаПеребрати {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      // значення перебрати
      змінна позиція_помилки_операції: природне = 0;
      якщо спробувати_розібрати_операцію(М, слова, п, дані_сполуки_перебрати.предмет::адреса, п::адреса, ні, позиція_помилки_операції::адреса) {
        п += 1;
      } інакше {
        вихід_позиції_помилки::вміст = позиція_помилки_операції;
        стрибнути звільнити_і_вийти;
      }
      якщо слова.дані[п].вид == ВидСловаЯк {
        п += 1;
        якщо слова.дані[п].вид != ВидСловаІдентифікатор {
          вихід_позиції_помилки::вміст = п;
          стрибнути звільнити_і_вийти;
        }
        дані_сполуки_перебрати.ідентифікатор = можливо<Ідентифікатор> {
          так,
          Ідентифікатор { п }
        };
        п += 1;
      } інакше {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      // тіло перебрати
      якщо слова.дані[п].вид == ВидСловаСимволМіжряд {
        стрибнути розбір_тіла;
      } інакше якщо слова.дані[п].вид == ВидСловаСимволДвокрапка {
        стрибнути розбір_короткого_тіла;
      } інакше {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      розбір_короткого_тіла:
      п += 1;
      змінна сполука_значення: адреса<Сполука> = пусто;
      змінна позиція_помилки_сполуки_значення: природне = 0;
      якщо спробувати_розібрати_елемент_тіла(М, слова, п, сполука_значення::адреса, п::адреса, позиція_помилки_сполуки_значення::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_сполуки_значення;
        стрибнути звільнити_і_вийти;
      }
      дані_сполуки_перебрати.тіло.дані = перевиділити_памʼять<адреса<Сполука>>(М, дані_сполуки_перебрати.тіло.дані, 1);
      дані_сполуки_перебрати.тіло.дані[0] = сполука_значення;
      дані_сполуки_перебрати.тіло.розмір = 1;
      стрибнути після_тіла;
      розбір_тіла:
      п += 1;
      змінна позиція_помилки_тіла: природне = 0;
      якщо спробувати_розібрати_тіло(М, слова, п, дані_сполуки_перебрати.тіло::адреса, п::адреса, ВидСловаКінець, позиція_помилки_тіла::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_тіла;
        стрибнути звільнити_і_вийти;
      }
      після_тіла:
      змінна сполука_перебрати = виділити<Сполука>(М);
      сполука_перебрати.вид = ВидСполукиПеребрати;
      сполука_перебрати.дані = дані_сполуки_перебрати;
      сполука_перебрати.місцезнаходження = Місцезнаходження {
        позиція_початку
      };
      вихід::вміст = сполука_перебрати;
      вихід_позиції_кінця::вміст = п;
      вернути так;
      звільнити_і_вийти:
      звільнити_сполуку(М, дані_сполуки_перебрати.предмет);
      звільнити_тіло(М, дані_сполуки_перебрати.тіло);
      вернути ні;
    }

    дія спробувати_розібрати_спробувати(М: адреса<Машина>, слова: Слова, позиція_початку: природне, вихід: адреса<адреса<Сполука>>, вихід_позиції_кінця: адреса<природне>, вихід_позиції_помилки: адреса<природне>) -> логічне {
      змінна дані_сполуки_спробувати = ДаніСполукиСпробувати {
        тіло = Сполуки { 0, пусто },
        ідентифікатор_зловити = можливо<Ідентифікатор> { ні, ... },
        тіло_зловити = Сполуки { 0, пусто }
      };
      змінна п = позиція_початку;
      // спробувати?
      якщо слова.дані[п].вид != ВидСловаСпробувати {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      якщо слова.дані[п].вид != ВидСловаСимволМіжряд {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      // тіло спробувати
      змінна позиція_помилки_тіла: природне = 0;
      якщо спробувати_розібрати_тіло(М, слова, п, дані_сполуки_спробувати.тіло::адреса, п::адреса, ВидСловаЗловити, позиція_помилки_тіла::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_тіла;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      якщо слова.дані[п].вид == ВидСловаІдентифікатор {
        дані_сполуки_спробувати.ідентифікатор_зловити = можливо<Ідентифікатор> {
          так,
          Ідентифікатор { п }
        };
        п += 1;
      }
      якщо слова.дані[п].вид != ВидСловаСимволМіжряд {
        вихід_позиції_помилки::вміст = п;
        стрибнути звільнити_і_вийти;
      }
      п += 1;
      // тіло зловити
      змінна позиція_помилки_тіла_зловити: природне = 0;
      якщо спробувати_розібрати_тіло(М, слова, п, дані_сполуки_спробувати.тіло_зловити::адреса, п::адреса, ВидСловаКінець, позиція_помилки_тіла_зловити::адреса) == ні {
        вихід_позиції_помилки::вміст = позиція_помилки_тіла_зловити;
        стрибнути звільнити_і_вийти;
      }
      змінна сполука_спробувати = виділити<Сполука>(М);
      сполука_спробувати.вид = ВидСполукиСпробувати;
      сполука_спробувати.дані = дані_сполуки_спробувати;
      сполука_спробувати.місцезнаходження = Місцезнаходження {
        позиція_початку
      };
      вихід::вміст = сполука_спробувати;
      вихід_позиції_кінця::вміст = п;
      вернути так;
      звільнити_і_вийти:
      звільнити_тіло(М, дані_сполуки_спробувати.тіло);
      звільнити_тіло(М, дані_сполуки_спробувати.тіло_зловити);
      вернути ні;
    }

    місцева дія розібрати_слова_на_сполуки(М: адреса<Машина>, значення_кд: кд, слова: Слова, вихід: адреса<Сполуки>, вихід_помилки: адреса<ПомилкаРозборуНаСполуки>) -> логічне {
      змінна тіло = Сполуки { 0, пусто };
      змінна позиція_кінця: природне = 0;
      змінна позиція_помилки: природне = 0;
      якщо спробувати_розібрати_тіло(М, слова, 0, тіло::адреса, позиція_кінця::адреса, ВидСловаКІНЕЦЬСЛІВ, позиція_помилки::адреса) {
        вихід::вміст = Сполуки {
          тіло.розмір,
          тіло.дані
        };
        вернути так;
      }
      вихід_помилки::вміст = ПомилкаРозборуНаСполуки {
        позиція_слова = позиція_помилки,
        рядок = слова.дані[позиція_помилки].позиція_початку.рядок,
        стовпець = слова.дані[позиція_помилки].позиція_початку.стовпець
      };
      вернути ні;
    }

    місцева дія звільнити_сполуки(М: адреса<Машина>, сполуки: Сполуки) {
      змінна п: природне = 0;
      поки п < сполуки.розмір {
        звільнити_сполуку(М, сполуки.дані[п]);
        п += 1;
      }
      звільнити_памʼять(М, сполуки.дані);
    }

    місцева дія звільнити_помилку_розбору_на_сполуки(М: адреса<Машина>, помилка: ПомилкаРозборуНаСполуки) {
      // ...
    }

    місцева дія отримати_помилку_розбору_на_сполуки(М: адреса<Машина>, помилка: ПомилкаРозборуНаСполуки, вихід: адреса<кд>) -> логічне {
      виділити_копію_кд(М, "Не вдалось розібрати", вихід);
      вернути так;
    }

    місцева дія отримати_рядок_помилки_розбору_на_сполуки(М: адреса<Машина>, помилка: ПомилкаРозборуНаСполуки) -> природне {
      вернути помилка.рядок;
    }

    місцева дія отримати_стовпець_помилки_розбору_на_сполуки(М: адреса<Машина>, помилка: ПомилкаРозборуНаСполуки) -> природне {
      вернути помилка.стовпець;
    }
  }
}