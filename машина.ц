/* Машина Мавки */

взяти означення ./мавка;

простір мавка {
  дія виділити_дійсне(М: адреса<Машина>) -> Значення {
    змінна дійсне = виділити<Дійсне>(М);
    якщо М.перше_дійсне == пусто {
      М.перше_дійсне = дійсне;
    }
    дійсне.попереднє = М.останнє_дійсне;
    М.останнє_дійсне = дійсне;
    дійсне.позначено = ні;
    дійсне.тип = М.значення_дійсне;
    дійсне.користувацькі_дані = пусто;
    вернути дійсне;
  }

  дія виділити_послідовність(М: адреса<Машина>) -> адреса<Послідовність> {
    змінна послідовність = виділити<Послідовність>(М);
    якщо М.перше_дійсне == пусто {
      М.перше_дійсне = послідовність як Значення;
    }
    послідовність.попереднє = М.останнє_дійсне;
    М.останнє_дійсне = послідовність як Значення;
    послідовність.позначено = ні;
    послідовність.тип = М.значення_дійсне;
    послідовність.користувацькі_дані = пусто;
    послідовність.розмір = 0;
    послідовність.дані = пусто;
    вернути послідовність;
  }

  дія виділити_дійсність(М: адреса<Машина>) -> адреса<Дійсність> {
    змінна дійсність = виділити<Дійсність>(М);
    якщо М.перше_дійсне == пусто {
      М.перше_дійсне = дійсність як Значення;
    }
    дійсність.попереднє = М.останнє_дійсне;
    М.останнє_дійсне = дійсність як Значення;
    дійсність.позначено = ні;
    дійсність.тип = М.значення_дійсне;
    дійсність.зовні = пусто;
    дійсність.здійснювач = пусто;
    дійсність.кількість_діячів = 0;
    дійсність.діячі = пусто;
    дійсність.спроби = Спроби { 0, пусто };
    дійсність.значення_модуля = пусто;
    вернути дійсність;
  }

  дія виділити_предмет(М: адреса<Машина>, тип: Значення) -> адреса<Предмет> {
    змінна предмет = виділити<Предмет>(М);
    якщо М.перше_дійсне == пусто {
      М.перше_дійсне = предмет як Значення;
    }
    предмет.попереднє = М.останнє_дійсне;
    М.останнє_дійсне = предмет як Значення;
    предмет.позначено = ні;
    предмет.тип = тип;
    предмет.користувацькі_дані = пусто;
    вернути предмет;
  }

  місцева дія створити_дійсність(М: адреса<Машина>, зовні: адреса<Дійсність>, здійснювач: Значення) -> адреса<Дійсність> {
    змінна дійсність = виділити_дійсність(М);
    
    дійсність.зовні = зовні;
    дійсність.здійснювач = здійснювач;
    
    вернути дійсність;
  }

  місцева дія створити_послідовність(М: адреса<Машина>, розмір: природне, дані: памʼять<Значення>) -> адреса<Послідовність> {
    змінна копія_даних = виділити_памʼять<Значення>(М, розмір);

    змінна п: природне = 0;
    поки п < розмір {
      копія_даних[п] = дані[п];
      п += 1;
    }

    змінна послідовність = виділити_послідовність(М);

    послідовність.розмір = розмір;
    послідовність.дані = копія_даних;

    вернути послідовність;
  }

  місцева дія створити_послідовність_без_копіювання(М: адреса<Машина>, розмір: природне, дані: памʼять<Значення>) -> адреса<Послідовність> {
    змінна послідовність = виділити_послідовність(М) як адреса<Послідовність>;
    
    послідовність.розмір = розмір;
    послідовність.дані = дані;
    
    вернути послідовність;
  }
  
  місцева дія створити_сиру_послідовність(М: адреса<Машина>, розмір: природне) -> адреса<Послідовність> {
    змінна послідовність = виділити_послідовність(М) як адреса<Послідовність>;
    
    послідовність.розмір = розмір;
    послідовність.дані = виділити_памʼять<Значення>(М, розмір);
    
    вернути послідовність;
  }

  місцева дія створити_предмет(М: адреса<Машина>, значення_структури: Значення) -> Значення {
    змінна предмет = виділити_предмет(М, значення_структури);
    
    предмет.властивості = Властивості { 0, пусто };
    
    вернути предмет як Значення;
  }

  місцева дія створити_ціле(М: адреса<Машина>, значення: ц64) -> Значення {
    змінна предмет = виділити_предмет(М, М.значення_структура_Ціле як Значення);
    
    предмет.властивості = ВластивостіЦілого { значення };
    
    вернути предмет як Значення;
  }

  місцева дія створити_дробове(М: адреса<Машина>, значення: д64) -> Значення {
    змінна предмет = виділити_предмет(М, М.значення_структура_Дробове як Значення);

    предмет.властивості = ВластивостіДробового { значення };
    
    вернути предмет як Значення;
  }

  місцева дія створити_текст(М: адреса<Машина>, значення: кд) -> Значення {
    змінна предмет = виділити_предмет(М, М.значення_структура_Текст як Значення);

    змінна копія_тексту = виділити_памʼять<п8>(М, значення.розмір);
    
    змінна п: природне = 0;
    поки п < значення.розмір {
      копія_тексту[п] = значення.дані[п];

      п += 1;
    }
    
    предмет.властивості = ВластивостіТексту { кд { значення.розмір, копія_тексту } };
    
    вернути предмет як Значення;
  }

  місцева дія створити_текст_без_копіювання(М: адреса<Машина>, розмір: природне, дані: памʼять<п8>) -> Значення {
    змінна предмет = виділити_предмет(М, М.значення_структура_Текст як Значення);

    предмет.властивості = ВластивостіТексту { кд { розмір, дані } };
    
    вернути предмет як Значення;
  }

  місцева дія створити_структуру(М: адреса<Машина>, назва: Значення, предок: Значення, параметри: адреса<Послідовність>) -> Значення {
    змінна предмет = виділити_предмет(М, М.значення_структура_Структура як Значення);
    
    предмет.властивості = ВластивостіСтруктури {
      заборонити_наслідування = ні,
      назва = назва,
      предок = предок,
      параметри = параметри,
      методи = Методи { 0, пусто }
    };

    вернути предмет як Значення;
  }
  
  місцева дія створити_модуль(М: адреса<Машина>, назва: Значення) -> Значення {
    змінна предмет = виділити_предмет(М, М.значення_структура_Модуль як Значення);
    
    предмет.властивості = ВластивостіМодуля {
      готовий = ні,
      назва = назва,
      властивості = Властивості { 0, пусто }
    };
    
    вернути предмет як Значення;
  }
  
  місцева дія створити_дію(М: адреса<Машина>, дійсність_створення: адреса<Дійсність>, назва: Значення, параметри: адреса<Послідовність>, тип_результату: Значення, код: Значення) -> Значення {
    змінна предмет = виділити_предмет(М, М.значення_структура_Дія як Значення);
    
    предмет.властивості = ВластивостіДії {
      рідна = ні,
      назва = назва,
      параметри = параметри,
      код = код,
      тип_результату = тип_результату,
      дійсність_створення = дійсність_створення
    };
    
    вернути предмет як Значення;
  }

  місцева дія створити_рідну_дію(М: адреса<Машина>, назва: Значення, параметри: адреса<Послідовність>, тип_результату: Значення, рідна_дія: РіднаДія) -> Значення {
    змінна предмет = виділити_предмет(М, М.значення_структура_Дія як Значення);
   
    предмет.властивості = ВластивостіДії {
      рідна = так,
      назва = назва,
      параметри = параметри,
      тип_результату = тип_результату,
      код = рідна_дія,
      дійсність_створення = пусто
    };
   
    вернути предмет як Значення;
  }

  місцева дія створити_дані(М: адреса<Машина>, розмір: природне, дані: памʼять<п8>) -> Значення {
    змінна предмет = виділити_предмет(М, М.значення_структура_Дані як Значення);
    змінна копія_даних = виділити_памʼять<п8>(М, розмір);
    
    змінна п: природне = 0;
    поки п < розмір {
      копія_даних[п] = дані[п];
      п += 1;
    }
    
    предмет.властивості = ВластивостіДаних { розмір, копія_даних };
    
    вернути предмет як Значення;
  }

  місцева дія створити_дані_без_копіювання(М: адреса<Машина>, розмір: природне, дані: памʼять<п8>) -> Значення {
    змінна предмет = виділити_предмет(М, М.значення_структура_Дані як Значення);
    
    предмет.властивості = ВластивостіДаних { розмір, дані };
    
    вернути предмет як Значення;
  }

  місцева дія створити_код(М: адреса<Машина>, константи: адреса<Послідовність>, вказівки: Значення) -> Значення {
    змінна предмет = виділити_предмет(М, М.значення_структура_Код як Значення);
    
    предмет.властивості = ВластивостіКоду { константи, вказівки };
    
    вернути предмет як Значення;
  }

  місцева дія створити_список_без_копіювання(М: адреса<Машина>, розмір: природне, елементи: памʼять<Значення>) -> Значення {
    змінна предмет = виділити_предмет(М, М.значення_структура_Список як Значення);
    
    предмет.властивості = ВластивостіСписку { розмір, елементи };
    
    вернути предмет як Значення;
  }

  місцева дія створити_словник(М: адреса<Машина>) -> Значення {
    змінна предмет = виділити_предмет(М, М.значення_структура_Словник як Значення);
    
    предмет.властивості = ВластивостіСловника { 0, пусто };
    
    вернути предмет як Значення;
  }

  місцева дія створити_параметр(М: адреса<Машина>, назва: Значення, тип: Значення, дія_значення: Значення) -> Значення {
    змінна предмет = виділити_предмет(М, М.значення_структура_Параметр як Значення);
    
    предмет.властивості = ВластивостіПараметра {
      назва,
      тип,
      дія_значення
    };
    
    вернути предмет як Значення;
  }

  місцева дія записати_в_словник(М: адреса<Машина>, словник: Значення, ключ: Значення, значення: Значення) {
    змінна предмет_словника = словник як адреса<Предмет>;
    змінна властивості_словника = (предмет_словника.властивості як ВластивостіСловника)::адреса;

    змінна п: природне = 0;
    поки п < властивості_словника.розмір {
      змінна елемент = властивості_словника.елементи[п]::адреса;

      якщо перевірити_чи_значення_рівні(М, елемент.ключ, ключ) {
        елемент.значення = значення;

        вернути;
      }

      п += 1;
    }

    властивості_словника.елементи = перевиділити_памʼять<ЕлементСловника>(М, властивості_словника.елементи, властивості_словника.розмір + 1);
    властивості_словника.елементи[властивості_словника.розмір] = ЕлементСловника { ключ, значення };
    властивості_словника.розмір += 1;
  }

  // позначка: прохід по типах предметів
  місцева дія отримати_діапазон(М: адреса<Машина>, від: Значення, до: Значення, включно: логічне, місцезнаходження: Місцезнаходження) -> Значення {
    якщо від == пусто {
      вернути пусто;
    }

    якщо від.тип == М.значення_дійсне {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_послідовність {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_дійсність {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_предмет {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_Структура {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_Модуль {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_Параметр {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_Число {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_Ціле {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_Дробове {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_Текст {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_Код {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_Дія {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_Список {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_Словник {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_Дані {
      вернути пусто;
    }
    
    якщо від.тип == М.значення_структура_ЗмінніДані {
      вернути пусто;
    }

    змінна кількість_задіяних: природне = 2;
    змінна задіяні = виділити_памʼять<Значення>(М, кількість_задіяних);
    задіяні[0] = до;
    якщо включно {
      задіяні[1] = М.значення_дійсне;
    } інакше {
      задіяні[1] = пусто як Значення;
    }

    вернути здійснити_властивість(
      М,
      від,
      створити_текст(М, "чародія_діапазон"),
      кількість_задіяних,
      задіяні,
      пусто,
      місцезнаходження
    );
  }

  місцева дія записати_метод_структури(М: адреса<Машина>, значення_структури: Значення, назва: Значення, значення_дії: Значення) {
    змінна предмет_структури = значення_структури як адреса<Предмет>;
    змінна властивості_структури = (предмет_структури.властивості як ВластивостіСтруктури)::адреса;

    змінна п: природне = 0;
    поки п < властивості_структури.методи.розмір {
      змінна метод = властивості_структури.методи.дані[п]::адреса;

      якщо перевірити_чи_значення_рівні(М, метод.назва, назва) {
        метод.значення = значення_дії;

        вернути;
      }

      п += 1;
    }

    властивості_структури.методи.дані = перевиділити_памʼять<Метод>(М, властивості_структури.методи.дані, властивості_структури.методи.розмір + 1);
    властивості_структури.методи.дані[властивості_структури.методи.розмір] = Метод { назва, значення_дії };
    властивості_структури.методи.розмір += 1;
  }

  місцева дія створити_визначення(М: адреса<Машина>, назва: Значення, значення: Значення) -> Значення {
    запанікувати(М, "Створення визначення не втілено.");
  }

  // позначка: прохід по типах предметів
  місцева дія отримати_властивість(М: адреса<Машина>, предмет: Значення, назва: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо предмет == пусто {
      вернути пусто;
    }

    якщо предмет.тип == М.значення_дійсне {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_послідовність {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_дійсність {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_предмет {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Структура {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Модуль {
      змінна властивості_модуля = (предмет як адреса<Предмет>).властивості як ВластивостіМодуля;
      змінна властивості = властивості_модуля.властивості;
      
      змінна п: природне = 0;
      поки п < властивості.розмір {
        змінна властивість = властивості.дані[п];
  
        якщо перевірити_чи_значення_рівні(М, властивість.назва, назва) {
          вернути властивість.значення;
        }
  
        п += 1;
      }

      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Параметр {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Число {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Ціле {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Дробове {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Текст {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Код {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Дія {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Список {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Словник {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Дані {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_ЗмінніДані {
      вернути пусто;
    }

    змінна властивості = (предмет як адреса<Предмет>).властивості як Властивості;
    
    змінна п: природне = 0;
    поки п < властивості.розмір {
      змінна властивість = властивості.дані[п];

      якщо перевірити_чи_значення_рівні(М, властивість.назва, назва) {
        вернути властивість.значення;
      }

      п += 1;
    }

    якщо предмет.тип.тип == М.значення_структура_Структура {
      вернути знайти_метод_в_структурі(М, предмет.тип, назва);
    }

    вернути пусто;
  }

  місцева дія знайти_метод_в_структурі(М: адреса<Машина>, значення_структури: Значення, назва: Значення) -> Значення {
    змінна предмет_структури = значення_структури як адреса<Предмет>;
    змінна властивості_структури = (предмет_структури.властивості як ВластивостіСтруктури)::адреса;

    змінна п: природне = 0;
    поки п < властивості_структури.методи.розмір {
      змінна метод = властивості_структури.методи.дані[п];

      якщо перевірити_чи_значення_рівні(М, метод.назва, назва) {
        вернути метод.значення;
      }

      п += 1;
    }

    вернути пусто;
  }

  // позначка: прохід по типах предметів
  місцева дія змінити_властивість(М: адреса<Машина>, предмет: Значення, назва: Значення, значення: Значення, місцезнаходження: Місцезнаходження) {
    якщо предмет == пусто {
      вернути;
    }

    якщо предмет.тип == М.значення_дійсне {
      вернути;
    }
    
    якщо предмет.тип == М.значення_послідовність {
      вернути;
    }
    
    якщо предмет.тип == М.значення_дійсність {
      вернути;
    }
    
    якщо предмет.тип == М.значення_предмет {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Структура {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Модуль {
      змінна властивості_модуля = ((предмет як адреса<Предмет>).властивості як ВластивостіМодуля)::адреса;
      змінна властивості = властивості_модуля.властивості::адреса;
      
      змінна п: природне = 0;
      поки п < властивості.розмір {
        змінна властивість = властивості.дані[п]::адреса;
  
        якщо перевірити_чи_значення_рівні(М, властивість.назва, назва) {
          властивість.значення = значення;
  
          вернути;
        }
  
        п += 1;
      }
  
      властивості.дані = перевиділити_памʼять<Властивість>(М, властивості.дані, властивості.розмір + 1);
      властивості.дані[властивості.розмір] = Властивість { назва, значення };
      властивості.розмір += 1;
  
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Параметр {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Число {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Ціле {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Дробове {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Текст {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Код {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Дія {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Список {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Словник {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Дані {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_ЗмінніДані {
      вернути;
    }

    змінна властивості = ((предмет як адреса<Предмет>).властивості як Властивості)::адреса;
    
    змінна п: природне = 0;
    поки п < властивості.розмір {
      змінна властивість = властивості.дані[п]::адреса;

      якщо перевірити_чи_значення_рівні(М, властивість.назва, назва) {
        властивість.значення = значення;

        вернути;
      }

      п += 1;
    }

    властивості.дані = перевиділити_памʼять<Властивість>(М, властивості.дані, властивості.розмір + 1);
    властивості.дані[властивості.розмір] = Властивість { назва, значення };
    властивості.розмір += 1;

    вернути;
  }

  місцева дія здійснити_властивість(М: адреса<Машина>, предмет: Значення, назва: Значення, кількість_задіяних: природне, задіяні: памʼять<Значення>, іменовано_задіяні: адреса<ІменованіЗадіяні>, місцезнаходження: Місцезнаходження) -> Значення {
    змінна значення_властивості = отримати_властивість(М, предмет, назва, місцезнаходження);
    якщо М.стан_падіння {
      // звільнити_памʼять(М, задіяні);
      // якщо іменовано_задіяні != пусто {
      //   знищити_іменовано_задіяні(М, іменовано_задіяні);
      // }
      вернути пусто;
    }

    якщо значення_властивості == пусто {
      увімкнути_стан_падіння(
        М, 
        створити_текст(М, "Не влалось здійснити властивість."), 
        місцезнаходження
      );
      // звільнити_памʼять(М, задіяні);
      // якщо іменовано_задіяні != пусто {
      //   знищити_іменовано_задіяні(М, іменовано_задіяні);
      // }
      вернути пусто;
    }

    вернути здійснити(
      М,
      предмет,
      значення_властивості,
      кількість_задіяних,
      задіяні,
      іменовано_задіяні,
      місцезнаходження
    );
  }

  // позначка: прохід по типах предметів
  місцева дія отримати_елемент(М: адреса<Машина>, предмет: Значення, ключ: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо предмет == пусто {
      вернути пусто;
    }

    якщо предмет.тип == М.значення_дійсне {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_послідовність {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_дійсність {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_предмет {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Структура {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Модуль {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Параметр {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Число {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Ціле {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Дробове {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Текст {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Код {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Дія {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Список {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Словник {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Дані {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_ЗмінніДані {
      вернути пусто;
    }

    вернути пусто;
  }

  // позначка: прохід по типах предметів
  місцева дія змінити_елемент(М: адреса<Машина>, предмет: Значення, ключ: Значення, значення: Значення, місцезнаходження: Місцезнаходження) {
    якщо предмет == пусто {
      вернути;
    }

    якщо предмет.тип == М.значення_дійсне {
      вернути;
    }
    
    якщо предмет.тип == М.значення_послідовність {
      вернути;
    }
    
    якщо предмет.тип == М.значення_дійсність {
      вернути;
    }
    
    якщо предмет.тип == М.значення_предмет {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Структура {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Модуль {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Параметр {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Число {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Ціле {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Дробове {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Текст {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Код {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Дія {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Список {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Словник {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_Дані {
      вернути;
    }
    
    якщо предмет.тип == М.значення_структура_ЗмінніДані {
      вернути;
    }

    вернути;
  }

  // позначка: прохід по типах предметів
  місцева дія отримати_перебір(М: адреса<Машина>, предмет: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо предмет == пусто {
      вернути пусто;
    }

    якщо предмет.тип == М.значення_дійсне {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_послідовність {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_дійсність {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_предмет {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Структура {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Модуль {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Параметр {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Число {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Ціле {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Дробове {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Текст {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Код {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Дія {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Список {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Словник {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_Дані {
      вернути пусто;
    }
    
    якщо предмет.тип == М.значення_структура_ЗмінніДані {
      вернути пусто;
    }

    вернути здійснити_властивість(
      М,
      предмет,
      створити_текст(М, "чародія_перебір"),
      0,
      пусто,
      пусто,
      місцезнаходження
    );
  }

  місцева дія створити_іменовано_задіяні(М: адреса<Машина>) -> адреса<ІменованіЗадіяні> {
    змінна іменовано_задіяні = виділити<ІменованіЗадіяні>(М);

    іменовано_задіяні.розмір = 0;
    іменовано_задіяні.елементи = пусто;

    вернути іменовано_задіяні;
  }

  місцева дія знищити_іменовано_задіяні(М: адреса<Машина>, іменовано_задіяні: адреса<ІменованіЗадіяні>) -> ніщо {
    звільнити_памʼять(М, іменовано_задіяні.елементи);

    звільнити(М, іменовано_задіяні);
  }

  місцева дія покласти_іменовано_задіяне(М: адреса<Машина>, іменовано_задіяні: адреса<ІменованіЗадіяні>, назва: Значення, значення: Значення) {
    іменовано_задіяні.елементи = перевиділити_памʼять<ІменованоЗадіяне>(М, іменовано_задіяні.елементи, іменовано_задіяні.розмір + 1);
    іменовано_задіяні.елементи[іменовано_задіяні.розмір] = ІменованоЗадіяне { назва, значення };
    іменовано_задіяні.розмір += 1;
  }

  місцева дія знайти_іменоване_задіяне(М: адреса<Машина>, іменовано_задіяні: адреса<ІменованіЗадіяні>, назва: Значення, вихід_значення: адреса<Значення>) -> логічне {
    змінна п: природне = 0;

    поки п < іменовано_задіяні.розмір {
      змінна елемент = іменовано_задіяні.елементи[п]::адреса;

      якщо перевірити_чи_значення_рівні(М, елемент.назва, назва) {
        вихід_значення::вміст = елемент.значення;

        вернути так;
      }

      п += 1;
    }

    вернути ні;
  }

  місцева дія покласти_в_накопичувач_значень(М: адреса<Машина>, значення: Значення) {
    якщо М.накопичувач_значень.розмір == М.накопичувач_значень.вмісткість {
      запанікувати(М, "Накопичувач значень заповнено!");
      вернути;
    }

    М.накопичувач_значень.дані[М.накопичувач_значень.розмір] = значення;
    М.накопичувач_значень.розмір += 1;
  }

  місцева дія забрати_з_накопичувача_значень(М: адреса<Машина>) -> Значення {
    якщо М.накопичувач_значень.розмір == 0 {
      запанікувати(М, "Накопичувач значень порожній 1!");
    }

    М.накопичувач_значень.розмір -= 1;
    вернути М.накопичувач_значень.дані[М.накопичувач_значень.розмір];
  }

  місцева дія взяти_з_накопичувача_значень(М: адреса<Машина>, позиція: природне) -> Значення {
    якщо М.накопичувач_значень.розмір == 0 {
      запанікувати(М, "Накопичувач значень порожній 2!");
    }

    вернути М.накопичувач_значень.дані[М.накопичувач_значень.розмір - 1 - позиція];
  }

  місцева дія видалити_з_накопичувача_значень(М: адреса<Машина>, кількість: природне) {
    якщо М.накопичувач_значень.розмір == 0 {
      запанікувати(М, "Накопичувач значень порожній 3!");
    }
    
    М.накопичувач_значень.розмір -= кількість;
  }

  // позначка: прохід по типах предметів
  місцева дія виконати_текст(М: адреса<Машина>, значення: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо значення == пусто {
      вернути створити_текст(М, "недійсне");
    }

    якщо значення.тип == М.значення_дійсне {
      вернути створити_текст(М, "дійсне");
    }
    
    якщо значення.тип == М.значення_послідовність {
      вернути створити_текст(М, "послідовність");
    }
    
    якщо значення.тип == М.значення_дійсність {
      вернути створити_текст(М, "дійсність");
    }
    
    якщо значення.тип == М.значення_предмет {
      вернути створити_текст(М, "предмет");
    }
    
    якщо значення.тип == М.значення_структура_Структура {
      вернути створити_текст(М, "<Структура>");
    }
    
    якщо значення.тип == М.значення_структура_Модуль {
      вернути створити_текст(М, "<Модуль>");
    }
    
    якщо значення.тип == М.значення_структура_Параметр {
      вернути створити_текст(М, "<Параметр>");
    }
    
    якщо значення.тип == М.значення_структура_Число {
      вернути створити_текст(М, "<Число>");
    }
    
    якщо значення.тип == М.значення_структура_Ціле {
      вернути створити_текст(М, "<Ціле>");
    }
    
    якщо значення.тип == М.значення_структура_Дробове {
      вернути створити_текст(М, "<Дробове>");
    }
    
    якщо значення.тип == М.значення_структура_Текст {
      вернути значення;
    }
    
    якщо значення.тип == М.значення_структура_Код {
      вернути створити_текст(М, "<Код>");
    }
    
    якщо значення.тип == М.значення_структура_Дія {
      вернути створити_текст(М, "<Дія>");
    }
    
    якщо значення.тип == М.значення_структура_Список {
      вернути створити_текст(М, "<Список>");
    }
    
    якщо значення.тип == М.значення_структура_Словник {
      вернути створити_текст(М, "<Словник>");
    }
    
    якщо значення.тип == М.значення_структура_Дані {
      вернути створити_текст(М, "<Дані>");
    }
    
    якщо значення.тип == М.значення_структура_ЗмінніДані {
      вернути створити_текст(М, "<ЗмінніДані>");
    }
    
    вернути пусто;
  }

  місцева дія перевірити_чи_значення_рівні(М: адреса<Машина>, а: Значення, б: Значення) -> логічне {
    якщо а == б {
      вернути так;
    }

    якщо а == пусто або б == пусто {
      вернути ні;
    }
    
    якщо а.тип == б.тип {
      якщо а.тип == М.значення_структура_Ціле {
        змінна предмет_цілого_а = а як адреса<Предмет>;
        змінна властивості_цілого_а = предмет_цілого_а.властивості як ВластивостіЦілого;

        змінна предмет_цілого_б = б як адреса<Предмет>;
        змінна властивості_цілого_б = предмет_цілого_б.властивості як ВластивостіЦілого;

        якщо властивості_цілого_а.значення == властивості_цілого_б.значення {
          вернути так;
        }

        вернути ні;
      }
      
      якщо а.тип == М.значення_структура_Дробове {
        змінна предмет_дробового_а = а як адреса<Предмет>;
        змінна властивості_дробового_а = предмет_дробового_а.властивості як ВластивостіДробового;

        змінна предмет_дробового_б = б як адреса<Предмет>;
        змінна властивості_дробового_б = предмет_дробового_б.властивості як ВластивостіДробового;

        якщо властивості_дробового_а.значення == властивості_дробового_б.значення {
          вернути так;
        }

        вернути ні;
      }

      якщо а.тип == М.значення_структура_Текст {
        змінна предмет_тексту_а = а як адреса<Предмет>;
        змінна властивості_тексту_а = предмет_тексту_а.властивості як ВластивостіТексту;

        змінна предмет_тексту_б = б як адреса<Предмет>;
        змінна властивості_тексту_б = предмет_тексту_б.властивості як ВластивостіТексту;

        якщо властивості_тексту_а.значення.розмір != властивості_тексту_б.значення.розмір {
          вернути ні;
        }

        змінна п: природне = 0;
        поки п < властивості_тексту_а.значення.розмір {
          якщо властивості_тексту_а.значення.дані[п] != властивості_тексту_б.значення.дані[п] {
            вернути ні;
          }

          п += 1;
        }

        вернути так;
      }
    }

    якщо а.тип == М.значення_структура_Ціле і б.тип == М.значення_структура_Дробове {
      змінна предмет_цілого_а = а як адреса<Предмет>;
      змінна властивості_цілого_а = предмет_цілого_а.властивості як ВластивостіЦілого;

      змінна предмет_дробового_б = б як адреса<Предмет>;
      змінна властивості_дробового_б = предмет_дробового_б.властивості як ВластивостіДробового;

      якщо д64(властивості_цілого_а.значення) == властивості_дробового_б.значення {
        вернути так;
      }

      вернути ні;
    }

    якщо а.тип == М.значення_структура_Дробове і б.тип == М.значення_структура_Ціле {
      змінна предмет_дробового_а = а як адреса<Предмет>;
      змінна властивості_дробового_а = предмет_дробового_а.властивості як ВластивостіДробового;

      змінна предмет_цілого_б = б як адреса<Предмет>;
      змінна властивості_цілого_б = предмет_цілого_б.властивості як ВластивостіЦілого;

      якщо властивості_дробового_а.значення == д64(властивості_цілого_б.значення) {
        вернути так;
      }

      вернути ні;
    }
    
    вернути ні;
  }

  місцева дія перевірити_чи_значення_є(М: адреса<Машина>, а: Значення, б: Значення) -> логічне {
    якщо а == пусто {
      якщо б == пусто {
        вернути так;
      }

      вернути ні;
    }

    якщо б == пусто {
      вернути ні;
    }

    якщо б == М.значення_дійсне {
      вернути так;
    }

    змінна тип_а = а.тип;

    поки тип_а != М.значення_дійсне {
      якщо тип_а == б {
        вернути так;
      }

      якщо тип_а == М.значення_предмет {
        вернути ні;
      }

      змінна предмет_типу_а = тип_а як адреса<Предмет>;
      змінна властивості_типу_а = предмет_типу_а.властивості як ВластивостіСтруктури;

      тип_а = властивості_типу_а.предок;
    }
    
    вернути ні;
  }

  місцева дія визначити_в_дійсності(М: адреса<Машина>, дійсність: адреса<Дійсність>, назва: Значення, значення: Значення) {
    змінна п: природне = 0;
    поки п < дійсність.кількість_діячів {
      змінна діяч = дійсність.діячі[п]::адреса;

      якщо перевірити_чи_значення_рівні(М, діяч.назва, назва) {
        діяч.значення = значення;
        
        вернути;
      }

      п += 1;
    }

    дійсність.діячі = перевиділити_памʼять<Діяч>(М, дійсність.діячі, дійсність.кількість_діячів + 1);
    дійсність.діячі[дійсність.кількість_діячів] = Діяч { назва, значення };
    дійсність.кількість_діячів += 1;
  }
  
  місцева дія знайти_в_дійсності(М: адреса<Машина>, дійсність: адреса<Дійсність>, назва: Значення, вихід_значення: адреса<Значення>) -> логічне {
    змінна п: природне = 0;

    поки п < дійсність.кількість_діячів {
      змінна діяч = дійсність.діячі[п];

      якщо перевірити_чи_значення_рівні(М, діяч.назва, назва) {
        вихід_значення::вміст = діяч.значення;
        
        вернути так;
      }

      п += 1;
    }

    якщо дійсність.зовні != пусто {
      вернути знайти_в_дійсності(М, дійсність.зовні, назва, вихід_значення);
    }

    вернути ні;
  }

  місцева дія налаштувати_машину(М: адреса<Машина>, налаштування: Налаштування) {
    М.налаштування = налаштування;
    М.значення_дійсне = виділити_дійсне(М);
    М.значення_дійсне.тип = М.значення_дійсне;
    М.значення_дійсність = виділити_дійсне(М);
    М.значення_послідовність = виділити_дійсне(М);
    М.значення_предмет = виділити_дійсне(М);
    
    змінна значення_структура_Структура = виділити_предмет(М, пусто);
    значення_структура_Структура.тип = М.значення_структура_Структура;
    М.значення_структура_Структура = значення_структура_Структура як Значення;

    змінна значення_структура_Модуль = виділити_предмет(М, М.значення_структура_Структура);
    М.значення_структура_Модуль = значення_структура_Модуль як Значення;

    змінна значення_структура_Параметр = виділити_предмет(М, М.значення_структура_Структура);
    М.значення_структура_Параметр = значення_структура_Параметр як Значення;

    змінна значення_структура_Число = виділити_предмет(М, М.значення_структура_Структура);
    М.значення_структура_Число = значення_структура_Число як Значення;

    змінна значення_структура_Ціле = виділити_предмет(М, М.значення_структура_Структура);
    М.значення_структура_Ціле = значення_структура_Ціле як Значення;

    змінна значення_структура_Дробове = виділити_предмет(М, М.значення_структура_Структура);
    М.значення_структура_Дробове = значення_структура_Дробове як Значення;

    змінна значення_структура_Текст = виділити_предмет(М, М.значення_структура_Структура);
    М.значення_структура_Текст = значення_структура_Текст як Значення;

    змінна значення_структура_Код = виділити_предмет(М, М.значення_структура_Структура);
    М.значення_структура_Код = значення_структура_Код як Значення;

    змінна значення_структура_Дія = виділити_предмет(М, М.значення_структура_Структура);
    М.значення_структура_Дія = значення_структура_Дія як Значення;

    змінна значення_структура_Список = виділити_предмет(М, М.значення_структура_Структура);
    М.значення_структура_Список = значення_структура_Список як Значення;

    змінна значення_структура_Словник = виділити_предмет(М, М.значення_структура_Структура);
    М.значення_структура_Словник = значення_структура_Словник як Значення;

    змінна значення_структура_Дані = виділити_предмет(М, М.значення_структура_Структура);
    М.значення_структура_Дані = значення_структура_Дані як Значення;

    змінна значення_структура_ЗмінніДані = виділити_предмет(М, М.значення_структура_Структура);
    М.значення_структура_ЗмінніДані = значення_структура_ЗмінніДані як Значення;

    значення_структура_Структура.властивості = ВластивостіСтруктури {
      заборонити_наслідування = так,
      назва = створити_текст(М, "Структура"),
      предок = М.значення_предмет,
      параметри = пусто,
      методи = Методи { 0, пусто }
    };

    значення_структура_Модуль.властивості = ВластивостіСтруктури {
      заборонити_наслідування = так,
      назва = створити_текст(М, "Модуль"),
      предок = М.значення_предмет,
      параметри = пусто,
      методи = Методи { 0, пусто }
    };

    значення_структура_Параметр.властивості = ВластивостіСтруктури {
      заборонити_наслідування = так,
      назва = створити_текст(М, "Параметр"),
      предок = М.значення_предмет,
      параметри = пусто,
      методи = Методи { 0, пусто }
    };

    значення_структура_Текст.властивості = ВластивостіСтруктури {
      заборонити_наслідування = так,
      назва = створити_текст(М, "Текст"),
      предок = М.значення_предмет,
      параметри = пусто,
      методи = Методи { 0, пусто }
    };

    значення_структура_Число.властивості = ВластивостіСтруктури {
      заборонити_наслідування = так,
      назва = створити_текст(М, "Число"),
      предок = М.значення_предмет,
      параметри = пусто,
      методи = Методи { 0, пусто }
    };

    значення_структура_Ціле.властивості = ВластивостіСтруктури {
      заборонити_наслідування = так,
      назва = створити_текст(М, "Ціле"),
      предок = М.значення_структура_Число,
      параметри = пусто,
      методи = Методи { 0, пусто }
    };

    значення_структура_Дробове.властивості = ВластивостіСтруктури {
      заборонити_наслідування = так,
      назва = створити_текст(М, "Дробове"),
      предок = М.значення_структура_Число,
      параметри = пусто,
      методи = Методи { 0, пусто }
    };

    значення_структура_Код.властивості = ВластивостіСтруктури {
      заборонити_наслідування = так,
      назва = створити_текст(М, "Код"),
      предок = М.значення_предмет,
      параметри = пусто,
      методи = Методи { 0, пусто }
    };

    значення_структура_Дія.властивості = ВластивостіСтруктури {
      заборонити_наслідування = так,
      назва = створити_текст(М, "Дія"),
      предок = М.значення_предмет,
      параметри = пусто,
      методи = Методи { 0, пусто }
    };

    значення_структура_Список.властивості = ВластивостіСтруктури {
      заборонити_наслідування = так,
      назва = створити_текст(М, "Список"),
      предок = М.значення_предмет,
      параметри = пусто,
      методи = Методи { 0, пусто }
    };

    значення_структура_Словник.властивості = ВластивостіСтруктури {
      заборонити_наслідування = так,
      назва = створити_текст(М, "Словник"),
      предок = М.значення_предмет,
      параметри = пусто,
      методи = Методи { 0, пусто }
    };

    значення_структура_Дані.властивості = ВластивостіСтруктури {
      заборонити_наслідування = так,
      назва = створити_текст(М, "Дані"),
      предок = М.значення_предмет,
      параметри = пусто,
      методи = Методи { 0, пусто }
    };

    значення_структура_ЗмінніДані.властивості = ВластивостіСтруктури {
      заборонити_наслідування = так,
      назва = створити_текст(М, "ЗмінніДані"),
      предок = М.значення_предмет,
      параметри = пусто,
      методи = Методи { 0, пусто }
    };

    М.глобальна_дійсність = створити_дійсність(М, пусто, пусто);

    стала вмісткість_накопичувача_значень = 1024;
    М.накопичувач_значень = НакопичувачЗначень {
      розмір = 0,
      дані = виділити_памʼять<Значення>(М, вмісткість_накопичувача_значень),
      вмісткість = вмісткість_накопичувача_значень
    };

    стала вмісткість_історії_здійснення = 1024;
    М.історія_здійснення = ІсторіяЗдійснення {
      розмір = 0,
      дані = виділити_памʼять<Здійснюване>(М, вмісткість_історії_здійснення),
      вмісткість = вмісткість_історії_здійснення
    };

    М.стан_падіння = ні;
    М.значення_падіння = пусто;
    М.місцезнаходження_падіння = Місцезнаходження { пусто, 0 };

    визначити_в_дійсності(М, М.глобальна_дійсність, створити_текст(М, "дійсне"), М.значення_дійсне);
    визначити_в_дійсності(М, М.глобальна_дійсність, створити_текст(М, "послідовність"), М.значення_послідовність);
    визначити_в_дійсності(М, М.глобальна_дійсність, створити_текст(М, "дійсність"), М.значення_дійсність);
    визначити_в_дійсності(М, М.глобальна_дійсність, створити_текст(М, "предмет"), М.значення_предмет);
    визначити_в_дійсності(М, М.глобальна_дійсність, створити_текст(М, "Структура"), М.значення_структура_Структура);
    визначити_в_дійсності(М, М.глобальна_дійсність, створити_текст(М, "Модуль"), М.значення_структура_Модуль);
    визначити_в_дійсності(М, М.глобальна_дійсність, створити_текст(М, "Параметр"), М.значення_структура_Параметр);
    визначити_в_дійсності(М, М.глобальна_дійсність, створити_текст(М, "Число"), М.значення_структура_Число);
    визначити_в_дійсності(М, М.глобальна_дійсність, створити_текст(М, "Ціле"), М.значення_структура_Ціле);
    визначити_в_дійсності(М, М.глобальна_дійсність, створити_текст(М, "Дробове"), М.значення_структура_Дробове);
    визначити_в_дійсності(М, М.глобальна_дійсність, створити_текст(М, "Текст"), М.значення_структура_Текст);
    визначити_в_дійсності(М, М.глобальна_дійсність, створити_текст(М, "Код"), М.значення_структура_Код);
    визначити_в_дійсності(М, М.глобальна_дійсність, створити_текст(М, "Дія"), М.значення_структура_Дія);
    визначити_в_дійсності(М, М.глобальна_дійсність, створити_текст(М, "Список"), М.значення_структура_Список);
    визначити_в_дійсності(М, М.глобальна_дійсність, створити_текст(М, "Словник"), М.значення_структура_Словник);
    визначити_в_дійсності(М, М.глобальна_дійсність, створити_текст(М, "Дані"), М.значення_структура_Дані);
    визначити_в_дійсності(М, М.глобальна_дійсність, створити_текст(М, "ЗмінніДані"), М.значення_структура_ЗмінніДані);
  }

  місцева дія створити_машину(налаштування: Налаштування) -> адреса<Машина> {
    змінна М = налаштування.виділити_сиру_памʼять(пусто, Машина.розмір) як адреса<Машина>;
  
    налаштувати_машину(М, налаштування);
  
    вернути М;
  }

  місцева дія покласти_спробу(М: адреса<Машина>, спроби: адреса<Спроби>, спроба: Спроба) {
    спроби.дані = перевиділити_памʼять<Спроба>(М, спроби.дані, спроби.розмір + 1);
    спроби.дані[спроби.розмір] = спроба;
    спроби.розмір += 1;
  }

  місцева дія видалити_останню_спробу(М: адреса<Машина>, спроби: адреса<Спроби>) {
    якщо спроби.розмір == 0 {
      запанікувати(М, "Немає спроб для видалення.");
      вернути;
    }

    спроби.розмір -= 1;
  }

  місцева дія зробити_накопичувач_тексту(М: адреса<Машина>, вмісткість: природне) -> НакопичувачТексту {
    змінна дані: памʼять<п8> = пусто;

    якщо вмісткість > 0 {
      дані = виділити_памʼять<п8>(М, вмісткість);
    }
    
    вернути НакопичувачТексту {
      розмір = 0,
      дані = дані,
      вмісткість = вмісткість
    };
  }

  місцева дія покласти_в_накопичувач_тексту(М: адреса<Машина>, накопичувач: адреса<НакопичувачТексту>, значення: кд) {
    змінна новий_розмір = накопичувач.розмір + значення.розмір;

    накопичувач.дані = перевиділити_памʼять<п8>(М, накопичувач.дані, новий_розмір);

    змінна п: природне = 0;
    поки п < значення.розмір {
      накопичувач.дані[накопичувач.розмір + п] = значення.дані[п];
      п += 1;
    }

    накопичувач.розмір = новий_розмір;
  }

  місцева дія увімкнути_стан_падіння(М: адреса<Машина>, значення_падіння: Значення, місцезнаходження_падіння: Місцезнаходження) -> ніщо {
    М.стан_падіння = так;
    М.значення_падіння = значення_падіння;
    М.місцезнаходження_падіння = місцезнаходження_падіння;
  }

  дія вивести_пропуски(М: адреса<Машина>, кількість: природне) {
    змінна п: природне = 0;
    
    поки п < кількість {
      вивести(М, " ");
    
      п += 1;
    }
  }

  // позначка: прохід по типах предметів
  місцева дія вивести_значення(М: адреса<Машина>, значення: Значення, розмір_відступу: природне, глибина: природне) {
    якщо значення == пусто {
      вивести_формат(М, ФКолірТекстуЖовтий);
      
      вивести(М, "недійсне");
      
      вивести_формат(М, ФОчистити);

      вернути;
    }
    
    якщо значення == М.значення_дійсне {
      вивести_формат(М, ФКолірТекстуЖовтий);
      
      вивести(М, "дійсне");

      вивести_формат(М, ФОчистити);

      вернути;
    }
    
    якщо значення == М.значення_послідовність {
      вивести(М, "послідовність");
      вернути;
    }
    
    якщо значення == М.значення_дійсність {
      вивести(М, "дійсність");
      вернути;
    }
    
    якщо значення == М.значення_предмет {
      вивести(М, "предмет");
      вернути;
    }

    якщо значення.тип == М.значення_дійсне {
      вивести(М, "дійсне()");
      вернути;
    }
    
    якщо значення.тип == М.значення_послідовність {
      вивести(М, "послідовність()");
      вернути;
    }
    
    якщо значення.тип == М.значення_дійсність {
      вивести(М, "дійсність()");
      вернути;
    }
    
    якщо значення.тип == М.значення_предмет {
      вивести(М, "предмет()");
      вернути;
    }
    
    якщо значення.тип == М.значення_структура_Структура {
      змінна предмет = значення як адреса<Предмет>;
      змінна властивості = предмет.властивості як ВластивостіСтруктури;

      вивести_формат(М, ФКолірТекстуСиній);

      якщо властивості.назва == пусто {
        вивести(М, "<структура>");
      } інакше {
        вивести(М, "<структура ");
        
        вивести_значення(М, властивості.назва, 0, 0);

        вивести(М, ">");
      }

      вивести_формат(М, ФОчистити);

      вернути;
    }
    
    якщо значення.тип == М.значення_структура_Модуль {
      змінна предмет = значення як адреса<Предмет>;
      змінна властивості_модуля = предмет.властивості як ВластивостіМодуля;

      вивести_формат(М, ФКолірТекстуСиній);

      якщо властивості_модуля.назва == пусто {
        вивести(М, "<модуль");
      } інакше {
        вивести(М, "<модуль ");

        вивести_значення(М, властивості_модуля.назва, 0, 0);
      }

      якщо властивості_модуля.властивості.розмір > 0 {
        вивести(М, "[");
        змінна п: природне = 0;

        поки п < властивості_модуля.властивості.розмір {
          вивести_значення(М, властивості_модуля.властивості.дані[п].назва, 0, 0);
  
          якщо п + 1 < властивості_модуля.властивості.розмір {
            вивести(М, ", ");
          }
  
          п += 1;
        }
        вивести(М, "]");
      }
      
      вивести(М, ">");

      вивести_формат(М, ФОчистити);

      вернути;
    }
    
    якщо значення.тип == М.значення_структура_Параметр {
      вивести(М, "Параметр()");
      вернути;
    }
    
    якщо значення.тип == М.значення_структура_Число {
      запанікувати(М, "Неможливо вивести значення типу Число без конкретизації Ціле або Дробове.");
    }
    
    якщо значення.тип == М.значення_структура_Ціле {
      змінна предмет = значення як адреса<Предмет>;
      змінна властивості = предмет.властивості як ВластивостіЦілого;

      вивести_формат(М, ФКолірТекстуЖовтий);

      вивести_ц64(М, властивості.значення);

      вивести_формат(М, ФОчистити);

      вернути;
    }
    
    якщо значення.тип == М.значення_структура_Дробове {
      змінна предмет = значення як адреса<Предмет>;
      змінна властивості = предмет.властивості як ВластивостіДробового;

      вивести_формат(М, ФКолірТекстуЖовтий);

      вивести_д64(М, властивості.значення);

      вивести_формат(М, ФОчистити);

      вернути;
    }
    
    якщо значення.тип == М.значення_структура_Текст {
      змінна предмет = значення як адреса<Предмет>;
      змінна властивості = предмет.властивості як ВластивостіТексту;


      якщо глибина != 0 {
        вивести_формат(М, ФКолірТекстуЗелений);
        вивести(М, "\"");
      }

      якщо глибина == 0 {
        вивести(М, властивості.значення);
      } інакше {
        змінна п: природне = 0;
        поки п < властивості.значення.розмір {
          змінна символ = властивості.значення.дані[п];

          якщо символ == КД::символи::Міжряд {
            вивести(М, "\\р");
          } інакше якщо символ == КД::символи::Дволапка {
            вивести(М, "\\\"");
          } інакше якщо символ == КД::символи::Обернена_похила {
            вивести(М, "\\\\");
          } інакше {
            вивести(М, кд { 1, символ::адреса як памʼять<п8> });
          }

          п += 1;
        }
      }

      якщо глибина != 0 {
        вивести(М, "\"");
        вивести_формат(М, ФОчистити);
      }

      вернути;
    }
    
    якщо значення.тип == М.значення_структура_Код {
      вивести(М, "Код()");
      вернути;
    }
    
    якщо значення.тип == М.значення_структура_Дія {
      змінна предмет = значення як адреса<Предмет>;
      змінна властивості = предмет.властивості як ВластивостіДії;

      вивести_формат(М, ФКолірТекстуСиній);

      якщо властивості.назва == пусто {
        вивести(М, "<дія>");
      } інакше {
        вивести(М, "<дія ");
        
        вивести_значення(М, властивості.назва, 0, 0);

        вивести(М, ">");
      }

      вивести_формат(М, ФОчистити);

      вернути;
    }
    
    якщо значення.тип == М.значення_структура_Список {
      змінна предмет_списку = значення як адреса<Предмет>;
      змінна властивості_списку = предмет_списку.властивості як ВластивостіСписку;
      
      вивести(М, "[");

      якщо властивості_списку.розмір > 0 {
        якщо розмір_відступу > 0 {
          вивести(М, "\р");
        }

        змінна п: природне = 0;
        поки п < властивості_списку.розмір {
          змінна елемент = властивості_списку.елементи[п];
          вивести_пропуски(М, розмір_відступу * (глибина + 1));
          вивести_значення(М, елемент, розмір_відступу, глибина + 1);
          якщо п + 1 < властивості_списку.розмір {
            вивести(М, ",");
            якщо розмір_відступу > 0 {
              вивести(М, "\р");
            } інакше {
              вивести(М, " ");
            }
          }

          п += 1;
        }

        якщо розмір_відступу > 0 {
          вивести(М, "\р");
        }
        вивести_пропуски(М, розмір_відступу * глибина);
      }

      вивести(М, "]");
      
      вернути;
    }
    
    якщо значення.тип == М.значення_структура_Словник {
      змінна предмет_словника = значення як адреса<Предмет>;
      змінна властивості_словника = предмет_словника.властивості як ВластивостіСловника;

      вивести(М, "{");
      якщо властивості_словника.розмір > 0 {
        якщо розмір_відступу > 0 {
          вивести(М, "\р");
        }

        змінна п: природне = 0;
        поки п < властивості_словника.розмір {
          змінна пара = властивості_словника.елементи[п];
          вивести_пропуски(М, розмір_відступу * (глибина + 1));
          вивести_значення(М, пара.ключ, розмір_відступу, глибина + 1);
          вивести(М, " => ");
          вивести_значення(М, пара.значення, розмір_відступу, глибина + 1);
          якщо п + 1 < властивості_словника.розмір {
            вивести(М, ",");
            якщо розмір_відступу > 0 {
              вивести(М, "\р");
            } інакше {
              вивести(М, " ");
            }
          }

          п += 1;
        }

        якщо розмір_відступу > 0 {
          вивести(М, "\р");
        }
        вивести_пропуски(М, розмір_відступу * глибина);
      }
      
      вивести(М, "}");

      вернути;
    }
    
    якщо значення.тип == М.значення_структура_Дані {
      вивести(М, "Дані()");
      вернути;
    }
    
    якщо значення.тип == М.значення_структура_ЗмінніДані {
      вивести(М, "ЗмінніДані()");
      вернути;
    }

    змінна предмет_структури = значення.тип як адреса<Предмет>;
    змінна властивості_структури = предмет_структури.властивості як ВластивостіСтруктури;

    вивести_формат(М, ФКолірТекстуСиній);

    якщо властивості_структури.назва == пусто {
      вивести(М, "<без_назви>");
    } інакше {
      вивести_значення(М, властивості_структури.назва, 0, 0);
    }

    вивести_формат(М, ФОчистити);

    вивести(М, "(");

    якщо властивості_структури.параметри != пусто {
      якщо розмір_відступу > 0 {
        вивести(М, "\р");
      }

      змінна п: природне = 0;
      поки п < властивості_структури.параметри.розмір {
        змінна параметр = властивості_структури.параметри.дані[п];
        змінна предмет_параметра = параметр як адреса<Предмет>;
        змінна властивості_параметра = предмет_параметра.властивості як ВластивостіПараметра;
  
        змінна значення_властивості = отримати_властивість(М, значення, властивості_параметра.назва, Місцезнаходження { пусто, 0});
        вивести_пропуски(М, розмір_відступу * (глибина + 1));
        вивести_значення(М, властивості_параметра.назва, 0, 0);
        вивести(М, "=");
        вивести_значення(М, значення_властивості, розмір_відступу, глибина + 1);
        якщо п + 1 < властивості_структури.параметри.розмір {
          вивести(М, ",");
          якщо розмір_відступу > 0 {
            вивести(М, "\р");
          } інакше {
            вивести(М, " ");
          }
        }
  
        п += 1;
      }

      якщо розмір_відступу > 0 {
        вивести(М, "\р");
      }
      вивести_пропуски(М, розмір_відступу * глибина);
    }

    вивести(М, ")");
  }

  місцева дія надрукувати_значення(М: адреса<Машина>, значення: Значення, розмір_відступу: природне, глибина: природне) {
    вивести_значення(М, значення, розмір_відступу, глибина);
    вивести(М, "\р");
  }

  дія рідна_дія_друк(М: адреса<Машина>,
                     здійснювач: Значення,
                     значення: Значення,
                     кількість_задіяних: природне, 
                     задіяні: памʼять<Значення>,
                     іменовано_задіяні: адреса<ІменованіЗадіяні>) -> адреса<Дійсне> {
    змінна п: природне = 0;
    поки п < кількість_задіяних {
      надрукувати_значення(М, задіяні[п], 2, 0);
    
      п += 1;
    }
    
    вернути пусто;                  
  }

  місцева дія визначити_глобальні_виводу(М: адреса<Машина>) {
    змінна дія_друк = створити_рідну_дію(
      М,
      створити_текст(М, "друк"),
      пусто,
      пусто,
      рідна_дія_друк
    );
  
    визначити_в_дійсності(
      М,
      М.глобальна_дійсність,
      створити_текст(М, "друк"),
      дія_друк
    );
  }

  дія КД_виділити_сиру_памʼять(система: адреса<КД::Система>, розмір: природне) -> памʼять<п8> {
    змінна М = система.дані як адреса<Машина>;

    вернути виділити_памʼять<п8>(М, розмір);
  }
  
  дія КД_перевиділити_сиру_памʼять(система: адреса<КД::Система>, значення: памʼять<п8>, новий_розмір: природне) -> памʼять<п8> {
    змінна М = система.дані як адреса<Машина>;

    вернути перевиділити_памʼять<п8>(М, значення, новий_розмір);
  }
  
  дія КД_звільнити_сиру_памʼять(система: адреса<КД::Система>, значення: невідома_памʼять) {
    змінна М = система.дані як адреса<Машина>;

    звільнити_памʼять(М, значення як памʼять<п8>);
  }

  місцева дія перекодувати_ю8_в_кд(М: адреса<Машина>, вхід: ю8, вихід: адреса<кд>, вихід_позиції_помилки: адреса<природне>) -> логічне {
    змінна система_КД = КД::Система {
      дані = М,
      виділити_сиру_памʼять = КД_виділити_сиру_памʼять,
      звільнити_сиру_памʼять = КД_звільнити_сиру_памʼять,
      перевиділити_сиру_памʼять = КД_перевиділити_сиру_памʼять
    };

    вернути КД::перекодувати_з_ю8(система_КД::адреса, вхід, ні, ні, вихід, вихід_позиції_помилки);
  }

  місцева дія перекодувати_кд_в_ю8(М: адреса<Машина>, вхід: кд, вихід: адреса<ю8>, вихід_позиції_помилки: адреса<природне>) -> логічне {
    змінна система_КД = КД::Система {
      дані = М,
      виділити_сиру_памʼять = КД_виділити_сиру_памʼять,
      звільнити_сиру_памʼять = КД_звільнити_сиру_памʼять,
      перевиділити_сиру_памʼять = КД_перевиділити_сиру_памʼять
    };

    вернути КД::перекодувати_в_ю8(система_КД::адреса, вхід, ні, вихід, вихід_позиції_помилки);
  }

  дія обробити_стан_падіння(М: адреса<Машина>,
                            дійсність: адреса<Дійсність>,
                            код: Значення,
                            позиція_вказівки_падіння: природне,
                            позиція: адреса<природне>) -> логічне {
    якщо дійсність.спроби.розмір > 0 {
      дійсність.спроби.розмір -= 1;
      змінна спроба = дійсність.спроби.дані[дійсність.спроби.розмір];

      якщо спроба.назва_зловити != пусто {
        визначити_в_дійсності(М, дійсність, спроба.назва_зловити, М.значення_падіння);
      }

      позиція::вміст = спроба.позиція_вказівки_зловити;
      М.історія_здійснення.розмір = спроба.розмір_історії_здійснення;
      М.накопичувач_значень.розмір = спроба.розмір_накопичувача_значень;
      
      М.стан_падіння = ні;
      М.значення_падіння = пусто;
      М.місцезнаходження_падіння = Місцезнаходження { пусто, 0 };
      
      вернути так;
    }
    
    якщо М.місцезнаходження_падіння.значення == пусто {
      М.місцезнаходження_падіння = Місцезнаходження { код, позиція_вказівки_падіння };
    }

    вернути ні;                     
  }

  дія прочитати_аргумент_вказівки(вказівки: ВластивостіДаних, позиція: адреса<природне>) -> п32 {
    позиція::вміст += 1;
    змінна адреса_аргумента = вказівки.дані[позиція::вміст]::адреса як адреса<п32>;
    позиція::вміст += 3;
    вернути адреса_аргумента::вміст;
  }

  дія виконати_код(М: адреса<Машина>,
                   дійсність: адреса<Дійсність>,
                   код: Значення) -> Значення {
    змінна предмет_коду = код як адреса<Предмет>;
    змінна властивості_коду = предмет_коду.властивості як ВластивостіКоду;
    змінна константи = властивості_коду.константи;
    змінна предмет_вказівок = властивості_коду.вказівки як адреса<Предмет>;
    змінна дані_вказівок = предмет_вказівок.властивості як ВластивостіДаних;
    змінна вказівки = предмет_вказівок.властивості як ВластивостіДаних;

    змінна результат_вернути: Значення = пусто;
    змінна результат: Значення = пусто;

    змінна позиція: природне = 0;
    змінна позиція_поточної_вказівки: природне = 0;
    змінна вказівка: п8 = 0;

    // надрукувати_ю8(М, ю8"Початок виконання коду");
    // надрукувати_д64(М, д64(вказівки.розмір));

    поки позиція < вказівки.розмір {
  крок_виконання_вказівки:
      позиція_поточної_вказівки = позиція;
      вказівка = вказівки.дані[позиція_поточної_вказівки];
      
      // надрукувати_ю8(М, ю8"Виконується вказівка: ");
      // надрукувати_д64(М, д64(вказівка));

      якщо вказівка == ВПокластиНедійсне {
        покласти_в_накопичувач_значень(М, пусто);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПокластиДійсне {
        покласти_в_накопичувач_значень(М, М.значення_дійсне);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПокластиПредмет {
        покласти_в_накопичувач_значень(М, М.значення_предмет);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПокластиПослідовність {
        покласти_в_накопичувач_значень(М, М.значення_послідовність);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПокластиЯ {
        покласти_в_накопичувач_значень(М, дійсність.здійснювач);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПокластиКонстанту {
        змінна позиція_константи = прочитати_аргумент_вказівки(вказівки, позиція::адреса);

        покласти_в_накопичувач_значень(М, константи.дані[позиція_константи]);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиДію {
        змінна кількість_параметрів = прочитати_аргумент_вказівки(вказівки, позиція::адреса);
        
        змінна код = забрати_з_накопичувача_значень(М);

        змінна параметри = створити_сиру_послідовність(М, природне(кількість_параметрів));
        
        змінна п: п32 = 0;
        поки п < кількість_параметрів {
          параметри.дані[кількість_параметрів - п - 1] = забрати_з_накопичувача_значень(М);

          п += 1;
        }
        
        змінна тип_результату = забрати_з_накопичувача_значень(М);
        змінна назва = забрати_з_накопичувача_значень(М);

        змінна предмет_дії = створити_дію(М, дійсність, назва, параметри, тип_результату, код);

        покласти_в_накопичувач_значень(М, предмет_дії);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиСтруктуру {
        змінна кількість_параметрів = прочитати_аргумент_вказівки(вказівки, позиція::адреса);
                
        змінна параметри: адреса<Послідовність> = пусто;
      
        якщо кількість_параметрів > 0 {
          параметри = створити_сиру_послідовність(М, природне(кількість_параметрів));
          
          змінна п: п32 = 0;
          поки п < кількість_параметрів {
            параметри.дані[кількість_параметрів - п - 1] = забрати_з_накопичувача_значень(М);

            п += 1;
          }
        }

        змінна предок = забрати_з_накопичувача_значень(М);        
        змінна назва = забрати_з_накопичувача_значень(М);

        змінна предмет_структури = створити_структуру(М, назва, предок, параметри);

        покласти_в_накопичувач_значень(М, предмет_структури);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиМодуль {
        змінна код = забрати_з_накопичувача_значень(М);
        змінна назва = забрати_з_накопичувача_значень(М);

        змінна предмет_модуля = створити_модуль(М, назва);

        змінна предмет_дії = створити_дію(
          М,
          дійсність,
          назва,
          пусто,
          пусто,
          код
        );

        змінна результат = здійснити(
          М,
          предмет_модуля,
          предмет_дії,
          0,
          пусто,
          пусто,
          Місцезнаходження { код, позиція_поточної_вказівки }
        );

        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, предмет_модуля);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиСписок {
        змінна кількість_елементів = прочитати_аргумент_вказівки(вказівки, позиція::адреса);

        змінна дані_елементів = виділити_памʼять<Значення>(М, природне(кількість_елементів));
                
        змінна п: п32 = 0;
        поки п < кількість_елементів {
          дані_елементів[кількість_елементів - п - 1] = забрати_з_накопичувача_значень(М);

          п += 1;
        }

        змінна предмет_списку = створити_список_без_копіювання(М, природне(кількість_елементів), дані_елементів);

        покласти_в_накопичувач_значень(М, предмет_списку);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиСловник {
        змінна кількість_елементів = прочитати_аргумент_вказівки(вказівки, позиція::адреса);
                
        змінна предмет_словника = створити_словник(М);

        змінна п: п32 = 0;
        поки п < кількість_елементів {
          змінна значення = забрати_з_накопичувача_значень(М);
          змінна ключ = забрати_з_накопичувача_значень(М);
          
          записати_в_словник(М, предмет_словника, ключ, значення);

          п += 1;
        }

        покласти_в_накопичувач_значень(М, предмет_словника);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиПослідовність {
        змінна кількість_елементів = прочитати_аргумент_вказівки(вказівки, позиція::адреса);

        змінна послідовність = створити_сиру_послідовність(М, природне(кількість_елементів));
                
        змінна п: п32 = 0;
        поки п < кількість_елементів {
          послідовність.дані[кількість_елементів - п - 1] = забрати_з_накопичувача_значень(М);
        }

        покласти_в_накопичувач_значень(М, послідовність як Значення);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиДіапазон {
        змінна до = забрати_з_накопичувача_значень(М);
        змінна включно = забрати_з_накопичувача_значень(М);
        змінна від = забрати_з_накопичувача_значень(М);

        змінна включно_логічне: логічне = ні;
        якщо включно != пусто {
          включно_логічне = так;
        }

        змінна предмет_діапазону = отримати_діапазон(
          М,
          від,
          до,
          включно_логічне,
          Місцезнаходження { код, позиція_поточної_вказівки }
        );
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, предмет_діапазону);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиПараметр {
        змінна дія_значення = забрати_з_накопичувача_значень(М);
        змінна тип = забрати_з_накопичувача_значень(М);
        змінна назва = забрати_з_накопичувача_значень(М);

        змінна предмет_параметра = створити_параметр(М, назва, тип, дія_значення);
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, предмет_параметра);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗаписатиМетод {
        змінна значення_структури = забрати_з_накопичувача_значень(М);
        змінна значення_дії = забрати_з_накопичувача_значень(М);
        змінна назва = забрати_з_накопичувача_значень(М);

        записати_метод_структури(М, значення_структури, назва, значення_дії);

        покласти_в_накопичувач_значень(М, значення_дії);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВВизначити {
        змінна значення = забрати_з_накопичувача_значень(М);
        змінна назва = забрати_з_накопичувача_значень(М);

        визначити_в_дійсності(М, дійсність, назва, значення);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗвернутись {
        змінна назва = забрати_з_накопичувача_значень(М);

        змінна значення: Значення;
        якщо не знайти_в_дійсності(М, дійсність, назва, значення::адреса) {
          увімкнути_стан_падіння(
            М, 
            створити_текст(М, "Діяча з такою назвою не знайдено."), 
            Місцезнаходження { код, позиція_поточної_вказівки }
          );
          
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }
  
          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, значення);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗдійснити {
        змінна кількість_задіяних = прочитати_аргумент_вказівки(вказівки, позиція::адреса);
        змінна кількість_іменованих_аргументів = прочитати_аргумент_вказівки(вказівки, позиція::адреса);

        змінна іменовано_задіяні: адреса<ІменованіЗадіяні> = пусто;
        змінна п: п32 = 0;

        якщо кількість_іменованих_аргументів > 0 {
          іменовано_задіяні = створити_іменовано_задіяні(М);
          
          поки п < кількість_іменованих_аргументів {
            змінна значення = забрати_з_накопичувача_значень(М);
            змінна назва = забрати_з_накопичувача_значень(М);

            покласти_іменовано_задіяне(М, іменовано_задіяні, назва, значення);

            п += 1;
          }
        }

        змінна дані_аргументів = виділити_памʼять<Значення>(М, природне(кількість_задіяних));

        п = 0;
        поки п < кількість_задіяних {
          дані_аргументів[кількість_задіяних - п - 1] = забрати_з_накопичувача_значень(М);

          п += 1;
        }
        
        змінна предмет_дії = забрати_з_накопичувача_значень(М);

        результат = здійснити(
          М,
          пусто, 
          предмет_дії,
          природне(кількість_задіяних), 
          дані_аргументів,
          іменовано_задіяні,
          Місцезнаходження { код, позиція_поточної_вказівки }
        );
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВОтриматиВластивість {
        змінна назва = забрати_з_накопичувача_значень(М);
        змінна предмет = забрати_з_накопичувача_значень(М);

        результат = отримати_властивість(М, предмет, назва, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗмінитиВластивість {
        змінна значення = забрати_з_накопичувача_значень(М);
        змінна назва = забрати_з_накопичувача_значень(М);
        змінна предмет = забрати_з_накопичувача_значень(М);

        змінити_властивість(
          М,
          предмет,
          назва,
          значення,
          Місцезнаходження { код, позиція_поточної_вказівки }
        );
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗдійснитиВластивість {
        змінна кількість_задіяних = прочитати_аргумент_вказівки(вказівки, позиція::адреса);
        змінна кількість_іменованих_аргументів = прочитати_аргумент_вказівки(вказівки, позиція::адреса);

        змінна іменовано_задіяні: адреса<ІменованіЗадіяні> = пусто;
        змінна п: п32 = 0;

        якщо кількість_іменованих_аргументів > 0 {
          іменовано_задіяні = створити_іменовано_задіяні(М);
          
          поки п < кількість_іменованих_аргументів {
            змінна значення = забрати_з_накопичувача_значень(М);
            змінна назва = забрати_з_накопичувача_значень(М);

            покласти_іменовано_задіяне(М, іменовано_задіяні, назва, значення);

            п += 1;
          }
        }

        змінна дані_аргументів = виділити_памʼять<Значення>(М, природне(кількість_задіяних));

        п = 0;
        поки п < кількість_задіяних {
          дані_аргументів[кількість_задіяних - п - 1] = забрати_з_накопичувача_значень(М);

          п += 1;
        }

        змінна назва = забрати_з_накопичувача_значень(М);
        змінна предмет = забрати_з_накопичувача_значень(М);

        результат = здійснити_властивість(
          М, 
          предмет, 
          назва, 
          природне(кількість_задіяних), 
          дані_аргументів, 
          іменовано_задіяні,
          Місцезнаходження { код, позиція_поточної_вказівки }
        );
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВОтриматиЕлемент {
        змінна ключ = забрати_з_накопичувача_значень(М);
        змінна предмет = забрати_з_накопичувача_значень(М);

        змінна значення = отримати_елемент(М, предмет, ключ, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, значення);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗмінитиЕлемент {
        змінна значення = забрати_з_накопичувача_значень(М);
        змінна ключ = забрати_з_накопичувача_значень(М);
        змінна предмет = забрати_з_накопичувача_значень(М);
        
        змінити_елемент(М, предмет, ключ, значення, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВОтриматиПеребір {
        змінна значення = забрати_з_накопичувача_значень(М);

        результат = отримати_перебір(М, значення, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВДодати {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_додавання(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВВідняти {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_відімання(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВПомножити {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_множення(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПоділити {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_ділення(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВОтриматиОстачуДілення {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_остача(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВОтриматиНеповнуЧасткуДілення {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_неповна_частка(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВПіднестиДоСтепеня {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_степінь(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВЗсунутиВліво {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_вліво(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВЗсунутиВправо {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_вправо(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВЗсунутиВправо2 {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_вправо_2(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВДвійковеІ {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_двійкове_і(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВДвійковеАБО {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_двійкове_або(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВДвійковеВиключнеАБО {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_двійкове_вабо(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВМенше {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_менше(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВБільше {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_більше(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВНеБільше {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_не_більше(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВНеМенше {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_не_менше(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВРівно {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_рівно(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВНеРівно {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_не_рівно(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВМістить {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_містить(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВНеМістить {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_не_містить(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВЄ {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_є(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВНеЄ {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        результат = виконати_не_є(М, а, б, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;      
      }
      
      якщо вказівка == ВДвійковеНЕ {
        змінна значення = забрати_з_накопичувача_значень(М);

        результат = виконати_двійкове_не(М, значення, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВВідʼємне {
        змінна значення = забрати_з_накопичувача_значень(М);

        результат = виконати_відʼємне(М, значення, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВЗаперечити {
        змінна значення = забрати_з_накопичувача_значень(М);

        результат = виконати_заперечення(М, значення, Місцезнаходження { код, позиція_поточної_вказівки });
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВПочатиСпробу {
        змінна назва_зловити = забрати_з_накопичувача_значень(М);

        змінна позиція_вказівки_зловити = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));
        
        покласти_спробу(М, дійсність.спроби::адреса, Спроба {
          назва_зловити = назва_зловити,
          позиція_вказівки_зловити = позиція_вказівки_зловити,
          розмір_історії_здійснення = М.історія_здійснення.розмір,
          розмір_накопичувача_значень = М.накопичувач_значень.розмір
        });
  
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВВпасти {
        змінна значення_помилки = забрати_з_накопичувача_значень(М);

        увімкнути_стан_падіння(
          М, 
          значення_помилки, 
          Місцезнаходження { код, позиція_поточної_вказівки }
        );        

        якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
          стрибнути крок_виконання_вказівки;
        }
  
        стрибнути крок_вихід;
      }
  
      якщо вказівка == ВЗакінчитиСпробу {
        змінна позиція_вказівки_виходу = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        видалити_останню_спробу(М, дійсність.спроби::адреса);
        
        позиція = позиція_вказівки_виходу;
  
        стрибнути крок_виконання_вказівки;
      }

      якщо вказівка == ВВзяти {
        змінна кількість_назв = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        змінна дані_назв: памʼять<Значення> = пусто;

        якщо кількість_назв > 0 {
          дані_назв = виділити_памʼять<Значення>(М, кількість_назв);
          
          змінна п: природне = 0;
          
          поки п < кількість_назв {
            змінна назва = забрати_з_накопичувача_значень(М);
          
            дані_назв[кількість_назв - п - 1] = назва;
          
            п += 1;
          }
        }

        змінна назва = забрати_з_накопичувача_значень(М);

        результат = виконати_взяти(
          М, 
          пусто, // потім: передати предмет файлового модуля
          назва, 
          кількість_назв, 
          дані_назв,
          Місцезнаходження { код, позиція_поточної_вказівки }
        );
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
  
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВДати {
        змінна назва = забрати_з_накопичувача_значень(М);
        змінна значення = забрати_з_накопичувача_значень(М);

        якщо дійсність.здійснювач == пусто {
          увімкнути_стан_падіння(
            М, 
            створити_текст(М, "Неможливо дати."), 
            Місцезнаходження { код, позиція_поточної_вказівки }
          );

          якщо М.стан_падіння {
            якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
              стрибнути крок_виконання_вказівки;
            }
  
            стрибнути крок_вихід;
          }
        }
        
        змінити_властивість(
          М,
          дійсність.здійснювач,
          назва,
          значення,
          Місцезнаходження { код, позиція_поточної_вказівки }
        );
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }
  
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПеребратиДалі {
        змінна значення_перебору = забрати_з_накопичувача_значень(М);

        покласти_в_накопичувач_значень(М, значення_перебору);
        
        результат = здійснити_властивість(
          М,
          значення_перебору,
          створити_текст(М, "далі"),
          0,
          пусто,
          пусто,
          Місцезнаходження { код, позиція_поточної_вказівки }
        );
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }
        
        покласти_в_накопичувач_значень(М, результат);
  
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗбитиТекст {
        змінна кількість_предметів = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));
        
        змінна накопичувач_тексту = зробити_накопичувач_тексту(М, кількість_предметів);
        
        змінна п: природне = 0;
        
        поки п < кількість_предметів {
          змінна значення = взяти_з_накопичувача_значень(М, кількість_предметів - п - 1);

          змінна предмет_як_текст = виконати_текст(
            М, 
            значення,
            Місцезнаходження { код, позиція_поточної_вказівки }
          );
        
          якщо М.стан_падіння {
            звільнити_памʼять(М, накопичувач_тексту.дані);

            якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
              стрибнути крок_виконання_вказівки;
            }
  
            стрибнути крок_вихід;
          }
        
          якщо предмет_як_текст == пусто або предмет_як_текст.тип != М.значення_структура_Текст {
            увімкнути_стан_падіння(
              М, 
              створити_текст(М, "Не вдалось перетворити на текст."), 
              Місцезнаходження { код, позиція_поточної_вказівки }
            );

            звільнити_памʼять(М, накопичувач_тексту.дані);
           
            якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
              стрибнути крок_виконання_вказівки;
            }
  
            стрибнути крок_вихід;
          }

          змінна предмет_тексту = предмет_як_текст як адреса<Предмет>;
          змінна властивості_тексту = предмет_тексту.властивості як ВластивостіТексту;

          покласти_в_накопичувач_тексту(М, накопичувач_тексту::адреса, властивості_тексту.значення);
        
          п += 1;
        }

        видалити_з_накопичувача_значень(М, кількість_предметів);
                
        покласти_в_накопичувач_значень(
          М, 
          створити_текст_без_копіювання(М, накопичувач_тексту.розмір, накопичувач_тексту.дані)
        );
          
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВСтрибнути {
        змінна позиція_вказівки_стрибка = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        позиція = позиція_вказівки_стрибка;
  
        стрибнути крок_виконання_вказівки;
      }
  
      якщо вказівка == ВСтрибнутиЯкщоТак {
        змінна значення = забрати_з_накопичувача_значень(М);

        змінна позиція_вказівки_стрибка = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        якщо значення != пусто {
          позиція = позиція_вказівки_стрибка;

          стрибнути крок_виконання_вказівки;
        }
  
        стрибнути крок_виконати_далі;
      }
  
      якщо вказівка == ВСтрибнутиЯкщоНі {
        змінна значення = забрати_з_накопичувача_значень(М);

        змінна позиція_вказівки_стрибка = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        якщо значення == пусто {
          позиція = позиція_вказівки_стрибка;

          стрибнути крок_виконання_вказівки;
        }
  
        стрибнути крок_виконати_далі;
      }
  
      якщо вказівка == ВЗабрати {
        видалити_з_накопичувача_значень(М, 1);
  
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВДублювати {
        змінна значення = забрати_з_накопичувача_значень(М);

        покласти_в_накопичувач_значень(М, значення);
        покласти_в_накопичувач_значень(М, значення);
  
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВВернути {
        результат_вернути = забрати_з_накопичувача_значень(М);
        
        стрибнути крок_вихід;
      }

      запанікувати(М, "Невідома вказівка під час виконання коду.");
      
  крок_виконати_далі:
      позиція += 1;
    }
  
  крок_вихід:
    вернути результат_вернути;
  }

  // позначка: прохід по типах предметів
  дія здійснити_структуру(
    М: адреса<Машина>,
    значення: Значення,
    кількість_задіяних: природне,
    задіяні: памʼять<Значення>,
    іменовано_задіяні: адреса<ІменованіЗадіяні>,
    місцезнаходження: Місцезнаходження
  ) -> Значення {
    змінна результат: Значення = пусто;
    
    якщо значення == М.значення_дійсне {
      стрибнути крок_вихід;
    }
    
    якщо значення == М.значення_послідовність {
      стрибнути крок_вихід;
    }
    
    якщо значення == М.значення_дійсність {
      стрибнути крок_вихід;
    }
    
    якщо значення == М.значення_предмет {
      стрибнути крок_вихід;
    }
    
    якщо значення == М.значення_структура_Модуль {
      стрибнути крок_вихід;
    }
    
    якщо значення == М.значення_структура_Параметр {
      стрибнути крок_вихід;
    }
    
    якщо значення == М.значення_структура_Число {
      стрибнути крок_вихід;
    }
    
    якщо значення == М.значення_структура_Ціле {
      стрибнути крок_вихід;
    }
    
    якщо значення == М.значення_структура_Дробове {
      стрибнути крок_вихід;
    }
    
    якщо значення == М.значення_структура_Текст {
      стрибнути крок_вихід;
    }
    
    якщо значення == М.значення_структура_Код {
      стрибнути крок_вихід;
    }
    
    якщо значення == М.значення_структура_Дія {
      стрибнути крок_вихід;
    }
    
    якщо значення == М.значення_структура_Список {
      стрибнути крок_вихід;
    }
    
    якщо значення == М.значення_структура_Словник {
      стрибнути крок_вихід;
    }
    
    якщо значення == М.значення_структура_Дані {
      стрибнути крок_вихід;
    }
    
    якщо значення == М.значення_структура_ЗмінніДані {
      стрибнути крок_вихід;
    }

    змінна предмет_структури = значення як адреса<Предмет>;
    змінна властивості_структури = предмет_структури.властивості як ВластивостіСтруктури;

    результат = створити_предмет(М, значення);
    змінна п: природне = 0;

    якщо властивості_структури.параметри != пусто {
      поки п < властивості_структури.параметри.розмір {
        змінна параметр = властивості_структури.параметри.дані[п];
        змінна предмет_параметра = параметр як адреса<Предмет>;
        змінна властивості_параметра = предмет_параметра.властивості як ВластивостіПараметра;
  
        якщо кількість_задіяних > п {
          змінити_властивість(
            М,
            результат,
            властивості_параметра.назва,
            задіяні[п],
            місцезнаходження
          );
        }
  
        п += 1;
      }
  
      якщо іменовано_задіяні != пусто {
        п = 0;

        поки п < іменовано_задіяні.розмір {
          змінна іменовано_задіяне = іменовано_задіяні.елементи[п];
  
          змінити_властивість(
            М,
            результат,
            іменовано_задіяне.назва,
            іменовано_задіяне.значення,
            місцезнаходження
          );
  
          п += 1;
        }
      }
    }

  крок_вихід:
    звільнити_памʼять(М, задіяні);
    якщо іменовано_задіяні != пусто {
      знищити_іменовано_задіяні(М, іменовано_задіяні);
    }

    вернути результат;
  }

  місцева дія здійснити(
    М: адреса<Машина>,
    здійснювач: Значення,
    значення: Значення,
    кількість_задіяних: природне,
    задіяні: памʼять<Значення>,
    іменовано_задіяні: адреса<ІменованіЗадіяні>,
    місцезнаходження: Місцезнаходження
  ) -> ЗначенняАбоСтанПадіння {
    якщо значення.тип == М.значення_структура_Дія {
      змінна предмет_дії = значення як адреса<Предмет>;
      змінна властивості_дії = предмет_дії.властивості як ВластивостіДії;

      якщо властивості_дії.рідна {
        змінна рідна_дія = властивості_дії.код як РіднаДія;

        змінна результат = рідна_дія(
          М,
          здійснювач,
          значення,
          кількість_задіяних,
          задіяні,
          іменовано_задіяні
        );

        звільнити_памʼять(М, задіяні);
        якщо іменовано_задіяні != пусто {
          знищити_іменовано_задіяні(М, іменовано_задіяні);
        }

        вернути результат;
      } інакше {        
        змінна дійсність = створити_дійсність(
          М, 
          властивості_дії.дійсність_створення,
          здійснювач
        );

        якщо властивості_дії.параметри != пусто {
          змінна п: природне = 0;
          
          поки п < властивості_дії.параметри.розмір {
            змінна параметр = властивості_дії.параметри.дані[п];
            змінна предмет_параметра = параметр як адреса<Предмет>;
            змінна властивості_параметра = предмет_параметра.властивості як ВластивостіПараметра;
      
            якщо кількість_задіяних > п {
              визначити_в_дійсності(
                М,
                дійсність,
                властивості_параметра.назва,
                задіяні[п]
              );
            }
      
            п += 1;
          }
      
          якщо іменовано_задіяні != пусто {
            п = 0;
    
            поки п < іменовано_задіяні.розмір {
              змінна іменовано_задіяне = іменовано_задіяні.елементи[п];
      
              визначити_в_дійсності(
                М,
                дійсність,
                іменовано_задіяне.назва,
                іменовано_задіяне.значення
              );
      
              п += 1;
            }
          }
        }

        звільнити_памʼять(М, задіяні);
        якщо іменовано_задіяні != пусто {
          знищити_іменовано_задіяні(М, іменовано_задіяні);
        }

        вернути виконати_код(
          М,
          дійсність,
          властивості_дії.код як Значення
        );
      }
    } інакше якщо значення.тип == М.значення_структура_Структура {
      вернути здійснити_структуру(
        М,
        значення,
        кількість_задіяних,
        задіяні,
        іменовано_задіяні,
        місцезнаходження
      );
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати дію можна лише над діями.");

      вернути пусто;
    }                         
  }

  місцева дія виконати_додавання(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати додавання можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Дробове {
      якщо право.тип == М.значення_структура_Дробове {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;
  
        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіДробового;
        змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
  
        вернути створити_дробове(М, властивості_ліво.значення + властивості_право.значення);
      }

      якщо право.тип == М.значення_структура_Ціле {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;
  
        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіДробового;
        змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;

        вернути створити_дробове(М, властивості_ліво.значення + д64(властивості_право.значення));
      }

      стрибнути крок_вихід;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      якщо право.тип == М.значення_структура_Ціле {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;

        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
        змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;
  
        вернути створити_ціле(М, властивості_ліво.значення + властивості_право.значення);
      }

      якщо право.тип == М.значення_структура_Дробове {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;

        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
        змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
  
        вернути створити_дробове(М, д64(властивості_ліво.значення) + властивості_право.значення);
      }

      стрибнути крок_вихід;
    }
  
  крок_вихід:
    М.стан_падіння = так;
    М.значення_падіння = створити_текст(М, "Виконати додавання можна лише між числами.");

    вернути пусто;
  }

  місцева дія виконати_відімання(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати віднімання можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Дробове {
      якщо право.тип == М.значення_структура_Дробове {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;
  
        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіДробового;
        змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
  
        вернути створити_дробове(М, властивості_ліво.значення - властивості_право.значення);
      }

      якщо право.тип == М.значення_структура_Ціле {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;
  
        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіДробового;
        змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;

        вернути створити_дробове(М, властивості_ліво.значення - д64(властивості_право.значення));
      }

      стрибнути крок_вихід;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      якщо право.тип == М.значення_структура_Ціле {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;

        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
        змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;
  
        вернути створити_ціле(М, властивості_ліво.значення - властивості_право.значення);
      }

      якщо право.тип == М.значення_структура_Дробове {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;

        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
        змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
  
        вернути створити_дробове(М, д64(властивості_ліво.значення) - властивості_право.значення);
      }

      стрибнути крок_вихід;
    }
  
  крок_вихід:
    М.стан_падіння = так;
    М.значення_падіння = створити_текст(М, "Виконати віднімання можна лише між числами.");

    вернути пусто;
  }

  місцева дія виконати_множення(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати множення можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Дробове {
      якщо право.тип == М.значення_структура_Дробове {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;
  
        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіДробового;
        змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
  
        вернути створити_дробове(М, властивості_ліво.значення * властивості_право.значення);
      }

      якщо право.тип == М.значення_структура_Ціле {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;
  
        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіДробового;
        змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;

        вернути створити_дробове(М, властивості_ліво.значення * д64(властивості_право.значення));
      }

      стрибнути крок_вихід;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      якщо право.тип == М.значення_структура_Ціле {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;

        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
        змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;
  
        вернути створити_ціле(М, властивості_ліво.значення * властивості_право.значення);
      }

      якщо право.тип == М.значення_структура_Дробове {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;

        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
        змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
  
        вернути створити_дробове(М, д64(властивості_ліво.значення) * властивості_право.значення);
      }

      стрибнути крок_вихід;
    }
  
  крок_вихід:
    М.стан_падіння = так;
    М.значення_падіння = створити_текст(М, "Виконати множення можна лише між числами.");

    вернути пусто;
  }

  місцева дія виконати_ділення(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати ділення можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Дробове {
      якщо право.тип == М.значення_структура_Дробове {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;
  
        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіДробового;
        змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
  
        вернути створити_дробове(М, властивості_ліво.значення / властивості_право.значення);
      }

      якщо право.тип == М.значення_структура_Ціле {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;
  
        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіДробового;
        змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;

        вернути створити_дробове(М, властивості_ліво.значення / д64(властивості_право.значення));
      }

      стрибнути крок_вихід;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      якщо право.тип == М.значення_структура_Ціле {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;

        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
        змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;
  
        вернути створити_ціле(М, властивості_ліво.значення / властивості_право.значення);
      }

      якщо право.тип == М.значення_структура_Дробове {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;

        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
        змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
  
        вернути створити_дробове(М, д64(властивості_ліво.значення) / властивості_право.значення);
      }

      стрибнути крок_вихід;
    }
  
  крок_вихід:
    М.стан_падіння = так;
    М.значення_падіння = створити_текст(М, "Виконати ділення можна лише між числами.");

    вернути пусто;
  }

  місцева дія виконати_остача(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати отримання остачі можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Дробове {
      якщо право.тип == М.значення_структура_Дробове {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;
  
        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіДробового;
        змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
  
        вернути створити_дробове(М, властивості_ліво.значення % властивості_право.значення);
      }

      якщо право.тип == М.значення_структура_Ціле {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;
  
        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіДробового;
        змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;

        вернути створити_дробове(М, властивості_ліво.значення % д64(властивості_право.значення));
      }

      стрибнути крок_вихід;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      якщо право.тип == М.значення_структура_Ціле {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;

        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
        змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;
  
        вернути створити_ціле(М, властивості_ліво.значення % властивості_право.значення);
      }

      якщо право.тип == М.значення_структура_Дробове {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;

        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
        змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
  
        вернути створити_дробове(М, д64(властивості_ліво.значення) % властивості_право.значення);
      }

      стрибнути крок_вихід;
    }
  
  крок_вихід:
    М.стан_падіння = так;
    М.значення_падіння = створити_текст(М, "Виконати отримання остачі можна лише між числами.");

    вернути пусто;
  }

  місцева дія виконати_неповна_частка(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати отримання неповної частки можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Дробове {
      якщо право.тип == М.значення_структура_Дробове {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;
  
        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіДробового;
        змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
  
        вернути створити_дробове(М, властивості_ліво.значення / властивості_право.значення);
      }

      якщо право.тип == М.значення_структура_Ціле {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;
  
        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіДробового;
        змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;

        вернути створити_дробове(М, властивості_ліво.значення / д64(властивості_право.значення));
      }

      стрибнути крок_вихід;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      якщо право.тип == М.значення_структура_Ціле {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;

        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
        змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;
  
        вернути створити_ціле(М, властивості_ліво.значення / властивості_право.значення);
      }

      якщо право.тип == М.значення_структура_Дробове {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;

        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
        змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
  
        вернути створити_дробове(М, д64(властивості_ліво.значення) / властивості_право.значення);
      }

      стрибнути крок_вихід;
    }
  
  крок_вихід:
    М.стан_падіння = так;
    М.значення_падіння = створити_текст(М, "Виконати отримання неповної частки можна лише між числами.");

    вернути пусто;
  }

  місцева дія виконати_степінь(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати піднесення до степеня можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Дробове {
      якщо право.тип == М.значення_структура_Дробове {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;
  
        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіДробового;
        змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
  
        вернути створити_дробове(М, властивості_ліво.значення * властивості_право.значення);
      }

      якщо право.тип == М.значення_структура_Ціле {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;
  
        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіДробового;
        змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;

        вернути створити_дробове(М, властивості_ліво.значення * д64(властивості_право.значення));
      }

      стрибнути крок_вихід;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      якщо право.тип == М.значення_структура_Ціле {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;

        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
        змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;
  
        вернути створити_ціле(М, властивості_ліво.значення * властивості_право.значення);
      }

      якщо право.тип == М.значення_структура_Дробове {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;

        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
        змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
  
        вернути створити_дробове(М, д64(властивості_ліво.значення) * властивості_право.значення);
      }

      стрибнути крок_вихід;
    }
  
  крок_вихід:
    М.стан_падіння = так;
    М.значення_падіння = створити_текст(М, "Виконати піднесення до степеня можна лише між числами.");

    вернути пусто;
  }

  місцева дія виконати_вліво(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати зсув вліво можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Ціле і право.тип == М.значення_структура_Ціле {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
      змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;

      вернути створити_ціле(М, властивості_ліво.значення << властивості_право.значення);
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати зсув вліво можна лише між цілими.");

      вернути пусто;
    }
  }

  місцева дія виконати_вправо(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати зсув вправо можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Ціле і право.тип == М.значення_структура_Ціле {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
      змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;

      вернути створити_ціле(М, властивості_ліво.значення >> властивості_право.значення);
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати зсув вправо можна лише між цілими.");

      вернути пусто;
    }
  }

  місцева дія виконати_вправо_2(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати зсув вправо 2 можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Ціле і право.тип == М.значення_структура_Ціле {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
      змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;

      вернути створити_ціле(М, ц64(п64(властивості_ліво.значення) >> п64(властивості_право.значення)));
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати зсув вправо 2 можна лише між цілими.");

      вернути пусто;
    }
  }

  місцева дія виконати_двійкове_і(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати двійкове І можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Ціле і право.тип == М.значення_структура_Ціле {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
      змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;

      вернути створити_ціле(М, властивості_ліво.значення & властивості_право.значення);
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати двійкове І можна лише між цілими.");

      вернути пусто;
    }
  }

  місцева дія виконати_двійкове_або(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати двійкове АБО можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Ціле і право.тип == М.значення_структура_Ціле {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
      змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;

      вернути створити_ціле(М, властивості_ліво.значення | властивості_право.значення);
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати двійкове АБО можна лише між цілими.");

      вернути пусто;
    }
  }

  місцева дія виконати_двійкове_вабо(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати двійкове ВАБО можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Ціле і право.тип == М.значення_структура_Ціле {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
      змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;

      вернути створити_ціле(М, властивості_ліво.значення вабо властивості_право.значення);
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати двійкове ВАБО можна лише між цілими.");

      вернути пусто;
    }
  }

  місцева дія виконати_менше(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати менше можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Дробове {
      якщо право.тип == М.значення_структура_Дробове {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;
  
        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіДробового;
        змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
  
        якщо властивості_ліво.значення < властивості_право.значення {
          вернути М.значення_дійсне;
        } інакше {
          вернути пусто;
        }
      }

      якщо право.тип == М.значення_структура_Ціле {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;
  
        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіДробового;
        змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;

        якщо властивості_ліво.значення < д64(властивості_право.значення) {
          вернути М.значення_дійсне;
        } інакше {
          вернути пусто;
        }
      }

      стрибнути крок_вихід;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      якщо право.тип == М.значення_структура_Ціле {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;

        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
        змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;
  
        якщо властивості_ліво.значення < властивості_право.значення {
          вернути М.значення_дійсне;
        } інакше {
          вернути пусто;
        }
      }

      якщо право.тип == М.значення_структура_Дробове {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;

        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
        змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
  
        якщо д64(властивості_ліво.значення) < властивості_право.значення {
          вернути М.значення_дійсне;
        } інакше {
          вернути пусто;
        }
      }

      стрибнути крок_вихід;
    }
  
  крок_вихід:
    М.стан_падіння = так;
    М.значення_падіння = створити_текст(М, "Виконати менше можна лише між числами.");

    вернути пусто;
  }

  місцева дія виконати_не_менше(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати не менше можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Дробове {
      якщо право.тип == М.значення_структура_Дробове {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;
  
        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіДробового;
        змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
  
        якщо властивості_ліво.значення >= властивості_право.значення {
          вернути М.значення_дійсне;
        } інакше {
          вернути пусто;
        }
      }

      якщо право.тип == М.значення_структура_Ціле {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;
  
        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіДробового;
        змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;

        якщо властивості_ліво.значення >= д64(властивості_право.значення) {
          вернути М.значення_дійсне;
        } інакше {
          вернути пусто;
        }
      }

      стрибнути крок_вихід;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      якщо право.тип == М.значення_структура_Ціле {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;

        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
        змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;
  
        якщо властивості_ліво.значення >= властивості_право.значення {
          вернути М.значення_дійсне;
        } інакше {
          вернути пусто;
        }
      }

      якщо право.тип == М.значення_структура_Дробове {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;

        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
        змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
  
        якщо д64(властивості_ліво.значення) >= властивості_право.значення {
          вернути М.значення_дійсне;
        } інакше {
          вернути пусто;
        }
      }

      стрибнути крок_вихід;
    }
  
  крок_вихід:
    М.стан_падіння = так;
    М.значення_падіння = створити_текст(М, "Виконати не менше можна лише між числами.");

    вернути пусто;
  }

  місцева дія виконати_більше(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати більше можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Дробове {
      якщо право.тип == М.значення_структура_Дробове {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;
  
        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіДробового;
        змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
  
        якщо властивості_ліво.значення > властивості_право.значення {
          вернути М.значення_дійсне;
        } інакше {
          вернути пусто;
        }
      }

      якщо право.тип == М.значення_структура_Ціле {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;
  
        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіДробового;
        змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;

        якщо властивості_ліво.значення > д64(властивості_право.значення) {
          вернути М.значення_дійсне;
        } інакше {
          вернути пусто;
        }
      }

      стрибнути крок_вихід;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      якщо право.тип == М.значення_структура_Ціле {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;

        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
        змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;
  
        якщо властивості_ліво.значення > властивості_право.значення {
          вернути М.значення_дійсне;
        } інакше {
          вернути пусто;
        }
      }

      якщо право.тип == М.значення_структура_Дробове {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;

        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
        змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
  
        якщо д64(властивості_ліво.значення) > властивості_право.значення {
          вернути М.значення_дійсне;
        } інакше {
          вернути пусто;
        }
      }

      стрибнути крок_вихід;
    }
  
  крок_вихід:
    М.стан_падіння = так;
    М.значення_падіння = створити_текст(М, "Виконати більше можна лише між числами.");

    вернути пусто;
  }

  місцева дія виконати_не_більше(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати не більше можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Дробове {
      якщо право.тип == М.значення_структура_Дробове {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;
  
        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіДробового;
        змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
  
        якщо властивості_ліво.значення <= властивості_право.значення {
          вернути М.значення_дійсне;
        } інакше {
          вернути пусто;
        }
      }

      якщо право.тип == М.значення_структура_Ціле {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;
  
        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіДробового;
        змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;

        якщо властивості_ліво.значення <= д64(властивості_право.значення) {
          вернути М.значення_дійсне;
        } інакше {
          вернути пусто;
        }
      }

      стрибнути крок_вихід;
    }
    
    якщо ліво.тип == М.значення_структура_Ціле {
      якщо право.тип == М.значення_структура_Ціле {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;

        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
        змінна властивості_право = право_предмет.властивості як ВластивостіЦілого;
  
        якщо властивості_ліво.значення <= властивості_право.значення {
          вернути М.значення_дійсне;
        } інакше {
          вернути пусто;
        }
      }

      якщо право.тип == М.значення_структура_Дробове {
        змінна ліво_предмет = ліво як адреса<Предмет>;
        змінна право_предмет = право як адреса<Предмет>;

        змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЦілого;
        змінна властивості_право = право_предмет.властивості як ВластивостіДробового;
  
        якщо д64(властивості_ліво.значення) <= властивості_право.значення {
          вернути М.значення_дійсне;
        } інакше {
          вернути пусто;
        }
      }

      стрибнути крок_вихід;
    }
  
  крок_вихід:
    М.стан_падіння = так;
    М.значення_падіння = створити_текст(М, "Виконати не більше можна лише між числами.");

    вернути пусто;
  }

  місцева дія виконати_рівно(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо перевірити_чи_значення_рівні(М, ліво, право) {
      вернути М.значення_дійсне;
    } інакше {
      вернути пусто;
    }
  }

  місцева дія виконати_не_рівно(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо перевірити_чи_значення_рівні(М, ліво, право) {
      вернути пусто;
    } інакше {
      вернути М.значення_дійсне;
    }
  }

  місцева дія виконати_містить(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    вернути пусто;
  }

  місцева дія виконати_не_містить(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    вернути пусто;
  }

  місцева дія виконати_є(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо перевірити_чи_значення_є(М, ліво, право) {
      вернути М.значення_дійсне;
    } інакше {
      вернути пусто;
    }
  }

  місцева дія виконати_не_є(М: адреса<Машина>, ліво: Значення, право: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    якщо перевірити_чи_значення_є(М, ліво, право) {
      вернути пусто;
    } інакше {
      вернути М.значення_дійсне;
    }
  }

  місцева дія виконати_двійкове_не(М: адреса<Машина>, значення: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    вернути пусто;
  }

  місцева дія виконати_відʼємне(М: адреса<Машина>, значення: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    вернути пусто;
  }

  місцева дія виконати_заперечення(М: адреса<Машина>, значення: Значення, місцезнаходження: Місцезнаходження) -> Значення {
    вернути пусто;
  }

  місцева дія виконати_взяти(М: адреса<Машина>, модуль: Значення, звідки: Значення, довжина_шляху: природне, шлях: памʼять<Значення>, місцезнаходження: Місцезнаходження) -> Значення {
    вернути пусто;
  }

  місцева дія надрукувати_код(М: адреса<Машина>, розмір: природне, дані: памʼять<п8>, дія_виводу: (М: адреса<Машина>, значення: кд) -> ніщо) {
    змінна п: природне = 0;
    поки п < розмір {
      змінна вказівка = дані[п];
      якщо вказівка == ВПокластиНедійсне { дія_виводу(М, "ПокластиНедійсне\р"); }
      інакше якщо вказівка == ВПокластиДійсне { дія_виводу(М, "ПокластиДійсне\р"); }
      інакше якщо вказівка == ВПокластиПредмет { дія_виводу(М, "ПокластиПредмет\р"); }
      інакше якщо вказівка == ВПокластиПослідовність { дія_виводу(М, "ПокластиПослідовність\р"); }
      інакше якщо вказівка == ВПокластиЯ { дія_виводу(М, "ПокластиЯ\р"); }
      інакше якщо вказівка == ВПокластиКонстанту { дія_виводу(М, "ПокластиКонстанту\р"); п += 4; }
      інакше якщо вказівка == ВСтворитиПослідовність { дія_виводу(М, "СтворитиПослідовність\р"); }
      інакше якщо вказівка == ВСтворитиДію { дія_виводу(М, "СтворитиДію\р"); п += 4; }
      інакше якщо вказівка == ВСтворитиСтруктуру { дія_виводу(М, "СтворитиСтруктуру\р"); п += 4; }
      інакше якщо вказівка == ВСтворитиМодуль { дія_виводу(М, "СтворитиМодуль\р"); }
      інакше якщо вказівка == ВСтворитиСписок { дія_виводу(М, "СтворитиСписок\р"); п += 4; }
      інакше якщо вказівка == ВСтворитиСловник { дія_виводу(М, "СтворитиСловник\р"); п += 4; }
      інакше якщо вказівка == ВСтворитиДіапазон { дія_виводу(М, "СтворитиДіапазон\р"); }
      інакше якщо вказівка == ВЗаписатиМетод { дія_виводу(М, "ЗаписатиМетод\р"); }
      інакше якщо вказівка == ВСтворитиПараметр { дія_виводу(М, "СтворитиПараметр\р"); }
      інакше якщо вказівка == ВВизначити { дія_виводу(М, "Визначити\р"); }
      інакше якщо вказівка == ВЗвернутись { дія_виводу(М, "Звернутись\р"); }
      інакше якщо вказівка == ВЗдійснити { дія_виводу(М, "Здійснити\р"); п += 4; п += 4; }
      інакше якщо вказівка == ВОтриматиВластивість { дія_виводу(М, "ОтриматиВластивість\р"); }
      інакше якщо вказівка == ВЗмінитиВластивість { дія_виводу(М, "ЗмінитиВластивість\р"); }
      інакше якщо вказівка == ВЗдійснитиВластивість { дія_виводу(М, "ЗдійснитиВластивість\р"); п += 4; п += 4; }
      інакше якщо вказівка == ВОтриматиЕлемент { дія_виводу(М, "ОтриматиЕлемент\р"); }
      інакше якщо вказівка == ВЗмінитиЕлемент { дія_виводу(М, "ЗмінитиЕлемент\р"); }
      інакше якщо вказівка == ВОтриматиПеребір { дія_виводу(М, "ОтриматиПеребір\р"); }
      інакше якщо вказівка == ВДодати { дія_виводу(М, "Додати\р"); }
      інакше якщо вказівка == ВВідняти { дія_виводу(М, "Відняти\р"); }
      інакше якщо вказівка == ВПомножити { дія_виводу(М, "Помножити\р"); }
      інакше якщо вказівка == ВПоділити { дія_виводу(М, "Поділити\р"); }
      інакше якщо вказівка == ВОтриматиОстачуДілення { дія_виводу(М, "ОтриматиОстачуДілення\р"); }
      інакше якщо вказівка == ВОтриматиНеповнуЧасткуДілення { дія_виводу(М, "ОтриматиНеповнуЧасткуДілення\р"); }
      інакше якщо вказівка == ВПіднестиДоСтепеня { дія_виводу(М, "ПіднестиДоСтепеня\р"); }
      інакше якщо вказівка == ВЗсунутиВліво { дія_виводу(М, "ЗсунутиВліво\р"); }
      інакше якщо вказівка == ВЗсунутиВправо { дія_виводу(М, "ЗсунутиВправо\р"); }
      інакше якщо вказівка == ВЗсунутиВправо2 { дія_виводу(М, "ЗсунутиВправо2\р"); }
      інакше якщо вказівка == ВДвійковеІ { дія_виводу(М, "ДвійковеІ\р"); }
      інакше якщо вказівка == ВДвійковеАБО { дія_виводу(М, "ДвійковеАБО\р"); }
      інакше якщо вказівка == ВДвійковеВиключнеАБО { дія_виводу(М, "ДвійковеВиключнеАБО\р"); }
      інакше якщо вказівка == ВМенше { дія_виводу(М, "Менше\р"); }
      інакше якщо вказівка == ВБільше { дія_виводу(М, "Більше\р"); }
      інакше якщо вказівка == ВНеБільше { дія_виводу(М, "НеБільше\р"); }
      інакше якщо вказівка == ВНеМенше { дія_виводу(М, "НеМенше\р"); }
      інакше якщо вказівка == ВРівно { дія_виводу(М, "Рівно\р"); }
      інакше якщо вказівка == ВНеРівно { дія_виводу(М, "НеРівно\р"); }
      інакше якщо вказівка == ВМістить { дія_виводу(М, "Містить\р"); }
      інакше якщо вказівка == ВНеМістить { дія_виводу(М, "НеМістить\р"); }
      інакше якщо вказівка == ВЄ { дія_виводу(М, "Є\р"); }
      інакше якщо вказівка == ВНеЄ { дія_виводу(М, "НеЄ\р"); }
      інакше якщо вказівка == ВДвійковеНЕ { дія_виводу(М, "ДвійковеНЕ\р"); }
      інакше якщо вказівка == ВВідʼємне { дія_виводу(М, "Відʼємне\р"); }
      інакше якщо вказівка == ВЗаперечити { дія_виводу(М, "Заперечити\р"); }
      інакше якщо вказівка == ВПочатиСпробу { дія_виводу(М, "ПочатиСпробу\р"); п += 4; }
      інакше якщо вказівка == ВВпасти { дія_виводу(М, "Впасти\р"); }
      інакше якщо вказівка == ВЗакінчитиСпробу { дія_виводу(М, "ЗакінчитиСпробу\р"); п += 4; }
      інакше якщо вказівка == ВВзяти { дія_виводу(М, "Взяти\р"); п += 4; }
      інакше якщо вказівка == ВДати { дія_виводу(М, "Дати\р"); }
      інакше якщо вказівка == ВПеребратиДалі { дія_виводу(М, "ПеребратиДалі\р"); }
      інакше якщо вказівка == ВЗбитиТекст { дія_виводу(М, "ЗбитиТекст\р"); п += 4; }
      інакше якщо вказівка == ВСтрибнути { дія_виводу(М, "Стрибнути\р"); п += 4; }
      інакше якщо вказівка == ВСтрибнутиЯкщоНі { дія_виводу(М, "СтрибнутиЯкщоНі\р"); п += 4; }
      інакше якщо вказівка == ВЗабрати { дія_виводу(М, "Забрати\р"); }
      інакше якщо вказівка == ВВернути { дія_виводу(М, "Вернути\р"); }
      інакше якщо вказівка == ВСтрибнутиЯкщоТак { дія_виводу(М, "СтрибнутиЯкщоТак\р"); п += 4; }
      інакше якщо вказівка == ВДублювати { дія_виводу(М, "Дублювати\р"); }
      інакше { дія_виводу(М, "НЕВІДОМА ВКАЗІВКА\р"); }
      п += 1;
    }
  }
}