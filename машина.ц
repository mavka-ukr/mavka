/* Машина Мавки */

взяти означення ./мавка;

простір мавка {
  дія обробити_стан_падіння(М: адреса<Машина>,
                            дійсність: адреса<Дійсність>,
                            код: Значення,
                            позиція_вказівки_падіння: природне,
                            позиція: адреса<природне>) -> логічне {
    якщо дійсність.спроби.розмір > 0 {
      дійсність.спроби.розмір -= 1;
      змінна спроба = дійсність.спроби.дані[дійсність.спроби.розмір];

      якщо спроба.назва_зловити != пусто {
        визначити_діяча(М, дійсність, спроба.назва_зловити, М.значення_падіння);
      }

      позиція::вміст = спроба.позиція_вказівки_зловити;
      М.історія_здійснення.розмір = спроба.розмір_історії_здійснення;
      М.накопичувач_значень.розмір = спроба.розмір_накопичувача_значень;
      
      М.стан_падіння = ні;
      М.значення_падіння = пусто;
      М.місцезнаходження_падіння = Місцезнаходження { пусто, 0 };
      
      вернути так;
    }
    
    якщо М.місцезнаходження_падіння.значення == пусто {
      М.місцезнаходження_падіння = Місцезнаходження { код, позиція_вказівки_падіння };
    }

    вернути ні;                     
  }

  дія прочитати_аргумент_вказівки(вказівки: ВластивостіДаних, позиція: адреса<природне>) -> п32 {
    позиція::вміст += 1;
    змінна адреса_аргумента = вказівки.дані[позиція::вміст]::адреса як адреса<п32>;
    позиція::вміст += 3;
    вернути адреса_аргумента::вміст;
  }

  дія виконати_код(М: адреса<Машина>,
                   дійсність: адреса<Дійсність>,
                   код: Значення) -> Значення {
    змінна предмет_коду = код як адреса<Предмет>;
    змінна властивості_коду = предмет_коду.властивості як ВластивостіКоду;
    змінна константи = властивості_коду.константи;
    змінна предмет_вказівок = властивості_коду.вказівки як адреса<Предмет>;
    змінна дані_вказівок = предмет_вказівок.властивості як ВластивостіДаних;
    змінна вказівки = предмет_вказівок.властивості як ВластивостіДаних;

    змінна результат: Значення = пусто;

    змінна позиція: природне = 0;
    змінна позиція_поточної_вказівки: природне = 0;
    змінна вказівка: п8 = 0;

    поки позиція < вказівки.розмір {
  крок_виконання_вказівки:
      позиція_поточної_вказівки = позиція;
      вказівка = вказівки.дані[позиція_поточної_вказівки];

      якщо вказівка == ВПокластиНедійсне {
        покласти_в_накопичувач_значень(М, пусто);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПокластиДійсне {
        покласти_в_накопичувач_значень(М, М.значення_дійсне);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПокластиПредмет {
        покласти_в_накопичувач_значень(М, М.значення_предмет);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПокластиПослідовність {
        покласти_в_накопичувач_значень(М, М.значення_послідовність);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПокластиЯ {
        покласти_в_накопичувач_значень(М, дійсність.здійснювач);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПокластиКонстанту {
        змінна позиція_константи = прочитати_аргумент_вказівки(вказівки, позиція::адреса);

        покласти_в_накопичувач_значень(М, константи.дані[позиція_константи]);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиДію {
        змінна кількість_параметрів = прочитати_аргумент_вказівки(вказівки, позиція::адреса);
        
        змінна код = забрати_з_накопичувача_значень(М);

        змінна параметри = створити_сиру_послідовність(М, природне(кількість_параметрів));
        
        змінна п: п32 = 0;
        поки п < кількість_параметрів {
          параметри.дані[кількість_параметрів - п - 1] = забрати_з_накопичувача_значень(М);
        }
        
        змінна назва = забрати_з_накопичувача_значень(М);

        змінна предмет_дії = створити_дію(М, дійсність, назва, параметри, код);

        покласти_в_накопичувач_значень(М, предмет_дії);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиСтруктуру {
        змінна кількість_параметрів = прочитати_аргумент_вказівки(вказівки, позиція::адреса);
                
        змінна параметри: адреса<Послідовність> = пусто;
      
        якщо кількість_параметрів > 0 {
          параметри = створити_сиру_послідовність(М, природне(кількість_параметрів));
          
          змінна п: п32 = 0;
          поки п < кількість_параметрів {
            параметри.дані[кількість_параметрів - п - 1] = забрати_з_накопичувача_значень(М);
          }
        }

        змінна предок = забрати_з_накопичувача_значень(М);        
        змінна назва = забрати_з_накопичувача_значень(М);

        змінна предмет_структури = створити_структуру(М, назва, предок, параметри);

        покласти_в_накопичувач_значень(М, предмет_структури);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиМодуль {
        змінна назва = забрати_з_накопичувача_значень(М);

        змінна предмет_модуля = створити_модуль(М, назва);

        покласти_в_накопичувач_значень(М, предмет_модуля);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиСписок {
        змінна кількість_елементів = прочитати_аргумент_вказівки(вказівки, позиція::адреса);

        змінна дані_елементів = виділити_памʼять<Значення>(М, природне(кількість_елементів));
                
        змінна п: п32 = 0;
        поки п < кількість_елементів {
          дані_елементів[кількість_елементів - п - 1] = забрати_з_накопичувача_значень(М);
        }

        змінна предмет_списку = створити_список_без_копіювання(М, природне(кількість_елементів), дані_елементів);

        покласти_в_накопичувач_значень(М, предмет_списку);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиСловник {
        змінна кількість_елементів = прочитати_аргумент_вказівки(вказівки, позиція::адреса);
                
        змінна предмет_словника = створити_словник(М);

        змінна п: п32 = 0;
        поки п < кількість_елементів {
          змінна значення = забрати_з_накопичувача_значень(М);
          змінна ключ = забрати_з_накопичувача_значень(М);
          
          записати_в_словник(М, предмет_словника, ключ, значення);
        }

        покласти_в_накопичувач_значень(М, предмет_словника);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиПослідовність {
        змінна кількість_елементів = прочитати_аргумент_вказівки(вказівки, позиція::адреса);

        змінна послідовність = створити_сиру_послідовність(М, природне(кількість_елементів));
                
        змінна п: п32 = 0;
        поки п < кількість_елементів {
          послідовність.дані[кількість_елементів - п - 1] = забрати_з_накопичувача_значень(М);
        }

        покласти_в_накопичувач_значень(М, послідовність як Значення);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиДіапазон {
        змінна включно = логічне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        змінна до = забрати_з_накопичувача_значень(М);
        змінна від = забрати_з_накопичувача_значень(М);

        змінна предмет_діапазону = отримати_діапазон(М, від, до, включно);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, предмет_діапазону);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВСтворитиПараметр {
        змінна дія_значення = забрати_з_накопичувача_значень(М);
        змінна назва = забрати_з_накопичувача_значень(М);

        змінна предмет_параметра = створити_параметр(М, назва, дія_значення);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, предмет_параметра);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗаписатиМетод {
        змінна предмет_дії = забрати_з_накопичувача_значень(М);
        змінна назва = забрати_з_накопичувача_значень(М);
        змінна предмет_структури = забрати_з_накопичувача_значень(М);
        змінна значення_власна = забрати_з_накопичувача_значень(М);

        записати_метод_структури(М, значення_власна, предмет_структури, назва, предмет_дії);

        покласти_в_накопичувач_значень(М, предмет_дії);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВВизначити {
        змінна значення = забрати_з_накопичувача_значень(М);
        змінна назва = забрати_з_накопичувача_значень(М);

        визначити_діяча(М, дійсність, назва, значення);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗвернутись {
        змінна назва = забрати_з_накопичувача_значень(М);

        змінна значення: Значення;
        якщо не звернутись_до_діяча(М, дійсність, назва, значення::адреса) {
          увімкнути_стан_падіння(
            М, 
            створити_текст(М, "Діяча з такою назвою не знайдено."), 
            Місцезнаходження { код, позиція_поточної_вказівки }
          );
          
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }
  
          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, значення);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗдійснити {
        змінна кількість_аргументів = прочитати_аргумент_вказівки(вказівки, позиція::адреса);
        змінна кількість_іменованих_аргументів = прочитати_аргумент_вказівки(вказівки, позиція::адреса);

        змінна іменовано_задіяні: адреса<ІменованіЗадіяні> = пусто;
        змінна п: п32 = 0;

        якщо кількість_іменованих_аргументів > 0 {
          іменовано_задіяні = створити_іменовано_задіяні(М);
          
          поки п < кількість_іменованих_аргументів {
            змінна значення = забрати_з_накопичувача_значень(М);
            змінна назва = забрати_з_накопичувача_значень(М);
  
            покласти_іменовано_задіяне(М, назва, значення);
          
            п += 1;
          }
        }

        змінна дані_аргументів = виділити_памʼять<Значення>(М, природне(кількість_аргументів));

        п = 0;
        поки п < кількість_аргументів {
          дані_аргументів[кількість_аргументів - п - 1] = забрати_з_накопичувача_значень(М);

          п += 1;
        }
        
        змінна предмет_дії = забрати_з_накопичувача_значень(М);

        змінна результат = здійснити(
          М,
          пусто, 
          предмет_дії,
          природне(кількість_аргументів), 
          дані_аргументів,
          іменовано_задіяні
        );
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВОтриматиВластивість {
        змінна назва = забрати_з_накопичувача_значень(М);
        змінна предмет = забрати_з_накопичувача_значень(М);

        змінна результат = отримати_властивість(М, предмет, назва);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗмінитиВластивість {
        змінна значення = забрати_з_накопичувача_значень(М);
        змінна назва = забрати_з_накопичувача_значень(М);
        змінна предмет = забрати_з_накопичувача_значень(М);

        змінити_властивість(М, предмет, назва, значення);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗдійснитиВластивість {
        змінна кількість_аргументів = прочитати_аргумент_вказівки(вказівки, позиція::адреса);
        змінна кількість_іменованих_аргументів = прочитати_аргумент_вказівки(вказівки, позиція::адреса);

        змінна іменовано_задіяні: адреса<ІменованіЗадіяні> = пусто;
        змінна п: п32 = 0;

        якщо кількість_іменованих_аргументів > 0 {
          іменовано_задіяні = створити_іменовано_задіяні(М);
          
          поки п < кількість_іменованих_аргументів {
            змінна значення = забрати_з_накопичувача_значень(М);
            змінна назва = забрати_з_накопичувача_значень(М);
  
            покласти_іменовано_задіяне(М, назва, значення);
          }
        }

        змінна дані_аргументів = виділити_памʼять<Значення>(М, природне(кількість_аргументів));

        п = 0;
        поки п < кількість_аргументів {
          дані_аргументів[кількість_аргументів - п - 1] = забрати_з_накопичувача_значень(М);
        }

        змінна назва = забрати_з_накопичувача_значень(М);
        змінна предмет = забрати_з_накопичувача_значень(М);

        змінна результат = здійснити_властивість(
          М, 
          предмет, 
          назва, 
          природне(кількість_аргументів), 
          дані_аргументів, 
          іменовано_задіяні
        );
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВОтриматиЕлемент {
        змінна ключ = забрати_з_накопичувача_значень(М);
        змінна предмет = забрати_з_накопичувача_значень(М);

        змінна значення = отримати_елемент(М, предмет, ключ);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, значення);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗмінитиЕлемент {
        змінна значення = забрати_з_накопичувача_значень(М);
        змінна ключ = забрати_з_накопичувача_значень(М);
        змінна предмет = забрати_з_накопичувача_значень(М);
        
        змінити_елемент(М, предмет, ключ, значення);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВОтриматиПеребір {
        змінна значення = забрати_з_накопичувача_значень(М);

        змінна результат = отримати_перебір(М, значення);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);

        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗдійснитиЗПредка {
        запанікувати(М, "Здійснення з предка не втілено.");
      }

      якщо вказівка == ВДодати {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_додавання(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВВідняти {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_відімання(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВПомножити {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_множення(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПоділити {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_ділення(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВОтриматиОстачуДілення {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_остача(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВОтриматиНеповнуЧасткуДілення {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_неповна_частка(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВПіднестиДоСтепеня {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_степінь(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВЗсунутиВліво {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_вліво(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВЗсунутиВправо {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_вправо(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВЗсунутиВправоЗіЗаповненням {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_вправо_2(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВДвійковеІ {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_двійкове_і(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВДвійковеАБО {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_двійкове_або(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВДвійковеВиключнеАБО {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_двійкове_вабо(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВМенше {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_менше(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВБільше {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_більше(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВНеБільше {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_не_більше(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВНеМенше {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_не_менше(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВРівно {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_рівно(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВНеРівно {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_не_рівно(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВМістить {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_містить(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВНеМістить {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_не_містить(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВЄ {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_є(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВНеЄ {
        змінна б = забрати_з_накопичувача_значень(М);
        змінна а = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_не_є(М, а, б);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;      
      }
      
      якщо вказівка == ВДвійковеНЕ {
        змінна значення = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_двійкове_не(М, значення);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВВідʼємне {
        змінна значення = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_відʼємне(М, значення);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВЧислове {
        змінна значення = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_числове(М, значення);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВЗаперечити {
        змінна значення = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_заперечення(М, значення);
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
        
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВПочатиСпробу {
        змінна назва_зловити = забрати_з_накопичувача_значень(М);

        змінна позиція_вказівки_зловити = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));
        
        покласти_спробу(М, дійсність.спроби::адреса, Спроба {
          назва_зловити = назва_зловити,
          позиція_вказівки_зловити = позиція_вказівки_зловити,
          розмір_історії_здійснення = М.історія_здійснення.розмір,
          розмір_накопичувача_значень = М.накопичувач_значень.розмір
        });
  
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВВпасти {
        змінна значення_помилки = забрати_з_накопичувача_значень(М);

        увімкнути_стан_падіння(
          М, 
          значення_помилки, 
          Місцезнаходження { код, позиція_поточної_вказівки }
        );
        
        якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
          стрибнути крок_виконання_вказівки;
        }
  
        стрибнути крок_вихід;
      }
  
      якщо вказівка == ВЗакінчитиСпробу {
        змінна позиція_вказівки_виходу = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        видалити_останню_спробу(М, дійсність.спроби::адреса);
        
        позиція = позиція_вказівки_виходу;
  
        стрибнути крок_виконання_вказівки;
      }

      якщо вказівка == ВВзяти {
        змінна кількість_назв = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        змінна дані_назв: памʼять<адреса<Дійсне>> = пусто;

        якщо кількість_назв > 0 {
          дані_назв = виділити_памʼять<адреса<Дійсне>>(М, кількість_назв);
          
          змінна п: природне = 0;
          
          поки п < кількість_назв {
            змінна назва = забрати_з_накопичувача_значень(М);
          
            дані_назв[кількість_назв - п - 1] = назва;
          
            п += 1;
          }
        }

        змінна назва = забрати_з_накопичувача_значень(М);

        змінна результат = виконати_взяти(
          М, 
          дійсність, 
          назва, 
          кількість_назв, 
          дані_назв
        );
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }

        покласти_в_накопичувач_значень(М, результат);
  
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВДати {
        змінна назва = забрати_з_накопичувача_значень(М);
        змінна значення = забрати_з_накопичувача_значень(М);

        якщо дійсність.значення_модуля == пусто {
          увімкнути_стан_падіння(
            М, 
            створити_текст(М, "Неможливо дати."), 
            Місцезнаходження { код, позиція_поточної_вказівки }
          );

          якщо М.стан_падіння {
            якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
              стрибнути крок_виконання_вказівки;
            }
  
            стрибнути крок_вихід;
          }
        }
        
        змінити_властивість(
          М,
          дійсність.значення_модуля,
          назва,
          значення,
        );
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }
  
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВПеребратиДалі {
        змінна значення_перебору = забрати_з_накопичувача_значень(М);

        покласти_в_накопичувач_значень(М, значення_перебору);
        
        змінна результат = здійснити_властивість(
          М,
          значення_перебору,
          створити_текст(М, "далі"),
          0,
          пусто,
          пусто
        );
        
        якщо М.стан_падіння {
          якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
            стрибнути крок_виконання_вказівки;
          }

          стрибнути крок_вихід;
        }
        
        покласти_в_накопичувач_значень(М, результат);
  
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВЗбитиТекст {
        змінна кількість_предметів = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));
        
        змінна накопичувач_тексту = зробити_накопичувач_тексту(М, 0);
        
        змінна п: природне = 0;
        
        поки п < кількість_предметів {
          змінна значення = взяти_з_накопичувача_значень(М, п);

          змінна предмет_як_текст = отримати_текстове_зображення_значення(
            М, 
            значення
          );
        
          якщо М.стан_падіння {
            звільнити_памʼять(М, накопичувач_тексту.дані);

            якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
              стрибнути крок_виконання_вказівки;
            }
  
            стрибнути крок_вихід;
          }
        
          якщо предмет_як_текст.тип != М.значення_структура_Текст {
            увімкнути_стан_падіння(
              М, 
              створити_текст(М, "Не вдалось перетворити на текст."), 
              Місцезнаходження { код, позиція_поточної_вказівки }
            );

            звільнити_памʼять(М, накопичувач_тексту.дані);
           
            якщо обробити_стан_падіння(М, дійсність, код, позиція_поточної_вказівки, позиція::адреса) {
              стрибнути крок_виконання_вказівки;
            }
  
            стрибнути крок_вихід;
          }

          змінна предмет_тексту = предмет_як_текст як адреса<Предмет>;
          змінна властивості_тексту = предмет_тексту.властивості як ВластивостіТексту;

          покласти_в_накопичувач_тексту(М, накопичувач_тексту::адреса, властивості_тексту.значення);
        
          п += 1;
        }

        видалити_з_накопичувача_значень(М, кількість_предметів);
                
        покласти_в_накопичувач_значень(
          М, 
          створити_текст_без_копіювання(М, накопичувач_тексту.розмір, накопичувач_тексту.дані)
        );
          
        стрибнути крок_виконати_далі;
      }
      
      якщо вказівка == ВСтрибнути {
        змінна позиція_вказівки_стрибка = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        позиція = позиція_вказівки_стрибка;
  
        стрибнути крок_виконання_вказівки;
      }
  
      якщо вказівка == ВСтрибнутиЯкщоТак {
        змінна значення = забрати_з_накопичувача_значень(М);

        змінна позиція_вказівки_стрибка = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        якщо значення != пусто {
          позиція = позиція_вказівки_стрибка;

          стрибнути крок_виконання_вказівки;
        }
  
        стрибнути крок_виконати_далі;
      }
  
      якщо вказівка == ВСтрибнутиЯкщоНі {
        змінна значення = забрати_з_накопичувача_значень(М);

        змінна позиція_вказівки_стрибка = природне(прочитати_аргумент_вказівки(вказівки, позиція::адреса));

        якщо значення == пусто {
          позиція = позиція_вказівки_стрибка;

          стрибнути крок_виконання_вказівки;
        }
  
        стрибнути крок_виконати_далі;
      }
  
      якщо вказівка == ВЗабрати {
        видалити_з_накопичувача_значень(М, 1);
  
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВДублювати {
        змінна значення = забрати_з_накопичувача_значень(М);

        покласти_в_накопичувач_значень(М, значення);
        покласти_в_накопичувач_значень(М, значення);
  
        стрибнути крок_виконати_далі;
      }

      якщо вказівка == ВВернути {
        результат = забрати_з_накопичувача_значень(М);
        
        стрибнути крок_вихід;
      }
      
  крок_виконати_далі:
      позиція += 1;
    }
  
  крок_вихід:
    вернути результат;
  }

  місцева дія здійснити(М: адреса<Машина>,
                        здійснювач: Значення,
                        значення: Значення,
                        кількість_задіяних: природне, 
                        задіяні: памʼять<Значення>,
                        іменовано_задіяні: адреса<ІменованіЗадіяні>) -> Значення {
    якщо значення.тип == М.значення_структура_Дія {
      змінна предмет_дії = значення як адреса<Предмет>;
      змінна властивості_дії = предмет_дії.властивості як ВластивостіДії;

      якщо властивості_дії.рідна {
        змінна рідна_дія = властивості_дії.код як РіднаДія;

        вернути рідна_дія(
          М,
          здійснювач,
          значення,
          кількість_задіяних,
          задіяні,
          іменовано_задіяні
        );
      } інакше {        
        змінна дійсність = створити_дійсність(
          М, 
          властивості_дії.дійсність_створення,
          здійснювач
        );

        вернути виконати_код(
          М,
          дійсність,
          властивості_дії.код як Значення
        );
      }
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати дію можна лише над діями.");

      вернути пусто;
    }                         
  }

  місцева дія виконати_додавання(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати додавання можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Число і право.тип == М.значення_структура_Число {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЧисла;
      змінна властивості_право = право_предмет.властивості як ВластивостіЧисла;

      вернути створити_число(М, властивості_ліво.значення + властивості_право.значення);
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати додавання можна лише між числами.");

      вернути пусто;
    }
  }

  місцева дія виконати_відімання(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати віднімання можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Число і право.тип == М.значення_структура_Число {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЧисла;
      змінна властивості_право = право_предмет.властивості як ВластивостіЧисла;

      вернути створити_число(М, властивості_ліво.значення - властивості_право.значення);
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати віднімання можна лише між числами.");

      вернути пусто;
    }
  }

  місцева дія виконати_множення(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати множення можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Число і право.тип == М.значення_структура_Число {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЧисла;
      змінна властивості_право = право_предмет.властивості як ВластивостіЧисла;

      вернути створити_число(М, властивості_ліво.значення * властивості_право.значення);
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати множення можна лише між числами.");

      вернути пусто;
    }
  }

  місцева дія виконати_ділення(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати ділення можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Число і право.тип == М.значення_структура_Число {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЧисла;
      змінна властивості_право = право_предмет.властивості як ВластивостіЧисла;

      вернути створити_число(М, властивості_ліво.значення / властивості_право.значення);
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати ділення можна лише між числами.");

      вернути пусто;
    }
  }

  місцева дія виконати_остача(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати отримання остачі можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Число і право.тип == М.значення_структура_Число {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЧисла;
      змінна властивості_право = право_предмет.властивості як ВластивостіЧисла;

      вернути створити_число(М, властивості_ліво.значення % властивості_право.значення);
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати отримання остачі можна лише між числами.");

      вернути пусто;
    }
  }

  місцева дія виконати_неповна_частка(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати отримання неповної частки можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Число і право.тип == М.значення_структура_Число {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЧисла;
      змінна властивості_право = право_предмет.властивості як ВластивостіЧисла;

      запанікувати(М, "потім: неповна частка");

      вернути створити_число(М, властивості_ліво.значення / властивості_право.значення);
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати отримання неповної частки можна лише між числами.");

      вернути пусто;
    }
  }

  місцева дія виконати_степінь(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати піднесення до степеня можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Число і право.тип == М.значення_структура_Число {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЧисла;
      змінна властивості_право = право_предмет.властивості як ВластивостіЧисла;

      запанікувати(М, "потім: піднесення до степеня");

      вернути створити_число(М, властивості_ліво.значення / властивості_право.значення);
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати піднесення до степеня можна лише між числами.");

      вернути пусто;
    }
  }

  місцева дія виконати_вліво(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати зсув вліво можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Число і право.тип == М.значення_структура_Число {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЧисла;
      змінна властивості_право = право_предмет.властивості як ВластивостіЧисла;

      вернути створити_число(М, д64(ц32(властивості_ліво.значення) << ц32(властивості_право.значення)));
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати зсув вліво можна лише між числами.");

      вернути пусто;
    }
  }

  місцева дія виконати_вправо(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати зсув вправо можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Число і право.тип == М.значення_структура_Число {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЧисла;
      змінна властивості_право = право_предмет.властивості як ВластивостіЧисла;

      вернути створити_число(М, д64(ц32(властивості_ліво.значення) >> ц32(властивості_право.значення)));
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати зсув вправо можна лише між числами.");

      вернути пусто;
    }
  }

  місцева дія виконати_вправо_2(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати зсув вправо 2 можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Число і право.тип == М.значення_структура_Число {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЧисла;
      змінна властивості_право = право_предмет.властивості як ВластивостіЧисла;

      вернути створити_число(М, д64(п32(властивості_ліво.значення) >> п32(властивості_право.значення)));
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати зсув вправо 2 можна лише між числами.");

      вернути пусто;
    }
  }

  місцева дія виконати_двійкове_і(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати двійкове І можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Число і право.тип == М.значення_структура_Число {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЧисла;
      змінна властивості_право = право_предмет.властивості як ВластивостіЧисла;

      вернути створити_число(М, д64(ц32(властивості_ліво.значення) & ц32(властивості_право.значення)));
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати двійкове І можна лише між числами.");

      вернути пусто;
    }
  }

  місцева дія виконати_двійкове_або(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати двійкове АБО можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Число і право.тип == М.значення_структура_Число {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЧисла;
      змінна властивості_право = право_предмет.властивості як ВластивостіЧисла;

      вернути створити_число(М, д64(ц32(властивості_ліво.значення) | ц32(властивості_право.значення)));
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати двійкове АБО можна лише між числами.");

      вернути пусто;
    }
  }

  місцева дія виконати_двійкове_вабо(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати двійкове ВАБО можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Число і право.тип == М.значення_структура_Число {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЧисла;
      змінна властивості_право = право_предмет.властивості як ВластивостіЧисла;

      вернути створити_число(М, д64(ц32(властивості_ліво.значення) вабо ц32(властивості_право.значення)));
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати двійкове ВАБО можна лише між числами.");

      вернути пусто;
    }
  }

  місцева дія виконати_менше(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати менше можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Число і право.тип == М.значення_структура_Число {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЧисла;
      змінна властивості_право = право_предмет.властивості як ВластивостіЧисла;

      якщо властивості_ліво.значення < властивості_право.значення {
        вернути М.значення_дійсне;
      } інакше {
        вернути пусто;
      }
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати менше можна лише між числами.");

      вернути пусто;
    }
  }

  місцева дія виконати_не_менше(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати не менше можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Число і право.тип == М.значення_структура_Число {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЧисла;
      змінна властивості_право = право_предмет.властивості як ВластивостіЧисла;

      якщо властивості_ліво.значення < властивості_право.значення {
        вернути пусто;
      } інакше {
        вернути М.значення_дійсне;
      }
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати не менше можна лише між числами.");

      вернути пусто;
    }
  }

  місцева дія виконати_більше(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати більше можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Число і право.тип == М.значення_структура_Число {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЧисла;
      змінна властивості_право = право_предмет.властивості як ВластивостіЧисла;

      якщо властивості_ліво.значення > властивості_право.значення {
        вернути М.значення_дійсне;
      } інакше {
        вернути пусто;
      }
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати більше можна лише між числами.");

      вернути пусто;
    }
  }

  місцева дія виконати_не_більше(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    якщо ліво == пусто або право == пусто {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати не більше можна лише між числами.");

      вернути пусто;
    }

    якщо ліво.тип == М.значення_структура_Число і право.тип == М.значення_структура_Число {
      змінна ліво_предмет = ліво як адреса<Предмет>;
      змінна право_предмет = право як адреса<Предмет>;

      змінна властивості_ліво = ліво_предмет.властивості як ВластивостіЧисла;
      змінна властивості_право = право_предмет.властивості як ВластивостіЧисла;

      якщо властивості_ліво.значення > властивості_право.значення {
        вернути пусто;
      } інакше {
        вернути М.значення_дійсне;
      }
    } інакше {
      М.стан_падіння = так;
      М.значення_падіння = створити_текст(М, "Виконати не більше можна лише між числами.");

      вернути пусто;
    }
  }

  місцева дія виконати_рівно(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    якщо перевірити_чи_значення_рівні(М, ліво, право) {
      вернути М.значення_дійсне;
    } інакше {
      вернути пусто;
    }
  }

  місцева дія виконати_не_рівно(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    якщо перевірити_чи_значення_рівні(М, ліво, право) {
      вернути пусто;
    } інакше {
      вернути М.значення_дійсне;
    }
  }

  місцева дія виконати_містить(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    вернути пусто;
  }

  місцева дія виконати_не_містить(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    вернути пусто;
  }

  місцева дія виконати_є(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    вернути пусто;
  }

  місцева дія виконати_не_є(М: адреса<Машина>, ліво: Значення, право: Значення) -> Значення {
    вернути пусто;
  }

  місцева дія виконати_двійкове_не(М: адреса<Машина>, значення: Значення) -> Значення {
    вернути пусто;
  }

  місцева дія виконати_відʼємне(М: адреса<Машина>, значення: Значення) -> Значення {
    вернути пусто;
  }

  місцева дія виконати_числове(М: адреса<Машина>, значення: Значення) -> Значення {
    вернути пусто;
  }

  місцева дія виконати_заперечення(М: адреса<Машина>, значення: Значення) -> Значення {
    вернути пусто;
  }

  місцева дія виконати_взяти(М: адреса<Машина>, дійсність: адреса<Дійсність>, звідки: Значення, довжина_шляху: природне, шлях: памʼять<Значення>) -> Значення {
    вернути пусто;
  }
}