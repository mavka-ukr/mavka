#include <math.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ФОчистити 0
#define ФКолірТекстуЧервоний 1
#define ФКолірТекстуЗелений 2
#define ФКолірТекстуСиній 3
#define ФКолірТекстуЖовтий 4

typedef bool логічне;
typedef uint8_t п8;
typedef uint16_t п16;
typedef uint32_t п32;
typedef uint64_t п64;
typedef int32_t ц32;
typedef int64_t ц64;
typedef double д64;
typedef size_t природне;

extern логічне пристрій_мавки_перекодувати_ю8_в_кд(
    природне розмір,
    п8* дані,
    природне* вихід_розміру,
    п8** вихід_даних,
    природне* вихід_позиції_помилки);
extern логічне пристрій_мавки_перекодувати_кд_в_ю8(
    природне розмір,
    п8* дані,
    природне* вихід_розміру,
    п8** вихід_даних,
    природне* вихід_позиції_помилки);

extern void пристрій_мавки_вивести_формат(природне значення) {
  if (значення == ФОчистити) {
    printf("\033[0m");
  }

  if (значення == ФКолірТекстуЧервоний) {
    printf("\033[0;31m");
  }

  if (значення == ФКолірТекстуЗелений) {
    printf("\033[0;32m");
  }

  if (значення == ФКолірТекстуСиній) {
    printf("\033[0;34m");
  }

  if (значення == ФКолірТекстуЖовтий) {
    printf("\033[0;33m");
  }
}

extern void пристрій_мавки_вивести_сирі_дані(природне розмір, п8* дані) {
  fwrite(дані, 1, розмір, stdout);
}

extern void пристрій_мавки_вивести_кд(природне розмір, п8* дані) {
  природне розмір_ю8;
  п8* дані_ю8;
  природне позиція_помилки;

  if (пристрій_мавки_перекодувати_кд_в_ю8(розмір, дані, &розмір_ю8, &дані_ю8,
                                          &позиція_помилки)) {
    for (size_t i = 0; i < розмір_ю8; i++) {
      putchar(дані_ю8[i]);
    }
    free(дані_ю8);
  } else {
    printf("помилка виводу кд\n");
  }
}

extern void пристрій_мавки_надрукувати_кд(природне розмір, п8* дані) {
  природне розмір_ю8;
  п8* дані_ю8;
  природне позиція_помилки;

  if (пристрій_мавки_перекодувати_кд_в_ю8(розмір, дані, &розмір_ю8, &дані_ю8,
                                          &позиція_помилки)) {
    for (size_t i = 0; i < розмір_ю8; i++) {
      putchar(дані_ю8[i]);
    }
    putchar('\n');
    free(дані_ю8);
  } else {
    printf("помилка друку кд\n");
  }
}

extern п8* пристрій_мавки_виділити_сиру_памʼять(природне розмір) {
  return (п8*)malloc(розмір);
}

extern п8* пристрій_мавки_перевиділити_сиру_памʼять(п8* значення,
                                                    природне новий_розмір) {
  return (п8*)realloc(значення, новий_розмір);
}

extern void пристрій_мавки_звільнити_сиру_памʼять(п8* значення) {
  free(значення);
}

extern void пристрій_мавки_вийти(ц32 код_виходу) {
  exit(код_виходу);
}

extern логічне пристрій_мавки_прочитати_файл(природне розмір_шляху,
                                             п8* дані_шляху,
                                             природне* вихід_розміру,
                                             п8** вихід_даних) {
  char* шлях_рядок = (char*)malloc(розмір_шляху + 1);
  for (природне і = 0; і < розмір_шляху; і++) {
    шлях_рядок[і] = (char)дані_шляху[і];
  }
  шлях_рядок[розмір_шляху] = '\0';

  FILE* файл = fopen(шлях_рядок, "rb");
  free(шлях_рядок);
  if (!файл) {
    return false;
  }

  fseek(файл, 0, SEEK_END);
  *вихід_розміру = ftell(файл);
  fseek(файл, 0, SEEK_SET);

  *вихід_даних = (п8*)malloc(*вихід_розміру);
  if (!*вихід_даних) {
    fclose(файл);
    return false;
  }

  fread(*вихід_даних, 1, *вихід_розміру, файл);
  fclose(файл);
  return true;
}

логічне перетворити_п64_в_ю8(п64 значення,
                             природне* вихід_розміру,
                             п8** вихід_даних) {
  char буфер[32];
  int довжина =
      snprintf(буфер, sizeof(буфер), "%llu", (unsigned long long)значення);
  if (довжина < 0) {
    return false;
  }
  *вихід_розміру = (природне)довжина;
  *вихід_даних = (п8*)malloc(*вихід_розміру);
  if (!*вихід_даних) {
    return false;
  }
  for (природне і = 0; і < *вихід_розміру; і++) {
    (*вихід_даних)[і] = (п8)буфер[і];
  }
  return true;
}

логічне перетворити_ц64_в_ю8(ц64 значення,
                             природне* вихід_розміру,
                             п8** вихід_даних) {
  char буфер[32];
  int довжина = snprintf(буфер, sizeof(буфер), "%lld", (long long)значення);
  if (довжина < 0) {
    return false;
  }
  *вихід_розміру = (природне)довжина;
  *вихід_даних = (п8*)malloc(*вихід_розміру);
  if (!*вихід_даних) {
    return false;
  }
  for (природне і = 0; і < *вихід_розміру; і++) {
    (*вихід_даних)[і] = (п8)буфер[і];
  }
  return true;
}

логічне перетворити_д64_в_ю8(д64 значення,
                             природне* вихід_розміру,
                             п8** вихід_даних) {
  char буфер[32];
  int довжина = snprintf(буфер, sizeof(буфер), "%lf", значення);
  if (довжина < 0) {
    return false;
  }
  *вихід_розміру = (природне)довжина;
  *вихід_даних = (п8*)malloc(*вихід_розміру);
  if (!*вихід_даних) {
    return false;
  }
  for (природне і = 0; і < *вихід_розміру; і++) {
    (*вихід_даних)[і] = (п8)буфер[і];
  }
  return true;
}

extern логічне пристрій_мавки_перетворити_п64_в_кд(п64 значення,
                                                   природне* вихід_розміру,
                                                   п8** вихід_даних) {
  природне розмір_ю8;
  п8* дані_ю8;
  природне позиція_помилки;

  if (перетворити_п64_в_ю8(значення, &розмір_ю8, &дані_ю8)) {
    if (пристрій_мавки_перекодувати_ю8_в_кд(розмір_ю8, дані_ю8, вихід_розміру,
                                            вихід_даних, &позиція_помилки)) {
      free(дані_ю8);

      return true;
    }

    free(дані_ю8);
  }

  return false;
}

extern логічне пристрій_мавки_перетворити_ц64_в_кд(ц64 значення,
                                                   природне* вихід_розміру,
                                                   п8** вихід_даних) {
  природне розмір_ю8;
  п8* дані_ю8;
  природне позиція_помилки;

  if (перетворити_ц64_в_ю8(значення, &розмір_ю8, &дані_ю8)) {
    if (пристрій_мавки_перекодувати_ю8_в_кд(розмір_ю8, дані_ю8, вихід_розміру,
                                            вихід_даних, &позиція_помилки)) {
      free(дані_ю8);

      return true;
    }

    free(дані_ю8);
  }

  return false;
}

extern логічне пристрій_мавки_перетворити_д64_в_кд(д64 значення,
                                                   природне* вихід_розміру,
                                                   п8** вихід_даних) {
  природне розмір_ю8;
  п8* дані_ю8;
  природне позиція_помилки;

  if (перетворити_д64_в_ю8(значення, &розмір_ю8, &дані_ю8)) {
    if (пристрій_мавки_перекодувати_ю8_в_кд(розмір_ю8, дані_ю8, вихід_розміру,
                                            вихід_даних, &позиція_помилки)) {
      free(дані_ю8);

      return true;
    }

    free(дані_ю8);
  }

  return false;
}

extern п64 пристрій_мавки_піднести_до_степеня_п64(п64 значення, п64 степінь) {
  п64 результат = 1;
  for (п64 і = 0; і < степінь; і++) {
    результат *= значення;
  }
  return результат;
}

extern ц64 пристрій_мавки_піднести_до_степеня_ц64(ц64 значення, ц64 степінь) {
  ц64 результат = 1;
  for (ц64 і = 0; і < степінь; і++) {
    результат *= значення;
  }
  return результат;
}

extern д64 пристрій_мавки_піднести_до_степеня_д64(д64 значення, д64 степінь) {
  double результат = 1.0;
  for (double і = 0; і < степінь; і++) {
    результат *= значення;
  }
  return результат;
}

extern логічне пристрій_мавки_перевірити_чи_шлях_існує_і_є_файлом(
    природне розмір_шляху,
    п8* дані_шляху) {}

extern логічне пристрій_мавки_перевірити_чи_шлях_закінчується_як_модуль_мавки(
    природне розмір_шляху,
    п8* дані_шляху) {}

extern логічне пристрій_мавки_отримати_абсолютний_шлях(природне розмір_шляху,
                                                       п8* дані_шляху,
                                                       природне* вихід_розміру,
                                                       п8** вихід_даних) {}

extern логічне пристрій_мавки_отримати_теку_шляху(природне розмір_шляху,
                                                  п8* дані_шляху,
                                                  природне* вихід_розміру,
                                                  п8** вихід_даних,
                                                  природне рівень) {}

extern логічне пристрій_мавки_отримати_теку_до_паків(природне розмір_шляху,
                                                     п8* дані_шляху,
                                                     природне* вихід_розміру,
                                                     п8** вихід_даних) {}

extern логічне пристрій_мавки_отримати_назву_модуля_з_шляху(
    природне розмір_шляху,
    п8* дані_шляху,
    природне* вихід_розміру,
    п8** вихід_даних) {}