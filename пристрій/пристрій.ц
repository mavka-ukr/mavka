взяти означення пристрій_мавки;

дія КД_виділити_сиру_памʼять(система: адреса<КД::Система>, розмір: природне) -> памʼять<п8> {
  вернути пристрій_мавки_виділити_сиру_памʼять(розмір);
}

дія КД_перевиділити_сиру_памʼять(система: адреса<КД::Система>, значення: памʼять<п8>, новий_розмір: природне) -> памʼять<п8> {
  вернути пристрій_мавки_перевиділити_сиру_памʼять(значення, новий_розмір);
}

дія КД_звільнити_сиру_памʼять(система: адреса<КД::Система>, значення: невідома_памʼять) {
  пристрій_мавки_звільнити_сиру_памʼять(значення як памʼять<п8>);
}

зовнішня дія пристрій_мавки_перекодувати_ю8_в_кд(розмір: природне, дані: памʼять<п8>, вихід_розміру: адреса<природне>, вихід_даних: адреса<памʼять<п8>>, вихід_позиції_помилки: адреса<природне>) -> логічне {
  змінна система_КД = КД::Система {
    дані = пусто,
    виділити_сиру_памʼять = КД_виділити_сиру_памʼять,
    звільнити_сиру_памʼять = КД_звільнити_сиру_памʼять,
    перевиділити_сиру_памʼять = КД_перевиділити_сиру_памʼять
  };
  
  змінна вихід: кд;
  змінна позиція_помилки: природне;
  
  змінна успіх = КД::перекодувати_з_ю8(
    система_КД::адреса,
    ю8 { розмір, дані },
    ні,
    ні,
    вихід::адреса,
    позиція_помилки::адреса
  );
  
  якщо успіх {
    вихід_розміру::вміст = вихід.розмір;
    вихід_даних::вміст = вихід.дані;
  }

  вернути успіх;
}

зовнішня дія пристрій_мавки_перекодувати_кд_в_ю8(розмір: природне, дані: памʼять<п8>, вихід_розміру: адреса<природне>, вихід_даних: адреса<памʼять<п8>>, вихід_позиції_помилки: адреса<природне>) -> логічне {
  змінна система_КД = КД::Система {
    дані = пусто,
    виділити_сиру_памʼять = КД_виділити_сиру_памʼять,
    звільнити_сиру_памʼять = КД_звільнити_сиру_памʼять,
    перевиділити_сиру_памʼять = КД_перевиділити_сиру_памʼять
  };
  
  змінна вихід: ю8;
  змінна позиція_помилки: природне;
  
  змінна успіх = КД::перекодувати_в_ю8(
    система_КД::адреса,
    кд { розмір, дані },
    ні,
    вихід::адреса,
    позиція_помилки::адреса
  );
  
  якщо успіх {
    вихід_розміру::вміст = вихід.розмір;
    вихід_даних::вміст = вихід.дані;
  }

  вернути успіх;
}

простір мавка {
  простір пристрій {
    дія машина_виділити_сиру_памʼять(
      М: адреса<Машина>,
      розмір: природне
    ) -> памʼять<п8> {
      вернути пристрій_мавки_виділити_сиру_памʼять(розмір);
    }
    
    дія машина_перевиділити_сиру_памʼять(
      М: адреса<Машина>,
      значення: памʼять<п8>,
      новий_розмір: природне
    ) -> памʼять<п8> {
      вернути пристрій_мавки_перевиділити_сиру_памʼять(значення, новий_розмір);
    }
    
    дія машина_звільнити_сиру_памʼять(
      М: адреса<Машина>,
      значення: памʼять<п8>
    ) {
      пристрій_мавки_звільнити_сиру_памʼять(значення);
    }
    
    дія машина_запанікувати(
      М: адреса<Машина>,
      повідомлення: кд
    ) {
      надрукувати_кд(М, повідомлення);
    
      пристрій_мавки_вийти(1);
    }
    
    дія машина_вивести_кд(
      М: адреса<Машина>,
      значення: кд
    ) {
      пристрій_мавки_вивести_кд(значення.розмір, значення.дані);
    }
    
    дія машина_надрукувати(
      М: адреса<Машина>,
      значення: кд
    ) {
      пристрій_мавки_надрукувати_кд(значення.розмір, значення.дані);
    }
    
    дія машина_перетворити_п64_в_кд(
      М: адреса<Машина>,
      значення: п64,
      вихід_текстового_значення: адреса<кд>
    ) -> логічне {
      змінна значення_кд: кд;
    
      якщо пристрій_мавки_перетворити_п64_в_кд(значення, значення_кд.розмір::адреса, значення_кд.дані::адреса) {
        вихід_текстового_значення.розмір = значення_кд.розмір;
        вихід_текстового_значення.дані = значення_кд.дані;
        
        вернути так;
      }
    
      вернути ні;
    }
    
    дія машина_перетворити_ц64_в_кд(
      М: адреса<Машина>,
      значення: ц64,
      вихід_текстового_значення: адреса<кд>
    ) -> логічне {
      змінна значення_кд: кд;
    
      якщо пристрій_мавки_перетворити_ц64_в_кд(значення, значення_кд.розмір::адреса, значення_кд.дані::адреса) {
        вихід_текстового_значення.розмір = значення_кд.розмір;
        вихід_текстового_значення.дані = значення_кд.дані;
        
        вернути так; 
      }
    
      вернути ні;
    }
    
    дія машина_перетворити_д64_в_кд(
      М: адреса<Машина>,
      значення: д64,
      вихід_текстового_значення: адреса<кд>
    ) -> логічне {
      змінна значення_кд: кд;

      якщо пристрій_мавки_перетворити_д64_в_кд(значення, значення_кд.розмір::адреса, значення_кд.дані::адреса) {
        вихід_текстового_значення.розмір = значення_кд.розмір;
        вихід_текстового_значення.дані = значення_кд.дані;
        
        вернути так;
      }
    
      вернути ні;
    }
    
    дія машина_піднести_до_степеня_п64(
      М: адреса<Машина>,
      значення: п64,
      степінь: п64
    ) -> п64 {
      вернути пристрій_мавки_піднести_до_степеня_п64(значення, степінь);
    }
    
    дія машина_піднести_до_степеня_ц64(
      М: адреса<Машина>,
      значення: ц64,
      степінь: ц64
    ) -> ц64 {
      вернути пристрій_мавки_піднести_до_степеня_ц64(значення, степінь);
    }
    
    дія машина_піднести_до_степеня_д64(
      М: адреса<Машина>,
      значення: д64,
      степінь: д64
    ) -> д64 {
      вернути пристрій_мавки_піднести_до_степеня_д64(значення, степінь);
    }
    
    дія машина_взяти_модуль(
      М: адреса<Машина>,
      шлях_до_файлу_поточного_модуля: адреса<ПредметДаних>,
      відносно: логічне,
      довжина_шляху: природне,
      шлях: памʼять<адреса<ПредметТексту>>,
      місцезнаходження: Місцезнаходження
    ) -> ЗначенняАбоСтанПадіння {
      змінна успіх: логічне = ні;
      змінна розмір_шляху_до_теки_поточного_модуля: природне = 0;
      змінна дані_шляху_до_теки_поточного_модуля: памʼять<п8> = пусто;
      змінна кдпм = М.користувацькі_дані.значення як адреса<КористувацькіДаніПристроюМавки>;
      змінна шлях_до_теки_модулів = кдпм.шлях_до_теки_модулів.значення як адреса<ПредметДаних>;
      змінна предмет_шляху: адреса<ПредметДаних> = пусто;
      змінна розмір_елементів_збиття: природне = довжина_шляху + 1;
      змінна елементи_збиття = виділити_памʼять<ЕлементШляхуПристроюМавки>(М, розмір_елементів_збиття);
      змінна позиція_елементів_збиття: природне = 0;
      змінна п: природне = 0;
      змінна значення_ю8: ю8 = ю8 { 0, пусто };
      змінна позиція_помилки: природне = 0;
      змінна розмір_збитого_шляху: природне = 0;
      змінна дані_збитого_шляху: памʼять<п8> = пусто;
      змінна треба_звільнити_перший_елемент: логічне = ні;

      // потім: перевірити чи з паків

      якщо відносно {
        успіх = пристрій_мавки_отримати_теку_шляху(
          шлях_до_файлу_поточного_модуля.розмір,
          шлях_до_файлу_поточного_модуля.дані,
          розмір_шляху_до_теки_поточного_модуля::адреса,
          дані_шляху_до_теки_поточного_модуля::адреса,
          1
        );

        якщо не успіх {
          увімкнути_стан_падіння(
            М,
            створити_текст(М, "Не вдалося отримати теку шляху поточного модуля.") як Значення,
            місцезнаходження
          );
          звільнити_памʼять(М, елементи_збиття);
          звільнити_памʼять(М, шлях);
          вернути пусто;
        }
        
        елементи_збиття[позиція_елементів_збиття] = ЕлементШляхуПристроюМавки {
          розмір_шляху_до_теки_поточного_модуля,
          дані_шляху_до_теки_поточного_модуля
        };

        треба_звільнити_перший_елемент = так;

        позиція_елементів_збиття += 1;
      } інакше {
        елементи_збиття[позиція_елементів_збиття] = ЕлементШляхуПристроюМавки {
          шлях_до_теки_модулів.розмір,
          шлях_до_теки_модулів.дані
        };

        позиція_елементів_збиття += 1;
      }

      поки п < довжина_шляху {
        успіх = перекодувати_кд_в_ю8(
          М,
          шлях[п].значення,
          значення_ю8::адреса,
          позиція_помилки::адреса
        );

        якщо не успіх {
          увімкнути_стан_падіння(
            М,
            створити_текст(М, "Не вдалося перекодувати елемент шляху модуля в ю8.") як Значення,
            місцезнаходження
          );
          якщо треба_звільнити_перший_елемент {
            п = 0;
          } інакше {
            п = 1;
          }
          поки п < позиція_елементів_збиття {
            звільнити_памʼять(М, елементи_збиття[п].дані);
            
            п += 1;
          }
          звільнити_памʼять(М, елементи_збиття);
          звільнити_памʼять(М, шлях);
          вернути пусто;
        }

        елементи_збиття[позиція_елементів_збиття] = ЕлементШляхуПристроюМавки {
          значення_ю8.розмір,
          значення_ю8.дані
        };

        позиція_елементів_збиття += 1;

        п += 1;
      }

      успіх = пристрій_мавки_збити_шлях_до_модуля(
        розмір_елементів_збиття,
        елементи_збиття,
        розмір_збитого_шляху::адреса,
        дані_збитого_шляху::адреса
      );

      якщо не успіх {
        увімкнути_стан_падіння(
          М,
          створити_текст(М, "Не вдалося збити шлях до модуля.") як Значення,
          місцезнаходження
        );
        якщо треба_звільнити_перший_елемент {
          п = 0;
        } інакше {
          п = 1;
        }
        поки п < розмір_елементів_збиття {
          звільнити_памʼять(М, елементи_збиття[п].дані);
          
          п += 1;
        }
        звільнити_памʼять(М, елементи_збиття);
        звільнити_памʼять(М, шлях);
        вернути пусто;
      }

      предмет_шляху = створити_дані(
        М,
        розмір_збитого_шляху,
        дані_збитого_шляху
      );

      якщо треба_звільнити_перший_елемент {
        п = 0;
      } інакше {
        п = 1;
      }
      поки п < розмір_елементів_збиття {
        звільнити_памʼять(М, елементи_збиття[п].дані);

        п += 1;
      }
      звільнити_памʼять(М, елементи_збиття);
    
      змінна результат = взяти_файл(
        М,
        предмет_шляху,
        шлях[довжина_шляху - 1],
        місцезнаходження
      );

      звільнити_памʼять(М, шлях);

      вернути результат;
    }
    
    дія машина_взяти_пак(
      М: адреса<Машина>,
      довжина_шляху: природне,
      шлях: памʼять<адреса<ПредметТексту>>,
      місцезнаходження: Місцезнаходження
    ) -> ЗначенняАбоСтанПадіння {
      звільнити_памʼять(М, шлях);
    
      вернути пусто;
    }

    дія дія_перед_знищенням_користувацьких_даних_пристрою_мавки(
      М: адреса<Машина>,
      користувацькі_дані: адреса<КористувацькіДані>
    ) {
      змінна кдпм = користувацькі_дані.значення як адреса<КористувацькіДаніПристроюМавки>;
      
      // ...
    }

    місцева дія створити_машину() -> адреса<Машина> {
      змінна М = пристрій_мавки_виділити_сиру_памʼять(Машина.розмір) як адреса<Машина>;
      
      налаштувати_машину(М, Налаштування {
        виділити_сиру_памʼять = машина_виділити_сиру_памʼять,
        перевиділити_сиру_памʼять = машина_перевиділити_сиру_памʼять,
        звільнити_сиру_памʼять = машина_звільнити_сиру_памʼять,
        запанікувати = машина_запанікувати,
        вивести_кд = машина_вивести_кд,
        перетворити_п64_в_кд = машина_перетворити_п64_в_кд,
        перетворити_ц64_в_кд = машина_перетворити_ц64_в_кд,
        перетворити_д64_в_кд = машина_перетворити_д64_в_кд,
        піднести_до_степеня_п64 = машина_піднести_до_степеня_п64,
        піднести_до_степеня_ц64 = машина_піднести_до_степеня_ц64,
        піднести_до_степеня_д64 = машина_піднести_до_степеня_д64,
        взяти_модуль = машина_взяти_модуль,
        взяти_пак = машина_взяти_пак,
      });

      змінна кдпм = виділити<КористувацькіДаніПристроюМавки>(М);
      кдпм.шлях_до_теки_модулів = пусто;
      кдпм.шлях_до_теки_паків = пусто;

      М.користувацькі_дані = створити_користувацькі_дані(
        М,
        кдпм,
        дія_перед_знищенням_користувацьких_даних_пристрою_мавки
      );

      вернути М;
    }

    місцева дія розібрати_шлях_початкового_модуля(
      М: адреса<Машина>,
      шлях: адреса<ПредметДаних>,
      вихід_абсолютного_шляху: адреса<адреса<ПредметДаних>>,
      вихід_теки_модулів: адреса<адреса<ПредметДаних>>,
      вихід_теки_паків: адреса<адреса<ПредметДаних>>,
      вихід_назви_модуля: адреса<адреса<ПредметТексту>>
    ) -> логічне {
      змінна розмір_абсолютого_шляху: природне;
      змінна дані_абсолютного_шляху: памʼять<п8>;
      змінна розмір_теки_модулів: природне;
      змінна дані_теки_модулів: памʼять<п8>;
      змінна розмір_теки_паків: природне;
      змінна дані_теки_паків: памʼять<п8>;
      змінна розмір_назви_модуля: природне;
      змінна дані_назви_модуля: памʼять<п8>;

      якщо не пристрій_мавки_перевірити_чи_шлях_існує_і_є_файлом(
        шлях.розмір,
        шлях.дані
      ) {
        вернути ні;
      }

      якщо не пристрій_мавки_перевірити_чи_шлях_закінчується_як_модуль_мавки(
        шлях.розмір,
        шлях.дані
      ) {
        вернути ні;
      }

      якщо не пристрій_мавки_отримати_абсолютний_шлях(
        шлях.розмір,
        шлях.дані,
        розмір_абсолютого_шляху::адреса,
        дані_абсолютного_шляху::адреса
      ) {
        вернути ні;
      }

      якщо не пристрій_мавки_отримати_теку_шляху(
        розмір_абсолютого_шляху,
        дані_абсолютного_шляху,
        розмір_теки_модулів::адреса,
        дані_теки_модулів::адреса,
        1
      ) {
        пристрій_мавки_звільнити_сиру_памʼять(дані_абсолютного_шляху);
        вернути ні;
      }

      якщо не пристрій_мавки_отримати_теку_до_паків(
        розмір_теки_модулів,
        дані_теки_модулів,
        розмір_теки_паків::адреса,
        дані_теки_паків::адреса
      ) {
        пристрій_мавки_звільнити_сиру_памʼять(дані_абсолютного_шляху);
        пристрій_мавки_звільнити_сиру_памʼять(дані_теки_модулів);
        вернути ні;
      }

      якщо не пристрій_мавки_отримати_назву_модуля_з_шляху(
        розмір_абсолютого_шляху,
        дані_абсолютного_шляху,
        розмір_назви_модуля::адреса,
        дані_назви_модуля::адреса
      ) {
        пристрій_мавки_звільнити_сиру_памʼять(дані_абсолютного_шляху);
        пристрій_мавки_звільнити_сиру_памʼять(дані_теки_модулів);
        пристрій_мавки_звільнити_сиру_памʼять(дані_теки_паків);
        вернути ні;
      }

      вихід_абсолютного_шляху::вміст = створити_дані(
        М,
        розмір_абсолютого_шляху,
        дані_абсолютного_шляху
      );

      вихід_теки_модулів::вміст = створити_дані(
        М,
        розмір_теки_модулів,
        дані_теки_модулів
      );

      вихід_теки_паків::вміст = створити_дані(
        М,
        розмір_теки_паків,
        дані_теки_паків
      );

      вихід_назви_модуля::вміст = створити_текст(
        М,
        кд { розмір_назви_модуля, дані_назви_модуля }
      );

      вернути так;
    }

    місцева дія записати_шлях_до_теки_модулів_та_паків(
      М: адреса<Машина>,
      шлях_до_теки_модулів: адреса<ПредметДаних>,
      шлях_до_теки_паків: адреса<ПредметДаних>
    ) {
      змінна кдпм = М.користувацькі_дані.значення як адреса<КористувацькіДаніПристроюМавки>;
      якщо кдпм.шлях_до_теки_модулів != пусто {
        запанікувати(М, "Шлях до теки модулів вже встановлено.");
      }
      якщо кдпм.шлях_до_теки_паків != пусто {
        запанікувати(М, "Шлях до теки паків вже встановлено.");
      }
      кдпм.шлях_до_теки_модулів = притримати_в_користувацьких_даних(М, М.користувацькі_дані, шлях_до_теки_модулів як Значення);
      кдпм.шлях_до_теки_паків = притримати_в_користувацьких_даних(М, М.користувацькі_дані, шлях_до_теки_паків як Значення);
    }
    
    місцева дія взяти_файл(
      М: адреса<Машина>,
      шлях_до_файлу: адреса<ПредметДаних>,
      назва_модуля: адреса<ПредметТексту>,
      місцезнаходження: Місцезнаходження
    ) -> ЗначенняАбоСтанПадіння {
      змінна успіх: логічне = ні;
      змінна значення: Значення = пусто;
      змінна розмір_файлу: природне = 0;
      змінна дані_файлу: памʼять<п8> = пусто;
      змінна сирий_текст: кд = кд { 0, пусто };
      змінна слова: розбирач::Слова;
      змінна помилка_розбору_на_слова: розбирач::ПомилкаРозборуНаСлова;
      змінна сполуки: розбирач::Сполуки;
      змінна помилка_розбору_на_сполуки: розбирач::ПомилкаРозборуНаСполуки;
      змінна перекладений_код: адреса<ПредметКоду> = пусто;
      змінна помилка_перекладу: перекладач::ПомилкаПерекладу;
     
      якщо знайти_взяте_значення(М, шлях_до_файлу, значення::адреса) {
        вернути значення;
      }

      успіх = пристрій_мавки_прочитати_файл(
        шлях_до_файлу.розмір,
        шлях_до_файлу.дані,
        розмір_файлу::адреса,
        дані_файлу::адреса
      );

      якщо не успіх {
        увімкнути_стан_падіння(
          М,
          створити_текст(М, "Не вдалося прочитати файл.") як Значення,
          місцезнаходження
        );
        вернути пусто;
      }

      успіх = перекодувати_ю8_в_кд(
        М,
        ю8 { розмір_файлу, дані_файлу },
        сирий_текст::адреса,
        пусто
      );
    
      якщо не успіх {
        звільнити_памʼять(М, дані_файлу);
        увімкнути_стан_падіння(
          М,
          створити_текст(М, "Не вдалося перекодувати файл в код мавки.") як Значення,
          Місцезнаходження { шлях_до_файлу, 0 }
        );
        вернути пусто;
      }
      
      успіх = розбирач::розібрати_на_слова(
        М, 
        сирий_текст, 
        слова::адреса, 
        помилка_розбору_на_слова::адреса
      );
      
      якщо не успіх {
        змінна рядок = розбирач::отримати_рядок_помилки_розбору_на_слова(
          М,
          помилка_розбору_на_слова
        );
        увімкнути_стан_падіння(
          М,
          створити_текст(М, "Не вдалось розібрати.") як Значення,
          Місцезнаходження { шлях_до_файлу, рядок }
        );
        вернути пусто;
      }
    
      успіх = розбирач::розібрати_слова_на_сполуки(
        М,
        сирий_текст,
        слова,
        сполуки::адреса,
        помилка_розбору_на_сполуки::адреса
      );

      якщо не успіх {
        змінна рядок = розбирач::отримати_рядок_помилки_розбору_на_сполуки(
          М,
          помилка_розбору_на_сполуки
        );
        увімкнути_стан_падіння(
          М,
          створити_текст(М, "Не вдалось розібрати.") як Значення,
          Місцезнаходження { шлях_до_файлу, рядок }
        );
        вернути пусто;
      }
    
      успіх = перекласти_в_код(
        М,
        створити_дані(М, шлях_до_файлу.розмір, шлях_до_файлу.дані),
        сирий_текст,
        слова,
        сполуки,
        перекладений_код::адреса,
        помилка_перекладу::адреса
      );

      якщо не успіх {
        увімкнути_стан_падіння(
          М,
          створити_текст(М, "Не вдалось перекласти.") як Значення,
          місцезнаходження
        );
        вернути пусто;
      }

      змінна предмет_модуля = створити_модуль(
        М,
        назва_модуля
      );

      записати_взяте_значення(
        М,
        шлях_до_файлу,
        предмет_модуля як Значення 
      );
      
      змінна предмет_дії_модуля = створити_дію(
        М,
        М.глобальна_дійсність,
        назва_модуля,
        пусто,
        пусто,
        перекладений_код як адреса<ПредметКоду>,
        шлях_до_файлу
      );
    
      змінна результат = предмет_дії_здійснити(
        М,
        предмет_модуля як Значення,
        предмет_дії_модуля,
        0,
        пусто,
        пусто,
        місцезнаходження
      );

      якщо М.стан_падіння {
        видалити_взяте_значення(М, шлях_до_файлу);
      }

      вернути результат;
    }

    місцева дія надрукувати_інформацію_падіння(
      М: адреса<Машина>,
      інформація_падіння: ІнформаціяПадіння
    ) {
      пристрій_мавки_вивести_формат(ФКолірТекстуЧервоний);
      вивести_кд(М, "Помилка");
      пристрій_мавки_вивести_формат(ФОчистити);

      якщо інформація_падіння.місцезнаходження.шлях != пусто {
        вивести_кд(М, " в ");

        пристрій_мавки_вивести_шлях(інформація_падіння.місцезнаходження.шлях.розмір, інформація_падіння.місцезнаходження.шлях.дані);
  
        якщо інформація_падіння.місцезнаходження.рядок > 0 {
          вивести_кд(М, ":");
          вивести_п64(М, п64(інформація_падіння.місцезнаходження.рядок));
        }
        
        вивести_кд(М, "\р");
      }

      надрукувати_значення(М, інформація_падіння.значення, 2, 0);
  
      змінна п: природне = 0;
      
      якщо інформація_падіння.розмір_історії > 0 {
        надрукувати_кд(М, "\рІсторія здійснення:");
      }
  
      поки п < інформація_падіння.розмір_історії {
        змінна елемент_історії = інформація_падіння.історія[п];
        
        якщо елемент_історії.назва != пусто {
          вивести_кд(М, "  ");
          пристрій_мавки_вивести_формат(ФКолірТекстуСиній);
          вивести_кд(М, елемент_історії.назва.значення);
          пристрій_мавки_вивести_формат(ФОчистити);
        
          якщо елемент_історії.місцезнаходження.шлях == пусто {
            вивести_кд(М, "\р");
          } інакше {
            вивести_кд(М, " в ");
            пристрій_мавки_вивести_шлях(елемент_історії.місцезнаходження.шлях.розмір, елемент_історії.місцезнаходження.шлях.дані);
  
            якщо елемент_історії.місцезнаходження.рядок > 0 {
              вивести_кд(М, ":");
              вивести_п64(М, п64(елемент_історії.місцезнаходження.рядок));
            }
            
            вивести_кд(М, "\р");
          }
        }
        
        п += 1;
      }
    }

    дія вивести_пропуски(М: адреса<Машина>, кількість: природне) {
      змінна п: природне = 0;
      
      поки п < кількість {
        вивести_кд(М, " ");
      
        п += 1;
      }
    }
  
    // позначка: прохід по типах предметів
    місцева дія вивести_значення(М: адреса<Машина>, значення: Значення, розмір_відступу: природне, глибина: природне) {
      якщо значення == пусто {
        пристрій_мавки_вивести_формат(ФКолірТекстуЖовтий);
        
        вивести_кд(М, "недійсне");
        
        пристрій_мавки_вивести_формат(ФОчистити);
  
        вернути;
      }
      
      якщо значення == М.значення_дійсне {
        пристрій_мавки_вивести_формат(ФКолірТекстуЖовтий);
        
        вивести_кд(М, "дійсне");
  
        пристрій_мавки_вивести_формат(ФОчистити);
  
        вернути;
      }
      
      якщо значення == М.значення_послідовність {
        вивести_кд(М, "послідовність");
        вернути;
      }
      
      якщо значення == М.значення_дійсність {
        вивести_кд(М, "дійсність");
        вернути;
      }
      
      якщо значення == М.значення_предмет {
        вивести_кд(М, "предмет");
        вернути;
      }
  
      якщо значення.тип == М.значення_дійсне {
        вивести_кд(М, "дійсне()");
        вернути;
      }
      
      якщо значення.тип == М.значення_послідовність {
        вивести_кд(М, "послідовність()");
        вернути;
      }
      
      якщо значення.тип == М.значення_дійсність {
        вивести_кд(М, "дійсність()");
        вернути;
      }
      
      якщо значення.тип == М.значення_предмет {
        вивести_кд(М, "предмет()");
        вернути;
      }
      
      якщо значення.тип == М.предмет_структури_Структура {
        змінна властивості = значення як адреса<ПредметСтруктури>;
  
        пристрій_мавки_вивести_формат(ФКолірТекстуСиній);
  
        якщо властивості.назва == пусто {
          вивести_кд(М, "<структура>");
        } інакше {
          вивести_кд(М, "<структура ");
          
          вивести_значення(М, властивості.назва як Значення, 0, 0);
  
          вивести_кд(М, ">");
        }
  
        пристрій_мавки_вивести_формат(ФОчистити);
  
        вернути;
      }
      
      якщо значення.тип == М.предмет_структури_Модуль {
        змінна властивості_модуля = значення як адреса<ПредметМодуля>;
  
        пристрій_мавки_вивести_формат(ФКолірТекстуСиній);
  
        якщо властивості_модуля.назва == пусто {
          вивести_кд(М, "<модуль");
        } інакше {
          вивести_кд(М, "<модуль ");
  
          вивести_значення(М, властивості_модуля.назва як Значення, 0, 0);
        }
  
        якщо властивості_модуля.властивості.розмір > 0 {
          вивести_кд(М, "[");
          змінна п: природне = 0;
  
          поки п < властивості_модуля.властивості.розмір {
            вивести_значення(М, властивості_модуля.властивості.дані[п].назва як Значення, 0, 0);
    
            якщо п + 1 < властивості_модуля.властивості.розмір {
              вивести_кд(М, ", ");
            }
    
            п += 1;
          }
          вивести_кд(М, "]");
        }
        
        вивести_кд(М, ">");
  
        пристрій_мавки_вивести_формат(ФОчистити);
  
        вернути;
      }
      
      якщо значення.тип == М.предмет_структури_Параметр {
        вивести_кд(М, "Параметр()");
        вернути;
      }
      
      якщо значення.тип == М.предмет_структури_Число {
        запанікувати(М, "Неможливо вивести значення типу Число без конкретизації Ціле або Дробове.");
      }
      
      якщо значення.тип == М.предмет_структури_Ціле {
        змінна властивості = значення як адреса<ПредметЦілого>;
  
        пристрій_мавки_вивести_формат(ФКолірТекстуЖовтий);
  
        вивести_ц64(М, властивості.значення);
  
        пристрій_мавки_вивести_формат(ФОчистити);
  
        вернути;
      }
      
      якщо значення.тип == М.предмет_структури_Дробове {
        змінна властивості = значення як адреса<ПредметДробового>;
  
        пристрій_мавки_вивести_формат(ФКолірТекстуЖовтий);
  
        вивести_д64(М, властивості.значення);
  
        пристрій_мавки_вивести_формат(ФОчистити);
  
        вернути;
      }
      
      якщо значення.тип == М.предмет_структури_Текст {
        змінна властивості = значення як адреса<ПредметТексту>;
  
  
        якщо глибина != 0 {
          пристрій_мавки_вивести_формат(ФКолірТекстуЗелений);
          вивести_кд(М, "\"");
        }
  
        якщо глибина == 0 {
          вивести_кд(М, властивості.значення);
        } інакше {
          змінна п: природне = 0;
          поки п < властивості.значення.розмір {
            змінна символ = властивості.значення.дані[п];
  
            якщо символ == КД::символи::Міжряд {
              вивести_кд(М, "\\р");
            } інакше якщо символ == КД::символи::Дволапка {
              вивести_кд(М, "\\\"");
            } інакше якщо символ == КД::символи::Обернена_похила {
              вивести_кд(М, "\\\\");
            } інакше {
              вивести_кд(М, кд { 1, символ::адреса як памʼять<п8> });
            }
  
            п += 1;
          }
        }
  
        якщо глибина != 0 {
          вивести_кд(М, "\"");
          пристрій_мавки_вивести_формат(ФОчистити);
        }
  
        вернути;
      }
      
      якщо значення.тип == М.предмет_структури_Код {
        вивести_кд(М, "Код()");
        вернути;
      }
      
      якщо значення.тип == М.предмет_структури_Дія {
        змінна властивості = значення як адреса<ПредметДії>;
  
        пристрій_мавки_вивести_формат(ФКолірТекстуСиній);
  
        якщо властивості.назва == пусто {
          вивести_кд(М, "<дія>");
        } інакше {
          вивести_кд(М, "<дія ");
          
          вивести_значення(М, властивості.назва як Значення, 0, 0);
  
          вивести_кд(М, ">");
        }
  
        пристрій_мавки_вивести_формат(ФОчистити);
  
        вернути;
      }
      
      якщо значення.тип == М.предмет_структури_Список {
        змінна властивості_списку = значення як адреса<ПредметСписку>;
        
        вивести_кд(М, "[");
  
        якщо властивості_списку.розмір > 0 {
          якщо розмір_відступу > 0 {
            вивести_кд(М, "\р");
          }
  
          змінна п: природне = 0;
          поки п < властивості_списку.розмір {
            змінна елемент = властивості_списку.елементи[п];
            вивести_пропуски(М, розмір_відступу * (глибина + 1));
            вивести_значення(М, елемент, розмір_відступу, глибина + 1);
            якщо п + 1 < властивості_списку.розмір {
              вивести_кд(М, ",");
              якщо розмір_відступу > 0 {
                вивести_кд(М, "\р");
              } інакше {
                вивести_кд(М, " ");
              }
            }
  
            п += 1;
          }
  
          якщо розмір_відступу > 0 {
            вивести_кд(М, "\р");
          }
          вивести_пропуски(М, розмір_відступу * глибина);
        }
  
        вивести_кд(М, "]");
        
        вернути;
      }
      
      якщо значення.тип == М.предмет_структури_Словник {
        змінна властивості_словника = значення як адреса<ПредметСловника>;
  
        вивести_кд(М, "{");
        якщо властивості_словника.розмір > 0 {
          якщо розмір_відступу > 0 {
            вивести_кд(М, "\р");
          }
  
          змінна п: природне = 0;
          поки п < властивості_словника.розмір {
            змінна пара = властивості_словника.елементи[п];
            вивести_пропуски(М, розмір_відступу * (глибина + 1));
            вивести_значення(М, пара.ключ, розмір_відступу, глибина + 1);
            вивести_кд(М, " => ");
            вивести_значення(М, пара.значення, розмір_відступу, глибина + 1);
            якщо п + 1 < властивості_словника.розмір {
              вивести_кд(М, ",");
              якщо розмір_відступу > 0 {
                вивести_кд(М, "\р");
              } інакше {
                вивести_кд(М, " ");
              }
            }
  
            п += 1;
          }
  
          якщо розмір_відступу > 0 {
            вивести_кд(М, "\р");
          }
          вивести_пропуски(М, розмір_відступу * глибина);
        }
        
        вивести_кд(М, "}");
  
        вернути;
      }
      
      якщо значення.тип == М.предмет_структури_Дані {
        вивести_кд(М, "Дані()");
        вернути;
      }
      
      якщо значення.тип == М.предмет_структури_ЗмінніДані {
        вивести_кд(М, "ЗмінніДані()");
        вернути;
      }
      
      якщо значення.тип == М.предмет_структури_ДіапазонЦілих {
        вивести_кд(М, "ДіапазонЦілих()");
        вернути;
      }
      
      якщо значення.тип == М.предмет_структури_ДіапазонДробових {
        вивести_кд(М, "ДіапазонДробових()");
        вернути;
      }
      
      якщо значення.тип == М.предмет_структури_ПеребірДіапазонуЦілих {
        вивести_кд(М, "ПеребірДіапазонуЦілих()");
        вернути;
      }
      
      якщо значення.тип == М.предмет_структури_ПеребірДіапазонуДробових {
        вивести_кд(М, "ПеребірДіапазонуДробових()");
        вернути;
      }
      
      якщо значення.тип == М.предмет_структури_ПеребірСписку {
        вивести_кд(М, "ПеребірСписку()");
        вернути;
      }
  
      змінна властивості_структури = значення.тип як адреса<ПредметСтруктури>;
  
      пристрій_мавки_вивести_формат(ФКолірТекстуСиній);
  
      якщо властивості_структури.назва == пусто {
        вивести_кд(М, "<без_назви>");
      } інакше {
        вивести_значення(М, властивості_структури.назва як Значення, 0, 0);
      }
  
      пристрій_мавки_вивести_формат(ФОчистити);
  
      вивести_кд(М, "(");
  
      якщо властивості_структури.параметри != пусто {
        якщо розмір_відступу > 0 {
          вивести_кд(М, "\р");
        }
  
        змінна п: природне = 0;
        поки п < властивості_структури.параметри.розмір {
          змінна параметр = властивості_структури.параметри.дані[п];
          змінна властивості_параметра = параметр як адреса<ПредметПараметра>;
    
          змінна значення_властивості = отримати_властивість(М, значення, властивості_параметра.назва, Місцезнаходження { пусто, 0});
          вивести_пропуски(М, розмір_відступу * (глибина + 1));
          вивести_значення(М, властивості_параметра.назва як Значення, 0, 0);
          вивести_кд(М, "=");
          вивести_значення(М, значення_властивості, розмір_відступу, глибина + 1);
          якщо п + 1 < властивості_структури.параметри.розмір {
            вивести_кд(М, ",");
            якщо розмір_відступу > 0 {
              вивести_кд(М, "\р");
            } інакше {
              вивести_кд(М, " ");
            }
          }
    
          п += 1;
        }
  
        якщо розмір_відступу > 0 {
          вивести_кд(М, "\р");
        }
        вивести_пропуски(М, розмір_відступу * глибина);
      }
  
      вивести_кд(М, ")");
    }
  
    місцева дія надрукувати_значення(М: адреса<Машина>, значення: Значення, розмір_відступу: природне, глибина: природне) {
      вивести_значення(М, значення, розмір_відступу, глибина);
      вивести_кд(М, "\р");
    }
  }
}