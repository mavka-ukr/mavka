взяти означення пристрій_мавки;

дія КД_виділити_сиру_памʼять(система: адреса<КД::Система>, розмір: природне) -> памʼять<п8> {
  вернути пристрій_мавки_виділити_сиру_памʼять(розмір);
}

дія КД_перевиділити_сиру_памʼять(система: адреса<КД::Система>, значення: памʼять<п8>, новий_розмір: природне) -> памʼять<п8> {
  вернути пристрій_мавки_перевиділити_сиру_памʼять(значення, новий_розмір);
}

дія КД_звільнити_сиру_памʼять(система: адреса<КД::Система>, значення: невідома_памʼять) {
  пристрій_мавки_звільнити_сиру_памʼять(значення як памʼять<п8>);
}

зовнішня дія пристрій_мавки_перекодувати_ю8_в_кд(розмір: природне, дані: памʼять<п8>, вихід_розміру: адреса<природне>, вихід_даних: адреса<памʼять<п8>>, вихід_позиції_помилки: адреса<природне>) -> логічне {
  змінна система_КД = КД::Система {
    дані = пусто,
    виділити_сиру_памʼять = КД_виділити_сиру_памʼять,
    звільнити_сиру_памʼять = КД_звільнити_сиру_памʼять,
    перевиділити_сиру_памʼять = КД_перевиділити_сиру_памʼять
  };
  
  змінна вихід: кд;
  змінна позиція_помилки: природне;
  
  змінна успіх = КД::перекодувати_з_ю8(
    система_КД::адреса,
    ю8 { розмір, дані },
    ні,
    ні,
    вихід::адреса,
    позиція_помилки::адреса
  );
  
  якщо успіх {
    вихід_розміру::вміст = вихід.розмір;
    вихід_даних::вміст = вихід.дані;
  }

  вернути успіх;
}

зовнішня дія пристрій_мавки_перекодувати_кд_в_ю8(розмір: природне, дані: памʼять<п8>, вихід_розміру: адреса<природне>, вихід_даних: адреса<памʼять<п8>>, вихід_позиції_помилки: адреса<природне>) -> логічне {
  змінна система_КД = КД::Система {
    дані = пусто,
    виділити_сиру_памʼять = КД_виділити_сиру_памʼять,
    звільнити_сиру_памʼять = КД_звільнити_сиру_памʼять,
    перевиділити_сиру_памʼять = КД_перевиділити_сиру_памʼять
  };
  
  змінна вихід: ю8;
  змінна позиція_помилки: природне;
  
  змінна успіх = КД::перекодувати_в_ю8(
    система_КД::адреса,
    кд { розмір, дані },
    ні,
    вихід::адреса,
    позиція_помилки::адреса
  );
  
  якщо успіх {
    вихід_розміру::вміст = вихід.розмір;
    вихід_даних::вміст = вихід.дані;
  }

  вернути успіх;
}

простір мавка {
  простір пристрій {
    дія машина_виділити_сиру_памʼять(
      М: адреса<Машина>,
      розмір: природне
    ) -> памʼять<п8> {
      вернути пристрій_мавки_виділити_сиру_памʼять(розмір);
    }
    
    дія машина_перевиділити_сиру_памʼять(
      М: адреса<Машина>,
      значення: памʼять<п8>,
      новий_розмір: природне
    ) -> памʼять<п8> {
      вернути пристрій_мавки_перевиділити_сиру_памʼять(значення, новий_розмір);
    }
    
    дія машина_звільнити_сиру_памʼять(
      М: адреса<Машина>,
      значення: памʼять<п8>
    ) {
      пристрій_мавки_звільнити_сиру_памʼять(значення);
    }
    
    дія машина_запанікувати(
      М: адреса<Машина>,
      повідомлення: кд
    ) {
      надрукувати(М, повідомлення);
    
      пристрій_мавки_вийти(1);
    }
    
    дія машина_вивести(
      М: адреса<Машина>,
      значення: кд
    ) {
      пристрій_мавки_вивести_кд(значення.розмір, значення.дані);
    }
    
    дія машина_вивести_формат(
      М: адреса<Машина>,
      значення: природне
    ) {
      пристрій_мавки_вивести_формат(значення);
    }
    
    дія машина_надрукувати(
      М: адреса<Машина>,
      значення: кд
    ) {
      пристрій_мавки_надрукувати_кд(значення.розмір, значення.дані);
    }
    
    дія машина_перетворити_п64_в_кд(
      М: адреса<Машина>,
      значення: п64,
      вихід_текстового_значення: адреса<кд>
    ) -> логічне {
      змінна значення_кд: кд;
    
      якщо пристрій_мавки_перетворити_п64_в_кд(значення, значення_кд.розмір::адреса, значення_кд.дані::адреса) {
        вихід_текстового_значення.розмір = значення_кд.розмір;
        вихід_текстового_значення.дані = значення_кд.дані;
        
        вернути так;
      }
    
      вернути ні;
    }
    
    дія машина_перетворити_ц64_в_кд(
      М: адреса<Машина>,
      значення: ц64,
      вихід_текстового_значення: адреса<кд>
    ) -> логічне {
      змінна значення_кд: кд;
    
      якщо пристрій_мавки_перетворити_ц64_в_кд(значення, значення_кд.розмір::адреса, значення_кд.дані::адреса) {
        вихід_текстового_значення.розмір = значення_кд.розмір;
        вихід_текстового_значення.дані = значення_кд.дані;
        
        вернути так; 
      }
    
      вернути ні;
    }
    
    дія машина_перетворити_д64_в_кд(
      М: адреса<Машина>,
      значення: д64,
      вихід_текстового_значення: адреса<кд>
    ) -> логічне {
      змінна значення_кд: кд;

      якщо пристрій_мавки_перетворити_д64_в_кд(значення, значення_кд.розмір::адреса, значення_кд.дані::адреса) {
        вихід_текстового_значення.розмір = значення_кд.розмір;
        вихід_текстового_значення.дані = значення_кд.дані;
        
        вернути так;
      }
    
      вернути ні;
    }
    
    дія машина_піднести_до_степеня_п64(
      М: адреса<Машина>,
      значення: п64,
      степінь: п64
    ) -> п64 {
      вернути пристрій_мавки_піднести_до_степеня_п64(значення, степінь);
    }
    
    дія машина_піднести_до_степеня_ц64(
      М: адреса<Машина>,
      значення: ц64,
      степінь: ц64
    ) -> ц64 {
      вернути пристрій_мавки_піднести_до_степеня_ц64(значення, степінь);
    }
    
    дія машина_піднести_до_степеня_д64(
      М: адреса<Машина>,
      значення: д64,
      степінь: д64
    ) -> д64 {
      вернути пристрій_мавки_піднести_до_степеня_д64(значення, степінь);
    }
    
    дія машина_взяти_модуль(
      М: адреса<Машина>,
      шлях_до_файлу_поточного_модуля: адреса<ПредметДаних>,
      відносно: логічне,
      довжина_шляху: природне,
      шлях: памʼять<адреса<ПредметТексту>>
    ) -> ЗначенняАбоСтанПадіння {
      змінна успіх: логічне = ні;
      змінна розмір_шляху_до_теки_поточного_модуля: природне = 0;
      змінна дані_шляху_до_теки_поточного_модуля: памʼять<п8> = пусто;
      змінна кдпм = М.користувацькі_дані.значення як адреса<КористувацькіДаніПристроюМавки>;
      змінна шлях_до_теки_модулів = кдпм.шлях_до_теки_модулів.значення як адреса<ПредметДаних>;
      змінна предмет_шляху: адреса<ПредметДаних> = пусто;
      змінна розмір_елементів_збиття: природне = довжина_шляху + 1;
      змінна елементи_збиття = виділити_памʼять<ЕлементШляхуПристроюМавки>(М, розмір_елементів_збиття);
      змінна позиція_елементів_збиття: природне = 0;
      змінна п: природне = 0;
      змінна значення_ю8: ю8 = ю8 { 0, пусто };
      змінна позиція_помилки: природне = 0;
      змінна розмір_збитого_шляху: природне = 0;
      змінна дані_збитого_шляху: памʼять<п8> = пусто;
      змінна треба_звільнити_перший_елемент: логічне = ні;

      якщо відносно {
        успіх = пристрій_мавки_отримати_теку_шляху(
          шлях_до_файлу_поточного_модуля.розмір,
          шлях_до_файлу_поточного_модуля.дані,
          розмір_шляху_до_теки_поточного_модуля::адреса,
          дані_шляху_до_теки_поточного_модуля::адреса,
          1
        );
        якщо не успіх {
          увімкнути_стан_падіння(
            М,
            створити_текст(М, "Не вдалося отримати теку шляху поточного модуля.") як Значення,
            Місцезнаходження { пусто як адреса<ПредметДаних>, 0 }
          );
          звільнити_памʼять(М, елементи_збиття);
          звільнити_памʼять(М, шлях);
          вернути пусто;
        }
        
        елементи_збиття[позиція_елементів_збиття] = ЕлементШляхуПристроюМавки {
          розмір_шляху_до_теки_поточного_модуля,
          дані_шляху_до_теки_поточного_модуля
        };

        треба_звільнити_перший_елемент = так;

        позиція_елементів_збиття += 1;
      } інакше {
        елементи_збиття[позиція_елементів_збиття] = ЕлементШляхуПристроюМавки {
          шлях_до_теки_модулів.розмір,
          шлях_до_теки_модулів.дані
        };

        позиція_елементів_збиття += 1;
      }

      поки п < довжина_шляху {
        успіх = перекодувати_кд_в_ю8(
          М,
          шлях[п].значення,
          значення_ю8::адреса,
          позиція_помилки::адреса
        );

        якщо не успіх {
          увімкнути_стан_падіння(
            М,
            створити_текст(М, "Не вдалося перекодувати елемент шляху модуля в ю8.") як Значення,
            Місцезнаходження { пусто як адреса<ПредметДаних>, 0 }
          );
          якщо треба_звільнити_перший_елемент {
            п = 0;
          } інакше {
            п = 1;
          }
          поки п < позиція_елементів_збиття {
            звільнити_памʼять(М, елементи_збиття[п].дані);
            
            п += 1;
          }
          звільнити_памʼять(М, елементи_збиття);
          звільнити_памʼять(М, шлях);
          вернути пусто;
        }

        елементи_збиття[позиція_елементів_збиття] = ЕлементШляхуПристроюМавки {
          значення_ю8.розмір,
          значення_ю8.дані
        };

        позиція_елементів_збиття += 1;

        п += 1;
      }

      успіх = пристрій_мавки_збити_шлях_до_модуля(
        розмір_елементів_збиття,
        елементи_збиття,
        розмір_збитого_шляху::адреса,
        дані_збитого_шляху::адреса
      );

      якщо не успіх {
        увімкнути_стан_падіння(
          М,
          створити_текст(М, "Не вдалося збити шлях до модуля.") як Значення,
          Місцезнаходження { пусто як адреса<ПредметДаних>, 0 }
        );
        якщо треба_звільнити_перший_елемент {
          п = 0;
        } інакше {
          п = 1;
        }
        поки п < розмір_елементів_збиття {
          звільнити_памʼять(М, елементи_збиття[п].дані);
          
          п += 1;
        }
        звільнити_памʼять(М, елементи_збиття);
        звільнити_памʼять(М, шлях);
        вернути пусто;
      }

      предмет_шляху = створити_дані(
        М,
        розмір_збитого_шляху,
        дані_збитого_шляху
      );

      пристрій_мавки_вивести_сирі_дані(предмет_шляху.розмір, предмет_шляху.дані);

      якщо треба_звільнити_перший_елемент {
        п = 0;
      } інакше {
        п = 1;
      }
      поки п < розмір_елементів_збиття {
        звільнити_памʼять(М, елементи_збиття[п].дані);

        п += 1;
      }
      звільнити_памʼять(М, елементи_збиття);
      звільнити_памʼять(М, шлях);
    
      вернути взяти_файл(М, предмет_шляху, шлях[довжина_шляху - 1]);
    }
    
    дія машина_взяти_пак(
      М: адреса<Машина>,
      довжина_шляху: природне,
      шлях: памʼять<адреса<ПредметТексту>>
    ) -> ЗначенняАбоСтанПадіння {
      звільнити_памʼять(М, шлях);
    
      вернути пусто;
    }

    дія дія_перед_знищенням_користувацьких_даних_пристрою_мавки(
      М: адреса<Машина>,
      користувацькі_дані: адреса<КористувацькіДані>
    ) {
      змінна кдпм = користувацькі_дані.значення як адреса<КористувацькіДаніПристроюМавки>;
      
      // ...
    }

    місцева дія створити_машину() -> адреса<Машина> {
      змінна М = пристрій_мавки_виділити_сиру_памʼять(Машина.розмір) як адреса<Машина>;
      
      налаштувати_машину(М, Налаштування {
        виділити_сиру_памʼять = машина_виділити_сиру_памʼять,
        перевиділити_сиру_памʼять = машина_перевиділити_сиру_памʼять,
        звільнити_сиру_памʼять = машина_звільнити_сиру_памʼять,
        запанікувати = машина_запанікувати,
        вивести = машина_вивести,
        вивести_формат = машина_вивести_формат,
        перетворити_п64_в_кд = машина_перетворити_п64_в_кд,
        перетворити_ц64_в_кд = машина_перетворити_ц64_в_кд,
        перетворити_д64_в_кд = машина_перетворити_д64_в_кд,
        піднести_до_степеня_п64 = машина_піднести_до_степеня_п64,
        піднести_до_степеня_ц64 = машина_піднести_до_степеня_ц64,
        піднести_до_степеня_д64 = машина_піднести_до_степеня_д64,
        взяти_модуль = машина_взяти_модуль,
        взяти_пак = машина_взяти_пак,
      });

      змінна кдпм = виділити<КористувацькіДаніПристроюМавки>(М);
      кдпм.шлях_до_теки_модулів = пусто;
      кдпм.шлях_до_теки_паків = пусто;

      М.користувацькі_дані = створити_користувацькі_дані(
        М,
        кдпм,
        дія_перед_знищенням_користувацьких_даних_пристрою_мавки
      );

      вернути М;
    }

    місцева дія розібрати_шлях_початкового_модуля(
      М: адреса<Машина>,
      шлях: адреса<ПредметДаних>,
      вихід_абсолютного_шляху: адреса<адреса<ПредметДаних>>,
      вихід_теки_модулів: адреса<адреса<ПредметДаних>>,
      вихід_теки_паків: адреса<адреса<ПредметДаних>>,
      вихід_назви_модуля: адреса<адреса<ПредметТексту>>
    ) -> логічне {
      змінна розмір_абсолютого_шляху: природне;
      змінна дані_абсолютного_шляху: памʼять<п8>;
      змінна розмір_теки_модулів: природне;
      змінна дані_теки_модулів: памʼять<п8>;
      змінна розмір_теки_паків: природне;
      змінна дані_теки_паків: памʼять<п8>;
      змінна розмір_назви_модуля: природне;
      змінна дані_назви_модуля: памʼять<п8>;

      якщо не пристрій_мавки_перевірити_чи_шлях_існує_і_є_файлом(
        шлях.розмір,
        шлях.дані
      ) {
        вернути ні;
      }

      якщо не пристрій_мавки_перевірити_чи_шлях_закінчується_як_модуль_мавки(
        шлях.розмір,
        шлях.дані
      ) {
        вернути ні;
      }

      якщо не пристрій_мавки_отримати_абсолютний_шлях(
        шлях.розмір,
        шлях.дані,
        розмір_абсолютого_шляху::адреса,
        дані_абсолютного_шляху::адреса
      ) {
        вернути ні;
      }

      якщо не пристрій_мавки_отримати_теку_шляху(
        розмір_абсолютого_шляху,
        дані_абсолютного_шляху,
        розмір_теки_модулів::адреса,
        дані_теки_модулів::адреса,
        1
      ) {
        пристрій_мавки_звільнити_сиру_памʼять(дані_абсолютного_шляху);
        вернути ні;
      }

      якщо не пристрій_мавки_отримати_теку_до_паків(
        розмір_теки_модулів,
        дані_теки_модулів,
        розмір_теки_паків::адреса,
        дані_теки_паків::адреса
      ) {
        пристрій_мавки_звільнити_сиру_памʼять(дані_абсолютного_шляху);
        пристрій_мавки_звільнити_сиру_памʼять(дані_теки_модулів);
        вернути ні;
      }

      якщо не пристрій_мавки_отримати_назву_модуля_з_шляху(
        розмір_абсолютого_шляху,
        дані_абсолютного_шляху,
        розмір_назви_модуля::адреса,
        дані_назви_модуля::адреса
      ) {
        пристрій_мавки_звільнити_сиру_памʼять(дані_абсолютного_шляху);
        пристрій_мавки_звільнити_сиру_памʼять(дані_теки_модулів);
        пристрій_мавки_звільнити_сиру_памʼять(дані_теки_паків);
        вернути ні;
      }

      вихід_абсолютного_шляху::вміст = створити_дані(
        М,
        розмір_абсолютого_шляху,
        дані_абсолютного_шляху
      );

      вихід_теки_модулів::вміст = створити_дані(
        М,
        розмір_теки_модулів,
        дані_теки_модулів
      );

      вихід_теки_паків::вміст = створити_дані(
        М,
        розмір_теки_паків,
        дані_теки_паків
      );

      вихід_назви_модуля::вміст = створити_текст(
        М,
        кд { розмір_назви_модуля, дані_назви_модуля }
      );

      вернути так;
    }

    місцева дія записати_шлях_до_теки_модулів_та_паків(
      М: адреса<Машина>,
      шлях_до_теки_модулів: адреса<ПредметДаних>,
      шлях_до_теки_паків: адреса<ПредметДаних>
    ) {
      змінна кдпм = М.користувацькі_дані.значення як адреса<КористувацькіДаніПристроюМавки>;
      якщо кдпм.шлях_до_теки_модулів != пусто {
        запанікувати(М, "Шлях до теки модулів вже встановлено.");
      }
      якщо кдпм.шлях_до_теки_паків != пусто {
        запанікувати(М, "Шлях до теки паків вже встановлено.");
      }
      кдпм.шлях_до_теки_модулів = притримати_в_користувацьких_даних(М, М.користувацькі_дані, шлях_до_теки_модулів як Значення);
      кдпм.шлях_до_теки_паків = притримати_в_користувацьких_даних(М, М.користувацькі_дані, шлях_до_теки_паків як Значення);
    }
    
    місцева дія взяти_файл(
      М: адреса<Машина>,
      шлях_до_файлу: адреса<ПредметДаних>,
      назва_модуля: адреса<ПредметТексту>
    ) -> ЗначенняАбоСтанПадіння {
      змінна значення: Значення = пусто;
     
      якщо знайти_взяте_значення(М, шлях_до_файлу, значення::адреса) {
        вернути значення;
      }

      // змінна вихід_файлу: ВихідФайлу;
      // змінна шлях_до_файлу = ю8"привіт.м";
      // змінна шлях = шлях_до_файлу::адреса як адреса<Шлях>;
      // якщо не __прочитати_файл(шлях, вихід_файлу::адреса) {
      //   мавка::надрукувати(М, "Не вдалося прочитати файл привіт.м");
      //   вернути 1;
      // }
    
      // змінна сирий_текст: кд;
      // якщо не мавка::перекодувати_ю8_в_кд(М, ю8 { вихід_файлу.розмір, вихід_файлу.дані }, сирий_текст::адреса, пусто) {
      //   мавка::надрукувати(М, "Помилка перекодування файлу привіт.м в кд");
      //   вернути 1;
      // }
      
      // змінна слова: мавка::розбирач::Слова;
      // змінна помилка_розбору_на_слова: мавка::розбирач::ПомилкаРозборуНаСлова;
      
      // змінна успіх = мавка::розбирач::розібрати_на_слова(
      //   М, 
      //   сирий_текст, 
      //   слова::адреса, 
      //   помилка_розбору_на_слова::адреса
      // );
      // якщо не успіх {
      //   мавка::надрукувати(М, "Помилка розбору на слова");
      //   вернути 1;
      // }
    
      // змінна сполуки: мавка::розбирач::Сполуки;
      // змінна помилка_розбору_на_сполуки: мавка::розбирач::ПомилкаРозборуНаСполуки;
      // успіх = мавка::розбирач::розібрати_слова_на_сполуки(
      //   М,
      //   сирий_текст,
      //   слова,
      //   сполуки::адреса,
      //   помилка_розбору_на_сполуки::адреса
      // );
      // якщо не успіх {
      //   мавка::надрукувати(М, "Помилка розбору на сполуки");
      //   вернути 1;
      // }
    
      // змінна перекладений_код: адреса<мавка::ПредметКоду> = пусто;
      // змінна помилка_перекладу: мавка::перекладач::ПомилкаПерекладу;
    
      // змінна успіх_перекладу = мавка::перекласти_в_код(
      //   М,
      //   мавка::створити_дані(М, шлях_до_файлу.розмір, шлях_до_файлу.дані),
      //   сирий_текст,
      //   слова,
      //   сполуки,
      //   перекладений_код::адреса,
      //   помилка_перекладу::адреса
      // );
      // якщо не успіх_перекладу {
      //   мавка::надрукувати(М, "Помилка перекладу: ");
      //   мавка::надрукувати(М, помилка_перекладу.повідомлення);
      //   вернути 1;
      // }
      
      // змінна властивості_коду = перекладений_код як адреса<мавка::ПредметКоду>;
      // змінна властивості_даних_коду = властивості_коду.вказівки як адреса<мавка::ПредметДаних>;
      // // мавка::надрукувати_код(М, властивості_даних_коду.розмір, властивості_даних_коду.дані, дія_виводу);
    
      // змінна д = мавка::створити_дію(
      //   М,
      //   М.глобальна_дійсність,
      //   пусто,
      //   пусто,
      //   пусто,
      //   перекладений_код як адреса<мавка::ПредметКоду>
      // );
    
      // змінна результат = мавка::здійснити(
      //   М,
      //   пусто,
      //   д як мавка::Значення,
      //   0,
      //   пусто,
      //   пусто,
      //   мавка::Місцезнаходження { пусто, 0 }
      // );
      // якщо М.стан_падіння {
      //   змінна інформація_падіння: мавка::ІнформаціяПадіння;
      //   якщо мавка::отримати_інформацію_падіння(М, інформація_падіння::адреса) {  
      //     якщо інформація_падіння.місцезнаходження.шлях != пусто {
      //       __вивести_ю8((ю8 { інформація_падіння.місцезнаходження.шлях.розмір, інформація_падіння.місцезнаходження.шлях.дані })::адреса);
      
      //       якщо інформація_падіння.місцезнаходження.рядок > 0 {
      //         мавка::вивести(М, ":");
      //         мавка::вивести_п64(М, п64(інформація_падіння.місцезнаходження.рядок));
      //       }
            
      //       мавка::вивести(М, " ");
      //     }
    
      //     мавка::вивести_формат(М, мавка::ФКолірТекстуЧервоний);
      //     мавка::вивести(М, "падіння");
      //     мавка::вивести_формат(М, мавка::ФОчистити);
      //     мавка::вивести(М, ": ");
      //     мавка::надрукувати_значення(М, інформація_падіння.значення, 2, 0);
    
      //     змінна п: природне = 0;
          
      //     якщо інформація_падіння.розмір_історії > 0 {
      //       мавка::надрукувати(М, "\рІсторія здійснення:");
      //     }
    
      //     поки п < інформація_падіння.розмір_історії {
      //       змінна елемент_історії = інформація_падіння.історія[п];
            
      //       якщо елемент_історії.назва != пусто {
      //         мавка::вивести(М, "  ");
      //         мавка::вивести_формат(М, мавка::ФКолірТекстуСиній);
      //         мавка::вивести(М, елемент_історії.назва.значення);
      //         мавка::вивести_формат(М, мавка::ФОчистити);
            
      //         якщо елемент_історії.місцезнаходження.шлях == пусто {
      //           мавка::вивести(М, "\р");
      //         } інакше {
      //           мавка::вивести(М, " в ");
      //           __вивести_ю8((ю8 { елемент_історії.місцезнаходження.шлях.розмір, елемент_історії.місцезнаходження.шлях.дані })::адреса);
      
      //           якщо елемент_історії.місцезнаходження.рядок > 0 {
      //             мавка::вивести(М, ":");
      //             мавка::вивести_п64(М, п64(елемент_історії.місцезнаходження.рядок));
      //           }
                
      //           мавка::вивести(М, "\р");
      //         }
      //       }
            
      //       п += 1;
      //     }
      //   }
      //   вернути 1;
      // }
    }

    місцева дія надрукувати_інформацію_падіння(
      М: адреса<Машина>,
      інформація_падіння: ІнформаціяПадіння
    ) {
      якщо інформація_падіння.місцезнаходження.шлях != пусто {
        пристрій_мавки_вивести_сирі_дані(інформація_падіння.місцезнаходження.шлях.розмір, інформація_падіння.місцезнаходження.шлях.дані);
  
        якщо інформація_падіння.місцезнаходження.рядок > 0 {
          мавка::вивести(М, ":");
          мавка::вивести_п64(М, п64(інформація_падіння.місцезнаходження.рядок));
        }
        
        мавка::вивести(М, " ");
      }
  
      мавка::вивести_формат(М, мавка::ФКолірТекстуЧервоний);
      мавка::вивести(М, "падіння");
      мавка::вивести_формат(М, мавка::ФОчистити);
      мавка::вивести(М, ": ");
      мавка::надрукувати_значення(М, інформація_падіння.значення, 2, 0);
  
      змінна п: природне = 0;
      
      якщо інформація_падіння.розмір_історії > 0 {
        мавка::надрукувати(М, "\рІсторія здійснення:");
      }
  
      поки п < інформація_падіння.розмір_історії {
        змінна елемент_історії = інформація_падіння.історія[п];
        
        якщо елемент_історії.назва != пусто {
          мавка::вивести(М, "  ");
          мавка::вивести_формат(М, мавка::ФКолірТекстуСиній);
          мавка::вивести(М, елемент_історії.назва.значення);
          мавка::вивести_формат(М, мавка::ФОчистити);
        
          якщо елемент_історії.місцезнаходження.шлях == пусто {
            мавка::вивести(М, "\р");
          } інакше {
            мавка::вивести(М, " в ");
            пристрій_мавки_вивести_сирі_дані(елемент_історії.місцезнаходження.шлях.розмір, елемент_історії.місцезнаходження.шлях.дані);
  
            якщо елемент_історії.місцезнаходження.рядок > 0 {
              мавка::вивести(М, ":");
              мавка::вивести_п64(М, п64(елемент_історії.місцезнаходження.рядок));
            }
            
            мавка::вивести(М, "\р");
          }
        }
        
        п += 1;
      }
    }
  }
}