взяти означення пристрій_мавки;

дія КД_виділити_сиру_памʼять(система: адреса<КД::Система>, розмір: природне) -> памʼять<п8> {
  вернути пристрій_мавки_виділити_сиру_памʼять(розмір);
}

дія КД_перевиділити_сиру_памʼять(система: адреса<КД::Система>, значення: памʼять<п8>, новий_розмір: природне) -> памʼять<п8> {
  вернути пристрій_мавки_перевиділити_сиру_памʼять(значення, новий_розмір);
}

дія КД_звільнити_сиру_памʼять(система: адреса<КД::Система>, значення: невідома_памʼять) {
  пристрій_мавки_звільнити_сиру_памʼять(значення як памʼять<п8>);
}

зовнішня дія пристрій_мавки_перекодувати_ю8_в_кд(розмір: природне, дані: памʼять<п8>, вихід_розміру: адреса<природне>, вихід_даних: адреса<памʼять<п8>>, вихід_позиції_помилки: адреса<природне>) -> логічне {
  змінна система_КД = КД::Система {
    дані = пусто,
    виділити_сиру_памʼять = КД_виділити_сиру_памʼять,
    звільнити_сиру_памʼять = КД_звільнити_сиру_памʼять,
    перевиділити_сиру_памʼять = КД_перевиділити_сиру_памʼять
  };
  
  змінна вихід: кд;
  змінна позиція_помилки: природне;
  
  змінна успіх = КД::перекодувати_з_ю8(
    система_КД::адреса,
    ю8 { розмір, дані },
    ні,
    ні,
    вихід::адреса,
    позиція_помилки::адреса
  );
  
  якщо успіх {
    вихід_розміру::вміст = вихід.розмір;
    вихід_даних::вміст = вихід.дані;
  }

  вернути успіх;
}

зовнішня дія пристрій_мавки_перекодувати_кд_в_ю8(розмір: природне, дані: памʼять<п8>, вихід_розміру: адреса<природне>, вихід_даних: адреса<памʼять<п8>>, вихід_позиції_помилки: адреса<природне>) -> логічне {
  змінна система_КД = КД::Система {
    дані = пусто,
    виділити_сиру_памʼять = КД_виділити_сиру_памʼять,
    звільнити_сиру_памʼять = КД_звільнити_сиру_памʼять,
    перевиділити_сиру_памʼять = КД_перевиділити_сиру_памʼять
  };
  
  змінна вихід: ю8;
  змінна позиція_помилки: природне;
  
  змінна успіх = КД::перекодувати_в_ю8(
    система_КД::адреса,
    кд { розмір, дані },
    ні,
    вихід::адреса,
    позиція_помилки::адреса
  );
  
  якщо успіх {
    вихід_розміру::вміст = вихід.розмір;
    вихід_даних::вміст = вихід.дані;
  }

  вернути успіх;
}

простір мавка {
  простір пристрій {
    дія машина_виділити_сиру_памʼять(
      М: адреса<Машина>,
      розмір: природне
    ) -> памʼять<п8> {
      вернути пристрій_мавки_виділити_сиру_памʼять(розмір);
    }
    
    дія машина_перевиділити_сиру_памʼять(
      М: адреса<Машина>,
      значення: памʼять<п8>,
      новий_розмір: природне
    ) -> памʼять<п8> {
      вернути пристрій_мавки_перевиділити_сиру_памʼять(значення, новий_розмір);
    }
    
    дія машина_звільнити_сиру_памʼять(
      М: адреса<Машина>,
      значення: памʼять<п8>
    ) {
      пристрій_мавки_звільнити_сиру_памʼять(значення);
    }
    
    дія машина_запанікувати(
      М: адреса<Машина>,
      повідомлення: кд
    ) {
      надрукувати(М, повідомлення);
    
      пристрій_мавки_вийти(1);
    }
    
    дія машина_вивести(
      М: адреса<Машина>,
      значення: кд
    ) {
      пристрій_мавки_вивести_кд(значення.розмір, значення.дані);
    }
    
    дія машина_вивести_формат(
      М: адреса<Машина>,
      значення: природне
    ) {
      пристрій_мавки_вивести_формат(значення);
    }
    
    дія машина_надрукувати(
      М: адреса<Машина>,
      значення: кд
    ) {
      пристрій_мавки_надрукувати_кд(значення.розмір, значення.дані);
    }
    
    дія машина_перетворити_п64_в_кд(
      М: адреса<Машина>,
      значення: п64,
      вихід_текстового_значення: адреса<кд>
    ) -> логічне {
      змінна значення_кд: кд;
    
      якщо пристрій_мавки_перетворити_п64_в_кд(значення, значення_кд.розмір::адреса, значення_кд.дані::адреса) {
        вихід_текстового_значення.розмір = значення_кд.розмір;
        вихід_текстового_значення.дані = значення_кд.дані;
        
        вернути так;
      }
    
      вернути ні;
    }
    
    дія машина_перетворити_ц64_в_кд(
      М: адреса<Машина>,
      значення: ц64,
      вихід_текстового_значення: адреса<кд>
    ) -> логічне {
      змінна значення_кд: кд;
    
      якщо пристрій_мавки_перетворити_ц64_в_кд(значення, значення_кд.розмір::адреса, значення_кд.дані::адреса) {
        вихід_текстового_значення.розмір = значення_кд.розмір;
        вихід_текстового_значення.дані = значення_кд.дані;
        
        вернути так; 
      }
    
      вернути ні;
    }
    
    дія машина_перетворити_д64_в_кд(
      М: адреса<Машина>,
      значення: д64,
      вихід_текстового_значення: адреса<кд>
    ) -> логічне {
      змінна значення_кд: кд;

      якщо пристрій_мавки_перетворити_д64_в_кд(значення, значення_кд.розмір::адреса, значення_кд.дані::адреса) {
        вихід_текстового_значення.розмір = значення_кд.розмір;
        вихід_текстового_значення.дані = значення_кд.дані;
        
        вернути так;
      }
    
      вернути ні;
    }
    
    дія машина_піднести_до_степеня_п64(
      М: адреса<Машина>,
      значення: п64,
      степінь: п64
    ) -> п64 {
      вернути пристрій_мавки_піднести_до_степеня_п64(значення, степінь);
    }
    
    дія машина_піднести_до_степеня_ц64(
      М: адреса<Машина>,
      значення: ц64,
      степінь: ц64
    ) -> ц64 {
      вернути пристрій_мавки_піднести_до_степеня_ц64(значення, степінь);
    }
    
    дія машина_піднести_до_степеня_д64(
      М: адреса<Машина>,
      значення: д64,
      степінь: д64
    ) -> д64 {
      вернути пристрій_мавки_піднести_до_степеня_д64(значення, степінь);
    }
    
    дія машина_взяти_модуль(
      М: адреса<Машина>,
      шлях_до_файлу_поточного_модуля: адреса<ПредметДаних>,
      відносно: логічне,
      довжина_шляху: природне,
      шлях: памʼять<адреса<ПредметТексту>>,
      місцезнаходження: Місцезнаходження
    ) -> ЗначенняАбоСтанПадіння {
      змінна успіх: логічне = ні;
      змінна розмір_шляху_до_теки_поточного_модуля: природне = 0;
      змінна дані_шляху_до_теки_поточного_модуля: памʼять<п8> = пусто;
      змінна кдпм = М.користувацькі_дані.значення як адреса<КористувацькіДаніПристроюМавки>;
      змінна шлях_до_теки_модулів = кдпм.шлях_до_теки_модулів.значення як адреса<ПредметДаних>;
      змінна предмет_шляху: адреса<ПредметДаних> = пусто;
      змінна розмір_елементів_збиття: природне = довжина_шляху + 1;
      змінна елементи_збиття = виділити_памʼять<ЕлементШляхуПристроюМавки>(М, розмір_елементів_збиття);
      змінна позиція_елементів_збиття: природне = 0;
      змінна п: природне = 0;
      змінна значення_ю8: ю8 = ю8 { 0, пусто };
      змінна позиція_помилки: природне = 0;
      змінна розмір_збитого_шляху: природне = 0;
      змінна дані_збитого_шляху: памʼять<п8> = пусто;
      змінна треба_звільнити_перший_елемент: логічне = ні;

      // потім: перевірити чи з паків

      якщо відносно {
        успіх = пристрій_мавки_отримати_теку_шляху(
          шлях_до_файлу_поточного_модуля.розмір,
          шлях_до_файлу_поточного_модуля.дані,
          розмір_шляху_до_теки_поточного_модуля::адреса,
          дані_шляху_до_теки_поточного_модуля::адреса,
          1
        );

        якщо не успіх {
          увімкнути_стан_падіння(
            М,
            створити_текст(М, "Не вдалося отримати теку шляху поточного модуля.") як Значення,
            місцезнаходження
          );
          звільнити_памʼять(М, елементи_збиття);
          звільнити_памʼять(М, шлях);
          вернути пусто;
        }
        
        елементи_збиття[позиція_елементів_збиття] = ЕлементШляхуПристроюМавки {
          розмір_шляху_до_теки_поточного_модуля,
          дані_шляху_до_теки_поточного_модуля
        };

        треба_звільнити_перший_елемент = так;

        позиція_елементів_збиття += 1;
      } інакше {
        елементи_збиття[позиція_елементів_збиття] = ЕлементШляхуПристроюМавки {
          шлях_до_теки_модулів.розмір,
          шлях_до_теки_модулів.дані
        };

        позиція_елементів_збиття += 1;
      }

      поки п < довжина_шляху {
        успіх = перекодувати_кд_в_ю8(
          М,
          шлях[п].значення,
          значення_ю8::адреса,
          позиція_помилки::адреса
        );

        якщо не успіх {
          увімкнути_стан_падіння(
            М,
            створити_текст(М, "Не вдалося перекодувати елемент шляху модуля в ю8.") як Значення,
            місцезнаходження
          );
          якщо треба_звільнити_перший_елемент {
            п = 0;
          } інакше {
            п = 1;
          }
          поки п < позиція_елементів_збиття {
            звільнити_памʼять(М, елементи_збиття[п].дані);
            
            п += 1;
          }
          звільнити_памʼять(М, елементи_збиття);
          звільнити_памʼять(М, шлях);
          вернути пусто;
        }

        елементи_збиття[позиція_елементів_збиття] = ЕлементШляхуПристроюМавки {
          значення_ю8.розмір,
          значення_ю8.дані
        };

        позиція_елементів_збиття += 1;

        п += 1;
      }

      успіх = пристрій_мавки_збити_шлях_до_модуля(
        розмір_елементів_збиття,
        елементи_збиття,
        розмір_збитого_шляху::адреса,
        дані_збитого_шляху::адреса
      );

      якщо не успіх {
        увімкнути_стан_падіння(
          М,
          створити_текст(М, "Не вдалося збити шлях до модуля.") як Значення,
          місцезнаходження
        );
        якщо треба_звільнити_перший_елемент {
          п = 0;
        } інакше {
          п = 1;
        }
        поки п < розмір_елементів_збиття {
          звільнити_памʼять(М, елементи_збиття[п].дані);
          
          п += 1;
        }
        звільнити_памʼять(М, елементи_збиття);
        звільнити_памʼять(М, шлях);
        вернути пусто;
      }

      предмет_шляху = створити_дані(
        М,
        розмір_збитого_шляху,
        дані_збитого_шляху
      );

      якщо треба_звільнити_перший_елемент {
        п = 0;
      } інакше {
        п = 1;
      }
      поки п < розмір_елементів_збиття {
        звільнити_памʼять(М, елементи_збиття[п].дані);

        п += 1;
      }
      звільнити_памʼять(М, елементи_збиття);
    
      змінна результат = взяти_файл(
        М,
        предмет_шляху,
        шлях[довжина_шляху - 1],
        місцезнаходження
      );

      звільнити_памʼять(М, шлях);

      вернути результат;
    }
    
    дія машина_взяти_пак(
      М: адреса<Машина>,
      довжина_шляху: природне,
      шлях: памʼять<адреса<ПредметТексту>>,
      місцезнаходження: Місцезнаходження
    ) -> ЗначенняАбоСтанПадіння {
      звільнити_памʼять(М, шлях);
    
      вернути пусто;
    }

    дія дія_перед_знищенням_користувацьких_даних_пристрою_мавки(
      М: адреса<Машина>,
      користувацькі_дані: адреса<КористувацькіДані>
    ) {
      змінна кдпм = користувацькі_дані.значення як адреса<КористувацькіДаніПристроюМавки>;
      
      // ...
    }

    місцева дія створити_машину() -> адреса<Машина> {
      змінна М = пристрій_мавки_виділити_сиру_памʼять(Машина.розмір) як адреса<Машина>;
      
      налаштувати_машину(М, Налаштування {
        виділити_сиру_памʼять = машина_виділити_сиру_памʼять,
        перевиділити_сиру_памʼять = машина_перевиділити_сиру_памʼять,
        звільнити_сиру_памʼять = машина_звільнити_сиру_памʼять,
        запанікувати = машина_запанікувати,
        вивести = машина_вивести,
        вивести_формат = машина_вивести_формат,
        перетворити_п64_в_кд = машина_перетворити_п64_в_кд,
        перетворити_ц64_в_кд = машина_перетворити_ц64_в_кд,
        перетворити_д64_в_кд = машина_перетворити_д64_в_кд,
        піднести_до_степеня_п64 = машина_піднести_до_степеня_п64,
        піднести_до_степеня_ц64 = машина_піднести_до_степеня_ц64,
        піднести_до_степеня_д64 = машина_піднести_до_степеня_д64,
        взяти_модуль = машина_взяти_модуль,
        взяти_пак = машина_взяти_пак,
      });

      змінна кдпм = виділити<КористувацькіДаніПристроюМавки>(М);
      кдпм.шлях_до_теки_модулів = пусто;
      кдпм.шлях_до_теки_паків = пусто;

      М.користувацькі_дані = створити_користувацькі_дані(
        М,
        кдпм,
        дія_перед_знищенням_користувацьких_даних_пристрою_мавки
      );

      вернути М;
    }

    місцева дія розібрати_шлях_початкового_модуля(
      М: адреса<Машина>,
      шлях: адреса<ПредметДаних>,
      вихід_абсолютного_шляху: адреса<адреса<ПредметДаних>>,
      вихід_теки_модулів: адреса<адреса<ПредметДаних>>,
      вихід_теки_паків: адреса<адреса<ПредметДаних>>,
      вихід_назви_модуля: адреса<адреса<ПредметТексту>>
    ) -> логічне {
      змінна розмір_абсолютого_шляху: природне;
      змінна дані_абсолютного_шляху: памʼять<п8>;
      змінна розмір_теки_модулів: природне;
      змінна дані_теки_модулів: памʼять<п8>;
      змінна розмір_теки_паків: природне;
      змінна дані_теки_паків: памʼять<п8>;
      змінна розмір_назви_модуля: природне;
      змінна дані_назви_модуля: памʼять<п8>;

      якщо не пристрій_мавки_перевірити_чи_шлях_існує_і_є_файлом(
        шлях.розмір,
        шлях.дані
      ) {
        вернути ні;
      }

      якщо не пристрій_мавки_перевірити_чи_шлях_закінчується_як_модуль_мавки(
        шлях.розмір,
        шлях.дані
      ) {
        вернути ні;
      }

      якщо не пристрій_мавки_отримати_абсолютний_шлях(
        шлях.розмір,
        шлях.дані,
        розмір_абсолютого_шляху::адреса,
        дані_абсолютного_шляху::адреса
      ) {
        вернути ні;
      }

      якщо не пристрій_мавки_отримати_теку_шляху(
        розмір_абсолютого_шляху,
        дані_абсолютного_шляху,
        розмір_теки_модулів::адреса,
        дані_теки_модулів::адреса,
        1
      ) {
        пристрій_мавки_звільнити_сиру_памʼять(дані_абсолютного_шляху);
        вернути ні;
      }

      якщо не пристрій_мавки_отримати_теку_до_паків(
        розмір_теки_модулів,
        дані_теки_модулів,
        розмір_теки_паків::адреса,
        дані_теки_паків::адреса
      ) {
        пристрій_мавки_звільнити_сиру_памʼять(дані_абсолютного_шляху);
        пристрій_мавки_звільнити_сиру_памʼять(дані_теки_модулів);
        вернути ні;
      }

      якщо не пристрій_мавки_отримати_назву_модуля_з_шляху(
        розмір_абсолютого_шляху,
        дані_абсолютного_шляху,
        розмір_назви_модуля::адреса,
        дані_назви_модуля::адреса
      ) {
        пристрій_мавки_звільнити_сиру_памʼять(дані_абсолютного_шляху);
        пристрій_мавки_звільнити_сиру_памʼять(дані_теки_модулів);
        пристрій_мавки_звільнити_сиру_памʼять(дані_теки_паків);
        вернути ні;
      }

      вихід_абсолютного_шляху::вміст = створити_дані(
        М,
        розмір_абсолютого_шляху,
        дані_абсолютного_шляху
      );

      вихід_теки_модулів::вміст = створити_дані(
        М,
        розмір_теки_модулів,
        дані_теки_модулів
      );

      вихід_теки_паків::вміст = створити_дані(
        М,
        розмір_теки_паків,
        дані_теки_паків
      );

      вихід_назви_модуля::вміст = створити_текст(
        М,
        кд { розмір_назви_модуля, дані_назви_модуля }
      );

      вернути так;
    }

    місцева дія записати_шлях_до_теки_модулів_та_паків(
      М: адреса<Машина>,
      шлях_до_теки_модулів: адреса<ПредметДаних>,
      шлях_до_теки_паків: адреса<ПредметДаних>
    ) {
      змінна кдпм = М.користувацькі_дані.значення як адреса<КористувацькіДаніПристроюМавки>;
      якщо кдпм.шлях_до_теки_модулів != пусто {
        запанікувати(М, "Шлях до теки модулів вже встановлено.");
      }
      якщо кдпм.шлях_до_теки_паків != пусто {
        запанікувати(М, "Шлях до теки паків вже встановлено.");
      }
      кдпм.шлях_до_теки_модулів = притримати_в_користувацьких_даних(М, М.користувацькі_дані, шлях_до_теки_модулів як Значення);
      кдпм.шлях_до_теки_паків = притримати_в_користувацьких_даних(М, М.користувацькі_дані, шлях_до_теки_паків як Значення);
    }
    
    місцева дія взяти_файл(
      М: адреса<Машина>,
      шлях_до_файлу: адреса<ПредметДаних>,
      назва_модуля: адреса<ПредметТексту>,
      місцезнаходження: Місцезнаходження
    ) -> ЗначенняАбоСтанПадіння {
      змінна успіх: логічне = ні;
      змінна значення: Значення = пусто;
      змінна розмір_файлу: природне = 0;
      змінна дані_файлу: памʼять<п8> = пусто;
      змінна сирий_текст: кд = кд { 0, пусто };
      змінна слова: мавка::розбирач::Слова;
      змінна помилка_розбору_на_слова: мавка::розбирач::ПомилкаРозборуНаСлова;
      змінна сполуки: мавка::розбирач::Сполуки;
      змінна помилка_розбору_на_сполуки: мавка::розбирач::ПомилкаРозборуНаСполуки;
      змінна перекладений_код: адреса<мавка::ПредметКоду> = пусто;
      змінна помилка_перекладу: мавка::перекладач::ПомилкаПерекладу;
     
      якщо знайти_взяте_значення(М, шлях_до_файлу, значення::адреса) {
        вернути значення;
      }

      успіх = пристрій_мавки_прочитати_файл(
        шлях_до_файлу.розмір,
        шлях_до_файлу.дані,
        розмір_файлу::адреса,
        дані_файлу::адреса
      );

      якщо не успіх {
        увімкнути_стан_падіння(
          М,
          створити_текст(М, "Не вдалося прочитати файл.") як Значення,
          місцезнаходження
        );
        вернути пусто;
      }

      успіх = перекодувати_ю8_в_кд(
        М,
        ю8 { розмір_файлу, дані_файлу },
        сирий_текст::адреса,
        пусто
      );
    
      якщо не успіх {
        звільнити_памʼять(М, дані_файлу);
        увімкнути_стан_падіння(
          М,
          створити_текст(М, "Не вдалося перекодувати файл в код мавки.") як Значення,
          Місцезнаходження { шлях_до_файлу, 0 }
        );
        вернути пусто;
      }
      
      успіх = мавка::розбирач::розібрати_на_слова(
        М, 
        сирий_текст, 
        слова::адреса, 
        помилка_розбору_на_слова::адреса
      );
      
      якщо не успіх {
        змінна рядок = розбирач::отримати_рядок_помилки_розбору_на_слова(
          М,
          помилка_розбору_на_слова
        );
        увімкнути_стан_падіння(
          М,
          створити_текст(М, "Не вдалось розібрати.") як Значення,
          Місцезнаходження { шлях_до_файлу, рядок }
        );
        вернути пусто;
      }
    
      успіх = мавка::розбирач::розібрати_слова_на_сполуки(
        М,
        сирий_текст,
        слова,
        сполуки::адреса,
        помилка_розбору_на_сполуки::адреса
      );

      якщо не успіх {
        змінна рядок = розбирач::отримати_рядок_помилки_розбору_на_сполуки(
          М,
          помилка_розбору_на_сполуки
        );
        увімкнути_стан_падіння(
          М,
          створити_текст(М, "Не вдалось розібрати.") як Значення,
          Місцезнаходження { шлях_до_файлу, рядок }
        );
        вернути пусто;
      }
    
      успіх = мавка::перекласти_в_код(
        М,
        мавка::створити_дані(М, шлях_до_файлу.розмір, шлях_до_файлу.дані),
        сирий_текст,
        слова,
        сполуки,
        перекладений_код::адреса,
        помилка_перекладу::адреса
      );

      якщо не успіх {
        увімкнути_стан_падіння(
          М,
          створити_текст(М, "Не вдалось перекласти.") як Значення,
          місцезнаходження
        );
        вернути пусто;
      }

      змінна предмет_модуля = створити_модуль(
        М,
        назва_модуля
      );

      записати_взяте_значення(
        М,
        шлях_до_файлу,
        предмет_модуля як Значення 
      );
      
      змінна предмет_дії_модуля = створити_дію(
        М,
        М.глобальна_дійсність,
        назва_модуля,
        пусто,
        пусто,
        перекладений_код як адреса<мавка::ПредметКоду>,
        шлях_до_файлу
      );
    
      змінна результат = предмет_дії_здійснити(
        М,
        предмет_модуля як Значення,
        предмет_дії_модуля,
        0,
        пусто,
        пусто,
        місцезнаходження
      );

      якщо М.стан_падіння {
        видалити_взяте_значення(М, шлях_до_файлу);
      }

      вернути результат;
    }

    місцева дія надрукувати_інформацію_падіння(
      М: адреса<Машина>,
      інформація_падіння: ІнформаціяПадіння
    ) {
      мавка::вивести_формат(М, мавка::ФКолірТекстуЧервоний);
      мавка::вивести(М, "Помилка");
      мавка::вивести_формат(М, мавка::ФОчистити);

      якщо інформація_падіння.місцезнаходження.шлях != пусто {
        мавка::вивести(М, " в ");

        пристрій_мавки_вивести_сирі_дані(інформація_падіння.місцезнаходження.шлях.розмір, інформація_падіння.місцезнаходження.шлях.дані);
  
        якщо інформація_падіння.місцезнаходження.рядок > 0 {
          мавка::вивести(М, ":");
          мавка::вивести_п64(М, п64(інформація_падіння.місцезнаходження.рядок));
        }
        
        мавка::вивести(М, "\р");
      }

      мавка::надрукувати_значення(М, інформація_падіння.значення, 2, 0);
  
      змінна п: природне = 0;
      
      якщо інформація_падіння.розмір_історії > 0 {
        мавка::надрукувати(М, "\рІсторія здійснення:");
      }
  
      поки п < інформація_падіння.розмір_історії {
        змінна елемент_історії = інформація_падіння.історія[п];
        
        якщо елемент_історії.назва != пусто {
          мавка::вивести(М, "  ");
          мавка::вивести_формат(М, мавка::ФКолірТекстуСиній);
          мавка::вивести(М, елемент_історії.назва.значення);
          мавка::вивести_формат(М, мавка::ФОчистити);
        
          якщо елемент_історії.місцезнаходження.шлях == пусто {
            мавка::вивести(М, "\р");
          } інакше {
            мавка::вивести(М, " в ");
            пристрій_мавки_вивести_сирі_дані(елемент_історії.місцезнаходження.шлях.розмір, елемент_історії.місцезнаходження.шлях.дані);
  
            якщо елемент_історії.місцезнаходження.рядок > 0 {
              мавка::вивести(М, ":");
              мавка::вивести_п64(М, п64(елемент_історії.місцезнаходження.рядок));
            }
            
            мавка::вивести(М, "\р");
          }
        }
        
        п += 1;
      }
    }
  }
}