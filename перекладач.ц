взяти означення ./мавка;

дія перевірити_чи_кд_рівні(а: кд, б: кд) -> логічне {
  якщо а.розмір != б.розмір {
    вернути ні;
  }

  змінна п: природне = 0;
  
  поки п < а.розмір {
    якщо а.дані[п] != б.дані[п] {
      вернути ні;
    }

    п += 1;
  }

  вернути так;
}

дія перевірити_чи_починається_на(значення: кд, починається_на: кд, п: адреса<природне>): логічне {
  змінна пп: природне = 0;
  
  поки пп < починається_на.розмір {
    змінна ппп = п::вміст + пп;
  
    якщо ппп >= значення.розмір {
      вернути ні;
    }
  
    якщо значення.дані[ппп] != починається_на.дані[пп] {
      вернути ні;
    }
  
    пп += 1;
  }

  п::вміст = п::вміст + пп - 1;
  
  вернути так;
}

дія розібрати_число_з_кд(значення: кд, вихід: адреса<д64>) -> логічне {
  змінна відʼємне = ні;
  змінна п: природне = 0;
  якщо значення.дані[п] == 45 {
    відʼємне = так;
    п += 1;
  }
  якщо перевірити_чи_починається_на(значення, "0д", п::адреса) {
    п += 1;
    змінна значення_0д: ц64 = 0;
    поки п < значення.розмір {
      значення_0д *= 2;
      якщо значення.дані[п] == мавка::розбирач::КД_0 {
      } інакше якщо значення.дані[п] == мавка::розбирач::КД_1 {
        значення_0д += 1;
      } інакше {
        вернути ні;
      }
      п += 1;
    }
    якщо відʼємне {
      вихід::вміст = д64(ц64(0) - значення_0д);
      вернути так;
    }
    вихід::вміст = д64(значення_0д);
    вернути так;
  }
  якщо перевірити_чи_починається_на(значення, "0ш", п::адреса) {
    п += 1;
    змінна значення_0ш: ц64 = 0;
    поки п < значення.розмір {
      змінна с: п8 = 0;
      якщо перевірити_чи_починається_на(значення, "0", п::адреса) {
        с = 0;
      } інакше якщо перевірити_чи_починається_на(значення, "1", п::адреса) {
        с = 1;
      } інакше якщо перевірити_чи_починається_на(значення, "2", п::адреса) {
        с = 2;
      } інакше якщо перевірити_чи_починається_на(значення, "3", п::адреса) {
        с = 3;
      } інакше якщо перевірити_чи_починається_на(значення, "4", п::адреса) {
        с = 4;
      } інакше якщо перевірити_чи_починається_на(значення, "5", п::адреса) {
        с = 5;
      } інакше якщо перевірити_чи_починається_на(значення, "6", п::адреса) {
        с = 6;
      } інакше якщо перевірити_чи_починається_на(значення, "7", п::адреса) {
        с = 7;
      } інакше якщо перевірити_чи_починається_на(значення, "8", п::адреса) {
        с = 8;
      } інакше якщо перевірити_чи_починається_на(значення, "9", п::адреса) {
        с = 9;
      } інакше якщо перевірити_чи_починається_на(значення, "А", п::адреса) {
        с = 10;
      } інакше якщо перевірити_чи_починається_на(значення, "Б", п::адреса) {
        с = 11;
      } інакше якщо перевірити_чи_починається_на(значення, "В", п::адреса) {
        с = 12;
      } інакше якщо перевірити_чи_починається_на(значення, "Г", п::адреса) {
        с = 13;
      } інакше якщо перевірити_чи_починається_на(значення, "Д", п::адреса) {
        с = 14;
      } інакше якщо перевірити_чи_починається_на(значення, "Е", п::адреса) {
        с = 15;
      } інакше якщо перевірити_чи_починається_на(значення, "а", п::адреса) {
        с = 10;
      } інакше якщо перевірити_чи_починається_на(значення, "б", п::адреса) {
        с = 11;
      } інакше якщо перевірити_чи_починається_на(значення, "в", п::адреса) {
        с = 12;
      } інакше якщо перевірити_чи_починається_на(значення, "г", п::адреса) {
        с = 13;
      } інакше якщо перевірити_чи_починається_на(значення, "д", п::адреса) {
        с = 14;
      } інакше якщо перевірити_чи_починається_на(значення, "е", п::адреса) {
        с = 15;
      } інакше {
        вернути ні;
      }
      значення_0ш = (значення_0ш << 4) | (ц64(с) & 15);
      п += 1;
    }
    якщо відʼємне {
      вихід::вміст = д64(ц64(0) - значення_0ш);
      вернути так;
    }
    вихід::вміст = д64(значення_0ш);
    вернути так;
  }
  змінна результат: д64 = 0;
  змінна символ_: п8 = значення.дані[0];
  поки п < значення.розмір {
    символ_ = значення.дані[п];
    якщо символ_ == мавка::розбирач::КД_0 { // 0
      результат = результат * 10;
    } інакше якщо символ_ == мавка::розбирач::КД_1 { // 1
      результат = результат * 10 + 1;
    } інакше якщо символ_ == мавка::розбирач::КД_2 { // 2
      результат = результат * 10 + 2;
    } інакше якщо символ_ == мавка::розбирач::КД_3 { // 3
      результат = результат * 10 + 3;
    } інакше якщо символ_ == мавка::розбирач::КД_4 { // 4
      результат = результат * 10 + 4;
    } інакше якщо символ_ == мавка::розбирач::КД_5 { // 5
      результат = результат * 10 + 5;
    } інакше якщо символ_ == мавка::розбирач::КД_6 { // 6
      результат = результат * 10 + 6;
    } інакше якщо символ_ == мавка::розбирач::КД_7 { // 7
      результат = результат * 10 + 7;
    } інакше якщо символ_ == мавка::розбирач::КД_8 { // 8
      результат = результат * 10 + 8;
    } інакше якщо символ_ == мавка::розбирач::КД_9 { // 9
      результат = результат * 10 + 9;
    } інакше якщо символ_ == мавка::розбирач::КД_ПІДРИСКА { // _
      // ігноруємо
    } інакше якщо символ_ == мавка::розбирач::КД_КРАПКА { // .
      п += 1;
      символ_ = значення.дані[п];
      змінна дробна_частина: д64 = 0;
      змінна дільник: д64 = 1;
      поки п < значення.розмір {
        символ_ = значення.дані[п];
        якщо символ_ == мавка::розбирач::КД_0 { // 0
          дробна_частина = дробна_частина * 10;
        } інакше якщо символ_ == мавка::розбирач::КД_1 { // 1
          дробна_частина = дробна_частина * 10 + 1;
        } інакше якщо символ_ == мавка::розбирач::КД_2 { // 2
          дробна_частина = дробна_частина * 10 + 2;
        } інакше якщо символ_ == мавка::розбирач::КД_3 { // 3
          дробна_частина = дробна_частина * 10 + 3;
        } інакше якщо символ_ == мавка::розбирач::КД_4 { // 4
          дробна_частина = дробна_частина * 10 + 4;
        } інакше якщо символ_ == мавка::розбирач::КД_5 { // 5
          дробна_частина = дробна_частина * 10 + 5;
        } інакше якщо символ_ == мавка::розбирач::КД_6 { // 6
          дробна_частина = дробна_частина * 10 + 6;
        } інакше якщо символ_ == мавка::розбирач::КД_7 { // 7
          дробна_частина = дробна_частина * 10 + 7;
        } інакше якщо символ_ == мавка::розбирач::КД_8 { // 8
          дробна_частина = дробна_частина * 10 + 8;
        } інакше якщо символ_ == мавка::розбирач::КД_9 { // 9
          дробна_частина = дробна_частина * 10 + 9;
        } інакше якщо символ_ == мавка::розбирач::КД_ПІДРИСКА { // _
          // ігноруємо
        } інакше {
          вернути ні;
        }
        п += 1;
        дільник = дільник * 10;
      }
      результат = результат + дробна_частина / дільник;
      вихід::вміст = результат;
      вернути так;
    } інакше {
      вернути ні;
    }
    п += 1;
  }
  вихід::вміст = результат;
  вернути так;
}

простір мавка {
  простір перекладач {
    дія клонувати_кд(М: адреса<Машина>, значення: кд) -> кд {
      змінна дані_клону_значення = виділити_памʼять<п8>(М, значення.розмір);
      
      змінна п: природне = 0;
      поки п < значення.розмір {
        дані_клону_значення[п] = значення.дані[п];
        п += 1;
      }

      вернути кд {
        значення.розмір,
        дані_клону_значення
      };
    }

    дія отримати_оброблену_копію_кд_тексту(М: адреса<Машина>, значення_кд: кд, вихід: адреса<кд>): логічне {
      змінна розмір_обробленого_значення_кд: природне = 0;
      змінна дані_обробленого_значення_кд = виділити_памʼять<п8>(М, значення_кд.розмір);
      
      змінна п: природне = 0;
      
      поки п < значення_кд.розмір {
        змінна символ = значення_кд.дані[п];
      
        якщо символ == розбирач::КД_ОБЕРНЕНА_ПОХИЛА {
          якщо (п + 1) < значення_кд.розмір {
            змінна наступний_символ = значення_кд.дані[п + 1];
            
            якщо наступний_символ == розбирач::КД_ОБЕРНЕНА_ПОХИЛА {
              дані_обробленого_значення_кд[розмір_обробленого_значення_кд] = розбирач::КД_ОБЕРНЕНА_ПОХИЛА;
              розмір_обробленого_значення_кд += 1;
              п += 1;
            } інакше якщо наступний_символ == розбирач::КД_ДВОЛАПКА {
              дані_обробленого_значення_кд[розмір_обробленого_значення_кд] = розбирач::КД_ДВОЛАПКА;
              розмір_обробленого_значення_кд += 1;
              п += 1;
            } інакше якщо наступний_символ == розбирач::КД_ЛАПКА {
              дані_обробленого_значення_кд[розмір_обробленого_значення_кд] = розбирач::КД_ЛАПКА;
              розмір_обробленого_значення_кд += 1;
              п += 1;
            } інакше якщо наступний_символ == розбирач::КД_р {
              дані_обробленого_значення_кд[розмір_обробленого_значення_кд] = розбирач::КД_РОЗРИВ;
              розмір_обробленого_значення_кд += 1;
              п += 1;
            } інакше {
              дані_обробленого_значення_кд[розмір_обробленого_значення_кд] = значення_кд.дані[п];
              розмір_обробленого_значення_кд += 1;
            }
          } інакше {
            дані_обробленого_значення_кд[розмір_обробленого_значення_кд] = значення_кд.дані[п];
            розмір_обробленого_значення_кд += 1;
          }
        } інакше {
          дані_обробленого_значення_кд[розмір_обробленого_значення_кд] = значення_кд.дані[п];
          розмір_обробленого_значення_кд += 1;
        }
        
        п += 1;
      }

      вихід::вміст = кд {
        розмір_обробленого_значення_кд,
        дані_обробленого_значення_кд
      };
      
      вернути так;
    }

    дія покласти_вказівку_ПокластиДійсне(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВПокластиДійсне, 0, пусто);
    }

    дія покласти_вказівку_ПокластиНедійсне(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВПокластиНедійсне, 0, пусто);
    }

    дія покласти_вказівку_ПокластиЯ(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВПокластиЯ, 0, пусто);
    }

    дія покласти_вказівку_ПокластиКонстанту(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32, позиція_константи: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВПокластиКонстанту, 1, позиція_константи::адреса як памʼять<п32>);
    }

    дія покласти_вказівку_Звернутись(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВЗвернутись, 0, пусто);
    }

    дія покласти_вказівку_ОтриматиВластивість(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВОтриматиВластивість, 0, пусто);
    }

    дія покласти_вказівку_ОтриматиЕлемент(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВОтриматиЕлемент, 0, пусто);
    }

    дія покласти_вказівку_Здійснити(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32, кількість_аргументів: п32, кількість_іменованих_аргументів: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВЗдійснити, 2, кількість_аргументів::адреса як памʼять<п32>);
    }

    дія покласти_вказівку_ЗдійснитиВластивість(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32, кількість_аргументів: п32, кількість_іменованих_аргументів: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВЗдійснитиВластивість, 2, кількість_аргументів::адреса як памʼять<п32>);
    }

    дія покласти_вказівку_СтворитиПараметр(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВСтворитиПараметр, 0, пусто);
    }

    дія покласти_вказівку_СтворитиДію(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32, кількість_параметрів: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВСтворитиДію, 1, кількість_параметрів::адреса як памʼять<п32>);
    }

    дія покласти_вказівку_СтворитиСтруктуру(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32, кількість_параметрів: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВСтворитиСтруктуру, 1, кількість_параметрів::адреса як памʼять<п32>);
    }

    дія покласти_вказівку_СтворитиСписок(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32, кількість_елементів: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВСтворитиСписок, 1, кількість_елементів::адреса як памʼять<п32>);
    }

    дія покласти_вказівку_СтворитиСловник(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32, кількість_елементів: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВСтворитиСловник, 1, кількість_елементів::адреса як памʼять<п32>);
    }

    дія покласти_вказівку_СтворитиДіапазон(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВСтворитиДіапазон, 0, пусто);
    }

    дія покласти_вказівку_ЗбитиТекст(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32, кількість_елементів: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВЗбитиТекст, 1, кількість_елементів::адреса як памʼять<п32>);
    }

    дія покласти_вказівку_Дублювати(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВДублювати, 0, пусто);
    }

    дія покласти_вказівку_Забрати(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВЗабрати, 0, пусто);
    }

    дія покласти_вказівку_Стрибнути(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32, позиція_вказівки: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВСтрибнути, 1, позиція_вказівки::адреса як памʼять<п32>);
    }

    дія покласти_вказівку_СтрибнутиЯкщоНі(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32, позиція_вказівки: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВСтрибнутиЯкщоНі, 1, позиція_вказівки::адреса як памʼять<п32>);
    }

    дія покласти_вказівку_СтрибнутиЯкщоТак(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32, позиція_вказівки: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВСтрибнутиЯкщоТак, 1, позиція_вказівки::адреса як памʼять<п32>);
    }

    дія покласти_вказівку_Додати(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВДодати, 0, пусто);
    }
    
    дія покласти_вказівку_Відняти(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВВідняти, 0, пусто);
    }
    
    дія покласти_вказівку_Помножити(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВПомножити, 0, пусто);
    }
    
    дія покласти_вказівку_Поділити(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВПоділити, 0, пусто);
    }
    
    дія покласти_вказівку_ОтриматиОстачуДілення(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВОтриматиОстачуДілення, 0, пусто);
    }
    
    дія покласти_вказівку_ОтриматиНеповнуЧасткуДілення(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВОтриматиНеповнуЧасткуДілення, 0, пусто);
    }
    
    дія покласти_вказівку_ПіднестиДоСтепеня(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВПіднестиДоСтепеня, 0, пусто);
    }
    
    дія покласти_вказівку_ЗсунутиВліво(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВЗсунутиВліво, 0, пусто);
    }
    
    дія покласти_вказівку_ЗсунутиВправо(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВЗсунутиВправо, 0, пусто);
    }
    
    дія покласти_вказівку_ЗсунутиВправоЗіЗаповненням(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВЗсунутиВправоЗіЗаповненням, 0, пусто);
    }
    
    дія покласти_вказівку_ДвійковеІ(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВДвійковеІ, 0, пусто);
    }
    
    дія покласти_вказівку_ДвійковеАБО(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВДвійковеАБО, 0, пусто);
    }
    
    дія покласти_вказівку_ДвійковеВиключнеАБО(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВДвійковеВиключнеАБО, 0, пусто);
    }
    
    дія покласти_вказівку_ДвійковеНЕ(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВДвійковеНЕ, 0, пусто);
    }
    
    дія покласти_вказівку_Менше(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВМенше, 0, пусто);
    }
    
    дія покласти_вказівку_Більше(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВБільше, 0, пусто);
    }
    
    дія покласти_вказівку_НеБільше(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВНеБільше, 0, пусто);
    }
    
    дія покласти_вказівку_НеМенше(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВНеМенше, 0, пусто);
    }
    
    дія покласти_вказівку_Рівно(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВРівно, 0, пусто);
    }
    
    дія покласти_вказівку_НеРівно(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВНеРівно, 0, пусто);
    }
    
    дія покласти_вказівку_Містить(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВМістить, 0, пусто);
    }
    
    дія покласти_вказівку_НеМістить(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВНеМістить, 0, пусто);
    }
    
    дія покласти_вказівку_Є(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВЄ, 0, пусто);
    }
    
    дія покласти_вказівку_НеЄ(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВНеЄ, 0, пусто);
    }
    
    дія покласти_вказівку_Відʼємне(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВВідʼємне, 0, пусто);
    }
    
    дія покласти_вказівку_Числове(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВЧислове, 0, пусто);
    }
    
    дія покласти_вказівку_Заперечити(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВЗаперечити, 0, пусто);
    }
    
    дія покласти_вказівку_Збільшити(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВЗбільшити, 0, пусто);
    }
    
    дія покласти_вказівку_ЗбільшитиПопереднє(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВЗбільшитиПопереднє, 0, пусто);
    }
    
    дія покласти_вказівку_Зменшити(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВЗменшити, 0, пусто);
    }
    
    дія покласти_вказівку_Визначити(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВВизначити, 0, пусто);
    }
    
    дія покласти_вказівку_ЗмінитиВластивість(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВЗмінитиВластивість, 0, пусто);
    }
    
    дія покласти_вказівку_ЗмінитиЕлемент(М: адреса<Машина>, код: невідома_адреса, покласти_вказівку: ДіяПокластиВказівку, рядок: п32) -> п32 {
      вернути покласти_вказівку(М, код, рядок, ВЗмінитиЕлемент, 0, пусто);
    }
  }


  простір перекладач {
    структура КонтекстПерекладу;

    дія зробити_помилку_перекладу(М: адреса<Машина>,
                                  текст: кд,
                                  слова: розбирач::Слова,
                                  сполука: адреса<розбирач::Сполука>,
                                  повідомлення: кд) -> ПомилкаПерекладу {
      змінна слово = слова.дані[сполука.місцезнаходження.позиція_слова];
      змінна рядок = розбирач::отримати_рядок_з_місцезнаходження(текст, слова, сполука.місцезнаходження);
      змінна стовпець = розбирач::отримати_стовпець_з_місцезнаходження(текст, слова, сполука.місцезнаходження);

      вернути ПомилкаПерекладу {
        позиція_в_тексті = слово.позиція_початку.позиція_в_тексті,
        рядок = рядок,
        стовпець = стовпець,
        повідомлення = повідомлення,
      };
    }

    дія перекласти_значення(М: адреса<Машина>,
                            значення_коду_кд: кд,
                            слова: розбирач::Слова,
                            сполука: адреса<розбирач::Сполука>,
                            код: невідома_адреса,
                            дії: Дії,
                            вихід_помилки: адреса<ПомилкаПерекладу>) -> логічне;

    дія перекласти_тіло(М: адреса<Машина>,
                        сирий_текст: кд,
                        слова: розбирач::Слова,
                        здійснимі: розбирач::Сполуки,
                        код: невідома_адреса,
                        дії: Дії,
                        вихід_помилки: адреса<ПомилкаПерекладу>) -> логічне;
                        
    дія перекласти_значення(М: адреса<Машина>,
                            значення_коду_кд: кд,
                            слова: розбирач::Слова,
                            сполука: адреса<розбирач::Сполука>,
                            код: невідома_адреса,
                            дії: Дії,
                            вихід_помилки: адреса<ПомилкаПерекладу>) -> логічне {
      змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(значення_коду_кд, слова, сполука.місцезнаходження));

      якщо сполука.вид == розбирач::ВидСполукиЗвернутись {
        змінна дані = сполука.дані як розбирач::ДаніСполукиЗвернутись;
  
        змінна значення_ідентифікатора = розбирач::отримати_значення_ідентифікатора(значення_коду_кд, слова, дані.ідентифікатор);
  
        якщо перевірити_чи_кд_рівні(значення_ідентифікатора, "дійсне") {
          покласти_вказівку_ПокластиДійсне(М, код, дії.покласти_вказівку, рядок);
        } інакше якщо перевірити_чи_кд_рівні(значення_ідентифікатора, "недійсне") {
          покласти_вказівку_ПокластиНедійсне(М, код, дії.покласти_вказівку, рядок);
        } інакше якщо перевірити_чи_кд_рівні(значення_ідентифікатора, "я") {
          покласти_вказівку_ПокластиЯ(М, код, дії.покласти_вказівку, рядок);
        } інакше {
          змінна позиція_назви = дії.покласти_константу_тексту(М, код, значення_ідентифікатора);
          покласти_вказівку_ПокластиКонстанту(М, код, дії.покласти_вказівку, рядок, позиція_назви);
          покласти_вказівку_Звернутись(М, код, дії.покласти_вказівку, рядок);
        }
  
        вернути так;
      }

      якщо сполука.вид == розбирач::ВидСполукиОтриматиВластивість {
        змінна дані = сполука.дані як розбирач::ДаніСполукиОтриматиВластивість;
        
        змінна успіх_компіляції_предмета = перекласти_значення(
          М, 
          значення_коду_кд, 
          слова, 
          дані.предмет, 
          код, 
          дії,
          вихід_помилки
        );
        якщо не успіх_компіляції_предмета {
          вернути успіх_компіляції_предмета;
        }

        змінна значення_ідентифікатора = розбирач::отримати_значення_ідентифікатора(значення_коду_кд, слова, дані.ідентифікатор);
        змінна позиція_назви = дії.покласти_константу_тексту(М, код, значення_ідентифікатора);
        покласти_вказівку_ПокластиКонстанту(М, код, дії.покласти_вказівку, рядок, позиція_назви);
        покласти_вказівку_ОтриматиВластивість(М, код, дії.покласти_вказівку, рядок);
  
        вернути так;
      }

      якщо сполука.вид == розбирач::ВидСполукиОтриматиЕлемент {
        змінна дані = сполука.дані як розбирач::ДаніСполукиОтриматиЕлемент;
  
        змінна успіх_компіляції_предмета = перекласти_значення(
          М, 
          значення_коду_кд,
          слова, 
          дані.предмет, 
          код, 
          дії,
          вихід_помилки
        );
        якщо не успіх_компіляції_предмета {
          вернути успіх_компіляції_предмета;
        }
  
        змінна успіх_компіляції_ключа = перекласти_значення(
          М, 
          значення_коду_кд, 
          слова, 
          дані.предмет, 
          код, 
          дії,
          вихід_помилки
        );
        якщо не успіх_компіляції_ключа {
          вернути успіх_компіляції_ключа;
        }

        покласти_вказівку_ОтриматиЕлемент(М, код, дії.покласти_вказівку, рядок);
  
        вернути так;
      }

      якщо сполука.вид == розбирач::ВидСполукиВиконати {
        змінна дані = сполука.дані як розбирач::ДаніСполукиВиконати;

        якщо дані.предмет.вид == розбирач::ВидСполукиОтриматиВластивість {
          змінна дані_отримання = дані.предмет.дані як розбирач::ДаніСполукиОтриматиВластивість;

          змінна успіх_компіляції_предмета = перекласти_значення(
            М, 
            значення_коду_кд, 
            слова,
            дані_отримання.предмет,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх_компіляції_предмета {
            вернути успіх_компіляції_предмета;
          }

          змінна значення_ідентифікатора = розбирач::отримати_значення_ідентифікатора(значення_коду_кд, слова, дані_отримання.ідентифікатор);
          змінна позиція_назви_прохання = дії.покласти_константу_тексту(М, код, значення_ідентифікатора);
          покласти_вказівку_ПокластиКонстанту(М, код, дії.покласти_вказівку, рядок, позиція_назви_прохання);
        } інакше {
          змінна успіх_компіляції_предмета = перекласти_значення(
            М, 
            значення_коду_кд,
            слова,
            дані.предмет,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх_компіляції_предмета {
            вернути успіх_компіляції_предмета;
          }
        }

        змінна кількість_аргументів_без_назви: п32 = 0;
        змінна кількість_аргументів_з_назвою: п32 = 0;
        змінна п: п32 = 0;
        поки п < п32(дані.кількість_аргументів) {
          змінна аргумент = дані.аргументи[п];
          змінна рядок_аргумента = п32(розбирач::отримати_рядок_з_місцезнаходження(значення_коду_кд, слова, аргумент.місцезнаходження));

          якщо аргумент.ідентифікатор.заповнено {
            змінна значення_ідентифікатора_аргумента = розбирач::отримати_значення_ідентифікатора(значення_коду_кд, слова, аргумент.ідентифікатор.значення);
            змінна позиція_назви_аргумента = дії.покласти_константу_тексту(М, код, значення_ідентифікатора_аргумента);
            покласти_вказівку_ПокластиКонстанту(М, код, дії.покласти_вказівку, рядок_аргумента, позиція_назви_аргумента);

            змінна успіх_компіляції_аргумента = перекласти_значення(
              М,
              значення_коду_кд,
              слова,
              аргумент.значення,
              код,
              дії,
              вихід_помилки
            );
            якщо не успіх_компіляції_аргумента {
              вернути успіх_компіляції_аргумента;
            }

            кількість_аргументів_з_назвою += 1;
          } інакше {
            якщо кількість_аргументів_з_назвою > 0 {
              вихід_помилки::вміст = зробити_помилку_перекладу(
                М,
                значення_коду_кд,
                слова, 
                сполука, 
                клонувати_кд(М, "Аргументи без назви не можуть йти після аргументів з назвою.")
              );
              вернути ні;
            }

            змінна успіх_компіляції_аргумента = перекласти_значення(
              М,
              значення_коду_кд,
              слова,
              аргумент.значення,
              код,
              дії,
              вихід_помилки
            );
            якщо не успіх_компіляції_аргумента {
              вернути успіх_компіляції_аргумента;
            }

            кількість_аргументів_без_назви += 1;
          }

          п += 1;
        }

        якщо дані.предмет.вид == розбирач::ВидСполукиОтриматиВластивість {
          покласти_вказівку_ЗдійснитиВластивість(М, код, дії.покласти_вказівку, рядок, кількість_аргументів_без_назви, кількість_аргументів_з_назвою);
        } інакше {
          покласти_вказівку_Здійснити(М, код, дії.покласти_вказівку, рядок, кількість_аргументів_без_назви, кількість_аргументів_з_назвою);
        }

        вернути так;
      }

      якщо сполука.вид == розбирач::ВидСполукиДія {
        змінна дані = сполука.дані як розбирач::ДаніСполукиДія;

        якщо дані.ідентифікатор.заповнено {
          змінна значення_ідентифікатора = розбирач::отримати_значення_ідентифікатора(значення_коду_кд, слова, дані.ідентифікатор.значення);
          змінна позиція_назви = дії.покласти_константу_тексту(М, код, значення_ідентифікатора);
          покласти_вказівку_ПокластиКонстанту(М, код, дії.покласти_вказівку, рядок, позиція_назви); // назва
        } інакше {
          покласти_вказівку_ПокластиНедійсне(М, код, дії.покласти_вказівку, рядок); // назва
        }

        змінна п: природне = 0;
        поки п < дані.кількість_параметрів {
          змінна параметр = дані.параметри[п];

          змінна рядок_параметра = п32(розбирач::отримати_рядок_з_місцезнаходження(значення_коду_кд, слова, параметр.місцезнаходження));
          змінна значення_ідентифікатора_параметра = розбирач::отримати_значення_ідентифікатора(значення_коду_кд, слова, параметр.ідентифікатор);
          змінна позиція_назви_параметра = дії.покласти_константу_тексту(М, код, значення_ідентифікатора_параметра);
          покласти_вказівку_ПокластиКонстанту(М, код, дії.покласти_вказівку, рядок, позиція_назви_параметра);

          якщо параметр.значення != пусто {
            вихід_помилки::вміст = зробити_помилку_перекладу(
              М,
              значення_коду_кд,
              слова, 
              сполука, 
              клонувати_кд(М, "Значення параметра зараз не підтримується.")
            );
            вернути ні;
          } інакше {
            покласти_вказівку_ПокластиНедійсне(М, код, дії.покласти_вказівку, рядок);
          }

          покласти_вказівку_СтворитиПараметр(М, код, дії.покласти_вказівку, рядок);

          п += 1;
        }

        змінна код_дії = дії.створити_код(М);

        змінна успіх_перекладу_коду_дії = перекласти_тіло(
          М,
          значення_коду_кд,
          слова,
          дані.тіло,
          код_дії,
          дії,
          вихід_помилки
        );
        якщо не успіх_перекладу_коду_дії {
          вернути успіх_перекладу_коду_дії;
        }

        змінна позиція_коду_дії = дії.покласти_константу_коду(М, код, код_дії);
        покласти_вказівку_ПокластиКонстанту(М, код, дії.покласти_вказівку, рядок, позиція_коду_дії); // код
        покласти_вказівку_СтворитиДію(М, код, дії.покласти_вказівку, рядок, п32(дані.кількість_параметрів));

        вернути так;
      }

      якщо сполука.вид == розбирач::ВидСполукиСтруктура {
        змінна дані = сполука.дані як розбирач::ДаніСполукиСтруктура;

        якщо дані.ідентифікатор.заповнено {
          змінна значення_ідентифікатора = розбирач::отримати_значення_ідентифікатора(значення_коду_кд, слова, дані.ідентифікатор.значення);
          змінна позиція_назви = дії.покласти_константу_тексту(М, код, значення_ідентифікатора);
          покласти_вказівку_ПокластиКонстанту(М, код, дії.покласти_вказівку, рядок, позиція_назви); // назва
        } інакше {
          покласти_вказівку_ПокластиНедійсне(М, код, дії.покласти_вказівку, рядок); // назва
        }

        змінна успіх_перекладу_предка_структури = перекласти_значення(
          М,
          значення_коду_кд,
          слова,
          дані.предок,
          код,
          дії,
          вихід_помилки
        );
        якщо не успіх_перекладу_предка_структури {
          вернути успіх_перекладу_предка_структури;
        }

        змінна п: природне = 0;
        поки п < дані.кількість_параметрів {
          змінна параметр = дані.параметри[п];

          змінна рядок_параметра = п32(розбирач::отримати_рядок_з_місцезнаходження(значення_коду_кд, слова, параметр.місцезнаходження));
          змінна значення_ідентифікатора_параметра = розбирач::отримати_значення_ідентифікатора(значення_коду_кд, слова, параметр.ідентифікатор);
          змінна позиція_назви_параметра = дії.покласти_константу_тексту(М, код, значення_ідентифікатора_параметра);
          покласти_вказівку_ПокластиКонстанту(М, код, дії.покласти_вказівку, рядок, позиція_назви_параметра);

          якщо параметр.значення != пусто {
            вихід_помилки::вміст = зробити_помилку_перекладу(
              М,
              значення_коду_кд,
              слова, 
              сполука, 
              клонувати_кд(М, "Значення параметра зараз не підтримується.")
            );
            вернути ні;
          } інакше {
            покласти_вказівку_ПокластиНедійсне(М, код, дії.покласти_вказівку, рядок);
          }

          покласти_вказівку_СтворитиПараметр(М, код, дії.покласти_вказівку, рядок);

          п += 1;
        }

        покласти_вказівку_СтворитиСтруктуру(М, код, дії.покласти_вказівку, рядок, п32(дані.кількість_параметрів));

        вернути так;
      }

      якщо сполука.вид == розбирач::ВидСполукиЧисло {
        змінна дані = сполука.дані як розбирач::ДаніСполукиЧисло;

        змінна слово = слова.дані[дані.позиція_слова];
        змінна текст = розбирач::отримати_значення_слова(значення_коду_кд, слова, слово);

        змінна розібране_число: д64 = 0.0;
        якщо не розібрати_число_з_кд(текст, розібране_число::адреса) {
          вихід_помилки::вміст = зробити_помилку_перекладу(
            М,
            значення_коду_кд,
            слова, 
            сполука, 
            клонувати_кд(М, "Не вдалось розібрати число.")
          );
          вернути ні;
        }

        змінна позиція_константи = дії.покласти_константу_числа(М, код, розібране_число);
        покласти_вказівку_ПокластиКонстанту(М, код, дії.покласти_вказівку, рядок, позиція_константи);

        вернути так;
      }

      якщо сполука.вид == розбирач::ВидСполукиТекст {
        змінна дані = сполука.дані як розбирач::ДаніСполукиТекст;

        змінна значення_тексту_кд = розбирач::отримати_значення_тексту(значення_коду_кд, слова, сполука);

        змінна оброблене_значення_тексту_кд = кд { 0, пусто };
        якщо не отримати_оброблену_копію_кд_тексту(М, значення_тексту_кд, оброблене_значення_тексту_кд::адреса) {
          вихід_помилки::вміст = зробити_помилку_перекладу(
            М,
            значення_коду_кд,
            слова, 
            сполука, 
            клонувати_кд(М, "Не вдалось розібрати текст.")
          );
          вернути ні;
        }

        змінна позиція_константи = дії.покласти_константу_тексту(М, код, оброблене_значення_тексту_кд);
        покласти_вказівку_ПокластиКонстанту(М, код, дії.покласти_вказівку, рядок, позиція_константи);

        звільнити_памʼять(М, оброблене_значення_тексту_кд.дані);

        вернути так;
      }

      якщо сполука.вид == розбирач::ВидСполукиОперація {
        змінна дані = сполука.дані як розбирач::ДаніСполукиОперація;

        змінна успіх_компіляції_ліво = перекласти_значення(
          М,
          значення_коду_кд,
          слова,
          дані.ліво,
          код,
          дії,
          вихід_помилки
        );
        якщо не успіх_компіляції_ліво {
          вернути успіх_компіляції_ліво;
        }

        якщо дані.операція == розбирач::ВидОпераціїІ {
          покласти_вказівку_Дублювати(М, код, дії.покласти_вказівку, рядок);
          змінна позиція_вказівки_стрибнути_якщо_ні = покласти_вказівку_СтрибнутиЯкщоНі(М, код, дії.покласти_вказівку, рядок, 0);
          покласти_вказівку_Забрати(М, код, дії.покласти_вказівку, рядок);

          змінна успіх_компіляції_право = перекласти_значення(
            М,
            значення_коду_кд,
            слова,
            дані.право,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх_компіляції_право {
            вернути успіх_компіляції_право;
          }

          дії.змінити_аргумент_вказівки(
            М,
            код,
            позиція_вказівки_стрибнути_якщо_ні,
            0,
            дії.отримати_розмір_вказівок(М, код)
          );

          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїАБО {
          покласти_вказівку_Дублювати(М, код, дії.покласти_вказівку, рядок);
          змінна позиція_вказівки_стрибнути_якщо_так = покласти_вказівку_СтрибнутиЯкщоТак(М, код, дії.покласти_вказівку, рядок, 0);
          покласти_вказівку_Забрати(М, код, дії.покласти_вказівку, рядок);

          змінна успіх_компіляції_право = перекласти_значення(
            М,
            значення_коду_кд,
            слова,
            дані.право,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх_компіляції_право {
            вернути успіх_компіляції_право;
          }

          дії.змінити_аргумент_вказівки(
            М,
            код,
            позиція_вказівки_стрибнути_якщо_так,
            0,
            дії.отримати_розмір_вказівок(М, код)
          );

          вернути так;
        }

        змінна успіх_компіляції_право = перекласти_значення(
          М,
          значення_коду_кд,
          слова,
          дані.право,
          код,
          дії,
          вихід_помилки
        );
        якщо не успіх_компіляції_право {
          вернути успіх_компіляції_право;
        }

        якщо дані.операція == розбирач::ВидОпераціїДодавання {
          покласти_вказівку_Додати(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїВіднімання {
          покласти_вказівку_Відняти(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїМноження {
          покласти_вказівку_Помножити(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїДілення {
          покласти_вказівку_Поділити(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїМодуль {
          покласти_вказівку_ОтриматиОстачуДілення(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїДіленняНаціло {
          покласти_вказівку_ОтриматиНеповнуЧасткуДілення(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїПіднесенняДоСтепеня {
          покласти_вказівку_ПіднестиДоСтепеня(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїЗсувВліво {
          покласти_вказівку_ЗсунутиВліво(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїЗсувВправо {
          покласти_вказівку_ЗсунутиВправо(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїЗсувВправоЗнаковий {
          покласти_вказівку_ЗсунутиВправоЗіЗаповненням(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїДІ {
          покласти_вказівку_ДвійковеІ(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїДАБО {
          покласти_вказівку_ДвійковеАБО(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїВАБО {
          покласти_вказівку_ДвійковеВиключнеАБО(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїМенше {
          покласти_вказівку_Менше(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїБільше {
          покласти_вказівку_Більше(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїМеншеРівне {
          покласти_вказівку_НеБільше(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїБільшеРівне {
          покласти_вказівку_НеМенше(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїРівне {
          покласти_вказівку_Рівно(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїНерівне {
          покласти_вказівку_НеРівно(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїМістить {
          покласти_вказівку_Містить(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїНеМістить {
          покласти_вказівку_НеМістить(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїЄ {
          покласти_вказівку_Є(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        } інакше якщо дані.операція == розбирач::ВидОпераціїНеЄ {
          покласти_вказівку_НеЄ(М, код, дії.покласти_вказівку, рядок);
          вернути так;
        }

        вихід_помилки::вміст = зробити_помилку_перекладу(
          М,
          значення_коду_кд,
          слова, 
          сполука, 
          клонувати_кд(М, "Невідома операція.")
        );
        вернути ні;

      }

      якщо сполука.вид == розбирач::ВидСполукиЗначенняЯкщо {
        змінна дані = сполука.дані як розбирач::ДаніСполукиЗначенняЯкщо;

        змінна успіх_компіляції_умови = перекласти_значення(
          М,
          значення_коду_кд,
          слова,
          дані.умова,
          код,
          дії,
          вихід_помилки
        );
        якщо не успіх_компіляції_умови {
          вернути успіх_компіляції_умови;
        }

        змінна позиція_вказівки_стрибнути_якщо_ні = покласти_вказівку_СтрибнутиЯкщоНі(М, код, дії.покласти_вказівку, рядок, 0);

        змінна успіх_компіляції_так = перекласти_значення(
          М,
          значення_коду_кд,
          слова,
          дані.значення_так,
          код,
          дії,
          вихід_помилки
        );
        якщо не успіх_компіляції_так {
          вернути успіх_компіляції_так;
        }

        змінна позиція_вказівки_виходу_з_так = покласти_вказівку_Стрибнути(М, код, дії.покласти_вказівку, рядок, 0);
        дії.змінити_аргумент_вказівки(
          М,
          код,
          позиція_вказівки_стрибнути_якщо_ні,
          0,
          дії.отримати_розмір_вказівок(М, код)
        );

        змінна успіх_компіляції_ні = перекласти_значення(
          М,
          значення_коду_кд,
          слова,
          дані.значення_ні,
          код,
          дії,
          вихід_помилки
        );
        якщо не успіх_компіляції_ні {
          вернути успіх_компіляції_ні;
        }

        дії.змінити_аргумент_вказівки(
          М,
          код,
          позиція_вказівки_виходу_з_так,
          0,
          дії.отримати_розмір_вказівок(М, код)
        );

        вернути так;
      }

      якщо сполука.вид == розбирач::ВидСполукиСамоОперація {
        змінна дані = сполука.дані як розбирач::ДаніСполукиСамоОперація;

        змінна успіх_компіляції_предмета = перекласти_значення(
          М,
          значення_коду_кд,
          слова,
          дані.предмет,
          код,
          дії,
          вихід_помилки
        );
        якщо не успіх_компіляції_предмета {
          вернути успіх_компіляції_предмета;
        }

        якщо дані.операція == розбирач::ВидСамоОпераціїЛогічнеНі {
          покласти_вказівку_Заперечити(М, код, дії.покласти_вказівку, рядок);
          
          вернути так;
        }

        якщо дані.операція == розбирач::ВидСамоОпераціїДвійковеНі {
          покласти_вказівку_ДвійковеНЕ(М, код, дії.покласти_вказівку, рядок);
          
          вернути так;
        }

        якщо дані.операція == розбирач::ВидСамоОпераціїПлюс {
          покласти_вказівку_Числове(М, код, дії.покласти_вказівку, рядок);
          
          вернути так;
        }

        якщо дані.операція == розбирач::ВидСамоОпераціїМінус {
          покласти_вказівку_Відʼємне(М, код, дії.покласти_вказівку, рядок);
          
          вернути так;
        }

        вихід_помилки::вміст = зробити_помилку_перекладу(
          М,
          значення_коду_кд,
          слова, 
          сполука, 
          клонувати_кд(М, "Невідома самооперація.")
        );
        вернути ні;
      }

      якщо сполука.вид == розбирач::ВидСполукиМодуль {
        вихід_помилки::вміст = зробити_помилку_перекладу(
          М,
          значення_коду_кд,
          слова, 
          сполука, 
          клонувати_кд(М, "Модулі зараз не підтримуються.")
        );
        вернути ні;
      }

      якщо сполука.вид == розбирач::ВидСполукиСписок {
        змінна дані = сполука.дані як розбирач::ДаніСполукиСписок;

        змінна п: природне = 0;
        поки п < дані.кількість_елементів {
          змінна елемент_списку = дані.елементи[п];

          змінна успіх_компіляції_елементу_списку = перекласти_значення(
            М,
            значення_коду_кд,
            слова,
            елемент_списку,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх_компіляції_елементу_списку {
            вернути успіх_компіляції_елементу_списку;
          }

          п += 1;
        }

        покласти_вказівку_СтворитиСписок(М, код, дії.покласти_вказівку, рядок, п32(дані.кількість_елементів));

        вернути так;
      }

      якщо сполука.вид == розбирач::ВидСполукиСловник {
        змінна дані = сполука.дані як розбирач::ДаніСполукиСловник;

        змінна п: п32 = 0;
        поки п < п32(дані.кількість_елементів) {
          змінна елемент_словника = дані.елементи[п];

          змінна успіх_компіляції_ключа_словника_списку = перекласти_значення(
            М,
            значення_коду_кд,
            слова,
            елемент_словника.ключ,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх_компіляції_ключа_словника_списку {
            вернути успіх_компіляції_ключа_словника_списку;
          }

          змінна успіх_компіляції_значення_словника_списку = перекласти_значення(
            М,
            значення_коду_кд,
            слова,
            елемент_словника.значення,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх_компіляції_значення_словника_списку {
            вернути успіх_компіляції_значення_словника_списку;
          }

          п += 1;
        }

        покласти_вказівку_СтворитиСловник(М, код, дії.покласти_вказівку, рядок, п32(дані.кількість_елементів));

        вернути так;
      }

      якщо сполука.вид == розбирач::ВидСполукиСимвол {
        змінна дані = сполука.дані як розбирач::ДаніСполукиСимвол;

        змінна значення_символу_кд = розбирач::отримати_значення_символу(значення_коду_кд, слова, сполука);

        змінна оброблене_значення_символу_кд = кд { 0, пусто };
        якщо не отримати_оброблену_копію_кд_тексту(М, значення_символу_кд, оброблене_значення_символу_кд::адреса) {
          вихід_помилки::вміст = зробити_помилку_перекладу(
            М,
            значення_коду_кд,
            слова, 
            сполука, 
            клонувати_кд(М, "Не вдалось розібрати символ.")
          );
          вернути ні;
        }

        змінна позиція_константи: п32 = 0;
        якщо оброблене_значення_символу_кд.розмір == 0 {
          звільнити_памʼять(М, оброблене_значення_символу_кд.дані);
          
          вихід_помилки::вміст = зробити_помилку_перекладу(
            М,
            значення_коду_кд,
            слова, 
            сполука, 
            клонувати_кд(М, "Символ не може бути порожнім.")
          );
          вернути ні;
        } інакше {
          позиція_константи = дії.покласти_константу_числа(
            М,
            код,
            д64(оброблене_значення_символу_кд.дані[0])
          );
        }

        звільнити_памʼять(М, оброблене_значення_символу_кд.дані);

        покласти_вказівку_ПокластиКонстанту(М, код, дії.покласти_вказівку, рядок, позиція_константи);

        вернути так;
      }

      якщо сполука.вид == розбирач::ВидСполукиЧекати {
        вихід_помилки::вміст = зробити_помилку_перекладу(
          М,
          значення_коду_кд,
          слова, 
          сполука, 
          клонувати_кд(М, "Чекати зараз не підтримується.")
        );
        вернути ні;
      }

      якщо сполука.вид == розбирач::ВидСполукиДіапазон {
        змінна дані = сполука.дані як розбирач::ДаніСполукиДіапазон;

        змінна успіх_компіляції_від = перекласти_значення(
          М,
          значення_коду_кд,
          слова,
          дані.від,
          код,
          дії,
          вихід_помилки
        );
        якщо не успіх_компіляції_від {
          вернути успіх_компіляції_від;
        }

        якщо дані.включно {
          покласти_вказівку_ПокластиДійсне(М, код, дії.покласти_вказівку, рядок);
        } інакше {
          покласти_вказівку_ПокластиНедійсне(М, код, дії.покласти_вказівку, рядок);
        }

        змінна успіх_компіляції_до = перекласти_значення(
          М,
          значення_коду_кд,
          слова,
          дані.до,
          код,
          дії,
          вихід_помилки
        );
        якщо не успіх_компіляції_до {
          вернути успіх_компіляції_до;
        }

        покласти_вказівку_СтворитиДіапазон(М, код, дії.покласти_вказівку, рядок);

        вернути так;
      }

      якщо сполука.вид == розбирач::ВидСполукиЗбитийТекст {
        змінна дані = сполука.дані як розбирач::ДаніСполукиЗбитийТекст;

        змінна п: природне = 0;
        поки п < дані.кількість_гілок {
          змінна успіх_компіляції_значення = перекласти_значення(
            М,
            значення_коду_кд,
            слова,
            дані.сполуки[п],
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх_компіляції_значення {
            вернути успіх_компіляції_значення;
          }

          п += 1;
        }

        покласти_вказівку_ЗбитиТекст(М, код, дії.покласти_вказівку, рядок, п32(дані.кількість_гілок));

        вернути так;
      }

      вернути ні;            
    }

    дія перекласти_тіло(М: адреса<Машина>,
                        сирий_текст: кд,
                        слова: розбирач::Слова,
                        здійснимі: розбирач::Сполуки,
                        код: невідома_адреса,
                        дії: Дії,
                        вихід_помилки: адреса<ПомилкаПерекладу>) -> логічне {
      змінна п: природне = 0;
      поки п < здійснимі.розмір {
        змінна сполука = здійснимі.дані[п];
        змінна рядок = п32(розбирач::отримати_рядок_з_місцезнаходження(сирий_текст, слова, сполука.місцезнаходження));

        якщо сполука.вид == розбирач::ВидСполукиВизначити {
          змінна дані = сполука.дані як розбирач::ДаніСполукиВизначити;

          змінна назва = розбирач::отримати_значення_ідентифікатора(сирий_текст, слова, дані.ідентифікатор);
          змінна позиція_назви = дії.покласти_константу_тексту(
            М, 
            код, 
            назва
          );
          покласти_вказівку_ПокластиКонстанту(М, код, дії.покласти_вказівку, рядок, позиція_назви);
         
          змінна успіх_перекладу_елемента = перекласти_значення(
            М,
            сирий_текст,
            слова,
            дані.значення,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }
         
          покласти_вказівку_Визначити(М, код, дії.покласти_вказівку, рядок);
        } інакше якщо сполука.вид == розбирач::ВидСполукиЗвернутись
                  або сполука.вид == розбирач::ВидСполукиОтриматиВластивість
                  або сполука.вид == розбирач::ВидСполукиОтриматиЕлемент
                  або сполука.вид == розбирач::ВидСполукиВиконати
                  або сполука.вид == розбирач::ВидСполукиДія
                  або сполука.вид == розбирач::ВидСполукиСтруктура
                  або сполука.вид == розбирач::ВидСполукиЧисло
                  або сполука.вид == розбирач::ВидСполукиТекст
                  або сполука.вид == розбирач::ВидСполукиОперація
                  або сполука.вид == розбирач::ВидСполукиЗначенняЯкщо
                  або сполука.вид == розбирач::ВидСполукиМодуль
                  або сполука.вид == розбирач::ВидСполукиСписок
                  або сполука.вид == розбирач::ВидСполукиСловник
                  або сполука.вид == розбирач::ВидСполукиСимвол
                  або сполука.вид == розбирач::ВидСполукиЧекати
                  або сполука.вид == розбирач::ВидСполукиДіапазон
                  або сполука.вид == розбирач::ВидСполукиЗбитийТекст
                  або сполука.вид == розбирач::ВидСполукиСамоОперація {
          змінна успіх_перекладу_значення = перекласти_значення(
            М,
            сирий_текст,
            слова,
            сполука,
            код,
            дії,
            вихід_помилки
          );

          якщо не успіх_перекладу_значення {
            вернути успіх_перекладу_значення;
          }

          покласти_вказівку_Забрати(М, код, дії.покласти_вказівку, рядок);
        } інакше якщо сполука.вид == розбирач::ВидСполукиЗмінитиВластивість {
          змінна дані = сполука.дані як розбирач::ДаніСполукиЗмінитиВластивість;
         
          змінна успіх_перекладу_предмета = перекласти_значення(
            М,
            сирий_текст,
            слова,
            дані.предмет,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх_перекладу_предмета {
            вернути успіх_перекладу_предмета;
          }

          змінна назва = розбирач::отримати_значення_ідентифікатора(сирий_текст, слова, дані.ідентифікатор);
          змінна позиція_назви = дії.покласти_константу_тексту(
            М, 
            код, 
            назва
          );
          покласти_вказівку_ПокластиКонстанту(М, код, дії.покласти_вказівку, рядок, позиція_назви);
         
          змінна успіх_перекладу_елемента = перекласти_значення(
            М,
            сирий_текст,
            слова,
            дані.значення,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }
         
          покласти_вказівку_ЗмінитиВластивість(М, код, дії.покласти_вказівку, рядок);
        } інакше якщо сполука.вид == розбирач::ВидСполукиЗмінитиЕлемент {
          змінна дані = сполука.дані як розбирач::ДаніСполукиЗмінитиЕлемент;
         
          змінна успіх_перекладу_предмета = перекласти_значення(
            М,
            сирий_текст,
            слова,
            дані.предмет,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх_перекладу_предмета {
            вернути успіх_перекладу_предмета;
          }
         
          змінна успіх_перекладу_ключа = перекласти_значення(
            М,
            сирий_текст,
            слова,
            дані.ключ,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх_перекладу_ключа {
            вернути успіх_перекладу_ключа;
          }
         
          змінна успіх_перекладу_елемента = перекласти_значення(
            М,
            сирий_текст,
            слова,
            дані.значення,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх_перекладу_елемента {
            вернути успіх_перекладу_елемента;
          }
         
          покласти_вказівку_ЗмінитиЕлемент(М, код, дії.покласти_вказівку, рядок);
        } інакше якщо сполука.вид == розбирач::ВидСполукиЯкщо {
          змінна дані = сполука.дані як розбирач::ДаніСполукиЯкщо;

          змінна успіх_компіляції_умови = перекласти_значення(
            М,
            сирий_текст,
            слова,
            дані.умова,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх_компіляції_умови {
            вернути успіх_компіляції_умови;
          }

          змінна позиція_вказівки_якщо_ні = покласти_вказівку_СтрибнутиЯкщоНі(М, код, дії.покласти_вказівку, рядок, 0);

          якщо дані.тіло.розмір != 0 {
            змінна успіх_компіляції_тіла = перекласти_тіло(
              М,
              сирий_текст,
              слова,
              дані.тіло,
              код,
              дії,
              вихід_помилки
            );
            якщо не успіх_компіляції_тіла {
              вернути успіх_компіляції_тіла;
            }
          }

          змінна позиція_вказівки_якщо_так = покласти_вказівку_Стрибнути(М, код, дії.покласти_вказівку, рядок, 0);

          дії.змінити_аргумент_вказівки(
            М,
            код,
            позиція_вказівки_якщо_ні,
            0,
            дії.отримати_розмір_вказівок(М, код)
          );

          якщо дані.тіло_інакше.розмір != 0 {
            змінна успіх_компіляції_тіла_інакше = перекласти_тіло(
              М,
              сирий_текст,
              слова,
              дані.тіло_інакше,
              код,
              дії,
              вихід_помилки
            );
            якщо не успіх_компіляції_тіла_інакше {
              вернути успіх_компіляції_тіла_інакше;
            }
          }

          дії.змінити_аргумент_вказівки(
            М,
            код,
            позиція_вказівки_якщо_так,
            0,
            дії.отримати_розмір_вказівок(М, код)
          );
        } інакше якщо сполука.вид == розбирач::ВидСполукиПоки {
          змінна дані = сполука.дані як розбирач::ДаніСполукиПоки;

          змінна позиція_вказівки_початку_поки = дії.отримати_розмір_вказівок(М, код);

          змінна успіх_компіляції_умови = перекласти_значення(
            М,
            сирий_текст,
            слова,
            дані.умова,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх_компіляції_умови {
            вернути успіх_компіляції_умови;
          }

          змінна позиція_вказівки_якщо_ні = покласти_вказівку_СтрибнутиЯкщоНі(М, код, дії.покласти_вказівку, рядок, 0);

          змінна успіх_компіляції_тіла = перекласти_тіло(
            М,
            сирий_текст,
            слова,
            дані.тіло,
            код,
            дії,
            вихід_помилки
          );
          якщо не успіх_компіляції_тіла {
            вернути успіх_компіляції_тіла;
          }

          покласти_вказівку_Стрибнути(М, код, дії.покласти_вказівку, рядок, позиція_вказівки_початку_поки);

          дії.змінити_аргумент_вказівки(
            М,
            код,
            позиція_вказівки_якщо_ні,
            0,
            дії.отримати_розмір_вказівок(М, код)
          );
        } інакше якщо сполука.вид == розбирач::ВидСполукиВернути {
        } інакше якщо сполука.вид == розбирач::ВидСполукиВзяти {
        } інакше якщо сполука.вид == розбирач::ВидСполукиСпробувати {
        } інакше якщо сполука.вид == розбирач::ВидСполукиВпасти {
        } інакше якщо сполука.вид == розбирач::ВидСполукиДати {
        } інакше якщо сполука.вид == розбирач::ВидСполукиПеребрати {
        } інакше якщо сполука.вид == розбирач::ВидСполукиЦикл {
        } інакше якщо сполука.вид == розбирач::ВидСполукиВічнийЦикл {
        } інакше {
          вернути ні;
        }

        п += 1;
      }

      вернути так;
    }

    місцева дія перекласти(М: адреса<Машина>,
                           сирий_текст: кд,
                           слова: розбирач::Слова,
                           здійснимі: розбирач::Сполуки,
                           дії: Дії,
                           вихід_коду: невідома_адреса,
                           вихід_помилки: адреса<ПомилкаПерекладу>) -> логічне {
      вернути ні;                       
    }
  }

  місцева дія перекласти_в_код(М: адреса<Машина>,
                               сирий_текст: кд,
                               слова: розбирач::Слова,
                               здійснимі: розбирач::Сполуки,
                               вихід_коду: адреса<Значення>,
                               вихід_помилки: адреса<перекладач::ПомилкаПерекладу>) -> логічне {
    вернути ні;
  }

  місцева дія перекласти_у_файл_коду(М: адреса<Машина>,
                                     сирий_текст: кд,
                                     слова: розбирач::Слова,
                                     здійснимі: розбирач::Сполуки,
                                     вихід_розміру: адреса<природне>,
                                     вихід_даних: адреса<памʼять<п8>>,
                                     вихід_помилки: адреса<перекладач::ПомилкаПерекладу>) -> логічне {
    вернути ні;                                   
  }
}